/*
 * array.c - routines for awk arrays.
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2014, 2016, 2018-2023, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

extern FILE *output_fp;
extern NODE **fmt_list;          /* declared in eval.c */

NODE *success_node;

static size_t SUBSEPlen;
static char *SUBSEP;
static char indent_char[] = "    ";

static int sort_up_value_type(const void *p1, const void *p2);
static NODE **null_lookup(NODE *symbol, NODE *subs);
static NODE **null_dump(NODE *symbol, NODE *subs);
static const array_funcs_t null_array_func = {
	"null",
	(afunc_t) 0,
	(afunc_t) 0,
	null_lookup,
	null_afunc,
	null_afunc,
	null_afunc,
	null_afunc,
	null_afunc,
	null_dump,
	(afunc_t) 0,
};

#define MAX_ATYPE 10

static const array_funcs_t *array_types[MAX_ATYPE];
static int num_array_types = 0;

/* register_array_func --- add routines to handle arrays */

static int
register_array_func(const array_funcs_t *afunc)
{
	if (afunc && num_array_types < MAX_ATYPE) {
		if (afunc != & str_array_func && afunc->type_of == NULL)
			return false;
		array_types[num_array_types++] = afunc;
		if (afunc->init)	/* execute init routine if any */
			(void) (*afunc->init)(NULL, NULL);
		return true;
	}
	return false;
}


/* array_init --- register all builtin array types */

void
array_init()
{
	(void) register_array_func(& str_array_func);	/* the default */
	if (! do_mpfr) {
		(void) register_array_func(& int_array_func);
		(void) register_array_func(& cint_array_func);
	}
}


/* make_array --- create an array node */

NODE *
make_array()
{
	NODE *array;
	getnode(array);
	memset(array, '\0', sizeof(NODE));
	array->type = Node_var_array;
	array->array_funcs = & null_array_func;
	/* vname, flags, and parent_array not set here */

	return array;
}


/* null_array --- force symbol to be an empty typeless array */

void
null_array(NODE *symbol)
{
	symbol->type = Node_var_array;
	symbol->array_funcs = & null_array_func;
	symbol->buckets = NULL;
	symbol->table_size = 0;
	symbol->array_size = 0;
	symbol->array_capacity = 0;
	symbol->flags = 0;

	assert(symbol->xarray == NULL);

	/* vname, parent_array not (re)initialized */
}


/* null_lookup --- assign type to an empty array. */

static NODE **
null_lookup(NODE *symbol, NODE *subs)
{
	int i;
	const array_funcs_t *afunc = NULL;

	assert(symbol->table_size == 0);

	/*
	 * Check which array type wants to accept this sub; traverse
	 * array type list in reverse order.
	 */
	for (i = num_array_types - 1; i >= 1; i--) {
		afunc = array_types[i];
		if (afunc->type_of(symbol, subs) != NULL)
			break;
	}
	if (i == 0 || afunc == NULL)
		afunc = array_types[0];	/* default is str_array_func */
	symbol->array_funcs = afunc;

	/* We have the right type of array; install the subscript */
	return symbol->alookup(symbol, subs);
}


/* null_afunc --- default function for array interface */

NODE **
null_afunc(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)
{
	return NULL;
}

/* null_dump --- dump function for an empty array */

static NODE **
null_dump(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)
{
	fprintf(output_fp, "array `%s' is empty\n", array_vname(symbol));
	return NULL;
}


/* assoc_copy --- duplicate input array "symbol" */

NODE *
assoc_copy(NODE *symbol, NODE *newsymb)
{
	assert(newsymb->vname != NULL);

	assoc_clear(newsymb);
	(void) symbol->acopy(symbol, newsymb);
	newsymb->array_funcs = symbol->array_funcs;
	newsymb->flags = symbol->flags;
	return newsymb;
}


/* assoc_dump --- dump array */

void
assoc_dump(NODE *symbol, NODE *ndump)
{
	if (symbol->adump)
		(void) symbol->adump(symbol, ndump);
}


/* make_aname --- construct a 'vname' for a (sub)array */

const char *
make_aname(const NODE *symbol)
{
	static char *aname = NULL;
	static size_t alen;
	static size_t max_alen;
#define SLEN 256

	if (symbol->parent_array != NULL) {
		size_t slen;

		(void) make_aname(symbol->parent_array);
		slen = strlen(symbol->vname);	/* subscript in parent array */
		if (alen + slen + 4 > max_alen) {		/* sizeof("[\"\"]") = 4 */
			max_alen = alen + slen + 4 + SLEN;
			erealloc(aname, char *, (max_alen + 1) * sizeof(char *));
		}
		alen += sprintf(aname + alen, "[\"%s\"]", symbol->vname);
	} else {
		alen = strlen(symbol->vname);
		if (aname == NULL) {
			max_alen = alen + SLEN;
			emalloc(aname, char *, (max_alen + 1) * sizeof(char *));
		} else if (alen > max_alen) {
			max_alen = alen + SLEN;
			erealloc(aname, char *, (max_alen + 1) * sizeof(char *));
		}
		memcpy(aname, symbol->vname, alen + 1);
	}
	return aname;
}
#undef SLEN


/*
 * array_vname --- print the name of the array
 *
 * Returns a pointer to a statically maintained dynamically allocated string.
 * It's appropriate for printing the name once; if the caller wants
 * to save it, they have to make a copy.
 */

const char *
array_vname(const NODE *symbol)
{
	static char *message = NULL;
	static size_t msglen = 0;
	char *s;
	size_t len;
	int n;
	const NODE *save_symbol = symbol;
	const char *from = _("from %s");
	const char *aname;

	if (symbol->type != Node_array_ref
			|| symbol->orig_array->type != Node_var_array
	) {
		if (symbol->type != Node_var_array || symbol->parent_array == NULL)
			return symbol->vname;
		return make_aname(symbol);
	}

	/* First, we have to compute the length of the string: */

	len = 2; /* " (" */
	n = 0;
	while (symbol->type == Node_array_ref) {
		len += strlen(symbol->vname);
		n++;
		symbol = symbol->prev_array;
	}

	/* Get the (sub)array name */
	if (symbol->parent_array == NULL)
		aname = symbol->vname;
	else
		aname = make_aname(symbol);
	len += strlen(aname);
	/*
	 * Each node contributes by strlen(from) minus the length
	 * of "%s" in the translation (which is at least 2)
	 * plus 2 for ", " or ")\0"; this adds up to strlen(from).
	 */
	len += n * strlen(from);

	/* (Re)allocate memory: */
	if (message == NULL) {
		emalloc(message, char *, len);
		msglen = len;
	} else if (len > msglen) {
		erealloc(message, char *, len);
		msglen = len;
	} /* else
		current buffer can hold new name */

	/* We're ready to print: */
	symbol = save_symbol;
	s = message;
	/*
	 * Ancient systems have sprintf() returning char *, not int.
	 * If you have one of those, use sprintf(..); s += strlen(s) instead.
	 */

	s += sprintf(s, "%s (", symbol->vname);
	for (;;) {
		symbol = symbol->prev_array;
		if (symbol->type != Node_array_ref)
			break;
		s += sprintf(s, from, symbol->vname);
		s += sprintf(s, ", ");
	}
	s += sprintf(s, from, aname);
	strcpy(s, ")");

	return message;
}


/*
 *  force_array --- proceed to the actual Node_var_array,
 *	change Node_var_new or Node_elem_new to an array.
 *	If canfatal and type isn't good, die fatally,
 *	otherwise return the final actual value.
 */

NODE *
force_array(NODE *symbol, bool canfatal)
{
	NODE *save_symbol = symbol;
	bool isparam = false;

	if (symbol->type == Node_param_list) {
		save_symbol = symbol = GET_PARAM(symbol->param_cnt);
		isparam = true;
		if (symbol->type == Node_array_ref)
			symbol = symbol->orig_array;
	}

	NODE *elem_new_parent = NULL;
	char *elem_new_vname = NULL;

	switch (symbol->type) {
	case Node_elem_new:
		elem_new_parent = symbol->elemnew_parent;
		symbol->elemnew_parent = NULL;
		elem_new_vname = symbol->elemnew_vname;
		symbol->elemnew_vname = NULL;
		efree(symbol->stptr);
		symbol->stptr = NULL;
		symbol->stlen = 0;
		/* fall through */
	case Node_var_new:
		symbol->xarray = NULL;	/* make sure union is as it should be */
		null_array(symbol);
		symbol->parent_array = NULL;	/* main array has no parent */
		/* fall through */
	case Node_var_array:
		if (elem_new_parent != NULL)
			symbol->parent_array = elem_new_parent;
		if (elem_new_vname != NULL)
			symbol->vname = elem_new_vname;
		break;

	case Node_array_ref:
	default:
		/* notably Node_var but catches also e.g. a[1] = "x"; a[1][1] = "y" */
		if (canfatal) {
			if (symbol->type == Node_val)
				fatal(_("attempt to use a scalar value as array"));
			if (isparam)
				fatal(_("attempt to use scalar parameter `%s' as an array"),
					save_symbol->vname);
			else
				fatal(_("attempt to use scalar `%s' as an array"),
					save_symbol->vname);
		} else
			break;
	}

	return symbol;
}


/* set_SUBSEP --- update SUBSEP related variables when SUBSEP assigned to */

void
set_SUBSEP()
{
	SUBSEP_node->var_value = force_string(SUBSEP_node->var_value);
	SUBSEP = SUBSEP_node->var_value->stptr;
	SUBSEPlen = SUBSEP_node->var_value->stlen;
}


/* concat_exp --- concatenate expression list into a single string */

NODE *
concat_exp(int nargs, bool do_subsep)
{
	/* do_subsep is false for Op_concat */
	NODE *r;
	char *str;
	char *s;
	size_t len;
	size_t subseplen = 0;
	int i;
	extern NODE **args_array;

	if (nargs == 1)
		return POP_STRING();

	if (do_subsep)
		subseplen = SUBSEPlen;

	len = 0;
	for (i = 1; i <= nargs; i++) {
		r = TOP();
		if (r->type == Node_var_array) {
			while (--i > 0)
				DEREF(args_array[i]);	/* avoid memory leak */
			fatal(_("attempt to use array `%s' in a scalar context"), array_vname(r));
		}
		r = POP_STRING();
		args_array[i] = r;
		len += r->stlen;
	}
	len += (nargs - 1) * subseplen;

	emalloc(str, char *, len + 1);

	r = args_array[nargs];
	memcpy(str, r->stptr, r->stlen);
	s = str + r->stlen;
	DEREF(r);
	for (i = nargs - 1; i > 0; i--) {
		if (subseplen == 1)
			*s++ = *SUBSEP;
		else if (subseplen > 0) {
			memcpy(s, SUBSEP, subseplen);
			s += subseplen;
		}
		r = args_array[i];
		memcpy(s, r->stptr, r->stlen);
		s += r->stlen;
		DEREF(r);
	}

	return make_str_node(str, len, ALREADY_MALLOCED);
}


/*
 * adjust_param_node: change a parameter node when adjusting the call stack
 *  (code factored out from the adjust_fcall_stack function)
 */

static void
adjust_param_node(NODE *r)
{
	if (r->orig_array != NULL)
		if (r->orig_array->valref > 0)
			DEREF(r->orig_array);
	if (r->prev_array != NULL && r->prev_array != r->orig_array)
		if (r->prev_array->valref > 0)
			DEREF(r->prev_array);
	if (r->orig_array->type == Node_var_array) {
		r->orig_array = r->prev_array = NULL;
		null_array(r);
	} else	{ /* Node_elem_new */
		r->type = Node_var_new;
	}
	r->parent_array = NULL;
}


/*
 * adjust_fcall_stack: remove subarray(s) of symbol[] from
 *	function call stack.
 */

static void
adjust_fcall_stack(NODE *symbol, int nsubs)
{
	NODE *func, *r, *n;
	NODE **sp;
	int pcount;

	/*
	 * Solve the nasty problem of disappearing subarray arguments:
	 *
	 *  function f(c, d) { delete c; .. use non-existent array d .. }
	 *  BEGIN { a[0][0] = 1; f(a, a[0]); .. }
	 *
	 * The fix is to convert 'd' to a local empty array; This has
	 * to be done before clearing the parent array to avoid referring to
	 * already free-ed memory.
	 *
	 * Similar situations exist for builtins accepting more than
	 * one array argument: split, patsplit, asort and asorti. For example:
	 *
	 *  BEGIN { a[0][0] = 1; split("abc", a, "", a[0]) }
	 *
	 * These cases do not involve the function call stack, and are
	 * handled individually in their respective routines.
	 */

	func = frame_ptr->func_node;
	if (func == NULL)	/* in main */
		return;
	pcount = func->param_cnt;
	sp = frame_ptr->stack;

	for (; pcount > 0; pcount--) {
		r = *sp++;
		if (r->type != Node_array_ref
			|| (r->orig_array->type != Node_var_array
				&& r->orig_array->type != Node_elem_new))
			continue;
		n = r->orig_array;
#define PARENT_ARRAY(n) ((n->type == Node_elem_new) ? n->elemnew_parent : n->parent_array)

		/* Case 1 */
		if (n == symbol
			&& PARENT_ARRAY(symbol) != NULL
			&& nsubs > 0
		) {
			/*
			 * 'symbol' is a subarray, and 'r' is the same subarray:
			 *
			 *   function f(c, d) { delete c[0]; .. }
			 *   BEGIN { a[0][0] = 1; f(a, a[0]); .. }
			 *
			 * But excludes cases like (nsubs = 0):
			 *
			 *   function f(c, d) { delete c; ..}
			 *   BEGIN { a[0][0] = 1; f(a[0], a[0]); ...}
			 */

			adjust_param_node(r);
			continue;
		}

		/* Case 2 */
		for (n = PARENT_ARRAY(n); n != NULL; n = PARENT_ARRAY(n)) {
			assert(n->type == Node_var_array);
			if (n == symbol) {
				/*
				 * 'r' is a subarray of 'symbol':
				 *
				 *    function f(c, d) { delete c; .. use d as array .. }
				 *    BEGIN { a[0][0] = 1; f(a, a[0]); .. }
				 *	OR
				 *    BEGIN { a[0][0][0][0] = 1; f(a[0], a[0][0][0]); .. }
				 *
				 */
				adjust_param_node(r);
				break;
			}
		}
	}
}


/* do_delete --- perform `delete array[s]' */

/*
 * `symbol' is array
 * `nsubs' is no of subscripts
 */

void
do_delete(NODE *symbol, int nsubs)
{
	NODE *val, *subs;
	int i;

	assert(symbol->type == Node_var_array);
	subs = val = NULL;	/* silence the compiler */

	/*
	 * The force_string() call is needed to make sure that
	 * the string subscript is reasonable.  For example, with it:
	 *
	 * $ ./gawk --posix 'BEGIN { CONVFMT="%ld"; delete a[1.233]}'
	 * gawk: cmd. line:1: fatal: `%l' is not permitted in POSIX awk formats
	 *
	 * Without it, the code does not fail.
	 */

#define free_subs(n)    do {                                    \
    NODE *s = PEEK(n - 1);                                      \
    if (s->type == Node_val) {                                  \
        (void) force_string(s);	/* may have side effects. */    \
        DEREF(s);                                               \
    }                                                           \
} while (--n > 0)

	if (nsubs == 0) {
		/* delete array */

		adjust_fcall_stack(symbol, 0);	/* fix function call stack; See above. */
		assoc_clear(symbol);
		return;
	}

	/* NB: subscripts are in reverse order on stack */

	for (i = nsubs; i > 0; i--) {
		subs = PEEK(i - 1);
		if (subs->type != Node_val && subs->type != Node_elem_new) {
			free_subs(i);
			fatal(_("attempt to use array `%s' in a scalar context"), array_vname(subs));
		}

		val = in_array(symbol, subs);
		if (val == NULL) {
			if (do_lint) {
				subs = force_string(subs);
				lintwarn(_("delete: index `%.*s' not in array `%s'"),
					(int) subs->stlen, subs->stptr, array_vname(symbol));
			}
			/* avoid memory leak, free all subs */
			free_subs(i);
			return;
		}

		if (i > 1) {
			if (val->type != Node_var_array) {
				/* e.g.: a[1] = 1; delete a[1][1] */

				free_subs(i);
				subs = force_string(subs);
				fatal(_("attempt to use scalar `%s[\"%.*s\"]' as an array"),
					array_vname(symbol),
					(int) subs->stlen,
					subs->stptr);
			}
			symbol = val;
			DEREF(subs);
		}
	}

	if (val->type == Node_var_array) {
		adjust_fcall_stack(val, nsubs);  /* fix function call stack; See above. */
		assoc_clear(val);
		/* cleared a sub-array, free Node_var_array */
		efree(val->vname);
		freenode(val);
	} else if (val->type == Node_elem_new) {
		adjust_fcall_stack(val, nsubs);  /* fix function call stack; See above. */
		elem_new_reset(val);
		if ((val->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
			efree(val->stptr);

		mpfr_unset(val);
#ifdef MEMDEBUG
		memset(val, 0, sizeof(NODE));
		val->type = 0xbaad;
#endif
		freenode(val);
	} else {
		unref(val);
	}

	(void) assoc_remove(symbol, subs);
	DEREF(subs);
	if (assoc_empty(symbol))
		/* last element was removed, so reset array type to null */
		null_array(symbol);

#undef free_subs
}


/* do_delete_loop --- simulate ``for (iggy in foo) delete foo[iggy]'' */

/*
 * The primary hassle here is that `iggy' needs to have some arbitrary
 * array index put in it before we can clear the array, we can't
 * just replace the loop with `delete foo'.
 */

void
do_delete_loop(NODE *symbol, NODE **lhs)
{
	NODE **list;
	NODE akind;

	akind.flags = AINDEX|ADELETE;	/* need a single index */
	list = symbol->alist(symbol, & akind);

	if (assoc_empty(symbol))
		return;

	unref(*lhs);
	*lhs = list[0];
	efree(list);

	/* blast the array in one shot */
	adjust_fcall_stack(symbol, 0);
	assoc_clear(symbol);
}


/* value_info --- print scalar node info */

static void
value_info(NODE *n)
{

#define PREC_NUM -1

	if (n == Nnull_string || n == Null_field) {
		fprintf(output_fp, "<(null)>");
		return;
	}

	if ((n->flags & (STRING|STRCUR)) != 0) {
		fprintf(output_fp, "<");
		fprintf(output_fp, "\"%.*s\"", (int) n->stlen, n->stptr);
		if ((n->flags & (NUMBER|NUMCUR)) != 0) {
#ifdef HAVE_MPFR
			if (is_mpg_float(n))
				fprintf(output_fp, ":%s",
					mpg_fmt("%.*R*g", PREC_NUM, ROUND_MODE, n->mpg_numbr));
			else if (is_mpg_integer(n))
				fprintf(output_fp, ":%s", mpg_fmt("%Zd", n->mpg_i));
			else
#endif
			fprintf(output_fp, ":%.*g", PREC_NUM, n->numbr);
		}
		fprintf(output_fp, ">");
	} else {
#ifdef HAVE_MPFR
		if (is_mpg_float(n))
			fprintf(output_fp, "<%s>",
				mpg_fmt("%.*R*g", PREC_NUM, ROUND_MODE, n->mpg_numbr));
		else if (is_mpg_integer(n))
			fprintf(output_fp, "<%s>", mpg_fmt("%Zd", n->mpg_i));
		else
#endif
		fprintf(output_fp, "<%.*g>", PREC_NUM, n->numbr);
	}

	fprintf(output_fp, ":%s", flags2str(n->flags));

	if ((n->flags & MALLOC) != 0)
		fprintf(output_fp, ":%ld", n->valref);
	else
		fprintf(output_fp, ":");

	if ((n->flags & (STRING|STRCUR)) == STRCUR) {
		size_t len;

		fprintf(output_fp, "][");
		fprintf(output_fp, "stfmt=%d, ", n->stfmt);
		/*
		 * If not STFMT_UNUSED, could be CONVFMT or OFMT if last
		 * used in a print statement. If immutable, could be that it
		 * was originally set as a string, or it's a number that has
		 * an integer value.
		 */
		len = fmt_list[n->stfmt]->stlen;
		fmt_list[n->stfmt]->stptr[len] = '\0';
		fprintf(output_fp, "FMT=\"%s\"",
					n->stfmt == STFMT_UNUSED ? "<unused>"
					: fmt_list[n->stfmt]->stptr);
#ifdef HAVE_MPFR
		fprintf(output_fp, ", ROUNDMODE=\"%c\"", n->strndmode);
#endif
	}

#undef PREC_NUM
}


void
indent(int indent_level)
{
	int i;
	for (i = 0; i < indent_level; i++)
		fprintf(output_fp, "%s", indent_char);
}

/* assoc_info --- print index, value info */

void
assoc_info(NODE *subs, NODE *val, NODE *ndump, const char *aname)
{
	int indent_level = ndump->alevel;

	indent_level++;
	indent(indent_level);
	fprintf(output_fp, "I: [%s:", aname);
	if ((subs->flags & (MPFN|MPZN|INTIND)) == INTIND)
		fprintf(output_fp, "<%ld>", (long) subs->numbr);
	else
		value_info(subs);
	fprintf(output_fp, "]\n");

	indent(indent_level);
	switch (val->type) {
	case Node_val:
		fprintf(output_fp, "V: [scalar: ");
		value_info(val);
		break;
	case Node_var:
		fprintf(output_fp, "V: [scalar: ");
		value_info(val->var_value);
		break;
	case Node_var_array:
		fprintf(output_fp, "V: [");
		ndump->alevel++;
		ndump->adepth--;
		assoc_dump(val, ndump);
		ndump->adepth++;
		ndump->alevel--;
		indent(indent_level);
		break;
	case Node_func:
		fprintf(output_fp, "V: [user_defined_function");
		break;
	case Node_ext_func:
		fprintf(output_fp, "V: [external_function");
		break;
	case Node_builtin_func:
		fprintf(output_fp, "V: [builtin_function");
		break;
	default:
		cant_happen("unexpected node type %s", nodetype2str(val->type));
		break;
	}
	fprintf(output_fp, "]\n");
}


/* do_adump --- dump an array: interface to assoc_dump */

NODE *
do_adump(int nargs)
{
	NODE *symbol, *tmp;
	static NODE ndump;
	long depth = 0;

	/*
	 * depth < 0, no index and value info.
	 *       = 0, main array index and value info; does not descend into sub-arrays.
	 *       > 0, descends into 'depth' sub-arrays, and prints index and value info.
	 */

	if (nargs == 2) {
		tmp = POP_NUMBER();
		depth = get_number_si(tmp);
		DEREF(tmp);
	}
	symbol = POP_PARAM();
	if (symbol->type != Node_var_array)
		fatal(_("%s: first argument is not an array"), "adump");

	ndump.type = Node_dump_array;
	ndump.adepth = depth;
	ndump.alevel = 0;
	assoc_dump(symbol, & ndump);
	return make_number((AWKNUM) 0);
}


/* asort_actual --- do the actual work to sort the input array */

static NODE *
asort_actual(int nargs, sort_context_t ctxt)
{
	NODE *array, *dest = NULL, *result;
	NODE *r, *subs, *s;
	NODE **list = NULL, **ptr;
	unsigned long num_elems, i;
	const char *sort_str;
	char save;
	const char *name = (ctxt == ASORT ? "asort" : "asorti");	// D.R.Y.

	if (nargs == 3)  /* 3rd optional arg */
		s = POP_STRING();
	else
		s = dupnode(Nnull_string);	/* "" => default sorting */

	s = force_string(s);
	sort_str = s->stptr;
	save = s->stptr[s->stlen];
	s->stptr[s->stlen] = '\0';
	if (s->stlen == 0) {		/* default sorting */
		if (ctxt == ASORT)
			sort_str = "@val_type_asc";
		else
			sort_str = "@ind_str_asc";
	}

	if (nargs >= 2) {  /* 2nd optional arg */
		dest = POP_PARAM();
		if (dest->type != Node_var_array) {
			fatal(_("%s: second argument is not an array"), name);
		}
		check_symtab_functab(dest, name,
				_("%s: cannot use %s as second argument"));
	}

	array = POP_PARAM();
	if (array->type != Node_var_array) {
		fatal(_("%s: first argument is not an array"), name);
	}
	else if (array == symbol_table && dest == NULL)
		fatal(_("%s: first argument cannot be SYMTAB without a second argument"), name);
	else if (array == func_table && dest == NULL)
		fatal(_("%s: first argument cannot be FUNCTAB without a second argument"), name);

	if (dest != NULL) {
		static bool warned = false;

		if (nargs == 2 && array == dest && ! warned) {
			warned = true;
			lintwarn(_("asort/asorti: using the same array as source and destination without "
				   "a third argument is silly."));
		}
		for (r = dest->parent_array; r != NULL; r = r->parent_array) {
			if (r == array)
				fatal(_("%s: cannot use a subarray of first argument for second argument"),
					name);
		}
		for (r = array->parent_array; r != NULL; r = r->parent_array) {
			if (r == dest)
				fatal(_("%s: cannot use a subarray of second argument for first argument"),
					name);
		}
	}

	/* sorting happens inside assoc_list */
	list = assoc_list(array, sort_str, ctxt);
	s->stptr[s->stlen] = save;
	DEREF(s);

	num_elems = assoc_length(array);
	if (num_elems == 0 || list == NULL) {
 		/* source array is empty */
 		if (dest != NULL && dest != array)
 			assoc_clear(dest);
		if (list != NULL)
			efree(list);
 		return make_number((AWKNUM) 0);
 	}

	/*
	 * Must not assoc_clear() the source array before constructing
	 * the output array. assoc_list() does not duplicate array values
	 * which are needed for asort().
	 */

	if (dest != NULL && dest != array) {
		assoc_clear(dest);
		result = dest;
	} else {
		/* use 'result' as a temporary destination array */
		result = make_array();
		result->vname = array->vname;
		result->parent_array = array->parent_array;
	}

	if (ctxt == ASORTI) {
		/* We want the indices of the source array. */

		for (i = 1, ptr = list; i <= num_elems; i++, ptr += 2) {
			subs = make_number(i);
			assoc_set(result, subs, *ptr);
		}
	} else {
		/* We want the values of the source array. */

		for (i = 1, ptr = list; i <= num_elems; i++) {
			subs = make_number(i);

			/* free index node */
			r = *ptr++;
			unref(r);

			/* value node */
			r = *ptr++;

			NODE *value = NULL;

			switch (r->type) {
			case Node_val:
				value = dupnode(r);
				break;
			case Node_var:
				/* SYMTAB ... */
				value = dupnode(r->var_value);
				break;
			case Node_var_new:
			case Node_elem_new:
				value = dupnode(Nnull_string);
				break;
			case Node_builtin_func:
			case Node_func:
			case Node_ext_func:
				/* FUNCTAB ... */
				value = make_string(r->vname, strlen(r->vname));
				break;
			case Node_var_array:
			{
				NODE *arr;

				arr = make_array();
				subs = force_string(subs);
				arr->vname = subs->stptr;
				arr->vname[subs->stlen] = '\0';
				subs->stptr = NULL;
				subs->flags &= ~STRCUR;
				arr->parent_array = array; /* actual parent, not the temporary one. */

				value = assoc_copy(r, arr);
				break;
			}
			default:
				cant_happen("asort_actual: got unexpected type %s", nodetype2str(r->type));
			}
			assoc_set(result, subs, value);
		}
	}

	efree(list);

	if (result != dest) {
		/* dest == NULL or dest == array */
		assoc_clear(array);
		*array = *result;	/* copy result into array */
		freenode(result);
	} /* else
		result == dest
		dest != NULL and dest != array */

	return make_number((AWKNUM) num_elems);
}

/* do_asort --- sort array by value */

NODE *
do_asort(int nargs)
{
	return asort_actual(nargs, ASORT);
}

/* do_asorti --- sort array by index */

NODE *
do_asorti(int nargs)
{
	return asort_actual(nargs, ASORTI);
}


/*
 * cmp_strings --- compare two strings; logic similar to cmp_nodes() in eval.c
 *	except the extra case-sensitive comparison when the case-insensitive
 *	result is a match.
 */

static int
cmp_strings(const NODE *n1, const NODE *n2)
{
	char *s1, *s2;
	size_t len1, len2;
	int ret;

	s1 = n1->stptr;
	len1 = n1->stlen;
	s2 =  n2->stptr;
	len2 = n2->stlen;

	if (len1 == 0)
		return len2 == 0 ? 0 : -1;
	if (len2 == 0)
		return 1;

	/* len1 > 0 && len2 > 0 */
	// make const to ensure it doesn't change if we
	// need to call memcmp(), below
	const size_t lmin = len1 < len2 ? len1 : len2;

	if (IGNORECASE) {
		const unsigned char *cp1 = (const unsigned char *) s1;
		const unsigned char *cp2 = (const unsigned char *) s2;

		if (gawk_mb_cur_max > 1) {
			ret = strncasecmpmbs((const unsigned char *) cp1,
					     (const unsigned char *) cp2, lmin);
		} else {
			size_t count = lmin;

			for (ret = 0; count-- > 0 && ret == 0; cp1++, cp2++)
				ret = casetable[*cp1] - casetable[*cp2];
		}
		if (ret != 0)
			return ret;
		/*
		 * If case insensitive result is "they're the same",
		 * use case sensitive comparison to force distinct order.
		 */
	}

	ret = memcmp(s1, s2, lmin);
	if (ret != 0 || len1 == len2)
		return ret;
	return (len1 < len2) ? -1 : 1;
}

/* sort_up_index_string --- qsort comparison function; ascending index strings. */

static int
sort_up_index_string(const void *p1, const void *p2)
{
	const NODE *t1, *t2;

	/* Array indices are strings */
	t1 = *((const NODE *const *) p1);
	t2 = *((const NODE *const *) p2);
	return cmp_strings(t1, t2);
}


/* sort_down_index_str --- qsort comparison function; descending index strings. */

static int
sort_down_index_string(const void *p1, const void *p2)
{
	/*
	 * Negation versus transposed arguments:  when all keys are
	 * distinct, as with array indices here, either method will
	 * transform an ascending sort into a descending one.  But if
	 * there are equal keys--such as when IGNORECASE is honored--
	 * that get disambiguated into a determisitc order, negation
	 * will reverse those but transposed arguments would retain
	 * their relative order within the rest of the reversed sort.
	 */
	return -sort_up_index_string(p1, p2);
}


/* sort_up_index_number --- qsort comparison function; ascending index numbers. */

static int
sort_up_index_number(const void *p1, const void *p2)
{
	const NODE *t1, *t2;
	int ret;

	t1 = *((const NODE *const *) p1);
	t2 = *((const NODE *const *) p2);

	ret = cmp_numbers(t1, t2);
	if (ret != 0)
		return ret;

	/* break a tie with the index string itself */
	t1 = force_string((NODE *) t1);
	t2 = force_string((NODE *) t2);
	return cmp_strings(t1, t2);
}

/* sort_down_index_number --- qsort comparison function; descending index numbers */

static int
sort_down_index_number(const void *p1, const void *p2)
{
	return -sort_up_index_number(p1, p2);
}


/* sort_up_value_string --- qsort comparison function; ascending value string */

static int
sort_up_value_string(const void *p1, const void *p2)
{
	const NODE *t1, *t2;
	int ret;

	t1 = *((const NODE *const *) p1 + 1);
	t2 = *((const NODE *const *) p2 + 1);

	if (t1->type != Node_val || t2->type != Node_val)
		return sort_up_value_type(p1, p2);

	/* t1 and t2 both have string values */
	ret = cmp_strings(t1, t2);
	if (ret != 0)
		return ret;
	return sort_up_index_string(p1, p2);
}


/* sort_down_value_string --- qsort comparison function; descending value string */

static int
sort_down_value_string(const void *p1, const void *p2)
{
	return -sort_up_value_string(p1, p2);
}


/* sort_up_value_number --- qsort comparison function; ascending value number */

static int
sort_up_value_number(const void *p1, const void *p2)
{
	NODE *t1, *t2;
	int ret;

	t1 = *((NODE *const *) p1 + 1);
	t2 = *((NODE *const *) p2 + 1);

	if (t1->type != Node_val || t2->type != Node_val)
		return sort_up_value_type(p1, p2);

	ret = cmp_numbers(t1, t2);
	if (ret != 0)
		return ret;

	/*
	 * Use string value to guarantee same sort order on all
	 * versions of qsort().
	 */
	ret = cmp_strings(force_string(t1), force_string(t2));
	if (ret != 0)
		return ret;
	return sort_up_index_string(p1, p2);
}


/* sort_down_value_number --- qsort comparison function; descending value number */

static int
sort_down_value_number(const void *p1, const void *p2)
{
	return -sort_up_value_number(p1, p2);
}


/* do_sort_up_value_type --- backend comparison on ascending value type */

static int
do_sort_up_value_type(const void *p1, const void *p2)
{
	NODE *n1, *n2;

	static const NODETYPE element_types[] = {
		Node_builtin_func,
		Node_func,
		Node_ext_func,
		Node_var_new,
		Node_elem_new,
		Node_var,
		Node_var_array,
		Node_val,
		Node_illegal
	};

	/* we want to compare the element values */
	n1 = *((NODE *const *) p1 + 1);
	n2 = *((NODE *const *) p2 + 1);

	if (n1->type == Node_var && n2->type == Node_var) {
		/* compare the values of the variables */
		n1 = n1->var_value;
		n2 = n2->var_value;
	}

	/* 1. Arrays vs. everything else, everything else is less than array */
	if (n1->type == Node_var_array) {
		/* return 0 if n2 is a sub-array too, else return 1 */
		return (n2->type != Node_var_array);
	}
	if (n2->type == Node_var_array) {
		return -1;              /* n1 (non-array) < n2 (sub-array) */
	}

	/* 2. Non scalars */
	if (n1->type != Node_val || n2->type != Node_val) {
		int n1_pos, n2_pos, i;

		n1_pos = n2_pos = -1;
		for (i = 0; element_types[i] != Node_illegal; i++) {
			if (n1->type == element_types[i])
				n1_pos = i;

			if (n2->type == element_types[i])
				n2_pos = i;
		}

		assert(n1_pos != -1 && n2_pos != -1);
		return (n1_pos - n2_pos);
	}

	/* two scalars */
	(void) fixtype(n1);
	(void) fixtype(n2);

	/* 3a. Numbers first */
	if ((n1->flags & NUMBER) != 0 && (n2->flags & NUMBER) != 0) {
		return cmp_numbers(n1, n2);
	}

	/* 3b. All numbers are less than all strings. This is aribitrary. */
	if ((n1->flags & NUMBER) != 0 && (n2->flags & STRING) != 0) {
		return -1;
	} else if ((n1->flags & STRING) != 0 && (n2->flags & NUMBER) != 0) {
		return 1;
	}

	/* 4. Two strings */
	return cmp_strings(n1, n2);
}

/* sort_up_value_type --- qsort comparison function; ascending value type */

static int
sort_up_value_type(const void *p1, const void *p2)
{
	int rc = do_sort_up_value_type(p1, p2);

	/* use a tie-breaker if do_sort_up_value_type has no opinion */
	return rc ? rc : sort_up_index_string(p1, p2);
}

/* sort_down_value_type --- qsort comparison function; descending value type */

static int
sort_down_value_type(const void *p1, const void *p2)
{
	return -sort_up_value_type(p1, p2);
}

/* sort_user_func --- user defined qsort comparison function */

static int
sort_user_func(const void *p1, const void *p2)
{
	NODE *idx1, *idx2, *val1, *val2, *r;
	int ret;
	INSTRUCTION *code;

	idx1 = *((NODE *const *) p1);
	idx2 = *((NODE *const *) p2);
	val1 = *((NODE *const *) p1 + 1);
	val2 = *((NODE *const *) p2 + 1);

	code = TOP()->code_ptr;	/* comparison function call instructions */

	/* setup 4 arguments to comp_func() */
	UPREF(idx1);
	PUSH(idx1);
	if (val1->type == Node_val)
		UPREF(val1);
	PUSH(val1);

	UPREF(idx2);
	PUSH(idx2);
	if (val2->type == Node_val)
		UPREF(val2);
	PUSH(val2);

	/* execute the comparison function */
	(void) (*interpret)(code);

	/* return value of the comparison function */
	r = POP_NUMBER();
#ifdef HAVE_MPFR
	/*
	 * mpfr_sgn(mpz_sgn): Returns a positive value if op > 0,
	 * zero if op = 0, and a negative value if op < 0.
	 */
	if (is_mpg_float(r))
		ret = mpfr_sgn(r->mpg_numbr);
	else if (is_mpg_integer(r))
		ret = mpz_sgn(r->mpg_i);
	else
#endif
		ret = (r->numbr < 0.0) ? -1 : (r->numbr > 0.0);
	DEREF(r);
	return ret;
}


/* assoc_list -- construct, and optionally sort, a list of array elements */

NODE **
assoc_list(NODE *symbol, const char *sort_str, sort_context_t sort_ctxt)
{
	typedef int (*qsort_compfunc)(const void *, const void *);

	static const struct qsort_funcs {
		const char *name;
		qsort_compfunc comp_func;
		assoc_kind_t kind;
	} sort_funcs[] = {
{ "@ind_str_asc",	sort_up_index_string,	AINDEX|AISTR|AASC },
{ "@ind_num_asc",	sort_up_index_number,	AINDEX|AINUM|AASC },
{ "@val_str_asc",	sort_up_value_string,	AVALUE|AVSTR|AASC },
{ "@val_num_asc",	sort_up_value_number,	AVALUE|AVNUM|AASC },
{ "@ind_str_desc",	sort_down_index_string,	AINDEX|AISTR|ADESC },
{ "@ind_num_desc",	sort_down_index_number,	AINDEX|AINUM|ADESC },
{ "@val_str_desc",	sort_down_value_string,	AVALUE|AVSTR|ADESC },
{ "@val_num_desc",	sort_down_value_number,	AVALUE|AVNUM|ADESC },
{ "@val_type_asc",	sort_up_value_type,	AVALUE|AASC },
{ "@val_type_desc",	sort_down_value_type,	AVALUE|ADESC },
{ "@unsorted",		0,			AINDEX },
};

	/*
	 * N.B.: AASC and ADESC are hints to the specific array types.
	 *	See cint_list() in cint_array.c.
	 */

	NODE **list;
	NODE akind;
	unsigned long num_elems, j;
	int elem_size, qi;
	qsort_compfunc cmp_func = 0;
	INSTRUCTION *code = NULL;
	extern int currule;
	int save_rule = 0;
	assoc_kind_t assoc_kind = ANONE;

	elem_size = 1;

	for (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {
		if (strcmp(sort_funcs[qi].name, sort_str) == 0)
			break;
	}

	if (qi < j) {
		cmp_func = sort_funcs[qi].comp_func;
		assoc_kind = sort_funcs[qi].kind;

		if (symbol->array_funcs != & cint_array_func)
			assoc_kind &= ~(AASC|ADESC);

		if (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {
			/* need index and value pair in the list */

			assoc_kind |= (AINDEX|AVALUE);
			elem_size = 2;
		}

	} else {	/* unrecognized */
		NODE *f;
		const char *sp;

		for (sp = sort_str; *sp != '\0' && ! isspace((unsigned char) *sp); sp++)
			continue;

		/* empty string or string with space(s) not valid as function name */
		if (sp == sort_str || *sp != '\0')
			fatal(_("`%s' is invalid as a function name"), sort_str);

		f = lookup(sort_str);
		if (f == NULL || f->type != Node_func)
			fatal(_("sort comparison function `%s' is not defined"), sort_str);

		cmp_func = sort_user_func;

		/* need index and value pair in the list */
		assoc_kind |= (AVALUE|AINDEX);
		elem_size = 2;

		/* make function call instructions */
		code = bcalloc(Op_func_call, 2, 0);
		code->func_body = f;
		code->func_name = NULL;		/* not needed, func_body already assigned */
		(code + 1)->expr_count = 4;	/* function takes 4 arguments */
		code->nexti = bcalloc(Op_stop, 1, 0);

		/*
		 * make non-redirected getline, exit, `next' and `nextfile' fatal in
		 * callback function by setting currule in interpret()
		 * to undefined (0).
		 */

		save_rule = currule;	/* save current rule */
		currule = 0;

		PUSH_CODE(code);
	}

	akind.flags = (unsigned int) assoc_kind;	/* kludge */
	list = symbol->alist(symbol, & akind);
	assoc_kind = (assoc_kind_t) akind.flags;	/* symbol->alist can modify it */

	/* check for empty list or unsorted, or list already sorted */
	if (list != NULL && cmp_func != NULL && (assoc_kind & (AASC|ADESC)) == 0) {
		num_elems = assoc_length(symbol);

		qsort(list, num_elems, elem_size * sizeof(NODE *), cmp_func); /* shazzam! */

		if (sort_ctxt == SORTED_IN && (assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE)) {
			/* relocate all index nodes to the first half of the list. */
			for (j = 1; j < num_elems; j++)
				list[j] = list[2 * j];

			/* give back extra memory */

			erealloc(list, NODE **, num_elems * sizeof(NODE *));
		}
	}

	if (cmp_func == sort_user_func) {
		code = POP_CODE();
		currule = save_rule;            /* restore current rule */
		bcfree(code->nexti);            /* Op_stop */
		bcfree(code);                   /* Op_func_call */
	}

	return list;
}

/* new_array_element --- return a new empty element node */

NODE *
new_array_element(void)
{
	NODE *n = make_number(0.0);
	char *sp;

	emalloc(sp, char *, 2);
	sp[0] = sp[1] = '\0';

	n->stptr = sp;
	n->stlen = 0;
	n->stfmt = STFMT_UNUSED;

	n->flags |= (MALLOC|STRING|STRCUR);

	n->type = Node_elem_new;
	n->valref = 1;

	return n;
}
/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output, and Bison version.  */
#define YYBISON 30802

/* Bison version string.  */
#define YYBISON_VERSION "3.8.2"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 0

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1




/* First part of user prologue.  */
#line 26 "awkgram.y"

#ifdef GAWKDEBUG
#define YYDEBUG 12
#endif

#include "awk.h"

#if defined(__STDC__) && __STDC__ < 1	/* VMS weirdness, maybe elsewhere */
#define signed /**/
#endif

static void yyerror(const char *m, ...) ATTRIBUTE_PRINTF_1;
#define  YYERROR_IS_DECLARED	1	/* for bison 3.8. sigh. */
static void error_ln(int line, const char *m, ...) ATTRIBUTE_PRINTF_2;
static void lintwarn_ln(int line, const char *m, ...) ATTRIBUTE_PRINTF_2;
static void warning_ln(int line, const char *m, ...) ATTRIBUTE_PRINTF_2;
static char *get_src_buf(void);
static int yylex(void);
int	yyparse(void);
static INSTRUCTION *snode(INSTRUCTION *subn, INSTRUCTION *op);
static char **check_params(char *fname, int pcount, INSTRUCTION *list);
static int install_function(char *fname, INSTRUCTION *fi, INSTRUCTION *plist);
static NODE *mk_rexp(INSTRUCTION *exp);
static void param_sanity(INSTRUCTION *arglist);
static int parms_shadow(INSTRUCTION *pc, bool *shadow);
#ifndef NO_LINT
static int isnoeffect(OPCODE type);
#endif
static INSTRUCTION *make_assignable(INSTRUCTION *ip);
static void dumpintlstr(const char *str, size_t len);
static void dumpintlstr2(const char *str1, size_t len1, const char *str2, size_t len2);
static bool include_source(INSTRUCTION *file, void **srcfile_p);
static bool load_library(INSTRUCTION *file, void **srcfile_p);
static void set_namespace(INSTRUCTION *ns, INSTRUCTION *comment);
static void change_namespace(const char *new_namespace);
static void next_sourcefile(void);
static char *tokexpand(void);
static NODE *set_profile_text(NODE *n, const char *str, size_t len);
static int check_qualified_special(char *token);
static char *qualify_name(const char *name, size_t len);
static void push_ns_onto_namespace_chain(INSTRUCTION *comment);
static INSTRUCTION *trailing_comment;
static INSTRUCTION *outer_comment;
static INSTRUCTION *interblock_comment;
static INSTRUCTION *pending_comment;
static INSTRUCTION *namespace_chain;

#ifdef DEBUG_COMMENTS
static void
debug_print_comment_s(const char *name, INSTRUCTION *comment, int line)
{
	if (comment != NULL)
		fprintf(stderr, "%d: %s: <%.*s>\n", line, name,
				(int) (comment->memory->stlen - 1),
				comment->memory->stptr);
}
#define debug_print_comment(comment) \
	 debug_print_comment_s(# comment, comment, __LINE__)
#endif

#define instruction(t)	bcalloc(t, 1, 0)

static INSTRUCTION *mk_program(void);
static INSTRUCTION *append_rule(INSTRUCTION *pattern, INSTRUCTION *action);
static INSTRUCTION *mk_function(INSTRUCTION *fi, INSTRUCTION *def);
static INSTRUCTION *mk_condition(INSTRUCTION *cond, INSTRUCTION *ifp, INSTRUCTION *true_branch,
		INSTRUCTION *elsep,	INSTRUCTION *false_branch);
static INSTRUCTION *mk_expression_list(INSTRUCTION *list, INSTRUCTION *s1);
static INSTRUCTION *mk_for_loop(INSTRUCTION *forp, INSTRUCTION *init, INSTRUCTION *cond,
		INSTRUCTION *incr, INSTRUCTION *body);
static void fix_break_continue(INSTRUCTION *list, INSTRUCTION *b_target, INSTRUCTION *c_target);
static INSTRUCTION *mk_binary(INSTRUCTION *s1, INSTRUCTION *s2, INSTRUCTION *op);
static INSTRUCTION *mk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op);
static INSTRUCTION *mk_assignment(INSTRUCTION *lhs, INSTRUCTION *rhs, INSTRUCTION *op);
static INSTRUCTION *mk_getline(INSTRUCTION *op, INSTRUCTION *opt_var, INSTRUCTION *redir, int redirtype);
static int count_expressions(INSTRUCTION **list, bool isarg);
static INSTRUCTION *optimize_assignment(INSTRUCTION *exp);
static void add_lint(INSTRUCTION *list, LINTTYPE linttype);

enum defref { FUNC_DEFINE, FUNC_USE, FUNC_EXT };
static void func_use(const char *name, enum defref how);
static void check_funcs(void);

static ssize_t read_one_line(int fd, void *buffer, size_t count);
static int one_line_close(int fd);
static void merge_comments(INSTRUCTION *c1, INSTRUCTION *c2);
static INSTRUCTION *make_braced_statements(INSTRUCTION *lbrace, INSTRUCTION *stmts, INSTRUCTION *rbrace);
static void add_sign_to_num(NODE *n, char sign);

static int at_seen = 0;
static bool want_source = false;
static bool want_namespace = false;
static bool want_regexp = false;	/* lexical scanning kludge */
static enum {
	FUNC_HEADER,
	FUNC_BODY,
	DONT_CHECK
} want_param_names = DONT_CHECK;	/* ditto */
static bool in_function;		/* parsing kludge */
static int rule = 0;

const char *const ruletab[] = {
	"?",
	"BEGIN",
	"Rule",
	"END",
	"BEGINFILE",
	"ENDFILE",
};

static bool in_print = false;	/* lexical scanning kludge for print */
static int in_parens = 0;	/* lexical scanning kludge for print */
static int sub_counter = 0;	/* array dimension counter for use in delete */
static char *lexptr;		/* pointer to next char during parsing */
static char *lexend;		/* end of buffer */
static char *lexptr_begin;	/* keep track of where we were for error msgs */
static char *lexeme;		/* beginning of lexeme for debugging */
static bool lexeof;		/* seen EOF for current source? */
static char *thisline = NULL;
static int in_braces = 0;	/* count braces for firstline, lastline in an 'action' */
static int lastline = 0;
static int firstline = 0;
static SRCFILE *sourcefile = NULL;	/* current program source */
static int lasttok = 0;
static bool eof_warned = false;	/* GLOBAL: want warning for each file */
static int break_allowed;	/* kludge for break */
static int continue_allowed;	/* kludge for continue */

#define END_FILE	-1000
#define END_SRC  	-2000

#define YYDEBUG_LEXER_TEXT (lexeme)
static char *tokstart = NULL;
static char *tok = NULL;
static char *tokend;
int errcount = 0;

extern char *source;
extern int sourceline;
extern SRCFILE *srcfiles;
extern INSTRUCTION *rule_list;
extern int max_args;
extern NODE **args_array;

const char awk_namespace[] = "awk";
const char *current_namespace = awk_namespace;
bool namespace_changed = false;

static INSTRUCTION *rule_block[sizeof(ruletab)/sizeof(ruletab[0])];

static INSTRUCTION *ip_rec;
static INSTRUCTION *ip_newfile;
static INSTRUCTION *ip_atexit = NULL;
static INSTRUCTION *ip_end;
static INSTRUCTION *ip_endfile;
static INSTRUCTION *ip_beginfile;
INSTRUCTION *main_beginfile;
static bool called_from_eval = false;

static inline INSTRUCTION *list_create(INSTRUCTION *x);
static inline INSTRUCTION *list_append(INSTRUCTION *l, INSTRUCTION *x);
static inline INSTRUCTION *list_prepend(INSTRUCTION *l, INSTRUCTION *x);
static inline INSTRUCTION *list_merge(INSTRUCTION *l1, INSTRUCTION *l2);

extern double fmod(double x, double y);

#define YYSTYPE INSTRUCTION *

#line 240 "awkgram.c"

# ifndef YY_CAST
#  ifdef __cplusplus
#   define YY_CAST(Type, Val) static_cast<Type> (Val)
#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
#  else
#   define YY_CAST(Type, Val) ((Type) (Val))
#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
#  endif
# endif
# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif


/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int yydebug;
#endif

/* Token kinds.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    YYEMPTY = -2,
    YYEOF = 0,                     /* "end of file"  */
    YYerror = 256,                 /* error  */
    YYUNDEF = 257,                 /* "invalid token"  */
    FUNC_CALL = 258,               /* FUNC_CALL  */
    NAME = 259,                    /* NAME  */
    REGEXP = 260,                  /* REGEXP  */
    FILENAME = 261,                /* FILENAME  */
    YNUMBER = 262,                 /* YNUMBER  */
    YSTRING = 263,                 /* YSTRING  */
    TYPED_REGEXP = 264,            /* TYPED_REGEXP  */
    RELOP = 265,                   /* RELOP  */
    IO_OUT = 266,                  /* IO_OUT  */
    IO_IN = 267,                   /* IO_IN  */
    ASSIGNOP = 268,                /* ASSIGNOP  */
    ASSIGN = 269,                  /* ASSIGN  */
    MATCHOP = 270,                 /* MATCHOP  */
    CONCAT_OP = 271,               /* CONCAT_OP  */
    SUBSCRIPT = 272,               /* SUBSCRIPT  */
    LEX_BEGIN = 273,               /* LEX_BEGIN  */
    LEX_END = 274,                 /* LEX_END  */
    LEX_IF = 275,                  /* LEX_IF  */
    LEX_ELSE = 276,                /* LEX_ELSE  */
    LEX_RETURN = 277,              /* LEX_RETURN  */
    LEX_DELETE = 278,              /* LEX_DELETE  */
    LEX_SWITCH = 279,              /* LEX_SWITCH  */
    LEX_CASE = 280,                /* LEX_CASE  */
    LEX_DEFAULT = 281,             /* LEX_DEFAULT  */
    LEX_WHILE = 282,               /* LEX_WHILE  */
    LEX_DO = 283,                  /* LEX_DO  */
    LEX_FOR = 284,                 /* LEX_FOR  */
    LEX_BREAK = 285,               /* LEX_BREAK  */
    LEX_CONTINUE = 286,            /* LEX_CONTINUE  */
    LEX_PRINT = 287,               /* LEX_PRINT  */
    LEX_PRINTF = 288,              /* LEX_PRINTF  */
    LEX_NEXT = 289,                /* LEX_NEXT  */
    LEX_EXIT = 290,                /* LEX_EXIT  */
    LEX_FUNCTION = 291,            /* LEX_FUNCTION  */
    LEX_BEGINFILE = 292,           /* LEX_BEGINFILE  */
    LEX_ENDFILE = 293,             /* LEX_ENDFILE  */
    LEX_GETLINE = 294,             /* LEX_GETLINE  */
    LEX_NEXTFILE = 295,            /* LEX_NEXTFILE  */
    LEX_IN = 296,                  /* LEX_IN  */
    LEX_AND = 297,                 /* LEX_AND  */
    LEX_OR = 298,                  /* LEX_OR  */
    INCREMENT = 299,               /* INCREMENT  */
    DECREMENT = 300,               /* DECREMENT  */
    LEX_BUILTIN = 301,             /* LEX_BUILTIN  */
    LEX_LENGTH = 302,              /* LEX_LENGTH  */
    LEX_EOF = 303,                 /* LEX_EOF  */
    LEX_INCLUDE = 304,             /* LEX_INCLUDE  */
    LEX_EVAL = 305,                /* LEX_EVAL  */
    LEX_LOAD = 306,                /* LEX_LOAD  */
    LEX_NAMESPACE = 307,           /* LEX_NAMESPACE  */
    NEWLINE = 308,                 /* NEWLINE  */
    SLASH_BEFORE_EQUAL = 309,      /* SLASH_BEFORE_EQUAL  */
    UNARY = 310                    /* UNARY  */
  };
  typedef enum yytokentype yytoken_kind_t;
#endif
/* Token kinds.  */
#define YYEMPTY -2
#define YYEOF 0
#define YYerror 256
#define YYUNDEF 257
#define FUNC_CALL 258
#define NAME 259
#define REGEXP 260
#define FILENAME 261
#define YNUMBER 262
#define YSTRING 263
#define TYPED_REGEXP 264
#define RELOP 265
#define IO_OUT 266
#define IO_IN 267
#define ASSIGNOP 268
#define ASSIGN 269
#define MATCHOP 270
#define CONCAT_OP 271
#define SUBSCRIPT 272
#define LEX_BEGIN 273
#define LEX_END 274
#define LEX_IF 275
#define LEX_ELSE 276
#define LEX_RETURN 277
#define LEX_DELETE 278
#define LEX_SWITCH 279
#define LEX_CASE 280
#define LEX_DEFAULT 281
#define LEX_WHILE 282
#define LEX_DO 283
#define LEX_FOR 284
#define LEX_BREAK 285
#define LEX_CONTINUE 286
#define LEX_PRINT 287
#define LEX_PRINTF 288
#define LEX_NEXT 289
#define LEX_EXIT 290
#define LEX_FUNCTION 291
#define LEX_BEGINFILE 292
#define LEX_ENDFILE 293
#define LEX_GETLINE 294
#define LEX_NEXTFILE 295
#define LEX_IN 296
#define LEX_AND 297
#define LEX_OR 298
#define INCREMENT 299
#define DECREMENT 300
#define LEX_BUILTIN 301
#define LEX_LENGTH 302
#define LEX_EOF 303
#define LEX_INCLUDE 304
#define LEX_EVAL 305
#define LEX_LOAD 306
#define LEX_NAMESPACE 307
#define NEWLINE 308
#define SLASH_BEFORE_EQUAL 309
#define UNARY 310

/* Value type.  */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif


extern YYSTYPE yylval;


int yyparse (void);



/* Symbol kind.  */
enum yysymbol_kind_t
{
  YYSYMBOL_YYEMPTY = -2,
  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
  YYSYMBOL_YYerror = 1,                    /* error  */
  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
  YYSYMBOL_FUNC_CALL = 3,                  /* FUNC_CALL  */
  YYSYMBOL_NAME = 4,                       /* NAME  */
  YYSYMBOL_REGEXP = 5,                     /* REGEXP  */
  YYSYMBOL_FILENAME = 6,                   /* FILENAME  */
  YYSYMBOL_YNUMBER = 7,                    /* YNUMBER  */
  YYSYMBOL_YSTRING = 8,                    /* YSTRING  */
  YYSYMBOL_TYPED_REGEXP = 9,               /* TYPED_REGEXP  */
  YYSYMBOL_RELOP = 10,                     /* RELOP  */
  YYSYMBOL_IO_OUT = 11,                    /* IO_OUT  */
  YYSYMBOL_IO_IN = 12,                     /* IO_IN  */
  YYSYMBOL_ASSIGNOP = 13,                  /* ASSIGNOP  */
  YYSYMBOL_ASSIGN = 14,                    /* ASSIGN  */
  YYSYMBOL_MATCHOP = 15,                   /* MATCHOP  */
  YYSYMBOL_CONCAT_OP = 16,                 /* CONCAT_OP  */
  YYSYMBOL_SUBSCRIPT = 17,                 /* SUBSCRIPT  */
  YYSYMBOL_LEX_BEGIN = 18,                 /* LEX_BEGIN  */
  YYSYMBOL_LEX_END = 19,                   /* LEX_END  */
  YYSYMBOL_LEX_IF = 20,                    /* LEX_IF  */
  YYSYMBOL_LEX_ELSE = 21,                  /* LEX_ELSE  */
  YYSYMBOL_LEX_RETURN = 22,                /* LEX_RETURN  */
  YYSYMBOL_LEX_DELETE = 23,                /* LEX_DELETE  */
  YYSYMBOL_LEX_SWITCH = 24,                /* LEX_SWITCH  */
  YYSYMBOL_LEX_CASE = 25,                  /* LEX_CASE  */
  YYSYMBOL_LEX_DEFAULT = 26,               /* LEX_DEFAULT  */
  YYSYMBOL_LEX_WHILE = 27,                 /* LEX_WHILE  */
  YYSYMBOL_LEX_DO = 28,                    /* LEX_DO  */
  YYSYMBOL_LEX_FOR = 29,                   /* LEX_FOR  */
  YYSYMBOL_LEX_BREAK = 30,                 /* LEX_BREAK  */
  YYSYMBOL_LEX_CONTINUE = 31,              /* LEX_CONTINUE  */
  YYSYMBOL_LEX_PRINT = 32,                 /* LEX_PRINT  */
  YYSYMBOL_LEX_PRINTF = 33,                /* LEX_PRINTF  */
  YYSYMBOL_LEX_NEXT = 34,                  /* LEX_NEXT  */
  YYSYMBOL_LEX_EXIT = 35,                  /* LEX_EXIT  */
  YYSYMBOL_LEX_FUNCTION = 36,              /* LEX_FUNCTION  */
  YYSYMBOL_LEX_BEGINFILE = 37,             /* LEX_BEGINFILE  */
  YYSYMBOL_LEX_ENDFILE = 38,               /* LEX_ENDFILE  */
  YYSYMBOL_LEX_GETLINE = 39,               /* LEX_GETLINE  */
  YYSYMBOL_LEX_NEXTFILE = 40,              /* LEX_NEXTFILE  */
  YYSYMBOL_LEX_IN = 41,                    /* LEX_IN  */
  YYSYMBOL_LEX_AND = 42,                   /* LEX_AND  */
  YYSYMBOL_LEX_OR = 43,                    /* LEX_OR  */
  YYSYMBOL_INCREMENT = 44,                 /* INCREMENT  */
  YYSYMBOL_DECREMENT = 45,                 /* DECREMENT  */
  YYSYMBOL_LEX_BUILTIN = 46,               /* LEX_BUILTIN  */
  YYSYMBOL_LEX_LENGTH = 47,                /* LEX_LENGTH  */
  YYSYMBOL_LEX_EOF = 48,                   /* LEX_EOF  */
  YYSYMBOL_LEX_INCLUDE = 49,               /* LEX_INCLUDE  */
  YYSYMBOL_LEX_EVAL = 50,                  /* LEX_EVAL  */
  YYSYMBOL_LEX_LOAD = 51,                  /* LEX_LOAD  */
  YYSYMBOL_LEX_NAMESPACE = 52,             /* LEX_NAMESPACE  */
  YYSYMBOL_NEWLINE = 53,                   /* NEWLINE  */
  YYSYMBOL_SLASH_BEFORE_EQUAL = 54,        /* SLASH_BEFORE_EQUAL  */
  YYSYMBOL_55_ = 55,                       /* '?'  */
  YYSYMBOL_56_ = 56,                       /* ':'  */
  YYSYMBOL_57_ = 57,                       /* ','  */
  YYSYMBOL_58_ = 58,                       /* '<'  */
  YYSYMBOL_59_ = 59,                       /* '>'  */
  YYSYMBOL_60_ = 60,                       /* '+'  */
  YYSYMBOL_61_ = 61,                       /* '-'  */
  YYSYMBOL_62_ = 62,                       /* '*'  */
  YYSYMBOL_63_ = 63,                       /* '/'  */
  YYSYMBOL_64_ = 64,                       /* '%'  */
  YYSYMBOL_65_ = 65,                       /* '!'  */
  YYSYMBOL_UNARY = 66,                     /* UNARY  */
  YYSYMBOL_67_ = 67,                       /* '^'  */
  YYSYMBOL_68_ = 68,                       /* '$'  */
  YYSYMBOL_69_ = 69,                       /* '('  */
  YYSYMBOL_70_ = 70,                       /* ')'  */
  YYSYMBOL_71_ = 71,                       /* '@'  */
  YYSYMBOL_72_ = 72,                       /* '['  */
  YYSYMBOL_73_ = 73,                       /* ']'  */
  YYSYMBOL_74_ = 74,                       /* '{'  */
  YYSYMBOL_75_ = 75,                       /* '}'  */
  YYSYMBOL_76_ = 76,                       /* ';'  */
  YYSYMBOL_YYACCEPT = 77,                  /* $accept  */
  YYSYMBOL_program = 78,                   /* program  */
  YYSYMBOL_rule = 79,                      /* rule  */
  YYSYMBOL_source = 80,                    /* source  */
  YYSYMBOL_library = 81,                   /* library  */
  YYSYMBOL_namespace = 82,                 /* namespace  */
  YYSYMBOL_pattern = 83,                   /* pattern  */
  YYSYMBOL_action = 84,                    /* action  */
  YYSYMBOL_func_name = 85,                 /* func_name  */
  YYSYMBOL_lex_builtin = 86,               /* lex_builtin  */
  YYSYMBOL_function_prologue = 87,         /* function_prologue  */
  YYSYMBOL_88_1 = 88,                      /* $@1  */
  YYSYMBOL_regexp = 89,                    /* regexp  */
  YYSYMBOL_90_2 = 90,                      /* $@2  */
  YYSYMBOL_typed_regexp = 91,              /* typed_regexp  */
  YYSYMBOL_a_slash = 92,                   /* a_slash  */
  YYSYMBOL_statements = 93,                /* statements  */
  YYSYMBOL_statement_term = 94,            /* statement_term  */
  YYSYMBOL_statement = 95,                 /* statement  */
  YYSYMBOL_non_compound_stmt = 96,         /* non_compound_stmt  */
  YYSYMBOL_97_3 = 97,                      /* $@3  */
  YYSYMBOL_simple_stmt = 98,               /* simple_stmt  */
  YYSYMBOL_99_4 = 99,                      /* $@4  */
  YYSYMBOL_100_5 = 100,                    /* $@5  */
  YYSYMBOL_opt_simple_stmt = 101,          /* opt_simple_stmt  */
  YYSYMBOL_case_statements = 102,          /* case_statements  */
  YYSYMBOL_case_statement = 103,           /* case_statement  */
  YYSYMBOL_case_value = 104,               /* case_value  */
  YYSYMBOL_print = 105,                    /* print  */
  YYSYMBOL_print_expression_list = 106,    /* print_expression_list  */
  YYSYMBOL_output_redir = 107,             /* output_redir  */
  YYSYMBOL_108_6 = 108,                    /* $@6  */
  YYSYMBOL_if_statement = 109,             /* if_statement  */
  YYSYMBOL_nls = 110,                      /* nls  */
  YYSYMBOL_opt_nls = 111,                  /* opt_nls  */
  YYSYMBOL_input_redir = 112,              /* input_redir  */
  YYSYMBOL_opt_param_list = 113,           /* opt_param_list  */
  YYSYMBOL_param_list = 114,               /* param_list  */
  YYSYMBOL_opt_exp = 115,                  /* opt_exp  */
  YYSYMBOL_opt_expression_list = 116,      /* opt_expression_list  */
  YYSYMBOL_expression_list = 117,          /* expression_list  */
  YYSYMBOL_opt_fcall_expression_list = 118, /* opt_fcall_expression_list  */
  YYSYMBOL_fcall_expression_list = 119,    /* fcall_expression_list  */
  YYSYMBOL_fcall_exp = 120,                /* fcall_exp  */
  YYSYMBOL_opt_fcall_exp = 121,            /* opt_fcall_exp  */
  YYSYMBOL_exp = 122,                      /* exp  */
  YYSYMBOL_assign_operator = 123,          /* assign_operator  */
  YYSYMBOL_relop_or_less = 124,            /* relop_or_less  */
  YYSYMBOL_a_relop = 125,                  /* a_relop  */
  YYSYMBOL_common_exp = 126,               /* common_exp  */
  YYSYMBOL_simp_exp = 127,                 /* simp_exp  */
  YYSYMBOL_simp_exp_nc = 128,              /* simp_exp_nc  */
  YYSYMBOL_non_post_simp_exp = 129,        /* non_post_simp_exp  */
  YYSYMBOL_func_call = 130,                /* func_call  */
  YYSYMBOL_direct_func_call = 131,         /* direct_func_call  */
  YYSYMBOL_opt_variable = 132,             /* opt_variable  */
  YYSYMBOL_delete_subscript_list = 133,    /* delete_subscript_list  */
  YYSYMBOL_delete_subscript = 134,         /* delete_subscript  */
  YYSYMBOL_delete_exp_list = 135,          /* delete_exp_list  */
  YYSYMBOL_bracketed_exp_list = 136,       /* bracketed_exp_list  */
  YYSYMBOL_subscript = 137,                /* subscript  */
  YYSYMBOL_subscript_list = 138,           /* subscript_list  */
  YYSYMBOL_simple_variable = 139,          /* simple_variable  */
  YYSYMBOL_variable = 140,                 /* variable  */
  YYSYMBOL_opt_incdec = 141,               /* opt_incdec  */
  YYSYMBOL_l_brace = 142,                  /* l_brace  */
  YYSYMBOL_r_brace = 143,                  /* r_brace  */
  YYSYMBOL_r_paren = 144,                  /* r_paren  */
  YYSYMBOL_opt_semi = 145,                 /* opt_semi  */
  YYSYMBOL_semi = 146,                     /* semi  */
  YYSYMBOL_colon = 147,                    /* colon  */
  YYSYMBOL_comma = 148                     /* comma  */
};
typedef enum yysymbol_kind_t yysymbol_kind_t;




#ifdef short
# undef short
#endif

/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
   <limits.h> and (if available) <stdint.h> are included
   so that the code can choose integer types of a good width.  */

#ifndef __PTRDIFF_MAX__
# include <limits.h> /* INFRINGES ON USER NAME SPACE */
# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
#  define YY_STDINT_H
# endif
#endif

/* Narrow types that promote to a signed type and that can represent a
   signed or unsigned integer of at least N bits.  In tables they can
   save space and decrease cache pressure.  Promoting to a signed type
   helps avoid bugs in integer arithmetic.  */

#ifdef __INT_LEAST8_MAX__
typedef __INT_LEAST8_TYPE__ yytype_int8;
#elif defined YY_STDINT_H
typedef int_least8_t yytype_int8;
#else
typedef signed char yytype_int8;
#endif

#ifdef __INT_LEAST16_MAX__
typedef __INT_LEAST16_TYPE__ yytype_int16;
#elif defined YY_STDINT_H
typedef int_least16_t yytype_int16;
#else
typedef short yytype_int16;
#endif

/* Work around bug in HP-UX 11.23, which defines these macros
   incorrectly for preprocessor constants.  This workaround can likely
   be removed in 2023, as HPE has promised support for HP-UX 11.23
   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
#ifdef __hpux
# undef UINT_LEAST8_MAX
# undef UINT_LEAST16_MAX
# define UINT_LEAST8_MAX 255
# define UINT_LEAST16_MAX 65535
#endif

#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
typedef __UINT_LEAST8_TYPE__ yytype_uint8;
#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST8_MAX <= INT_MAX)
typedef uint_least8_t yytype_uint8;
#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
typedef unsigned char yytype_uint8;
#else
typedef short yytype_uint8;
#endif

#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
typedef __UINT_LEAST16_TYPE__ yytype_uint16;
#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST16_MAX <= INT_MAX)
typedef uint_least16_t yytype_uint16;
#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
typedef unsigned short yytype_uint16;
#else
typedef int yytype_uint16;
#endif

#ifndef YYPTRDIFF_T
# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
#  define YYPTRDIFF_T __PTRDIFF_TYPE__
#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
# elif defined PTRDIFF_MAX
#  ifndef ptrdiff_t
#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  endif
#  define YYPTRDIFF_T ptrdiff_t
#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
# else
#  define YYPTRDIFF_T long
#  define YYPTRDIFF_MAXIMUM LONG_MAX
# endif
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned
# endif
#endif

#define YYSIZE_MAXIMUM                                  \
  YY_CAST (YYPTRDIFF_T,                                 \
           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
            ? YYPTRDIFF_MAXIMUM                         \
            : YY_CAST (YYSIZE_T, -1)))

#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))


/* Stored state numbers (used for stacks). */
typedef yytype_int16 yy_state_t;

/* State numbers in computations.  */
typedef int yy_state_fast_t;

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(Msgid) Msgid
# endif
#endif


#ifndef YY_ATTRIBUTE_PURE
# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define YY_ATTRIBUTE_PURE
# endif
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
# else
#  define YY_ATTRIBUTE_UNUSED
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YY_USE(E) ((void) (E))
#else
# define YY_USE(E) /* empty */
#endif

/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
# else
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# endif
# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif

#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
# define YY_IGNORE_USELESS_CAST_BEGIN                          \
    _Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
# define YY_IGNORE_USELESS_CAST_END            \
    _Pragma ("GCC diagnostic pop")
#endif
#ifndef YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_END
#endif


#define YY_ASSERT(E) ((void) (0 && (E)))

#if !defined yyoverflow

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's 'empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
             && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* !defined yyoverflow */

#if (! defined yyoverflow \
     && (! defined __cplusplus \
         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yy_state_t yyss_alloc;
  YYSTYPE yyvs_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
    do                                                                  \
      {                                                                 \
        YYPTRDIFF_T yynewbytes;                                         \
        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        Stack = &yyptr->Stack_alloc;                                    \
        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
      }                                                                 \
    while (0)

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(Dst, Src, Count) \
      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
#  else
#   define YYCOPY(Dst, Src, Count)              \
      do                                        \
        {                                       \
          YYPTRDIFF_T yyi;                      \
          for (yyi = 0; yyi < (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (0)
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  2
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   1200

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  77
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  72
/* YYNRULES -- Number of rules.  */
#define YYNRULES  209
/* YYNSTATES -- Number of states.  */
#define YYNSTATES  356

/* YYMAXUTOK -- Last valid token kind.  */
#define YYMAXUTOK   310


/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex, with out-of-bounds checking.  */
#define YYTRANSLATE(YYX)                                \
  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
   : YYSYMBOL_YYUNDEF)

/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex.  */
static const yytype_int8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    65,     2,     2,    68,    64,     2,     2,
      69,    70,    62,    60,    57,    61,     2,    63,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,    56,    76,
      58,     2,    59,    55,    71,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    72,     2,    73,    67,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,    74,     2,    75,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
      66
};

#if YYDEBUG
/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
static const yytype_int16 yyrline[] =
{
       0,   236,   236,   237,   242,   252,   256,   268,   276,   290,
     301,   311,   321,   347,   357,   359,   364,   374,   376,   381,
     383,   385,   391,   395,   400,   430,   442,   454,   460,   469,
     487,   488,   499,   505,   513,   514,   518,   518,   552,   551,
     585,   600,   602,   607,   608,   628,   633,   634,   638,   649,
     654,   661,   769,   820,   870,   996,  1018,  1039,  1049,  1059,
    1069,  1080,  1093,  1111,  1110,  1127,  1145,  1145,  1247,  1247,
    1280,  1310,  1318,  1319,  1325,  1326,  1333,  1338,  1351,  1366,
    1368,  1376,  1383,  1385,  1393,  1402,  1404,  1413,  1414,  1422,
    1427,  1427,  1440,  1447,  1460,  1464,  1486,  1487,  1493,  1494,
    1503,  1504,  1509,  1514,  1531,  1533,  1535,  1542,  1543,  1549,
    1550,  1555,  1557,  1564,  1566,  1574,  1579,  1590,  1591,  1596,
    1598,  1605,  1607,  1615,  1620,  1630,  1631,  1636,  1637,  1642,
    1649,  1653,  1655,  1657,  1670,  1687,  1697,  1704,  1706,  1711,
    1713,  1715,  1723,  1725,  1730,  1732,  1737,  1739,  1741,  1798,
    1800,  1802,  1804,  1806,  1808,  1810,  1812,  1826,  1831,  1836,
    1862,  1868,  1870,  1872,  1874,  1876,  1878,  1883,  1887,  1919,
    1927,  1933,  1939,  1952,  1953,  1954,  1959,  1964,  1968,  1972,
    1987,  2008,  2013,  2050,  2087,  2088,  2094,  2095,  2100,  2102,
    2109,  2126,  2143,  2145,  2152,  2157,  2163,  2175,  2187,  2196,
    2200,  2205,  2209,  2213,  2217,  2222,  2223,  2227,  2231,  2235
};
#endif

/** Accessing symbol of state STATE.  */
#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])

#if YYDEBUG || 0
/* The user-facing name of the symbol whose (internal) number is
   YYSYMBOL.  No bounds checking.  */
static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;

/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "\"end of file\"", "error", "\"invalid token\"", "FUNC_CALL", "NAME",
  "REGEXP", "FILENAME", "YNUMBER", "YSTRING", "TYPED_REGEXP", "RELOP",
  "IO_OUT", "IO_IN", "ASSIGNOP", "ASSIGN", "MATCHOP", "CONCAT_OP",
  "SUBSCRIPT", "LEX_BEGIN", "LEX_END", "LEX_IF", "LEX_ELSE", "LEX_RETURN",
  "LEX_DELETE", "LEX_SWITCH", "LEX_CASE", "LEX_DEFAULT", "LEX_WHILE",
  "LEX_DO", "LEX_FOR", "LEX_BREAK", "LEX_CONTINUE", "LEX_PRINT",
  "LEX_PRINTF", "LEX_NEXT", "LEX_EXIT", "LEX_FUNCTION", "LEX_BEGINFILE",
  "LEX_ENDFILE", "LEX_GETLINE", "LEX_NEXTFILE", "LEX_IN", "LEX_AND",
  "LEX_OR", "INCREMENT", "DECREMENT", "LEX_BUILTIN", "LEX_LENGTH",
  "LEX_EOF", "LEX_INCLUDE", "LEX_EVAL", "LEX_LOAD", "LEX_NAMESPACE",
  "NEWLINE", "SLASH_BEFORE_EQUAL", "'?'", "':'", "','", "'<'", "'>'",
  "'+'", "'-'", "'*'", "'/'", "'%'", "'!'", "UNARY", "'^'", "'$'", "'('",
  "')'", "'@'", "'['", "']'", "'{'", "'}'", "';'", "$accept", "program",
  "rule", "source", "library", "namespace", "pattern", "action",
  "func_name", "lex_builtin", "function_prologue", "$@1", "regexp", "$@2",
  "typed_regexp", "a_slash", "statements", "statement_term", "statement",
  "non_compound_stmt", "$@3", "simple_stmt", "$@4", "$@5",
  "opt_simple_stmt", "case_statements", "case_statement", "case_value",
  "print", "print_expression_list", "output_redir", "$@6", "if_statement",
  "nls", "opt_nls", "input_redir", "opt_param_list", "param_list",
  "opt_exp", "opt_expression_list", "expression_list",
  "opt_fcall_expression_list", "fcall_expression_list", "fcall_exp",
  "opt_fcall_exp", "exp", "assign_operator", "relop_or_less", "a_relop",
  "common_exp", "simp_exp", "simp_exp_nc", "non_post_simp_exp",
  "func_call", "direct_func_call", "opt_variable", "delete_subscript_list",
  "delete_subscript", "delete_exp_list", "bracketed_exp_list", "subscript",
  "subscript_list", "simple_variable", "variable", "opt_incdec", "l_brace",
  "r_brace", "r_paren", "opt_semi", "semi", "colon", "comma", YY_NULLPTR
};

static const char *
yysymbol_name (yysymbol_kind_t yysymbol)
{
  return yytname[yysymbol];
}
#endif

#define YYPACT_NINF (-276)

#define yypact_value_is_default(Yyn) \
  ((Yyn) == YYPACT_NINF)

#define YYTABLE_NINF (-119)

#define yytable_value_is_error(Yyn) \
  ((Yyn) == YYTABLE_NINF)

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
static const yytype_int16 yypact[] =
{
    -276,   315,  -276,  -276,   -45,   -41,  -276,  -276,  -276,  -276,
     133,  -276,  -276,    13,    13,    13,   -13,    -7,  -276,  -276,
    -276,  1046,  1046,  -276,  1046,  1074,   817,   172,  -276,   -23,
     -10,  -276,  -276,    29,  1112,   973,   276,   310,  -276,  -276,
    -276,  -276,   137,   741,   817,  -276,     1,  -276,  -276,  -276,
    -276,  -276,    64,    84,  -276,    98,  -276,  -276,  -276,   741,
     741,   173,   111,   117,   111,   111,  1046,   125,  -276,  -276,
      15,  1016,    31,    65,   151,  -276,   141,  -276,  -276,  -276,
      29,  -276,   141,  -276,   198,  -276,  -276,  1001,   203,  1046,
    1046,  1046,   141,  -276,  -276,  -276,  1046,  1046,   175,   276,
    1046,  1046,  1046,  1046,  1046,  1046,  1046,  1046,  1046,  1046,
    1046,  1046,  -276,   209,  -276,  -276,   208,  1046,  -276,  -276,
    -276,   142,    74,  -276,  1141,    73,  1141,  -276,  -276,  -276,
    -276,  1046,  -276,   142,   142,  1016,  -276,  -276,  -276,  1046,
    -276,   186,   845,  -276,  -276,     8,    90,  -276,    34,    90,
    -276,    59,    90,    29,  -276,   541,  -276,  -276,  -276,    11,
    -276,   287,   130,  1131,  -276,   139,  1141,    13,   123,   123,
     111,   111,   111,   111,   123,   123,   111,   111,   111,   111,
    -276,  -276,  1141,  -276,  1001,   769,  -276,    45,   276,  -276,
    -276,  1141,   203,  -276,  1141,  -276,  -276,  -276,  -276,  -276,
    -276,  -276,   174,  -276,    10,   179,   183,   141,   185,    90,
      90,  -276,  -276,    90,  1046,    90,   141,  -276,  -276,    90,
    -276,  -276,  1141,  -276,   182,   141,  1046,  -276,  -276,  -276,
    -276,  -276,  -276,   142,    77,  -276,  1046,  1001,  -276,   251,
    1046,  1046,   659,   894,  -276,  -276,  -276,    90,  1141,  -276,
    -276,  -276,   589,   541,   141,  -276,  -276,  1141,   141,  -276,
      46,  1016,  -276,    90,   -41,   189,  1016,  1016,   243,   -15,
    -276,   182,  -276,   817,   263,  -276,   162,  -276,  -276,  -276,
    -276,  -276,   141,  -276,  -276,    60,  -276,  -276,  -276,   141,
     141,   211,   203,   141,    15,  -276,  -276,   659,  -276,  -276,
     -10,   659,  1046,   142,   693,   186,  1046,   256,  -276,  -276,
    1016,   141,  1089,   141,   973,   141,   260,   141,   659,   141,
     928,   659,  -276,   340,   222,  -276,   212,  -276,  -276,   928,
     142,  -276,  -276,  -276,   281,   282,  -276,  -276,   222,  -276,
     141,  -276,   142,   141,  -276,  -276,   141,  -276,   141,   659,
    -276,   389,   659,  -276,   465,  -276
};

/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
   Performed when YYTABLE does not specify something else to do.  Zero
   means the default is an error.  */
static const yytype_uint8 yydefact[] =
{
       2,     0,     1,     6,     0,   195,   177,   178,    25,    26,
       0,    27,    28,   184,     0,     0,     0,   172,     5,    94,
      42,     0,     0,    41,     0,     0,     0,     0,     3,     0,
       0,   167,    38,     4,    23,   138,   146,   147,   149,   173,
     181,   197,   174,     0,     0,   192,     0,   196,    31,    30,
      34,    35,     0,     0,    32,    98,   185,   175,   176,     0,
       0,     0,   180,   174,   179,   168,     0,   201,   174,   113,
       0,   111,     0,     0,     0,   182,    96,   207,     7,     8,
      46,    43,    96,     9,     0,    95,   142,     0,     0,     0,
       0,     0,    96,   143,   145,   144,     0,     0,     0,   148,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,   140,   139,   157,   158,     0,     0,   121,    40,
     126,     0,     0,   119,   125,     0,   111,   194,   193,    33,
      36,     0,   156,     0,     0,     0,   199,   200,   198,   114,
     204,     0,     0,   169,    15,     0,     0,    18,     0,     0,
      21,     0,     0,    97,   202,     0,    47,    39,   133,   134,
     135,   131,   132,     0,   209,   136,    24,   184,   154,   155,
     151,   152,   153,   150,   165,   166,   162,   163,   164,   161,
     130,   141,   129,   183,   122,     0,   191,     0,    99,   170,
     171,   115,     0,   116,   112,    14,    10,    17,    11,    20,
      12,    45,     0,    63,     0,     0,     0,    96,     0,     0,
       0,    85,    86,     0,   107,     0,    96,    44,    57,     0,
      66,    50,    71,    43,   205,    96,     0,   160,   123,   124,
     120,   104,   102,     0,     0,   159,     0,   127,    68,     0,
       0,     0,     0,    72,    58,    59,    60,     0,   108,    61,
     203,    65,     0,     0,    96,   206,    48,   137,    96,   105,
       0,     0,   128,     0,   186,     0,     0,     0,     0,   195,
      73,     0,    62,     0,    89,    87,     0,    49,    29,    37,
     106,   103,    96,    64,    69,     0,   188,   190,    70,    96,
      96,     0,     0,    96,     0,    90,    67,     0,   187,   189,
       0,     0,     0,     0,     0,    88,     0,    92,    74,    52,
       0,    96,     0,    96,    91,    96,     0,    96,     0,    96,
      72,     0,    76,     0,     0,    75,     0,    53,    54,    72,
       0,    93,    79,    82,     0,     0,    83,    84,     0,   208,
      96,    51,     0,    96,    81,    80,    96,    43,    96,     0,
      43,     0,     0,    56,     0,    55
};

/* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
    -276,  -276,  -276,  -276,  -276,  -276,  -276,   253,  -276,  -276,
    -276,  -276,   -32,  -276,   -77,  -276,  -208,   -55,   -68,  -276,
    -276,  -237,  -276,  -276,  -275,  -276,  -276,  -276,  -276,  -276,
    -276,  -276,  -276,    47,   -48,  -276,  -276,  -276,  -276,  -276,
     -43,   157,  -276,  -157,  -276,    -1,  -276,  -276,  -276,     0,
      17,  -276,   268,  -276,     2,   138,  -276,  -276,    22,   -38,
    -276,  -276,   -81,    -2,  -276,   -27,  -213,   -66,  -276,   -22,
     -30,   -29
};

/* YYDEFGOTO[NTERM-NUM].  */
static const yytype_int16 yydefgoto[] =
{
       0,     1,    28,   146,   149,   152,    29,    78,    53,    54,
      30,   187,    31,    84,   120,    32,   155,    79,   217,   218,
     237,   219,   252,   264,   271,   316,   325,   338,   220,   274,
     296,   306,   221,   153,   154,   132,   233,   234,   247,   275,
      70,   121,   122,   123,   263,   222,   117,    95,    96,    35,
      36,    37,    38,    39,    40,    55,   284,   285,   286,    45,
      46,    47,    41,    42,   138,   223,   224,   143,   254,    82,
     340,   142
};

/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule whose
   number is the opposite.  If YYTABLE_NINF, syntax error.  */
static const yytype_int16 yytable[] =
{
      34,   125,    81,    81,   141,    97,   270,   160,   128,   195,
     158,    56,    57,    58,   238,   253,   139,     5,   127,    63,
      63,    86,    63,    68,    43,    71,   292,   228,   230,    75,
      19,    44,   144,    63,   156,   197,   180,   145,    62,    64,
     277,    65,   124,   126,   164,   330,   231,   280,    33,   232,
     281,    76,    99,    77,   342,   183,    59,    44,   124,   124,
     199,   -13,    60,    75,    76,   135,   147,   189,   190,    93,
      94,   148,    92,    44,   139,   184,    80,   298,   259,   239,
     262,    25,    85,   270,   -13,   140,   159,   -16,   161,   162,
     163,   196,   270,   185,   198,   165,   166,   200,    63,    63,
      63,    63,    63,    63,    63,    63,    63,    63,    63,    63,
     -16,   235,   -19,   341,   129,  -100,   182,   168,   169,   170,
     171,   172,   173,   174,   175,   176,   177,   178,   179,    63,
      92,    92,    44,   225,    92,   -19,    48,    49,   191,   351,
      86,   194,   354,    19,  -118,    87,   186,  -101,   188,  -119,
     112,   113,   150,   130,   244,   245,   131,   151,   246,   242,
     249,   114,   115,   139,   251,    56,    77,   258,   250,   136,
     137,    88,    89,  -110,   268,     4,     4,   256,   105,    50,
      51,   114,   115,   124,   124,   102,   103,   104,    93,    94,
     105,   116,   272,    80,    19,   282,    80,  -119,  -119,    80,
     289,   290,   255,   157,    52,   260,   278,     5,   283,   276,
     279,   303,   140,   248,   167,  -110,   133,   134,   119,    92,
     225,    72,   181,    73,    74,   257,   287,   192,   305,   307,
     294,   225,  -110,   309,   297,   261,   124,   311,  -110,   266,
     267,   300,   301,   236,   317,   304,   337,   287,   240,   293,
     328,   126,   241,   331,   243,   265,    80,    80,    77,   288,
      80,   322,    80,   318,   343,   320,    80,   321,   326,   327,
     291,   329,    71,   308,   295,   225,   348,   315,   339,   225,
     302,   353,   313,    83,   355,   323,   324,   216,   344,   345,
     319,   336,   347,    67,    80,   349,   225,    86,   350,   225,
     352,   310,    87,   312,    63,   227,   314,   299,   346,     0,
      80,     0,    63,    19,     0,     2,     3,     0,     4,     5,
       0,     0,     6,     7,     0,     0,     0,   225,    88,   225,
     225,    99,   225,     8,     9,   -96,   100,   101,   102,   103,
     104,     0,     0,   105,     0,    93,    94,   332,   333,   119,
       0,    10,    11,    12,    13,     0,     0,     0,     0,    14,
      15,    16,    17,    18,     0,     0,     0,     0,    19,    20,
     106,   107,   108,   109,   110,    21,    22,   111,    23,     0,
      24,     0,     0,    25,    26,     0,    27,     0,     0,   -22,
     201,   -22,     4,     5,    20,     0,     6,     7,     0,     0,
     334,   335,     0,    23,     0,     0,     0,     0,     0,   202,
       0,   203,   204,   205,   -78,   -78,   206,   207,   208,   209,
     210,   211,   212,   213,   214,     0,     0,     0,    13,   215,
       0,     0,     0,    14,    15,    16,    17,     0,     0,     0,
       0,     0,   -78,    20,     0,     0,     0,     0,     0,    21,
      22,     0,    23,     0,    24,     0,     0,    25,    26,     0,
      61,     0,     0,    76,   -78,    77,   201,     0,     4,     5,
       0,     0,     6,     7,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,   202,     0,   203,   204,   205,
     -77,   -77,   206,   207,   208,   209,   210,   211,   212,   213,
     214,     0,     0,     0,    13,   215,     0,     0,     0,    14,
      15,    16,    17,     0,     0,     0,     0,     0,   -77,    20,
       0,     0,     0,     0,     0,    21,    22,     0,    23,     0,
      24,     0,     0,    25,    26,     0,    61,     0,     0,    76,
     -77,    77,   201,     0,     4,     5,     0,     0,     6,     7,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,   202,     0,   203,   204,   205,     0,     0,   206,   207,
     208,   209,   210,   211,   212,   213,   214,     0,     0,     0,
      13,   215,     0,     0,     0,    14,    15,    16,    17,     0,
      69,     0,     4,     5,     0,    20,     6,     7,     0,     0,
    -109,    21,    22,     0,    23,     0,    24,     0,     0,    25,
      26,     0,    61,     0,     0,    76,   216,    77,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    13,     0,
       0,     0,     0,    14,    15,    16,    17,     0,     0,     0,
       0,     0,  -109,    20,     0,     0,     0,     0,     0,    21,
      22,     0,    23,     0,    24,     0,     0,    25,   273,  -109,
      61,     0,     4,     5,     0,  -109,     6,     7,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   202,
       0,   203,   204,   205,     0,     0,   206,   207,   208,   209,
     210,   211,   212,   213,   214,     0,     4,     5,    13,   215,
       6,     7,     0,    14,    15,    16,    17,     0,     0,     0,
       0,     0,     0,    20,     0,     0,     0,     0,     0,    21,
      22,     0,    23,     0,    24,     0,     0,    25,    26,     0,
      61,     0,    13,    76,     0,    77,     0,    14,    15,    16,
      17,     0,   118,     0,     4,     5,     0,    20,     6,     7,
     119,     0,     0,    21,    22,     0,    23,     0,    24,     0,
       0,    25,    26,     0,    61,     0,     0,     0,     0,    77,
     229,     0,     4,     5,     0,     0,     6,     7,   119,     0,
      13,     0,     0,     0,     0,    14,    15,    16,    17,     0,
       0,     0,     0,     0,     0,    20,     0,     0,     0,     0,
       0,    21,    22,     0,    23,     0,    24,     0,    13,    25,
      26,  -117,    61,    14,    15,    16,    17,     0,    69,     0,
       4,     5,     0,    20,     6,     7,     0,     0,     0,    21,
      22,     0,    23,     0,    24,     0,     0,    25,    26,     0,
      61,     0,     0,     0,     0,     0,   193,     0,     4,     5,
       0,     0,     6,     7,     0,     0,    13,     0,     0,     0,
       0,    14,    15,    16,    17,     0,     0,     0,     0,     0,
       0,    20,     0,     0,     0,     0,     0,    21,    22,     0,
      23,     0,    24,     0,    13,    25,    26,     0,    61,    14,
      15,    16,    17,     0,     0,     0,     0,     4,   269,    20,
       0,     6,     7,     0,     0,    21,    22,     0,    23,     0,
      24,     0,     0,    25,    26,     0,    61,   204,     0,     0,
       0,     0,     0,     0,     0,     0,   211,   212,     0,     0,
       0,     4,     5,    13,     0,     6,     7,     0,    14,    15,
      16,    17,     0,     0,     0,     0,     0,     0,    20,     0,
       0,   204,     0,     0,    21,    22,     0,    23,     0,    24,
     211,   212,    25,    26,     0,    61,     0,    13,     0,     0,
       0,     0,    14,    15,    16,    17,     4,     5,     0,     0,
       6,     7,    20,     0,     0,    98,     0,     0,    21,    22,
       0,    23,     0,    24,     0,     0,    25,    26,     0,    61,
       0,     0,     0,     0,     4,     5,     0,     0,     6,     7,
     119,     0,    13,     0,     0,     0,     0,    14,    15,    16,
      17,     0,     0,     0,     0,     0,    86,    20,     0,     0,
       0,    87,     0,    21,    22,     0,    23,     0,    24,     0,
      13,    25,    26,     0,    61,    14,    15,    16,    17,     4,
       5,     0,     0,     6,     7,    20,     0,    88,    89,    90,
       0,    21,    22,     0,    23,     0,    24,     0,     0,    25,
      26,    91,    61,     0,    93,    94,     0,     4,     5,     0,
       0,     6,     7,     0,     0,    13,   140,     0,     0,     0,
      14,    15,    16,    17,     0,     0,     0,     0,     0,    86,
      20,     0,     0,     0,    87,     0,    21,    22,     0,    23,
       0,    24,     0,     0,    25,    26,     0,    61,    14,    15,
      16,    17,    86,     0,     0,     0,     0,    87,    20,     0,
      88,    89,    90,     0,    21,    22,     0,    23,     0,    24,
       0,    86,    25,    66,    91,    61,    87,    93,    94,     0,
       0,    86,     0,    88,    89,    90,    87,     0,     0,     0,
       0,     0,     0,     0,     0,    77,     0,    91,     0,    92,
      93,    94,    88,    89,    90,     0,     0,     0,     0,     0,
       0,     0,    88,    89,    90,     0,    91,   226,     0,    93,
      94,     0,     0,     0,     0,     0,    91,     0,     0,    93,
      94
};

static const yytype_int16 yycheck[] =
{
       1,    44,    29,    30,    70,    34,   243,    88,    46,     1,
      87,    13,    14,    15,     4,   223,     1,     4,    17,    21,
      22,    10,    24,    25,    69,    26,    41,   184,   185,    27,
      53,    72,     1,    35,    82,     1,   113,     6,    21,    22,
     253,    24,    43,    44,    92,   320,     1,     1,     1,     4,
       4,    74,    35,    76,   329,   121,    69,    72,    59,    60,
       1,    53,    69,    61,    74,    66,     1,   133,   134,    58,
      59,     6,    57,    72,     1,     1,    29,    17,     1,    69,
     237,    68,    53,   320,    76,    70,    87,    53,    89,    90,
      91,   146,   329,   122,   149,    96,    97,   152,   100,   101,
     102,   103,   104,   105,   106,   107,   108,   109,   110,   111,
      76,   192,    53,   326,    50,    70,   117,   100,   101,   102,
     103,   104,   105,   106,   107,   108,   109,   110,   111,   131,
      57,    57,    72,   155,    57,    76,     3,     4,   139,   347,
      10,   142,   350,    53,    70,    15,    73,    70,   131,    10,
      13,    14,     1,    69,   209,   210,    58,     6,   213,   207,
     215,    44,    45,     1,   219,   167,    76,   233,   216,    44,
      45,    41,    42,    11,   242,     3,     3,   225,    67,    46,
      47,    44,    45,   184,   185,    62,    63,    64,    58,    59,
      67,    54,   247,   146,    53,   261,   149,    58,    59,   152,
     266,   267,   224,     5,    71,   234,   254,     4,   263,   252,
     258,   292,    70,   214,    39,    53,    59,    60,     9,    57,
     242,    49,    14,    51,    52,   226,   264,    41,   294,   297,
     273,   253,    70,   301,   282,   236,   237,   303,    76,   240,
     241,   289,   290,    69,   310,   293,   323,   285,    69,   271,
     318,   252,    69,   321,    69,     4,   209,   210,    76,    70,
     213,     1,   215,   311,   330,   313,   219,   315,   316,   317,
      27,   319,   273,   300,    11,   297,   342,    21,    56,   301,
      69,   349,   304,    30,   352,    25,    26,    75,     7,     7,
     312,   323,   340,    25,   247,   343,   318,    10,   346,   321,
     348,   302,    15,   304,   306,   167,   306,   285,   338,    -1,
     263,    -1,   314,    53,    -1,     0,     1,    -1,     3,     4,
      -1,    -1,     7,     8,    -1,    -1,    -1,   349,    41,   351,
     352,   314,   354,    18,    19,    75,    60,    61,    62,    63,
      64,    -1,    -1,    67,    -1,    58,    59,     7,     8,     9,
      -1,    36,    37,    38,    39,    -1,    -1,    -1,    -1,    44,
      45,    46,    47,    48,    -1,    -1,    -1,    -1,    53,    54,
      60,    61,    62,    63,    64,    60,    61,    67,    63,    -1,
      65,    -1,    -1,    68,    69,    -1,    71,    -1,    -1,    74,
       1,    76,     3,     4,    54,    -1,     7,     8,    -1,    -1,
      60,    61,    -1,    63,    -1,    -1,    -1,    -1,    -1,    20,
      -1,    22,    23,    24,    25,    26,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    -1,    -1,    -1,    39,    40,
      -1,    -1,    -1,    44,    45,    46,    47,    -1,    -1,    -1,
      -1,    -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    60,
      61,    -1,    63,    -1,    65,    -1,    -1,    68,    69,    -1,
      71,    -1,    -1,    74,    75,    76,     1,    -1,     3,     4,
      -1,    -1,     7,     8,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    20,    -1,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    -1,    -1,    -1,    39,    40,    -1,    -1,    -1,    44,
      45,    46,    47,    -1,    -1,    -1,    -1,    -1,    53,    54,
      -1,    -1,    -1,    -1,    -1,    60,    61,    -1,    63,    -1,
      65,    -1,    -1,    68,    69,    -1,    71,    -1,    -1,    74,
      75,    76,     1,    -1,     3,     4,    -1,    -1,     7,     8,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    20,    -1,    22,    23,    24,    -1,    -1,    27,    28,
      29,    30,    31,    32,    33,    34,    35,    -1,    -1,    -1,
      39,    40,    -1,    -1,    -1,    44,    45,    46,    47,    -1,
       1,    -1,     3,     4,    -1,    54,     7,     8,    -1,    -1,
      11,    60,    61,    -1,    63,    -1,    65,    -1,    -1,    68,
      69,    -1,    71,    -1,    -1,    74,    75,    76,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    39,    -1,
      -1,    -1,    -1,    44,    45,    46,    47,    -1,    -1,    -1,
      -1,    -1,    53,    54,    -1,    -1,    -1,    -1,    -1,    60,
      61,    -1,    63,    -1,    65,    -1,    -1,    68,    69,    70,
      71,    -1,     3,     4,    -1,    76,     7,     8,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    20,
      -1,    22,    23,    24,    -1,    -1,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    -1,     3,     4,    39,    40,
       7,     8,    -1,    44,    45,    46,    47,    -1,    -1,    -1,
      -1,    -1,    -1,    54,    -1,    -1,    -1,    -1,    -1,    60,
      61,    -1,    63,    -1,    65,    -1,    -1,    68,    69,    -1,
      71,    -1,    39,    74,    -1,    76,    -1,    44,    45,    46,
      47,    -1,     1,    -1,     3,     4,    -1,    54,     7,     8,
       9,    -1,    -1,    60,    61,    -1,    63,    -1,    65,    -1,
      -1,    68,    69,    -1,    71,    -1,    -1,    -1,    -1,    76,
       1,    -1,     3,     4,    -1,    -1,     7,     8,     9,    -1,
      39,    -1,    -1,    -1,    -1,    44,    45,    46,    47,    -1,
      -1,    -1,    -1,    -1,    -1,    54,    -1,    -1,    -1,    -1,
      -1,    60,    61,    -1,    63,    -1,    65,    -1,    39,    68,
      69,    70,    71,    44,    45,    46,    47,    -1,     1,    -1,
       3,     4,    -1,    54,     7,     8,    -1,    -1,    -1,    60,
      61,    -1,    63,    -1,    65,    -1,    -1,    68,    69,    -1,
      71,    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,     4,
      -1,    -1,     7,     8,    -1,    -1,    39,    -1,    -1,    -1,
      -1,    44,    45,    46,    47,    -1,    -1,    -1,    -1,    -1,
      -1,    54,    -1,    -1,    -1,    -1,    -1,    60,    61,    -1,
      63,    -1,    65,    -1,    39,    68,    69,    -1,    71,    44,
      45,    46,    47,    -1,    -1,    -1,    -1,     3,     4,    54,
      -1,     7,     8,    -1,    -1,    60,    61,    -1,    63,    -1,
      65,    -1,    -1,    68,    69,    -1,    71,    23,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    32,    33,    -1,    -1,
      -1,     3,     4,    39,    -1,     7,     8,    -1,    44,    45,
      46,    47,    -1,    -1,    -1,    -1,    -1,    -1,    54,    -1,
      -1,    23,    -1,    -1,    60,    61,    -1,    63,    -1,    65,
      32,    33,    68,    69,    -1,    71,    -1,    39,    -1,    -1,
      -1,    -1,    44,    45,    46,    47,     3,     4,    -1,    -1,
       7,     8,    54,    -1,    -1,    12,    -1,    -1,    60,    61,
      -1,    63,    -1,    65,    -1,    -1,    68,    69,    -1,    71,
      -1,    -1,    -1,    -1,     3,     4,    -1,    -1,     7,     8,
       9,    -1,    39,    -1,    -1,    -1,    -1,    44,    45,    46,
      47,    -1,    -1,    -1,    -1,    -1,    10,    54,    -1,    -1,
      -1,    15,    -1,    60,    61,    -1,    63,    -1,    65,    -1,
      39,    68,    69,    -1,    71,    44,    45,    46,    47,     3,
       4,    -1,    -1,     7,     8,    54,    -1,    41,    42,    43,
      -1,    60,    61,    -1,    63,    -1,    65,    -1,    -1,    68,
      69,    55,    71,    -1,    58,    59,    -1,     3,     4,    -1,
      -1,     7,     8,    -1,    -1,    39,    70,    -1,    -1,    -1,
      44,    45,    46,    47,    -1,    -1,    -1,    -1,    -1,    10,
      54,    -1,    -1,    -1,    15,    -1,    60,    61,    -1,    63,
      -1,    65,    -1,    -1,    68,    69,    -1,    71,    44,    45,
      46,    47,    10,    -1,    -1,    -1,    -1,    15,    54,    -1,
      41,    42,    43,    -1,    60,    61,    -1,    63,    -1,    65,
      -1,    10,    68,    69,    55,    71,    15,    58,    59,    -1,
      -1,    10,    -1,    41,    42,    43,    15,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    76,    -1,    55,    -1,    57,
      58,    59,    41,    42,    43,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    41,    42,    43,    -1,    55,    56,    -1,    58,
      59,    -1,    -1,    -1,    -1,    -1,    55,    -1,    -1,    58,
      59
};

/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
   state STATE-NUM.  */
static const yytype_uint8 yystos[] =
{
       0,    78,     0,     1,     3,     4,     7,     8,    18,    19,
      36,    37,    38,    39,    44,    45,    46,    47,    48,    53,
      54,    60,    61,    63,    65,    68,    69,    71,    79,    83,
      87,    89,    92,   110,   122,   126,   127,   128,   129,   130,
     131,   139,   140,    69,    72,   136,   137,   138,     3,     4,
      46,    47,    71,    85,    86,   132,   140,   140,   140,    69,
      69,    71,   127,   140,   127,   127,    69,   129,   140,     1,
     117,   122,    49,    51,    52,   131,    74,    76,    84,    94,
     110,   142,   146,    84,    90,    53,    10,    15,    41,    42,
      43,    55,    57,    58,    59,   124,   125,   148,    12,   127,
      60,    61,    62,    63,    64,    67,    60,    61,    62,    63,
      64,    67,    13,    14,    44,    45,    54,   123,     1,     9,
      91,   118,   119,   120,   122,   117,   122,    17,   136,    50,
      69,    58,   112,   118,   118,   122,    44,    45,   141,     1,
      70,   144,   148,   144,     1,     6,    80,     1,     6,    81,
       1,     6,    82,   110,   111,    93,   111,     5,    91,   122,
     139,   122,   122,   122,   111,   122,   122,    39,   127,   127,
     127,   127,   127,   127,   127,   127,   127,   127,   127,   127,
      91,    14,   122,   144,     1,   148,    73,    88,   127,   144,
     144,   122,    41,     1,   122,     1,    94,     1,    94,     1,
      94,     1,    20,    22,    23,    24,    27,    28,    29,    30,
      31,    32,    33,    34,    35,    40,    75,    95,    96,    98,
     105,   109,   122,   142,   143,   146,    56,   132,   120,     1,
     120,     1,     4,   113,   114,   139,    69,    97,     4,    69,
      69,    69,   111,    69,    94,    94,    94,   115,   122,    94,
     111,    94,    99,    93,   145,   146,   111,   122,   144,     1,
     148,   122,   120,   121,   100,     4,   122,   122,    95,     4,
      98,   101,    94,    69,   106,   116,   117,   143,   111,   111,
       1,     4,   144,    94,   133,   134,   135,   136,    70,   144,
     144,    27,    41,   146,   117,    11,   107,   111,    17,   135,
     111,   111,    69,   139,   111,   144,   108,    95,   142,    95,
     122,   144,   122,   146,   126,    21,   102,   144,   111,   146,
     111,   111,     1,    25,    26,   103,   111,   111,    95,   111,
     101,    95,     7,     8,    60,    61,    89,    91,   104,    56,
     147,   143,   101,   144,     7,     7,   147,   111,   144,   111,
     111,    93,   111,    95,    93,    95
};

/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
static const yytype_uint8 yyr1[] =
{
       0,    77,    78,    78,    78,    78,    78,    79,    79,    79,
      79,    79,    79,    80,    80,    80,    81,    81,    81,    82,
      82,    82,    83,    83,    83,    83,    83,    83,    83,    84,
      85,    85,    85,    85,    86,    86,    88,    87,    90,    89,
      91,    92,    92,    93,    93,    93,    94,    94,    95,    95,
      95,    95,    95,    95,    95,    95,    95,    95,    96,    96,
      96,    96,    96,    97,    96,    96,    99,    98,   100,    98,
      98,    98,   101,   101,   102,   102,   102,   103,   103,   104,
     104,   104,   104,   104,   104,   105,   105,   106,   106,   107,
     108,   107,   109,   109,   110,   110,   111,   111,   112,   112,
     113,   113,   114,   114,   114,   114,   114,   115,   115,   116,
     116,   117,   117,   117,   117,   117,   117,   118,   118,   119,
     119,   119,   119,   119,   119,   120,   120,   121,   121,   122,
     122,   122,   122,   122,   122,   122,   122,   122,   122,   123,
     123,   123,   124,   124,   125,   125,   126,   126,   126,   127,
     127,   127,   127,   127,   127,   127,   127,   127,   127,   127,
     128,   128,   128,   128,   128,   128,   128,   129,   129,   129,
     129,   129,   129,   129,   129,   129,   129,   129,   129,   129,
     129,   130,   130,   131,   132,   132,   133,   133,   134,   134,
     135,   136,   137,   137,   138,   139,   139,   140,   140,   141,
     141,   141,   142,   143,   144,   145,   145,   146,   147,   148
};

/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
static const yytype_int8 yyr2[] =
{
       0,     2,     0,     2,     2,     2,     2,     2,     2,     2,
       4,     4,     4,     1,     2,     1,     1,     2,     1,     1,
       2,     1,     0,     1,     3,     1,     1,     1,     1,     5,
       1,     1,     1,     2,     1,     1,     0,     7,     0,     3,
       1,     1,     1,     0,     2,     2,     1,     2,     2,     3,
       1,     9,     6,     8,     8,    12,    11,     1,     2,     2,
       2,     2,     3,     0,     4,     2,     0,     4,     0,     4,
       4,     1,     0,     1,     0,     2,     2,     5,     4,     1,
       2,     2,     1,     1,     1,     1,     1,     1,     3,     0,
       0,     3,     6,     9,     1,     2,     0,     1,     0,     2,
       0,     1,     1,     3,     1,     2,     3,     0,     1,     0,
       1,     1,     3,     1,     2,     3,     3,     0,     1,     1,
       3,     1,     2,     3,     3,     1,     1,     0,     1,     3,
       3,     3,     3,     3,     3,     3,     3,     5,     1,     1,
       1,     2,     1,     1,     1,     1,     1,     1,     2,     1,
       3,     3,     3,     3,     3,     3,     3,     2,     2,     5,
       4,     3,     3,     3,     3,     3,     3,     1,     2,     3,
       4,     4,     1,     1,     1,     2,     2,     1,     1,     2,
       2,     1,     2,     4,     0,     1,     0,     2,     1,     2,
       1,     3,     1,     2,     2,     1,     2,     1,     3,     1,
       1,     0,     2,     2,     1,     0,     1,     1,     1,     2
};


enum { YYENOMEM = -2 };

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYNOMEM         goto yyexhaustedlab


#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                    \
  do                                                              \
    if (yychar == YYEMPTY)                                        \
      {                                                           \
        yychar = (Token);                                         \
        yylval = (Value);                                         \
        YYPOPSTACK (yylen);                                       \
        yystate = *yyssp;                                         \
        goto yybackup;                                            \
      }                                                           \
    else                                                          \
      {                                                           \
        yyerror (YY_("syntax error: cannot back up")); \
        YYERROR;                                                  \
      }                                                           \
  while (0)

/* Backward compatibility with an undocumented macro.
   Use YYerror or YYUNDEF. */
#define YYERRCODE YYUNDEF


/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)




# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, "%s ", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Kind, Value); \
      YYFPRINTF (stderr, "\n");                                           \
    }                                                                     \
} while (0)


/*-----------------------------------.
| Print this symbol's value on YYO.  |
`-----------------------------------*/

static void
yy_symbol_value_print (FILE *yyo,
                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
  FILE *yyoutput = yyo;
  YY_USE (yyoutput);
  if (!yyvaluep)
    return;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/*---------------------------.
| Print this symbol on YYO.  |
`---------------------------*/

static void
yy_symbol_print (FILE *yyo,
                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
  YYFPRINTF (yyo, "%s %s (",
             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));

  yy_symbol_value_print (yyo, yykind, yyvaluep);
  YYFPRINTF (yyo, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
                 int yyrule)
{
  int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr,
                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
                       &yyvsp[(yyi + 1) - (yynrhs)]);
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args) ((void) 0)
# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif






/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

static void
yydestruct (const char *yymsg,
            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
{
  YY_USE (yyvaluep);
  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/* Lookahead token kind.  */
int yychar;

/* The semantic value of the lookahead symbol.  */
YYSTYPE yylval;
/* Number of syntax errors so far.  */
int yynerrs;




/*----------.
| yyparse.  |
`----------*/

int
yyparse (void)
{
    yy_state_fast_t yystate = 0;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus = 0;

    /* Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* Their size.  */
    YYPTRDIFF_T yystacksize = YYINITDEPTH;

    /* The state stack: array, bottom, top.  */
    yy_state_t yyssa[YYINITDEPTH];
    yy_state_t *yyss = yyssa;
    yy_state_t *yyssp = yyss;

    /* The semantic value stack: array, bottom, top.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs = yyvsa;
    YYSTYPE *yyvsp = yyvs;

  int yyn;
  /* The return value of yyparse.  */
  int yyresult;
  /* Lookahead symbol kind.  */
  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;



#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yychar = YYEMPTY; /* Cause a token to be read.  */

  goto yysetstate;


/*------------------------------------------------------------.
| yynewstate -- push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;


/*--------------------------------------------------------------------.
| yysetstate -- set current state (the top of the stack) to yystate.  |
`--------------------------------------------------------------------*/
yysetstate:
  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
  YY_IGNORE_USELESS_CAST_BEGIN
  *yyssp = YY_CAST (yy_state_t, yystate);
  YY_IGNORE_USELESS_CAST_END
  YY_STACK_PRINT (yyss, yyssp);

  if (yyss + yystacksize - 1 <= yyssp)
#if !defined yyoverflow && !defined YYSTACK_RELOCATE
    YYNOMEM;
#else
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYPTRDIFF_T yysize = yyssp - yyss + 1;

# if defined yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        yy_state_t *yyss1 = yyss;
        YYSTYPE *yyvs1 = yyvs;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_("memory exhausted"),
                    &yyss1, yysize * YYSIZEOF (*yyssp),
                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                    &yystacksize);
        yyss = yyss1;
        yyvs = yyvs1;
      }
# else /* defined YYSTACK_RELOCATE */
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        YYNOMEM;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yy_state_t *yyss1 = yyss;
        union yyalloc *yyptr =
          YY_CAST (union yyalloc *,
                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
        if (! yyptr)
          YYNOMEM;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YY_IGNORE_USELESS_CAST_BEGIN
      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
                  YY_CAST (long, yystacksize)));
      YY_IGNORE_USELESS_CAST_END

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }
#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */


  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;


/*-----------.
| yybackup.  |
`-----------*/
yybackup:
  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token\n"));
      yychar = yylex ();
    }

  if (yychar <= YYEOF)
    {
      yychar = YYEOF;
      yytoken = YYSYMBOL_YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else if (yychar == YYerror)
    {
      /* The scanner already issued an error message, process directly
         to error recovery.  But do not keep the error token as
         lookahead, it is too special and may lead us to an endless
         loop in error recovery. */
      yychar = YYUNDEF;
      yytoken = YYSYMBOL_YYerror;
      goto yyerrlab1;
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  /* Discard the shifted token.  */
  yychar = YYEMPTY;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
  case 2: /* program: %empty  */
#line 236 "awkgram.y"
          { yyval = NULL; }
#line 1959 "awkgram.c"
    break;

  case 3: /* program: program rule  */
#line 238 "awkgram.y"
          {
		rule = 0;
		yyerrok;
	  }
#line 1968 "awkgram.c"
    break;

  case 4: /* program: program nls  */
#line 243 "awkgram.y"
          {
		if (yyvsp[0] != NULL) {
			if (yyvsp[-1] == NULL)
				outer_comment = yyvsp[0];
			else
				interblock_comment = yyvsp[0];
		}
		yyval = yyvsp[-1];
	  }
#line 1982 "awkgram.c"
    break;

  case 5: /* program: program LEX_EOF  */
#line 253 "awkgram.y"
          {
		next_sourcefile();
	  }
#line 1990 "awkgram.c"
    break;

  case 6: /* program: program error  */
#line 257 "awkgram.y"
          {
		rule = 0;
		/*
		 * If errors, give up, don't produce an infinite
		 * stream of syntax error messages.
		 */
  		/* yyerrok; */
	  }
#line 2003 "awkgram.c"
    break;

  case 7: /* rule: pattern action  */
#line 269 "awkgram.y"
          {
		(void) append_rule(yyvsp[-1], yyvsp[0]);
		if (pending_comment != NULL) {
			interblock_comment = pending_comment;
			pending_comment = NULL;
		}
	  }
#line 2015 "awkgram.c"
    break;

  case 8: /* rule: pattern statement_term  */
#line 277 "awkgram.y"
          {
		if (rule != Rule) {
			msg(_("%s blocks must have an action part"), ruletab[rule]);
			errcount++;
		} else if (yyvsp[-1] == NULL) {
			msg(_("each rule must have a pattern or an action part"));
			errcount++;
		} else {	/* pattern rule with non-empty pattern */
			if (yyvsp[0] != NULL)
				list_append(yyvsp[-1], yyvsp[0]);
			(void) append_rule(yyvsp[-1], NULL);
		}
	  }
#line 2033 "awkgram.c"
    break;

  case 9: /* rule: function_prologue action  */
#line 291 "awkgram.y"
          {
		in_function = false;
		(void) mk_function(yyvsp[-1], yyvsp[0]);
		want_param_names = DONT_CHECK;
		if (pending_comment != NULL) {
			interblock_comment = pending_comment;
			pending_comment = NULL;
		}
		yyerrok;
	  }
#line 2048 "awkgram.c"
    break;

  case 10: /* rule: '@' LEX_INCLUDE source statement_term  */
#line 302 "awkgram.y"
          {
		want_source = false;
		at_seen--;
		if (yyvsp[-1] != NULL && yyvsp[0] != NULL) {
			SRCFILE *s = (SRCFILE *) yyvsp[-1];
			s->comment = yyvsp[0];
		}
		yyerrok;
	  }
#line 2062 "awkgram.c"
    break;

  case 11: /* rule: '@' LEX_LOAD library statement_term  */
#line 312 "awkgram.y"
          {
		want_source = false;
		at_seen--;
		if (yyvsp[-1] != NULL && yyvsp[0] != NULL) {
			SRCFILE *s = (SRCFILE *) yyvsp[-1];
			s->comment = yyvsp[0];
		}
		yyerrok;
	  }
#line 2076 "awkgram.c"
    break;

  case 12: /* rule: '@' LEX_NAMESPACE namespace statement_term  */
#line 322 "awkgram.y"
          {
		/*
		 * 1/2022:
		 * We have an interesting isssue here.  This production isn't
		 * reduced until after the token following the statement_term
		 * is seen. As a result, the change in namespace doesn't take
		 * effect until then. That's fine if the first token is 'function'
		 * or BEGIN or some such, but it's a disaster if it's an identifer;
		 * that identifier will be in the previous namespace.
		 * Therefore, the actual setting of the namespace is done immediately
		 * down in the scanner.
		 */

		want_source = false;
		want_namespace = false;
		at_seen--;

		// this frees $3 storage in all cases
		set_namespace(yyvsp[-1], yyvsp[0]);

		yyerrok;
	  }
#line 2103 "awkgram.c"
    break;

  case 13: /* source: FILENAME  */
#line 348 "awkgram.y"
          {
		void *srcfile = NULL;

		if (! include_source(yyvsp[0], & srcfile))
			YYABORT;
		efree(yyvsp[0]->lextok);
		bcfree(yyvsp[0]);
		yyval = (INSTRUCTION *) srcfile;
	  }
#line 2117 "awkgram.c"
    break;

  case 14: /* source: FILENAME error  */
#line 358 "awkgram.y"
          { yyval = NULL; }
#line 2123 "awkgram.c"
    break;

  case 15: /* source: error  */
#line 360 "awkgram.y"
          { yyval = NULL; }
#line 2129 "awkgram.c"
    break;

  case 16: /* library: FILENAME  */
#line 365 "awkgram.y"
          {
		void *srcfile;

		if (! load_library(yyvsp[0], & srcfile))
			YYABORT;
		efree(yyvsp[0]->lextok);
		bcfree(yyvsp[0]);
		yyval = (INSTRUCTION *) srcfile;
	  }
#line 2143 "awkgram.c"
    break;

  case 17: /* library: FILENAME error  */
#line 375 "awkgram.y"
          { yyval = NULL; }
#line 2149 "awkgram.c"
    break;

  case 18: /* library: error  */
#line 377 "awkgram.y"
          { yyval = NULL; }
#line 2155 "awkgram.c"
    break;

  case 19: /* namespace: FILENAME  */
#line 382 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 2161 "awkgram.c"
    break;

  case 20: /* namespace: FILENAME error  */
#line 384 "awkgram.y"
          { yyval = NULL; }
#line 2167 "awkgram.c"
    break;

  case 21: /* namespace: error  */
#line 386 "awkgram.y"
          { yyval = NULL; }
#line 2173 "awkgram.c"
    break;

  case 22: /* pattern: %empty  */
#line 391 "awkgram.y"
          {
		rule = Rule;
		yyval = NULL;
	  }
#line 2182 "awkgram.c"
    break;

  case 23: /* pattern: exp  */
#line 396 "awkgram.y"
          {
		rule = Rule;
	  }
#line 2190 "awkgram.c"
    break;

  case 24: /* pattern: exp comma exp  */
#line 401 "awkgram.y"
          {
		INSTRUCTION *tp;

		add_lint(yyvsp[-2], LINT_assign_in_cond);
		add_lint(yyvsp[0], LINT_assign_in_cond);

		tp = instruction(Op_no_op);
		list_prepend(yyvsp[-2], bcalloc(Op_line_range, !!do_pretty_print + 1, 0));
		yyvsp[-2]->nexti->triggered = false;
		yyvsp[-2]->nexti->target_jmp = yyvsp[0]->nexti;

		list_append(yyvsp[-2], instruction(Op_cond_pair));
		yyvsp[-2]->lasti->line_range = yyvsp[-2]->nexti;
		yyvsp[-2]->lasti->target_jmp = tp;

		list_append(yyvsp[0], instruction(Op_cond_pair));
		yyvsp[0]->lasti->line_range = yyvsp[-2]->nexti;
		yyvsp[0]->lasti->target_jmp = tp;
		if (do_pretty_print) {
			(yyvsp[-2]->nexti + 1)->condpair_left = yyvsp[-2]->lasti;
			(yyvsp[-2]->nexti + 1)->condpair_right = yyvsp[0]->lasti;
		}
		/* Put any comments in front of the range expression */
		if (yyvsp[-1] != NULL)
			yyval = list_append(list_merge(list_prepend(yyvsp[-2], yyvsp[-1]), yyvsp[0]), tp);
		else
			yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), tp);
		rule = Rule;
	  }
#line 2224 "awkgram.c"
    break;

  case 25: /* pattern: LEX_BEGIN  */
#line 431 "awkgram.y"
          {
		static int begin_seen = 0;

		if (do_lint_old && ++begin_seen == 2)
			lintwarn_ln(yyvsp[0]->source_line,
				_("old awk does not support multiple `BEGIN' or `END' rules"));

		yyvsp[0]->in_rule = rule = BEGIN;
		yyvsp[0]->source_file = source;
		yyval = yyvsp[0];
	  }
#line 2240 "awkgram.c"
    break;

  case 26: /* pattern: LEX_END  */
#line 443 "awkgram.y"
          {
		static int end_seen = 0;

		if (do_lint_old && ++end_seen == 2)
			lintwarn_ln(yyvsp[0]->source_line,
				_("old awk does not support multiple `BEGIN' or `END' rules"));

		yyvsp[0]->in_rule = rule = END;
		yyvsp[0]->source_file = source;
		yyval = yyvsp[0];
	  }
#line 2256 "awkgram.c"
    break;

  case 27: /* pattern: LEX_BEGINFILE  */
#line 455 "awkgram.y"
          {
		yyvsp[0]->in_rule = rule = BEGINFILE;
		yyvsp[0]->source_file = source;
		yyval = yyvsp[0];
	  }
#line 2266 "awkgram.c"
    break;

  case 28: /* pattern: LEX_ENDFILE  */
#line 461 "awkgram.y"
          {
		yyvsp[0]->in_rule = rule = ENDFILE;
		yyvsp[0]->source_file = source;
		yyval = yyvsp[0];
	  }
#line 2276 "awkgram.c"
    break;

  case 29: /* action: l_brace statements r_brace opt_semi opt_nls  */
#line 470 "awkgram.y"
          {
		INSTRUCTION *ip = make_braced_statements(yyvsp[-4], yyvsp[-3], yyvsp[-2]);

		if (yyvsp[-2] != NULL && yyvsp[0] != NULL) {
			merge_comments(yyvsp[-2], yyvsp[0]);
			pending_comment = yyvsp[-2];
		} else if (yyvsp[-2] != NULL) {
			pending_comment = yyvsp[-2];
		} else if (yyvsp[0] != NULL) {
			pending_comment = yyvsp[0];
		}

		yyval = ip;
	  }
#line 2295 "awkgram.c"
    break;

  case 31: /* func_name: FUNC_CALL  */
#line 489 "awkgram.y"
          {
		const char *name = yyvsp[0]->lextok;
		char *qname = qualify_name(name, strlen(name));

		if (qname != name) {
			efree((void *)name);
			yyvsp[0]->lextok = qname;
		}
		yyval = yyvsp[0];
	  }
#line 2310 "awkgram.c"
    break;

  case 32: /* func_name: lex_builtin  */
#line 500 "awkgram.y"
          {
		yyerror(_("`%s' is a built-in function, it cannot be redefined"),
					tokstart);
		YYABORT;
	  }
#line 2320 "awkgram.c"
    break;

  case 33: /* func_name: '@' LEX_EVAL  */
#line 506 "awkgram.y"
          {
		yyval = yyvsp[0];
		at_seen--;
	  }
#line 2329 "awkgram.c"
    break;

  case 36: /* $@1: %empty  */
#line 518 "awkgram.y"
                                     { want_param_names = FUNC_HEADER; }
#line 2335 "awkgram.c"
    break;

  case 37: /* function_prologue: LEX_FUNCTION func_name '(' $@1 opt_param_list r_paren opt_nls  */
#line 519 "awkgram.y"
          {
		INSTRUCTION *func_comment = NULL;
		// Merge any comments found in the parameter list with those
		// following the function header, associate the whole shebang
		// with the function as one block comment.
		if (yyvsp[-2] != NULL && yyvsp[-2]->comment != NULL) {
			if (yyvsp[0] != NULL) {
				merge_comments(yyvsp[-2]->comment, yyvsp[0]);
			}
			func_comment = yyvsp[-2]->comment;
		} else if (yyvsp[0] != NULL) {
			func_comment = yyvsp[0];
		}

		yyvsp[-6]->source_file = source;
		yyvsp[-6]->comment = func_comment;
		if (install_function(yyvsp[-5]->lextok, yyvsp[-6], yyvsp[-2]) < 0)
			YYABORT;
		in_function = true;
		yyvsp[-5]->lextok = NULL;
		bcfree(yyvsp[-5]);
		/* $5 already free'd in install_function */
		yyval = yyvsp[-6];
		want_param_names = FUNC_BODY;
	  }
#line 2365 "awkgram.c"
    break;

  case 38: /* $@2: %empty  */
#line 552 "awkgram.y"
                { want_regexp = true; }
#line 2371 "awkgram.c"
    break;

  case 39: /* regexp: a_slash $@2 REGEXP  */
#line 554 "awkgram.y"
                {
		  NODE *n, *exp;
		  char *re;
		  size_t len;

		  re = yyvsp[0]->lextok;
		  yyvsp[0]->lextok = NULL;
		  len = strlen(re);
		  if (do_lint) {
			if (len == 0)
				lintwarn_ln(yyvsp[0]->source_line,
					_("regexp constant `//' looks like a C++ comment, but is not"));
			else if (re[0] == '*' && re[len-1] == '*')
				/* possible C comment */
				lintwarn_ln(yyvsp[0]->source_line,
					_("regexp constant `/%s/' looks like a C comment, but is not"), re);
		  }

		  exp = make_str_node(re, len, ALREADY_MALLOCED);
		  n = make_regnode(Node_regex, exp);
		  if (n == NULL) {
			unref(exp);
			YYABORT;
		  }
		  yyval = yyvsp[0];
		  yyval->opcode = Op_match_rec;
		  yyval->memory = n;
		}
#line 2404 "awkgram.c"
    break;

  case 40: /* typed_regexp: TYPED_REGEXP  */
#line 586 "awkgram.y"
                {
		  char *re;
		  size_t len;

		  re = yyvsp[0]->lextok;
		  yyvsp[0]->lextok = NULL;
		  len = strlen(re);

		  yyval = yyvsp[0];
		  yyval->opcode = Op_push_re;
		  yyval->memory = make_typed_regex(re, len);
		}
#line 2421 "awkgram.c"
    break;

  case 41: /* a_slash: '/'  */
#line 601 "awkgram.y"
          { bcfree(yyvsp[0]); }
#line 2427 "awkgram.c"
    break;

  case 43: /* statements: %empty  */
#line 607 "awkgram.y"
          { yyval = NULL; }
#line 2433 "awkgram.c"
    break;

  case 44: /* statements: statements statement  */
#line 609 "awkgram.y"
          {
		if (yyvsp[0] == NULL) {
			yyval = yyvsp[-1];
		} else {
			add_lint(yyvsp[0], LINT_no_effect);
			if (yyvsp[-1] == NULL) {
				yyval = yyvsp[0];
			} else {
				yyval = list_merge(yyvsp[-1], yyvsp[0]);
			}
		}

		if (trailing_comment != NULL) {
			yyval = list_append(yyval, trailing_comment);
			trailing_comment = NULL;
		}

		yyerrok;
	  }
#line 2457 "awkgram.c"
    break;

  case 45: /* statements: statements error  */
#line 629 "awkgram.y"
          {	yyval = NULL; }
#line 2463 "awkgram.c"
    break;

  case 46: /* statement_term: nls  */
#line 633 "awkgram.y"
                        { yyval = yyvsp[0]; }
#line 2469 "awkgram.c"
    break;

  case 47: /* statement_term: semi opt_nls  */
#line 634 "awkgram.y"
                        { yyval = yyvsp[0]; }
#line 2475 "awkgram.c"
    break;

  case 48: /* statement: semi opt_nls  */
#line 639 "awkgram.y"
          {
		if (yyvsp[0] != NULL) {
			INSTRUCTION *ip;

			merge_comments(yyvsp[0], NULL);
			ip = list_create(instruction(Op_no_op));
			yyval = list_append(ip, yyvsp[0]);
		} else
			yyval = NULL;
	  }
#line 2490 "awkgram.c"
    break;

  case 49: /* statement: l_brace statements r_brace  */
#line 650 "awkgram.y"
          {
		trailing_comment = yyvsp[0];	// NULL or comment
		yyval = make_braced_statements(yyvsp[-2], yyvsp[-1], yyvsp[0]);
	  }
#line 2499 "awkgram.c"
    break;

  case 50: /* statement: if_statement  */
#line 655 "awkgram.y"
          {
		if (do_pretty_print)
			yyval = list_prepend(yyvsp[0], instruction(Op_exec_count));
		else
			yyval = yyvsp[0];
 	  }
#line 2510 "awkgram.c"
    break;

  case 51: /* statement: LEX_SWITCH '(' exp r_paren opt_nls l_brace case_statements opt_nls r_brace  */
#line 662 "awkgram.y"
          {
		INSTRUCTION *dflt, *curr = NULL, *cexp, *cstmt;
		INSTRUCTION *ip, *nextc, *tbreak;
		const char **case_values = NULL;
		int maxcount = 128;
		int case_count = 0;
		int i;

		tbreak = instruction(Op_no_op);
		cstmt = list_create(tbreak);
		cexp = list_create(instruction(Op_pop));
		dflt = instruction(Op_jmp);
		dflt->target_jmp = tbreak;	/* if no case match and no explicit default */

		if (yyvsp[-2] != NULL) {
			curr = yyvsp[-2]->nexti;
			bcfree(yyvsp[-2]);	/* Op_list */
		}
		/*  else
			curr = NULL; */

		for (; curr != NULL; curr = nextc) {
			INSTRUCTION *caseexp = curr->case_exp;
			INSTRUCTION *casestmt = curr->case_stmt;

			nextc = curr->nexti;
			if (curr->opcode == Op_K_case) {
				if (caseexp->opcode == Op_push_i) {
					/* a constant scalar */
					char *caseval;
					caseval = force_string(caseexp->memory)->stptr;
					for (i = 0; i < case_count; i++) {
						if (strcmp(caseval, case_values[i]) == 0)
							error_ln(curr->source_line,
								_("duplicate case values in switch body: %s"), caseval);
					}

					if (case_values == NULL)
						emalloc(case_values, const char **, sizeof(char *) * maxcount);
					else if (case_count >= maxcount) {
						maxcount += 128;
						erealloc(case_values, const char **, sizeof(char*) * maxcount);
					}
					case_values[case_count++] = caseval;
				} else {
					/* match a constant regex against switch expression. */
					(curr + 1)->match_exp = true;
				}
				curr->stmt_start = casestmt->nexti;
				curr->stmt_end	= casestmt->lasti;
				(void) list_prepend(cexp, curr);
				(void) list_prepend(cexp, caseexp);
			} else {
				if (dflt->target_jmp != tbreak)
					error_ln(curr->source_line,
						_("duplicate `default' detected in switch body"));
				else
					dflt->target_jmp = casestmt->nexti;

				if (do_pretty_print) {
					curr->stmt_start = casestmt->nexti;
					curr->stmt_end = casestmt->lasti;
					(void) list_prepend(cexp, curr);
				} else
					bcfree(curr);
			}

			cstmt = list_merge(casestmt, cstmt);
		}

		if (case_values != NULL)
			efree(case_values);

		ip = yyvsp[-6];
		if (do_pretty_print) {
			// first merge comments
			INSTRUCTION *head_comment = NULL;

			if (yyvsp[-4] != NULL && yyvsp[-3] != NULL) {
				merge_comments(yyvsp[-4], yyvsp[-3]);
				head_comment = yyvsp[-4];
			} else if (yyvsp[-4] != NULL)
				head_comment = yyvsp[-4];
			else
				head_comment = yyvsp[-3];

			yyvsp[-8]->comment = head_comment;

			(void) list_prepend(ip, yyvsp[-8]);
			(void) list_prepend(ip, instruction(Op_exec_count));
			yyvsp[-8]->target_break = tbreak;
			(yyvsp[-8] + 1)->switch_start = cexp->nexti;
			(yyvsp[-8] + 1)->switch_end = cexp->lasti;
			(yyvsp[-8] + 1)->switch_end->comment = yyvsp[0];
		}
		/* else
			$1 is NULL */

		(void) list_append(cexp, dflt);
		(void) list_merge(ip, cexp);
		if (yyvsp[-1] != NULL)
			(void) list_append(cstmt, yyvsp[-1]);
		yyval = list_merge(ip, cstmt);

		break_allowed--;
		fix_break_continue(ip, tbreak, NULL);
	  }
#line 2622 "awkgram.c"
    break;

  case 52: /* statement: LEX_WHILE '(' exp r_paren opt_nls statement  */
#line 770 "awkgram.y"
          {
		/*
		 *    -----------------
		 * tc:
		 *         cond
		 *    -----------------
		 *    [Op_jmp_false tb   ]
		 *    -----------------
		 *         body
		 *    -----------------
		 *    [Op_jmp      tc    ]
		 * tb:[Op_no_op          ]
		 */

		INSTRUCTION *ip, *tbreak, *tcont;

		tbreak = instruction(Op_no_op);
		add_lint(yyvsp[-3], LINT_assign_in_cond);
		tcont = yyvsp[-3]->nexti;
		ip = list_append(yyvsp[-3], instruction(Op_jmp_false));
		ip->lasti->target_jmp = tbreak;

		if (do_pretty_print) {
			(void) list_append(ip, instruction(Op_exec_count));
			yyvsp[-5]->target_break = tbreak;
			yyvsp[-5]->target_continue = tcont;
			(yyvsp[-5] + 1)->while_body = ip->lasti;
			(void) list_prepend(ip, yyvsp[-5]);
		}
		/* else
			$1 is NULL */

		if (yyvsp[-1] != NULL) {
			if (yyvsp[0] == NULL)
				yyvsp[0] = list_create(instruction(Op_no_op));

			yyvsp[-1]->memory->comment_type = BLOCK_COMMENT;
			yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);
		}

		if (yyvsp[0] != NULL)
			(void) list_merge(ip, yyvsp[0]);
		(void) list_append(ip, instruction(Op_jmp));
		ip->lasti->target_jmp = tcont;
		yyval = list_append(ip, tbreak);

		break_allowed--;
		continue_allowed--;
		fix_break_continue(ip, tbreak, tcont);
	  }
#line 2677 "awkgram.c"
    break;

  case 53: /* statement: LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls  */
#line 821 "awkgram.y"
          {
		/*
		 *    -----------------
		 * z:
		 *         body
		 *    -----------------
		 * tc:
		 *         cond
		 *    -----------------
		 *    [Op_jmp_true | z  ]
		 * tb:[Op_no_op         ]
		 */

		INSTRUCTION *ip, *tbreak, *tcont;

		tbreak = instruction(Op_no_op);
		tcont = yyvsp[-2]->nexti;
		add_lint(yyvsp[-2], LINT_assign_in_cond);
		if (yyvsp[-5] != NULL)
			ip = list_merge(yyvsp[-5], yyvsp[-2]);
		else
			ip = list_prepend(yyvsp[-2], instruction(Op_no_op));

		if (yyvsp[-6] != NULL)
			(void) list_prepend(ip, yyvsp[-6]);

		if (do_pretty_print)
			(void) list_prepend(ip, instruction(Op_exec_count));

		(void) list_append(ip, instruction(Op_jmp_true));
		ip->lasti->target_jmp = ip->nexti;
		yyval = list_append(ip, tbreak);

		break_allowed--;
		continue_allowed--;
		fix_break_continue(ip, tbreak, tcont);

		if (do_pretty_print) {
			yyvsp[-7]->target_break = tbreak;
			yyvsp[-7]->target_continue = tcont;
			(yyvsp[-7] + 1)->doloop_cond = tcont;
			yyval = list_prepend(ip, yyvsp[-7]);
			bcfree(yyvsp[-4]);
			if (yyvsp[0] != NULL)
				yyvsp[-7]->comment = yyvsp[0];
		}
		/* else
			$1 and $4 are NULLs */
	  }
#line 2731 "awkgram.c"
    break;

  case 54: /* statement: LEX_FOR '(' NAME LEX_IN simple_variable r_paren opt_nls statement  */
#line 871 "awkgram.y"
          {
		INSTRUCTION *ip;
		char *var_name = yyvsp[-5]->lextok;

		if (yyvsp[0] != NULL
				&& yyvsp[0]->lasti->opcode == Op_K_delete
				&& yyvsp[0]->lasti->expr_count == 1
				&& yyvsp[0]->nexti->opcode == Op_push
				&& (yyvsp[0]->nexti->memory->type != Node_var || !(yyvsp[0]->nexti->memory->var_update))
				&& strcmp(yyvsp[0]->nexti->memory->vname, var_name) == 0
		) {

		/*
		 * Efficiency hack.  Recognize the special case of
		 *
		 * 	for (iggy in foo)
		 * 		delete foo[iggy]
		 *
		 * and treat it as if it were
		 *
		 * 	delete foo
		 *
		 * Check that the body is a `delete a[i]' statement,
		 * and that both the loop var and array names match.
		 */
			NODE *arr = NULL;

			ip = yyvsp[0]->nexti->nexti;
			if (yyvsp[-3]->nexti->opcode == Op_push && yyvsp[-3]->lasti == yyvsp[-3]->nexti)
				arr = yyvsp[-3]->nexti->memory;
			if (arr != NULL
					&& ip->opcode == Op_no_op
					&& ip->nexti->opcode == Op_push_array
					&& strcmp(ip->nexti->memory->vname, arr->vname) == 0
					&& ip->nexti->nexti == yyvsp[0]->lasti
			) {
				(void) make_assignable(yyvsp[0]->nexti);
				yyvsp[0]->lasti->opcode = Op_K_delete_loop;
				yyvsp[0]->lasti->expr_count = 0;
				if (yyvsp[-7] != NULL)
					bcfree(yyvsp[-7]);
				efree(var_name);
				bcfree(yyvsp[-5]);
				bcfree(yyvsp[-4]);
				bcfree(yyvsp[-3]);
				if (yyvsp[-1] != NULL) {
					merge_comments(yyvsp[-1], NULL);
					yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);
				}
				yyval = yyvsp[0];
			} else
				goto regular_loop;
		} else {
			INSTRUCTION *tbreak, *tcont;

			/*    [ Op_push_array a       ]
			 *    [ Op_arrayfor_init | ib ]
			 * ic:[ Op_arrayfor_incr | ib ]
			 *    [ Op_var_assign if any  ]
			 *
			 *              body
			 *
			 *    [Op_jmp | ic            ]
			 * ib:[Op_arrayfor_final      ]
			 */
regular_loop:
			ip = yyvsp[-3];
			ip->nexti->opcode = Op_push_array;

			tbreak = instruction(Op_arrayfor_final);
			yyvsp[-4]->opcode = Op_arrayfor_incr;
			yyvsp[-4]->array_var = variable(yyvsp[-5]->source_line, var_name, Node_var);
			yyvsp[-4]->target_jmp = tbreak;
			tcont = yyvsp[-4];
			yyvsp[-5]->opcode = Op_arrayfor_init;
			yyvsp[-5]->target_jmp = tbreak;
			(void) list_append(ip, yyvsp[-5]);

			if (do_pretty_print) {
				yyvsp[-7]->opcode = Op_K_arrayfor;
				yyvsp[-7]->target_continue = tcont;
				yyvsp[-7]->target_break = tbreak;
				(void) list_append(ip, yyvsp[-7]);
			}
			/* else
				$1 is NULL */

			/* add update_FOO instruction if necessary */
			if (yyvsp[-4]->array_var->type == Node_var && yyvsp[-4]->array_var->var_update) {
				(void) list_append(ip, instruction(Op_var_update));
				ip->lasti->update_var = yyvsp[-4]->array_var->var_update;
			}
			(void) list_append(ip, yyvsp[-4]);

			/* add set_FOO instruction if necessary */
			if (yyvsp[-4]->array_var->type == Node_var && yyvsp[-4]->array_var->var_assign) {
				(void) list_append(ip, instruction(Op_var_assign));
				ip->lasti->assign_var = yyvsp[-4]->array_var->var_assign;
			}

			if (do_pretty_print) {
				(void) list_append(ip, instruction(Op_exec_count));
				(yyvsp[-7] + 1)->forloop_cond = yyvsp[-4];
				(yyvsp[-7] + 1)->forloop_body = ip->lasti;
			}

			if (yyvsp[-1] != NULL)
				merge_comments(yyvsp[-1], NULL);

			if (yyvsp[0] != NULL) {
				if (yyvsp[-1] != NULL)
					yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);
				(void) list_merge(ip, yyvsp[0]);
			} else if (yyvsp[-1] != NULL)
				(void) list_append(ip, yyvsp[-1]);

			(void) list_append(ip, instruction(Op_jmp));
			ip->lasti->target_jmp = yyvsp[-4];
			yyval = list_append(ip, tbreak);
			fix_break_continue(ip, tbreak, tcont);
		}

		break_allowed--;
		continue_allowed--;
	  }
#line 2861 "awkgram.c"
    break;

  case 55: /* statement: LEX_FOR '(' opt_simple_stmt semi opt_nls exp semi opt_nls opt_simple_stmt r_paren opt_nls statement  */
#line 997 "awkgram.y"
          {
		if (yyvsp[-7] != NULL) {
			merge_comments(yyvsp[-7], NULL);
			yyvsp[-11]->comment = yyvsp[-7];
		}
		if (yyvsp[-4] != NULL) {
			merge_comments(yyvsp[-4], NULL);
			if (yyvsp[-11]->comment == NULL) {
				yyvsp[-4]->memory->comment_type = FOR_COMMENT;
				yyvsp[-11]->comment = yyvsp[-4];
			} else
				yyvsp[-11]->comment->comment = yyvsp[-4];
		}
		if (yyvsp[-1] != NULL)
			yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);
		add_lint(yyvsp[-6], LINT_assign_in_cond);
		yyval = mk_for_loop(yyvsp[-11], yyvsp[-9], yyvsp[-6], yyvsp[-3], yyvsp[0]);

		break_allowed--;
		continue_allowed--;
	  }
#line 2887 "awkgram.c"
    break;

  case 56: /* statement: LEX_FOR '(' opt_simple_stmt semi opt_nls semi opt_nls opt_simple_stmt r_paren opt_nls statement  */
#line 1019 "awkgram.y"
          {
		if (yyvsp[-6] != NULL) {
			merge_comments(yyvsp[-6], NULL);
			yyvsp[-10]->comment = yyvsp[-6];
		}
		if (yyvsp[-4] != NULL) {
			merge_comments(yyvsp[-4], NULL);
			if (yyvsp[-10]->comment == NULL) {
				yyvsp[-4]->memory->comment_type = FOR_COMMENT;
				yyvsp[-10]->comment = yyvsp[-4];
			} else
				yyvsp[-10]->comment->comment = yyvsp[-4];
		}
		if (yyvsp[-1] != NULL)
			yyvsp[0] = list_prepend(yyvsp[0], yyvsp[-1]);
		yyval = mk_for_loop(yyvsp[-10], yyvsp[-8], (INSTRUCTION *) NULL, yyvsp[-3], yyvsp[0]);

		break_allowed--;
		continue_allowed--;
	  }
#line 2912 "awkgram.c"
    break;

  case 57: /* statement: non_compound_stmt  */
#line 1040 "awkgram.y"
          {
		if (do_pretty_print)
			yyval = list_prepend(yyvsp[0], instruction(Op_exec_count));
		else
			yyval = yyvsp[0];
	  }
#line 2923 "awkgram.c"
    break;

  case 58: /* non_compound_stmt: LEX_BREAK statement_term  */
#line 1050 "awkgram.y"
          {
		if (! break_allowed)
			error_ln(yyvsp[-1]->source_line,
				_("`break' is not allowed outside a loop or switch"));
		yyvsp[-1]->target_jmp = NULL;
		yyval = list_create(yyvsp[-1]);
		if (yyvsp[0] != NULL)
			yyval = list_append(yyval, yyvsp[0]);
	  }
#line 2937 "awkgram.c"
    break;

  case 59: /* non_compound_stmt: LEX_CONTINUE statement_term  */
#line 1060 "awkgram.y"
          {
		if (! continue_allowed)
			error_ln(yyvsp[-1]->source_line,
				_("`continue' is not allowed outside a loop"));
		yyvsp[-1]->target_jmp = NULL;
		yyval = list_create(yyvsp[-1]);
		if (yyvsp[0] != NULL)
			yyval = list_append(yyval, yyvsp[0]);
	  }
#line 2951 "awkgram.c"
    break;

  case 60: /* non_compound_stmt: LEX_NEXT statement_term  */
#line 1070 "awkgram.y"
          {
		/* if inside function (rule = 0), resolve context at run-time */
		if (rule && rule != Rule)
			error_ln(yyvsp[-1]->source_line,
				_("`next' used in %s action"), ruletab[rule]);
		yyvsp[-1]->target_jmp = ip_rec;
		yyval = list_create(yyvsp[-1]);
		if (yyvsp[0] != NULL)
			yyval = list_append(yyval, yyvsp[0]);
	  }
#line 2966 "awkgram.c"
    break;

  case 61: /* non_compound_stmt: LEX_NEXTFILE statement_term  */
#line 1081 "awkgram.y"
          {
		/* if inside function (rule = 0), resolve context at run-time */
		if (rule == BEGIN || rule == END || rule == ENDFILE)
			error_ln(yyvsp[-1]->source_line,
				_("`nextfile' used in %s action"), ruletab[rule]);

		yyvsp[-1]->target_newfile = ip_newfile;
		yyvsp[-1]->target_endfile = ip_endfile;
		yyval = list_create(yyvsp[-1]);
		if (yyvsp[0] != NULL)
			yyval = list_append(yyval, yyvsp[0]);
	  }
#line 2983 "awkgram.c"
    break;

  case 62: /* non_compound_stmt: LEX_EXIT opt_exp statement_term  */
#line 1094 "awkgram.y"
          {
		/* Initialize the two possible jump targets, the actual target
		 * is resolved at run-time.
		 */
		yyvsp[-2]->target_end = ip_end;	/* first instruction in end_block */
		yyvsp[-2]->target_atexit = ip_atexit;	/* cleanup and go home */

		if (yyvsp[-1] == NULL) {
			yyval = list_create(yyvsp[-2]);
			(void) list_prepend(yyval, instruction(Op_push_i));
			yyval->nexti->memory = dupnode(Nnull_string);
		} else
			yyval = list_append(yyvsp[-1], yyvsp[-2]);
		if (yyvsp[0] != NULL)
			yyval = list_append(yyval, yyvsp[0]);
	  }
#line 3004 "awkgram.c"
    break;

  case 63: /* $@3: %empty  */
#line 1111 "awkgram.y"
          {
		if (! in_function)
			yyerror(_("`return' used outside function context"));
	  }
#line 3013 "awkgram.c"
    break;

  case 64: /* non_compound_stmt: LEX_RETURN $@3 opt_fcall_exp statement_term  */
#line 1114 "awkgram.y"
                                         {
		if (called_from_eval)
			yyvsp[-3]->opcode = Op_K_return_from_eval;

		if (yyvsp[-1] == NULL) {
			yyval = list_create(yyvsp[-3]);
			(void) list_prepend(yyval, instruction(Op_push_i));
			yyval->nexti->memory = dupnode(Nnull_string);
		} else
			yyval = list_append(yyvsp[-1], yyvsp[-3]);
		if (yyvsp[0] != NULL)
			yyval = list_append(yyval, yyvsp[0]);
	  }
#line 3031 "awkgram.c"
    break;

  case 65: /* non_compound_stmt: simple_stmt statement_term  */
#line 1128 "awkgram.y"
          {
		if (yyvsp[0] != NULL)
			yyval = list_append(yyvsp[-1], yyvsp[0]);
		else
			yyval = yyvsp[-1];
	  }
#line 3042 "awkgram.c"
    break;

  case 66: /* $@4: %empty  */
#line 1145 "awkgram.y"
                { in_print = true; in_parens = 0; }
#line 3048 "awkgram.c"
    break;

  case 67: /* simple_stmt: print $@4 print_expression_list output_redir  */
#line 1146 "awkgram.y"
          {
		/*
		 * Optimization: plain `print' has no expression list, so $3 is null.
		 * If $3 is NULL or is a bytecode list for $0 use Op_K_print_rec,
		 * which is faster for these two cases.
		 */

		if (do_optimize && yyvsp[-3]->opcode == Op_K_print &&
			(yyvsp[-1] == NULL
				|| (yyvsp[-1]->lasti->opcode == Op_field_spec
					&& yyvsp[-1]->nexti->nexti->nexti == yyvsp[-1]->lasti
					&& yyvsp[-1]->nexti->nexti->opcode == Op_push_i
					&& yyvsp[-1]->nexti->nexti->memory->type == Node_val)
			)
		) {
			static bool warned = false;
			/*   -----------------
			 *      output_redir
			 *    [ redirect exp ]
			 *   -----------------
			 *     expression_list
			 *   ------------------
			 *    [Op_K_print_rec | NULL | redir_type | expr_count]
			 */

			if (yyvsp[-1] != NULL) {
				NODE *n = yyvsp[-1]->nexti->nexti->memory;

				if ((n->flags & (STRING|STRCUR)) != 0 || ! is_zero(n))
					goto regular_print;

				bcfree(yyvsp[-1]->lasti);			/* Op_field_spec */
				unref(n);				/* Node_val */
				bcfree(yyvsp[-1]->nexti->nexti);		/* Op_push_i */
				bcfree(yyvsp[-1]->nexti);			/* Op_list */
				bcfree(yyvsp[-1]);				/* Op_list */
			} else {
				if (do_lint && (rule == BEGIN || rule == END) && ! warned) {
					warned = true;
					lintwarn_ln(yyvsp[-3]->source_line,
		_("plain `print' in BEGIN or END rule should probably be `print \"\"'"));
				}
			}

			yyvsp[-3]->expr_count = 0;
			yyvsp[-3]->opcode = Op_K_print_rec;
			if (yyvsp[0] == NULL) {    /* no redircetion */
				yyvsp[-3]->redir_type = redirect_none;
				yyval = list_create(yyvsp[-3]);
			} else {
				INSTRUCTION *ip;
				ip = yyvsp[0]->nexti;
				yyvsp[-3]->redir_type = ip->redir_type;
				yyvsp[0]->nexti = ip->nexti;
				bcfree(ip);
				yyval = list_append(yyvsp[0], yyvsp[-3]);
			}
		} else {
			/*   -----------------
			 *    [ output_redir    ]
			 *    [ redirect exp    ]
			 *   -----------------
			 *    [ expression_list ]
			 *   ------------------
			 *    [$1 | NULL | redir_type | expr_count]
			 *
			 */
regular_print:
			if (yyvsp[0] == NULL) {		/* no redirection */
				if (yyvsp[-1] == NULL)	{	/* print/printf without arg */
					yyvsp[-3]->expr_count = 0;
					if (yyvsp[-3]->opcode == Op_K_print)
						yyvsp[-3]->opcode = Op_K_print_rec;
					yyvsp[-3]->redir_type = redirect_none;
					yyval = list_create(yyvsp[-3]);
				} else {
					INSTRUCTION *t = yyvsp[-1];
					yyvsp[-3]->expr_count = count_expressions(&t, false);
					yyvsp[-3]->redir_type = redirect_none;
					yyval = list_append(t, yyvsp[-3]);
				}
			} else {
				INSTRUCTION *ip;
				ip = yyvsp[0]->nexti;
				yyvsp[-3]->redir_type = ip->redir_type;
				yyvsp[0]->nexti = ip->nexti;
				bcfree(ip);
				if (yyvsp[-1] == NULL) {
					yyvsp[-3]->expr_count = 0;
					if (yyvsp[-3]->opcode == Op_K_print)
						yyvsp[-3]->opcode = Op_K_print_rec;
					yyval = list_append(yyvsp[0], yyvsp[-3]);
				} else {
					INSTRUCTION *t = yyvsp[-1];
					yyvsp[-3]->expr_count = count_expressions(&t, false);
					yyval = list_append(list_merge(yyvsp[0], t), yyvsp[-3]);
				}
			}
		}
	  }
#line 3153 "awkgram.c"
    break;

  case 68: /* $@5: %empty  */
#line 1247 "awkgram.y"
                          { sub_counter = 0; }
#line 3159 "awkgram.c"
    break;

  case 69: /* simple_stmt: LEX_DELETE NAME $@5 delete_subscript_list  */
#line 1248 "awkgram.y"
          {
		char *arr = yyvsp[-2]->lextok;

		yyvsp[-2]->opcode = Op_push_array;
		yyvsp[-2]->memory = variable(yyvsp[-2]->source_line, arr, Node_var_new);

		if (! do_posix && ! do_traditional) {
			if (yyvsp[-2]->memory == symbol_table)
				fatal(_("`delete' is not allowed with SYMTAB"));
			else if (yyvsp[-2]->memory == func_table)
				fatal(_("`delete' is not allowed with FUNCTAB"));
		}

		if (yyvsp[0] == NULL) {
			/*
			 * As of September 2012, POSIX has added support
			 * for `delete array'. See:
			 * http://austingroupbugs.net/view.php?id=544
			 *
			 * Thanks to Nathan Weeks for the initiative.
			 *
			 * Thus we no longer warn or check do_posix.
			 * Also, since BWK awk supports it, we don't have to
			 * check do_traditional either.
			 */
			yyvsp[-3]->expr_count = 0;
			yyval = list_append(list_create(yyvsp[-2]), yyvsp[-3]);
		} else {
			yyvsp[-3]->expr_count = sub_counter;
			yyval = list_append(list_append(yyvsp[0], yyvsp[-2]), yyvsp[-3]);
		}
	  }
#line 3196 "awkgram.c"
    break;

  case 70: /* simple_stmt: LEX_DELETE '(' NAME ')'  */
#line 1285 "awkgram.y"
          {
		static bool warned = false;
		char *arr = yyvsp[-1]->lextok;

		if (do_lint && ! warned) {
			warned = true;
			lintwarn_ln(yyvsp[-3]->source_line,
				_("`delete(array)' is a non-portable tawk extension"));
		}
		if (do_traditional) {
			error_ln(yyvsp[-3]->source_line,
				_("`delete(array)' is a non-portable tawk extension"));
		}
		yyvsp[-1]->memory = variable(yyvsp[-1]->source_line, arr, Node_var_new);
		yyvsp[-1]->opcode = Op_push_array;
		yyvsp[-3]->expr_count = 0;
		yyval = list_append(list_create(yyvsp[-1]), yyvsp[-3]);

		if (! do_posix && ! do_traditional) {
			if (yyvsp[-1]->memory == symbol_table)
				fatal(_("`delete' is not allowed with SYMTAB"));
			else if (yyvsp[-1]->memory == func_table)
				fatal(_("`delete' is not allowed with FUNCTAB"));
		}
	  }
#line 3226 "awkgram.c"
    break;

  case 71: /* simple_stmt: exp  */
#line 1311 "awkgram.y"
          {
		yyval = optimize_assignment(yyvsp[0]);
	  }
#line 3234 "awkgram.c"
    break;

  case 72: /* opt_simple_stmt: %empty  */
#line 1318 "awkgram.y"
          { yyval = NULL; }
#line 3240 "awkgram.c"
    break;

  case 73: /* opt_simple_stmt: simple_stmt  */
#line 1320 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3246 "awkgram.c"
    break;

  case 74: /* case_statements: %empty  */
#line 1325 "awkgram.y"
          { yyval = NULL; }
#line 3252 "awkgram.c"
    break;

  case 75: /* case_statements: case_statements case_statement  */
#line 1327 "awkgram.y"
          {
		if (yyvsp[-1] == NULL)
			yyval = list_create(yyvsp[0]);
		else
			yyval = list_prepend(yyvsp[-1], yyvsp[0]);
	  }
#line 3263 "awkgram.c"
    break;

  case 76: /* case_statements: case_statements error  */
#line 1334 "awkgram.y"
          { yyval = NULL; }
#line 3269 "awkgram.c"
    break;

  case 77: /* case_statement: LEX_CASE case_value colon opt_nls statements  */
#line 1339 "awkgram.y"
          {
		INSTRUCTION *casestmt = yyvsp[0];
		if (yyvsp[0] == NULL)
			casestmt = list_create(instruction(Op_no_op));
		if (do_pretty_print)
			(void) list_prepend(casestmt, instruction(Op_exec_count));
		yyvsp[-4]->case_exp = yyvsp[-3];
		yyvsp[-4]->case_stmt = casestmt;
		yyvsp[-4]->comment = yyvsp[-1];
		bcfree(yyvsp[-2]);
		yyval = yyvsp[-4];
	  }
#line 3286 "awkgram.c"
    break;

  case 78: /* case_statement: LEX_DEFAULT colon opt_nls statements  */
#line 1352 "awkgram.y"
          {
		INSTRUCTION *casestmt = yyvsp[0];
		if (yyvsp[0] == NULL)
			casestmt = list_create(instruction(Op_no_op));
		if (do_pretty_print)
			(void) list_prepend(casestmt, instruction(Op_exec_count));
		bcfree(yyvsp[-2]);
		yyvsp[-3]->case_stmt = casestmt;
		yyvsp[-3]->comment = yyvsp[-1];
		yyval = yyvsp[-3];
	  }
#line 3302 "awkgram.c"
    break;

  case 79: /* case_value: YNUMBER  */
#line 1367 "awkgram.y"
          {	yyval = yyvsp[0]; }
#line 3308 "awkgram.c"
    break;

  case 80: /* case_value: '-' YNUMBER  */
#line 1369 "awkgram.y"
          {
		NODE *n = yyvsp[0]->memory;
		(void) force_number(n);
		negate_num(n);
		bcfree(yyvsp[-1]);
		yyval = yyvsp[0];
	  }
#line 3320 "awkgram.c"
    break;

  case 81: /* case_value: '+' YNUMBER  */
#line 1377 "awkgram.y"
          {
		NODE *n = yyvsp[0]->lasti->memory;
		bcfree(yyvsp[-1]);
		add_sign_to_num(n, '+');
		yyval = yyvsp[0];
	  }
#line 3331 "awkgram.c"
    break;

  case 82: /* case_value: YSTRING  */
#line 1384 "awkgram.y"
          {	yyval = yyvsp[0]; }
#line 3337 "awkgram.c"
    break;

  case 83: /* case_value: regexp  */
#line 1386 "awkgram.y"
          {
		if (yyvsp[0]->memory->type == Node_regex)
			yyvsp[0]->opcode = Op_push_re;
		else
			yyvsp[0]->opcode = Op_push;
		yyval = yyvsp[0];
	  }
#line 3349 "awkgram.c"
    break;

  case 84: /* case_value: typed_regexp  */
#line 1394 "awkgram.y"
          {
		assert((yyvsp[0]->memory->flags & REGEX) == REGEX);
		yyvsp[0]->opcode = Op_push_re;
		yyval = yyvsp[0];
	  }
#line 3359 "awkgram.c"
    break;

  case 85: /* print: LEX_PRINT  */
#line 1403 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3365 "awkgram.c"
    break;

  case 86: /* print: LEX_PRINTF  */
#line 1405 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3371 "awkgram.c"
    break;

  case 88: /* print_expression_list: '(' expression_list r_paren  */
#line 1415 "awkgram.y"
          {
		yyval = yyvsp[-1];
	  }
#line 3379 "awkgram.c"
    break;

  case 89: /* output_redir: %empty  */
#line 1422 "awkgram.y"
          {
		in_print = false;
		in_parens = 0;
		yyval = NULL;
	  }
#line 3389 "awkgram.c"
    break;

  case 90: /* $@6: %empty  */
#line 1427 "awkgram.y"
                 { in_print = false; in_parens = 0; }
#line 3395 "awkgram.c"
    break;

  case 91: /* output_redir: IO_OUT $@6 common_exp  */
#line 1428 "awkgram.y"
          {
		if (yyvsp[-2]->redir_type == redirect_twoway
		    	&& yyvsp[0]->lasti->opcode == Op_K_getline_redir
		   	 	&& yyvsp[0]->lasti->redir_type == redirect_twoway)
			yyerror(_("multistage two-way pipelines don't work"));
		if (do_lint && yyvsp[-2]->redir_type == redirect_output && yyvsp[0]->lasti->opcode == Op_concat)
			lintwarn(_("concatenation as I/O `>' redirection target is ambiguous"));
		yyval = list_prepend(yyvsp[0], yyvsp[-2]);
	  }
#line 3409 "awkgram.c"
    break;

  case 92: /* if_statement: LEX_IF '(' exp r_paren opt_nls statement  */
#line 1441 "awkgram.y"
          {
		if (yyvsp[-1] != NULL)
			yyvsp[-5]->comment = yyvsp[-1];
		add_lint(yyvsp[-3], LINT_assign_in_cond);
		yyval = mk_condition(yyvsp[-3], yyvsp[-5], yyvsp[0], NULL, NULL);
	  }
#line 3420 "awkgram.c"
    break;

  case 93: /* if_statement: LEX_IF '(' exp r_paren opt_nls statement LEX_ELSE opt_nls statement  */
#line 1449 "awkgram.y"
          {
		if (yyvsp[-4] != NULL)
			yyvsp[-8]->comment = yyvsp[-4];
		if (yyvsp[-1] != NULL)
			yyvsp[-2]->comment = yyvsp[-1];
		add_lint(yyvsp[-6], LINT_assign_in_cond);
		yyval = mk_condition(yyvsp[-6], yyvsp[-8], yyvsp[-3], yyvsp[-2], yyvsp[0]);
	  }
#line 3433 "awkgram.c"
    break;

  case 94: /* nls: NEWLINE  */
#line 1461 "awkgram.y"
          {
		yyval = yyvsp[0];
	  }
#line 3441 "awkgram.c"
    break;

  case 95: /* nls: nls NEWLINE  */
#line 1465 "awkgram.y"
          {
		if (yyvsp[-1] != NULL && yyvsp[0] != NULL) {
			if (yyvsp[-1]->memory->comment_type == EOL_COMMENT) {
				assert(yyvsp[0]->memory->comment_type == BLOCK_COMMENT);
				yyvsp[-1]->comment = yyvsp[0];	// chain them
			} else {
				merge_comments(yyvsp[-1], yyvsp[0]);
			}

			yyval = yyvsp[-1];
		} else if (yyvsp[-1] != NULL) {
			yyval = yyvsp[-1];
		} else if (yyvsp[0] != NULL) {
			yyval = yyvsp[0];
		} else
			yyval = NULL;
	  }
#line 3463 "awkgram.c"
    break;

  case 96: /* opt_nls: %empty  */
#line 1486 "awkgram.y"
          { yyval = NULL; }
#line 3469 "awkgram.c"
    break;

  case 97: /* opt_nls: nls  */
#line 1488 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3475 "awkgram.c"
    break;

  case 98: /* input_redir: %empty  */
#line 1493 "awkgram.y"
          { yyval = NULL; }
#line 3481 "awkgram.c"
    break;

  case 99: /* input_redir: '<' simp_exp  */
#line 1495 "awkgram.y"
          {
		bcfree(yyvsp[-1]);
		yyval = yyvsp[0];
	  }
#line 3490 "awkgram.c"
    break;

  case 100: /* opt_param_list: %empty  */
#line 1503 "awkgram.y"
          { yyval = NULL; }
#line 3496 "awkgram.c"
    break;

  case 101: /* opt_param_list: param_list  */
#line 1505 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3502 "awkgram.c"
    break;

  case 102: /* param_list: NAME  */
#line 1510 "awkgram.y"
          {
		yyvsp[0]->param_count = 0;
		yyval = list_create(yyvsp[0]);
	  }
#line 3511 "awkgram.c"
    break;

  case 103: /* param_list: param_list comma NAME  */
#line 1515 "awkgram.y"
          {
		if (yyvsp[-2] != NULL && yyvsp[0] != NULL) {
			yyvsp[0]->param_count = yyvsp[-2]->lasti->param_count + 1;
			yyval = list_append(yyvsp[-2], yyvsp[0]);
			yyerrok;

			// newlines are allowed after commas, catch any comments
			if (yyvsp[-1] != NULL) {
				if (yyvsp[-2]->comment != NULL)
					merge_comments(yyvsp[-2]->comment, yyvsp[-1]);
				else
					yyvsp[-2]->comment = yyvsp[-1];
			}
		} else
			yyval = NULL;
	  }
#line 3532 "awkgram.c"
    break;

  case 104: /* param_list: error  */
#line 1532 "awkgram.y"
          { yyval = NULL; }
#line 3538 "awkgram.c"
    break;

  case 105: /* param_list: param_list error  */
#line 1534 "awkgram.y"
          { yyval = yyvsp[-1]; }
#line 3544 "awkgram.c"
    break;

  case 106: /* param_list: param_list comma error  */
#line 1536 "awkgram.y"
          { yyval = yyvsp[-2]; }
#line 3550 "awkgram.c"
    break;

  case 107: /* opt_exp: %empty  */
#line 1542 "awkgram.y"
          { yyval = NULL; }
#line 3556 "awkgram.c"
    break;

  case 108: /* opt_exp: exp  */
#line 1544 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3562 "awkgram.c"
    break;

  case 109: /* opt_expression_list: %empty  */
#line 1549 "awkgram.y"
          { yyval = NULL; }
#line 3568 "awkgram.c"
    break;

  case 110: /* opt_expression_list: expression_list  */
#line 1551 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3574 "awkgram.c"
    break;

  case 111: /* expression_list: exp  */
#line 1556 "awkgram.y"
          {	yyval = mk_expression_list(NULL, yyvsp[0]); }
#line 3580 "awkgram.c"
    break;

  case 112: /* expression_list: expression_list comma exp  */
#line 1558 "awkgram.y"
          {
		if (yyvsp[-1] != NULL)
			yyvsp[-2]->lasti->comment = yyvsp[-1];
		yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);
		yyerrok;
	  }
#line 3591 "awkgram.c"
    break;

  case 113: /* expression_list: error  */
#line 1565 "awkgram.y"
          { yyval = NULL; }
#line 3597 "awkgram.c"
    break;

  case 114: /* expression_list: expression_list error  */
#line 1567 "awkgram.y"
          {
		/*
		 * Returning the expression list instead of NULL lets
		 * snode get a list of arguments that it can count.
		 */
		yyval = yyvsp[-1];
	  }
#line 3609 "awkgram.c"
    break;

  case 115: /* expression_list: expression_list error exp  */
#line 1575 "awkgram.y"
          {
		/* Ditto */
		yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);
	  }
#line 3618 "awkgram.c"
    break;

  case 116: /* expression_list: expression_list comma error  */
#line 1580 "awkgram.y"
          {
		/* Ditto */
		if (yyvsp[-1] != NULL)
			yyvsp[-2]->lasti->comment = yyvsp[-1];
		yyval = yyvsp[-2];
	  }
#line 3629 "awkgram.c"
    break;

  case 117: /* opt_fcall_expression_list: %empty  */
#line 1590 "awkgram.y"
          { yyval = NULL; }
#line 3635 "awkgram.c"
    break;

  case 118: /* opt_fcall_expression_list: fcall_expression_list  */
#line 1592 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3641 "awkgram.c"
    break;

  case 119: /* fcall_expression_list: fcall_exp  */
#line 1597 "awkgram.y"
          {	yyval = mk_expression_list(NULL, yyvsp[0]); }
#line 3647 "awkgram.c"
    break;

  case 120: /* fcall_expression_list: fcall_expression_list comma fcall_exp  */
#line 1599 "awkgram.y"
          {
		if (yyvsp[-1] != NULL)
			yyvsp[-2]->lasti->comment = yyvsp[-1];
		yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);
		yyerrok;
	  }
#line 3658 "awkgram.c"
    break;

  case 121: /* fcall_expression_list: error  */
#line 1606 "awkgram.y"
          { yyval = NULL; }
#line 3664 "awkgram.c"
    break;

  case 122: /* fcall_expression_list: fcall_expression_list error  */
#line 1608 "awkgram.y"
          {
		/*
		 * Returning the expression list instead of NULL lets
		 * snode get a list of arguments that it can count.
		 */
		yyval = yyvsp[-1];
	  }
#line 3676 "awkgram.c"
    break;

  case 123: /* fcall_expression_list: fcall_expression_list error fcall_exp  */
#line 1616 "awkgram.y"
          {
		/* Ditto */
		yyval = mk_expression_list(yyvsp[-2], yyvsp[0]);
	  }
#line 3685 "awkgram.c"
    break;

  case 124: /* fcall_expression_list: fcall_expression_list comma error  */
#line 1621 "awkgram.y"
          {
		/* Ditto */
		if (yyvsp[-1] != NULL)
			yyvsp[-2]->comment = yyvsp[-1];
		yyval = yyvsp[-2];
	  }
#line 3696 "awkgram.c"
    break;

  case 125: /* fcall_exp: exp  */
#line 1630 "awkgram.y"
              { yyval = yyvsp[0]; }
#line 3702 "awkgram.c"
    break;

  case 126: /* fcall_exp: typed_regexp  */
#line 1631 "awkgram.y"
                       { yyval = list_create(yyvsp[0]); }
#line 3708 "awkgram.c"
    break;

  case 127: /* opt_fcall_exp: %empty  */
#line 1636 "awkgram.y"
          { yyval = NULL; }
#line 3714 "awkgram.c"
    break;

  case 128: /* opt_fcall_exp: fcall_exp  */
#line 1637 "awkgram.y"
                    { yyval = yyvsp[0]; }
#line 3720 "awkgram.c"
    break;

  case 129: /* exp: variable assign_operator exp  */
#line 1643 "awkgram.y"
          {
		if (do_lint && yyvsp[0]->lasti->opcode == Op_match_rec)
			lintwarn_ln(yyvsp[-1]->source_line,
				_("regular expression on right of assignment"));
		yyval = mk_assignment(yyvsp[-2], yyvsp[0], yyvsp[-1]);
	  }
#line 3731 "awkgram.c"
    break;

  case 130: /* exp: variable ASSIGN typed_regexp  */
#line 1650 "awkgram.y"
          {
		yyval = mk_assignment(yyvsp[-2], list_create(yyvsp[0]), yyvsp[-1]);
	  }
#line 3739 "awkgram.c"
    break;

  case 131: /* exp: exp LEX_AND exp  */
#line 1654 "awkgram.y"
          {	yyval = mk_boolean(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3745 "awkgram.c"
    break;

  case 132: /* exp: exp LEX_OR exp  */
#line 1656 "awkgram.y"
          {	yyval = mk_boolean(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3751 "awkgram.c"
    break;

  case 133: /* exp: exp MATCHOP typed_regexp  */
#line 1658 "awkgram.y"
          {
		if (yyvsp[-2]->lasti->opcode == Op_match_rec)
			warning_ln(yyvsp[-1]->source_line,
				_("regular expression on left of `~' or `!~' operator"));

		assert(yyvsp[0]->opcode == Op_push_re
			&& (yyvsp[0]->memory->flags & REGEX) != 0);
		/* RHS is @/.../ */
		yyvsp[-1]->memory = yyvsp[0]->memory;
		bcfree(yyvsp[0]);
		yyval = list_append(yyvsp[-2], yyvsp[-1]);
	  }
#line 3768 "awkgram.c"
    break;

  case 134: /* exp: exp MATCHOP exp  */
#line 1671 "awkgram.y"
          {
		if (yyvsp[-2]->lasti->opcode == Op_match_rec)
			warning_ln(yyvsp[-1]->source_line,
				_("regular expression on left of `~' or `!~' operator"));

		if (yyvsp[0]->lasti == yyvsp[0]->nexti && yyvsp[0]->nexti->opcode == Op_match_rec) {
			/* RHS is /.../ */
			yyvsp[-1]->memory = yyvsp[0]->nexti->memory;
			bcfree(yyvsp[0]->nexti);	/* Op_match_rec */
			bcfree(yyvsp[0]);			/* Op_list */
			yyval = list_append(yyvsp[-2], yyvsp[-1]);
		} else {
			yyvsp[-1]->memory = make_regnode(Node_dynregex, NULL);
			yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), yyvsp[-1]);
		}
	  }
#line 3789 "awkgram.c"
    break;

  case 135: /* exp: exp LEX_IN simple_variable  */
#line 1688 "awkgram.y"
          {
		if (do_lint_old)
			lintwarn_ln(yyvsp[-1]->source_line,
				_("old awk does not support the keyword `in' except after `for'"));
		yyvsp[0]->nexti->opcode = Op_push_array;
		yyvsp[-1]->opcode = Op_in_array;
		yyvsp[-1]->expr_count = 1;
		yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), yyvsp[-1]);
	  }
#line 3803 "awkgram.c"
    break;

  case 136: /* exp: exp a_relop exp  */
#line 1698 "awkgram.y"
          {
		if (do_lint && yyvsp[0]->lasti->opcode == Op_match_rec)
			lintwarn_ln(yyvsp[-1]->source_line,
				_("regular expression on right of comparison"));
		yyval = list_append(list_merge(yyvsp[-2], yyvsp[0]), yyvsp[-1]);
	  }
#line 3814 "awkgram.c"
    break;

  case 137: /* exp: exp '?' exp ':' exp  */
#line 1705 "awkgram.y"
          { yyval = mk_condition(yyvsp[-4], yyvsp[-3], yyvsp[-2], yyvsp[-1], yyvsp[0]); }
#line 3820 "awkgram.c"
    break;

  case 138: /* exp: common_exp  */
#line 1707 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3826 "awkgram.c"
    break;

  case 139: /* assign_operator: ASSIGN  */
#line 1712 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3832 "awkgram.c"
    break;

  case 140: /* assign_operator: ASSIGNOP  */
#line 1714 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3838 "awkgram.c"
    break;

  case 141: /* assign_operator: SLASH_BEFORE_EQUAL ASSIGN  */
#line 1716 "awkgram.y"
          {
		yyvsp[0]->opcode = Op_assign_quotient;
		yyval = yyvsp[0];
	  }
#line 3847 "awkgram.c"
    break;

  case 142: /* relop_or_less: RELOP  */
#line 1724 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3853 "awkgram.c"
    break;

  case 143: /* relop_or_less: '<'  */
#line 1726 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3859 "awkgram.c"
    break;

  case 144: /* a_relop: relop_or_less  */
#line 1731 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3865 "awkgram.c"
    break;

  case 145: /* a_relop: '>'  */
#line 1733 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3871 "awkgram.c"
    break;

  case 146: /* common_exp: simp_exp  */
#line 1738 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3877 "awkgram.c"
    break;

  case 147: /* common_exp: simp_exp_nc  */
#line 1740 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 3883 "awkgram.c"
    break;

  case 148: /* common_exp: common_exp simp_exp  */
#line 1742 "awkgram.y"
          {
		int count = 2;
		bool is_simple_var = false;

		if (yyvsp[-1]->lasti->opcode == Op_concat) {
			/* multiple (> 2) adjacent strings optimization */
			is_simple_var = (yyvsp[-1]->lasti->concat_flag & CSVAR) != 0;
			count = yyvsp[-1]->lasti->expr_count + 1;
			yyvsp[-1]->lasti->opcode = Op_no_op;
		} else {
			is_simple_var = (yyvsp[-1]->nexti->opcode == Op_push
					&& yyvsp[-1]->lasti == yyvsp[-1]->nexti); /* first exp. is a simple
					                             * variable?; kludge for use
					                             * in Op_assign_concat.
		 			                             */
		}

		if (do_optimize
			&& yyvsp[-1]->nexti == yyvsp[-1]->lasti && yyvsp[-1]->nexti->opcode == Op_push_i
			&& yyvsp[0]->nexti == yyvsp[0]->lasti && yyvsp[0]->nexti->opcode == Op_push_i
		) {
			NODE *n1 = yyvsp[-1]->nexti->memory;
			NODE *n2 = yyvsp[0]->nexti->memory;
			size_t nlen;

			// 1.5 ""   # can't fold this if program mucks with CONVFMT.
			// See test #12 in test/posix.awk.
			// Also can't fold if one or the other is translatable.
			if ((n1->flags & (NUMBER|NUMINT|INTLSTR)) != 0 || (n2->flags & (NUMBER|NUMINT|INTLSTR)) != 0)
				goto plain_concat;

			n1 = force_string(n1);
			n2 = force_string(n2);
			nlen = n1->stlen + n2->stlen;
			erealloc(n1->stptr, char *, nlen + 1);
			memcpy(n1->stptr + n1->stlen, n2->stptr, n2->stlen);
			n1->stlen = nlen;
			n1->stptr[nlen] = '\0';
			n1->flags &= ~(NUMCUR|NUMBER|NUMINT);
			n1->flags |= (STRING|STRCUR);
			unref(n2);
			bcfree(yyvsp[0]->nexti);
			bcfree(yyvsp[0]);
			yyval = yyvsp[-1];
		} else {
	plain_concat:
			yyval = list_append(list_merge(yyvsp[-1], yyvsp[0]), instruction(Op_concat));
			yyval->lasti->concat_flag = (is_simple_var ? CSVAR : 0);
			yyval->lasti->expr_count = count;
			if (count > max_args)
				max_args = count;
		}
	  }
#line 3941 "awkgram.c"
    break;

  case 150: /* simp_exp: simp_exp '^' simp_exp  */
#line 1801 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3947 "awkgram.c"
    break;

  case 151: /* simp_exp: simp_exp '*' simp_exp  */
#line 1803 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3953 "awkgram.c"
    break;

  case 152: /* simp_exp: simp_exp '/' simp_exp  */
#line 1805 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3959 "awkgram.c"
    break;

  case 153: /* simp_exp: simp_exp '%' simp_exp  */
#line 1807 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3965 "awkgram.c"
    break;

  case 154: /* simp_exp: simp_exp '+' simp_exp  */
#line 1809 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3971 "awkgram.c"
    break;

  case 155: /* simp_exp: simp_exp '-' simp_exp  */
#line 1811 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 3977 "awkgram.c"
    break;

  case 156: /* simp_exp: LEX_GETLINE opt_variable input_redir  */
#line 1813 "awkgram.y"
          {
		/*
		 * In BEGINFILE/ENDFILE, allow `getline [var] < file'
		 */

		if ((rule == BEGINFILE || rule == ENDFILE) && yyvsp[0] == NULL)
			error_ln(yyvsp[-2]->source_line,
				 _("non-redirected `getline' invalid inside `%s' rule"), ruletab[rule]);
		if (do_lint && rule == END && yyvsp[0] == NULL)
			lintwarn_ln(yyvsp[-2]->source_line,
				_("non-redirected `getline' undefined inside END action"));
		yyval = mk_getline(yyvsp[-2], yyvsp[-1], yyvsp[0], redirect_input);
	  }
#line 3995 "awkgram.c"
    break;

  case 157: /* simp_exp: variable INCREMENT  */
#line 1827 "awkgram.y"
          {
		yyvsp[0]->opcode = Op_postincrement;
		yyval = mk_assignment(yyvsp[-1], NULL, yyvsp[0]);
	  }
#line 4004 "awkgram.c"
    break;

  case 158: /* simp_exp: variable DECREMENT  */
#line 1832 "awkgram.y"
          {
		yyvsp[0]->opcode = Op_postdecrement;
		yyval = mk_assignment(yyvsp[-1], NULL, yyvsp[0]);
	  }
#line 4013 "awkgram.c"
    break;

  case 159: /* simp_exp: '(' expression_list r_paren LEX_IN simple_variable  */
#line 1837 "awkgram.y"
          {
		if (do_lint_old) {
		    /* first one is warning so that second one comes out if warnings are fatal */
		    warning_ln(yyvsp[-1]->source_line,
				_("old awk does not support the keyword `in' except after `for'"));
		    lintwarn_ln(yyvsp[-1]->source_line,
				_("old awk does not support multidimensional arrays"));
		}
		yyvsp[0]->nexti->opcode = Op_push_array;
		yyvsp[-1]->opcode = Op_in_array;
		if (yyvsp[-3] == NULL) {	/* error */
			errcount++;
			yyvsp[-1]->expr_count = 0;
			yyval = list_merge(yyvsp[0], yyvsp[-1]);
		} else {
			INSTRUCTION *t = yyvsp[-3];
			yyvsp[-1]->expr_count = count_expressions(&t, false);
			yyval = list_append(list_merge(t, yyvsp[0]), yyvsp[-1]);
		}
	  }
#line 4038 "awkgram.c"
    break;

  case 160: /* simp_exp_nc: common_exp IO_IN LEX_GETLINE opt_variable  */
#line 1863 "awkgram.y"
                {
		  yyval = mk_getline(yyvsp[-1], yyvsp[0], yyvsp[-3], yyvsp[-2]->redir_type);
		  bcfree(yyvsp[-2]);
		}
#line 4047 "awkgram.c"
    break;

  case 161: /* simp_exp_nc: simp_exp_nc '^' simp_exp  */
#line 1869 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 4053 "awkgram.c"
    break;

  case 162: /* simp_exp_nc: simp_exp_nc '*' simp_exp  */
#line 1871 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 4059 "awkgram.c"
    break;

  case 163: /* simp_exp_nc: simp_exp_nc '/' simp_exp  */
#line 1873 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 4065 "awkgram.c"
    break;

  case 164: /* simp_exp_nc: simp_exp_nc '%' simp_exp  */
#line 1875 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 4071 "awkgram.c"
    break;

  case 165: /* simp_exp_nc: simp_exp_nc '+' simp_exp  */
#line 1877 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 4077 "awkgram.c"
    break;

  case 166: /* simp_exp_nc: simp_exp_nc '-' simp_exp  */
#line 1879 "awkgram.y"
          { yyval = mk_binary(yyvsp[-2], yyvsp[0], yyvsp[-1]); }
#line 4083 "awkgram.c"
    break;

  case 167: /* non_post_simp_exp: regexp  */
#line 1884 "awkgram.y"
          {
		yyval = list_create(yyvsp[0]);
	  }
#line 4091 "awkgram.c"
    break;

  case 168: /* non_post_simp_exp: '!' simp_exp  */
#line 1888 "awkgram.y"
          {
		if (yyvsp[0]->opcode == Op_match_rec) {
			yyvsp[0]->opcode = Op_nomatch;
			yyvsp[-1]->opcode = Op_push_i;
			yyvsp[-1]->memory = set_profile_text(make_number(0.0), "0", 1);
			yyval = list_append(list_append(list_create(yyvsp[-1]),
						instruction(Op_field_spec)), yyvsp[0]);
		} else {
			if (do_optimize && yyvsp[0]->nexti == yyvsp[0]->lasti
					&& yyvsp[0]->nexti->opcode == Op_push_i
					&& (yyvsp[0]->nexti->memory->flags & (MPFN|MPZN|INTLSTR)) == 0
			) {
				NODE *n = yyvsp[0]->nexti->memory;
				if ((n->flags & STRING) != 0) {
					n->numbr = (AWKNUM) (n->stlen == 0);
					n->flags &= ~(STRCUR|STRING);
					n->flags |= (NUMCUR|NUMBER);
					efree(n->stptr);
					n->stptr = NULL;
					n->stlen = 0;
				} else
					n->numbr = (AWKNUM) (n->numbr == 0.0);
				bcfree(yyvsp[-1]);
				yyval = yyvsp[0];
			} else {
				yyvsp[-1]->opcode = Op_not;
				add_lint(yyvsp[0], LINT_assign_in_cond);
				yyval = list_append(yyvsp[0], yyvsp[-1]);
			}
		}
	   }
#line 4127 "awkgram.c"
    break;

  case 169: /* non_post_simp_exp: '(' exp r_paren  */
#line 1920 "awkgram.y"
          {
		// Always include. Allows us to lint warn on
		// print "foo" > "bar" 1
		// but not warn on
		// print "foo" > ("bar" 1)
		yyval = list_append(yyvsp[-1], bcalloc(Op_parens, 1, sourceline));
	  }
#line 4139 "awkgram.c"
    break;

  case 170: /* non_post_simp_exp: LEX_BUILTIN '(' opt_fcall_expression_list r_paren  */
#line 1928 "awkgram.y"
          {
		yyval = snode(yyvsp[-1], yyvsp[-3]);
		if (yyval == NULL)
			YYABORT;
	  }
#line 4149 "awkgram.c"
    break;

  case 171: /* non_post_simp_exp: LEX_LENGTH '(' opt_fcall_expression_list r_paren  */
#line 1934 "awkgram.y"
          {
		yyval = snode(yyvsp[-1], yyvsp[-3]);
		if (yyval == NULL)
			YYABORT;
	  }
#line 4159 "awkgram.c"
    break;

  case 172: /* non_post_simp_exp: LEX_LENGTH  */
#line 1940 "awkgram.y"
          {
		static bool warned = false;

		if (do_lint && ! warned) {
			warned = true;
			lintwarn_ln(yyvsp[0]->source_line,
				_("call of `length' without parentheses is not portable"));
		}
		yyval = snode(NULL, yyvsp[0]);
		if (yyval == NULL)
			YYABORT;
	  }
#line 4176 "awkgram.c"
    break;

  case 175: /* non_post_simp_exp: INCREMENT variable  */
#line 1955 "awkgram.y"
          {
		yyvsp[-1]->opcode = Op_preincrement;
		yyval = mk_assignment(yyvsp[0], NULL, yyvsp[-1]);
	  }
#line 4185 "awkgram.c"
    break;

  case 176: /* non_post_simp_exp: DECREMENT variable  */
#line 1960 "awkgram.y"
          {
		yyvsp[-1]->opcode = Op_predecrement;
		yyval = mk_assignment(yyvsp[0], NULL, yyvsp[-1]);
	  }
#line 4194 "awkgram.c"
    break;

  case 177: /* non_post_simp_exp: YNUMBER  */
#line 1965 "awkgram.y"
          {
		yyval = list_create(yyvsp[0]);
	  }
#line 4202 "awkgram.c"
    break;

  case 178: /* non_post_simp_exp: YSTRING  */
#line 1969 "awkgram.y"
          {
		yyval = list_create(yyvsp[0]);
	  }
#line 4210 "awkgram.c"
    break;

  case 179: /* non_post_simp_exp: '-' simp_exp  */
#line 1973 "awkgram.y"
          {
		if (yyvsp[0]->lasti->opcode == Op_push_i
			&& (yyvsp[0]->lasti->memory->flags & STRING) == 0
		) {
			NODE *n = yyvsp[0]->lasti->memory;
			(void) force_number(n);
			negate_num(n);
			yyval = yyvsp[0];
			bcfree(yyvsp[-1]);
		} else {
			yyvsp[-1]->opcode = Op_unary_minus;
			yyval = list_append(yyvsp[0], yyvsp[-1]);
		}
	  }
#line 4229 "awkgram.c"
    break;

  case 180: /* non_post_simp_exp: '+' simp_exp  */
#line 1988 "awkgram.y"
          {
		if (yyvsp[0]->lasti->opcode == Op_push_i
			&& (yyvsp[0]->lasti->memory->flags & STRING) == 0
			&& (yyvsp[0]->lasti->memory->flags & NUMCONSTSTR) != 0) {
			NODE *n = yyvsp[0]->lasti->memory;
			add_sign_to_num(n, '+');
			yyval = yyvsp[0];
			bcfree(yyvsp[-1]);
		} else {
			/*
			 * was: $$ = $2
			 * POSIX semantics: force a conversion to numeric type
			 */
			yyvsp[-1]->opcode = Op_unary_plus;
			yyval = list_append(yyvsp[0], yyvsp[-1]);
		}
	  }
#line 4251 "awkgram.c"
    break;

  case 181: /* func_call: direct_func_call  */
#line 2009 "awkgram.y"
          {
		func_use(yyvsp[0]->lasti->func_name, FUNC_USE);
		yyval = yyvsp[0];
	  }
#line 4260 "awkgram.c"
    break;

  case 182: /* func_call: '@' direct_func_call  */
#line 2014 "awkgram.y"
          {
		/* indirect function call */
		INSTRUCTION *f, *t;
		char *name;
		NODE *indirect_var;
		static bool warned = false;
		const char *msg = _("indirect function calls are a gawk extension");

		if (do_traditional || do_posix)
			yyerror("%s", msg);
		else if (do_lint_extensions && ! warned) {
			warned = true;
			lintwarn("%s", msg);
		}

		f = yyvsp[0]->lasti;
		f->opcode = Op_indirect_func_call;
		name = estrdup(f->func_name, strlen(f->func_name));
		if (is_std_var(name))
			yyerror(_("cannot use special variable `%s' for indirect function call"), name);
		indirect_var = variable(f->source_line, name, Node_var_new);
		t = instruction(Op_push);
		t->memory = indirect_var;

		/* prepend indirect var instead of appending to arguments (opt_expression_list),
		 * and pop it off in setup_frame (eval.c) (left to right evaluation order); Test case:
		 *		f = "fun"
		 *		@f(f="real_fun")
		 */

		yyval = list_prepend(yyvsp[0], t);
		at_seen--;
	  }
#line 4298 "awkgram.c"
    break;

  case 183: /* direct_func_call: FUNC_CALL '(' opt_fcall_expression_list r_paren  */
#line 2051 "awkgram.y"
          {
		NODE *n;
		char *name = yyvsp[-3]->func_name;
		char *qname = qualify_name(name, strlen(name));

		if (qname != name) {
			efree((char *) name);
			yyvsp[-3]->func_name = qname;
		}

		if (! at_seen) {
			n = lookup(yyvsp[-3]->func_name);
			if (n != NULL && n->type != Node_func
			    && n->type != Node_ext_func) {
				error_ln(yyvsp[-3]->source_line,
					_("attempt to use non-function `%s' in function call"),
						yyvsp[-3]->func_name);
			}
		}

		param_sanity(yyvsp[-1]);
		yyvsp[-3]->opcode = Op_func_call;
		yyvsp[-3]->func_body = NULL;
		if (yyvsp[-1] == NULL) {	/* no argument or error */
			(yyvsp[-3] + 1)->expr_count = 0;
			yyval = list_create(yyvsp[-3]);
		} else {
			INSTRUCTION *t = yyvsp[-1];
			(yyvsp[-3] + 1)->expr_count = count_expressions(&t, true);
			yyval = list_append(t, yyvsp[-3]);
		}
	  }
#line 4335 "awkgram.c"
    break;

  case 184: /* opt_variable: %empty  */
#line 2087 "awkgram.y"
          { yyval = NULL; }
#line 4341 "awkgram.c"
    break;

  case 185: /* opt_variable: variable  */
#line 2089 "awkgram.y"
          { yyval = yyvsp[0]; }
#line 4347 "awkgram.c"
    break;

  case 186: /* delete_subscript_list: %empty  */
#line 2094 "awkgram.y"
          { yyval = NULL; }
#line 4353 "awkgram.c"
    break;

  case 187: /* delete_subscript_list: delete_subscript SUBSCRIPT  */
#line 2096 "awkgram.y"
          { yyval = yyvsp[-1]; }
#line 4359 "awkgram.c"
    break;

  case 188: /* delete_subscript: delete_exp_list  */
#line 2101 "awkgram.y"
          {	yyval = yyvsp[0]; }
#line 4365 "awkgram.c"
    break;

  case 189: /* delete_subscript: delete_subscript delete_exp_list  */
#line 2103 "awkgram.y"
          {
		yyval = list_merge(yyvsp[-1], yyvsp[0]);
	  }
#line 4373 "awkgram.c"
    break;

  case 190: /* delete_exp_list: bracketed_exp_list  */
#line 2110 "awkgram.y"
          {
		INSTRUCTION *ip = yyvsp[0]->lasti;
		int count = ip->sub_count;	/* # of SUBSEP-seperated expressions */
		if (count > 1) {
			/* change Op_subscript or Op_sub_array to Op_concat */
			ip->opcode = Op_concat;
			ip->concat_flag = CSUBSEP;
			ip->expr_count = count;
		} else
			ip->opcode = Op_no_op;
		sub_counter++;	/* count # of dimensions */
		yyval = yyvsp[0];
	  }
#line 4391 "awkgram.c"
    break;

  case 191: /* bracketed_exp_list: '[' expression_list ']'  */
#line 2127 "awkgram.y"
          {
		INSTRUCTION *t = yyvsp[-1];
		if (yyvsp[-1] == NULL) {
			error_ln(yyvsp[0]->source_line,
				_("invalid subscript expression"));
			/* install Null string as subscript. */
			t = list_create(instruction(Op_push_i));
			t->nexti->memory = dupnode(Nnull_string);
			yyvsp[0]->sub_count = 1;
		} else
			yyvsp[0]->sub_count = count_expressions(&t, false);
		yyval = list_append(t, yyvsp[0]);
	  }
#line 4409 "awkgram.c"
    break;

  case 192: /* subscript: bracketed_exp_list  */
#line 2144 "awkgram.y"
          {	yyval = yyvsp[0]; }
#line 4415 "awkgram.c"
    break;

  case 193: /* subscript: subscript bracketed_exp_list  */
#line 2146 "awkgram.y"
          {
		yyval = list_merge(yyvsp[-1], yyvsp[0]);
	  }
#line 4423 "awkgram.c"
    break;

  case 194: /* subscript_list: subscript SUBSCRIPT  */
#line 2153 "awkgram.y"
          { yyval = yyvsp[-1]; }
#line 4429 "awkgram.c"
    break;

  case 195: /* simple_variable: NAME  */
#line 2158 "awkgram.y"
          {
		yyvsp[0]->opcode = Op_push;
		yyvsp[0]->memory = variable(yyvsp[0]->source_line, yyvsp[0]->lextok, Node_var_new);
		yyval = list_create(yyvsp[0]);
	  }
#line 4439 "awkgram.c"
    break;

  case 196: /* simple_variable: NAME subscript_list  */
#line 2164 "awkgram.y"
          {
		char *arr = yyvsp[-1]->lextok;

		// Don't use Node_var_array here; breaks rwarray:readall extension.
		yyvsp[-1]->memory = variable(yyvsp[-1]->source_line, arr, Node_var_new);
		yyvsp[-1]->opcode = Op_push_array;
		yyval = list_prepend(yyvsp[0], yyvsp[-1]);
	  }
#line 4452 "awkgram.c"
    break;

  case 197: /* variable: simple_variable  */
#line 2176 "awkgram.y"
          {
		INSTRUCTION *ip = yyvsp[0]->nexti;
		if (ip->opcode == Op_push
			&& ip->memory->type == Node_var
			&& ip->memory->var_update
		) {
			yyval = list_prepend(yyvsp[0], instruction(Op_var_update));
			yyval->nexti->update_var = ip->memory->var_update;
		} else
			yyval = yyvsp[0];
	  }
#line 4468 "awkgram.c"
    break;

  case 198: /* variable: '$' non_post_simp_exp opt_incdec  */
#line 2188 "awkgram.y"
          {
		yyval = list_append(yyvsp[-1], yyvsp[-2]);
		if (yyvsp[0] != NULL)
			mk_assignment(yyvsp[-1], NULL, yyvsp[0]);
	  }
#line 4478 "awkgram.c"
    break;

  case 199: /* opt_incdec: INCREMENT  */
#line 2197 "awkgram.y"
          {
		yyvsp[0]->opcode = Op_postincrement;
	  }
#line 4486 "awkgram.c"
    break;

  case 200: /* opt_incdec: DECREMENT  */
#line 2201 "awkgram.y"
          {
		yyvsp[0]->opcode = Op_postdecrement;
	  }
#line 4494 "awkgram.c"
    break;

  case 201: /* opt_incdec: %empty  */
#line 2205 "awkgram.y"
          { yyval = NULL; }
#line 4500 "awkgram.c"
    break;

  case 202: /* l_brace: '{' opt_nls  */
#line 2209 "awkgram.y"
                      { yyval = yyvsp[0]; }
#line 4506 "awkgram.c"
    break;

  case 203: /* r_brace: '}' opt_nls  */
#line 2213 "awkgram.y"
                        { yyval = yyvsp[0]; yyerrok; }
#line 4512 "awkgram.c"
    break;

  case 204: /* r_paren: ')'  */
#line 2217 "awkgram.y"
              { yyerrok; }
#line 4518 "awkgram.c"
    break;

  case 205: /* opt_semi: %empty  */
#line 2222 "awkgram.y"
          { yyval = NULL; }
#line 4524 "awkgram.c"
    break;

  case 207: /* semi: ';'  */
#line 2227 "awkgram.y"
                { yyerrok; }
#line 4530 "awkgram.c"
    break;

  case 208: /* colon: ':'  */
#line 2231 "awkgram.y"
                { yyval = yyvsp[0]; yyerrok; }
#line 4536 "awkgram.c"
    break;

  case 209: /* comma: ',' opt_nls  */
#line 2235 "awkgram.y"
                        { yyval = yyvsp[0]; yyerrok; }
#line 4542 "awkgram.c"
    break;


#line 4546 "awkgram.c"

      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */
  {
    const int yylhs = yyr1[yyn] - YYNTOKENS;
    const int yyi = yypgoto[yylhs] + *yyssp;
    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
               ? yytable[yyi]
               : yydefgoto[yylhs]);
  }

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
      yyerror (YY_("syntax error"));
    }

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ("Error: discarding",
                      yytoken, &yylval);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:
  /* Pacify compilers when the user code never invokes YYERROR and the
     label yyerrorlab therefore never appears in user code.  */
  if (0)
    YYERROR;
  ++yynerrs;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  /* Pop stack until we find a state that shifts the error token.  */
  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYSYMBOL_YYerror;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct ("Error: popping",
                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturnlab;


/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturnlab;


/*-----------------------------------------------------------.
| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
`-----------------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_("memory exhausted"));
  yyresult = 2;
  goto yyreturnlab;


/*----------------------------------------------------------.
| yyreturnlab -- parsing is finished, clean up and return.  |
`----------------------------------------------------------*/
yyreturnlab:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif

  return yyresult;
}

#line 2237 "awkgram.y"


struct token {
	const char *operator;	/* text to match */
	OPCODE value;			/*  type */
	int class;				/* lexical class */
	unsigned flags;			/* # of args. allowed and compatability */
#	define	ARGS	0xFF	/* 0, 1, 2, 3 args allowed (any combination */
#	define	A(n)	(1<<(n))
#	define	VERSION_MASK	0xFF00	/* old awk is zero */
#	define	NOT_OLD		0x0100	/* feature not in old awk */
#	define	NOT_POSIX	0x0200	/* feature not in POSIX */
#	define	GAWKX		0x0400	/* gawk extension */
#	define	BREAK		0x0800	/* break allowed inside */
#	define	CONTINUE	0x1000	/* continue allowed inside */
#	define	DEBUG_USE	0x2000	/* for use by developers */

	NODE *(*ptr)(int);	/* function that implements this keyword */
	NODE *(*ptr2)(int);	/* alternate arbitrary-precision function */
};

#ifdef USE_EBCDIC
/* tokcompare --- lexicographically compare token names for sorting */

static int
tokcompare(const void *l, const void *r)
{
	struct token *lhs, *rhs;

	lhs = (struct token *) l;
	rhs = (struct token *) r;

	return strcmp(lhs->operator, rhs->operator);
}
#endif

/*
 * Tokentab is sorted ASCII ascending order, so it can be binary searched.
 * See check_special(), which sorts the table on EBCDIC systems.
 * Function pointers come from declarations in awk.h.
 */

#ifdef HAVE_MPFR
#define MPF(F) do_mpfr_##F
#else
#define MPF(F) 0
#endif

static const struct token tokentab[] = {
{"BEGIN",	Op_rule,	 LEX_BEGIN,	0,		0,	0},
{"BEGINFILE",	Op_rule,	 LEX_BEGINFILE,	GAWKX,		0,	0},
{"END",		Op_rule,	 LEX_END,	0,		0,	0},
{"ENDFILE",	Op_rule,	 LEX_ENDFILE,	GAWKX,		0,	0},
#ifdef ARRAYDEBUG
{"adump",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(1)|A(2)|DEBUG_USE,	do_adump,	0},
#endif
{"and",		Op_builtin,    LEX_BUILTIN,	GAWKX,		do_and,	MPF(and)},
{"asort",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2)|A(3),	do_asort,	0},
{"asorti",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2)|A(3),	do_asorti,	0},
{"atan2",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(2),	do_atan2,	MPF(atan2)},
{"bindtextdomain",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2),	do_bindtextdomain,	0},
{"break",	Op_K_break,	 LEX_BREAK,	0,		0,	0},
{"case",	Op_K_case,	 LEX_CASE,	GAWKX,		0,	0},
{"close",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(1)|A(2),	do_close,	0},
{"compl",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(1),	do_compl,	MPF(compl)},
{"continue",	Op_K_continue, LEX_CONTINUE,	0,		0,	0},
{"cos",		Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(1),	do_cos,	MPF(cos)},
{"dcgettext",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2)|A(3),	do_dcgettext,	0},
{"dcngettext",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2)|A(3)|A(4)|A(5),	do_dcngettext,	0},
{"default",	Op_K_default,	 LEX_DEFAULT,	GAWKX,		0,	0},
{"delete",	Op_K_delete,	 LEX_DELETE,	NOT_OLD,	0,	0},
{"do",		Op_K_do,	 LEX_DO,	NOT_OLD|BREAK|CONTINUE,	0,	0},
{"else",	Op_K_else,	 LEX_ELSE,	0,		0,	0},
{"eval",	Op_symbol,	 LEX_EVAL,	0,		0,	0},
{"exit",	Op_K_exit,	 LEX_EXIT,	0,		0,	0},
{"exp",		Op_builtin,	 LEX_BUILTIN,	A(1),		do_exp,	MPF(exp)},
{"fflush",	Op_builtin,	 LEX_BUILTIN,	A(0)|A(1), do_fflush,	0},
{"for",		Op_K_for,	 LEX_FOR,	BREAK|CONTINUE,	0,	0},
{"func",	Op_func, 	LEX_FUNCTION,	NOT_POSIX|NOT_OLD,	0,	0},
{"function",	Op_func, 	LEX_FUNCTION,	NOT_OLD,	0,	0},
{"gensub",	Op_sub_builtin,	 LEX_BUILTIN,	GAWKX|A(3)|A(4), 0,	0},
{"getline",	Op_K_getline_redir,	 LEX_GETLINE,	NOT_OLD,	0,	0},
{"gsub",	Op_sub_builtin,	 LEX_BUILTIN,	NOT_OLD|A(2)|A(3), 0,	0},
{"if",		Op_K_if,	 LEX_IF,	0,		0,	0},
{"in",		Op_symbol,	 LEX_IN,	0,		0,	0},
{"include",	Op_symbol,	 LEX_INCLUDE,	GAWKX,	0,	0},
{"index",	Op_builtin,	 LEX_BUILTIN,	A(2),		do_index,	0},
{"int",		Op_builtin,	 LEX_BUILTIN,	A(1),		do_int,	MPF(int)},
#ifdef SUPPLY_INTDIV
{"intdiv0",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(3),	do_intdiv,	MPF(intdiv)},
#endif
{"isarray",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1),	do_isarray,	0},
{"length",	Op_builtin,	 LEX_LENGTH,	A(0)|A(1),	do_length,	0},
{"load",  	Op_symbol,	 LEX_LOAD,	GAWKX,		0,	0},
{"log",		Op_builtin,	 LEX_BUILTIN,	A(1),		do_log,	MPF(log)},
{"lshift",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(2),	do_lshift,	MPF(lshift)},
{"match",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(2)|A(3), do_match,	0},
{"mkbool",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(1),	do_mkbool,	0},
{"mktime",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2), do_mktime, 0},
{"namespace",  	Op_symbol,	 LEX_NAMESPACE,	GAWKX,		0,	0},
{"next",	Op_K_next,	 LEX_NEXT,	0,		0,	0},
{"nextfile",	Op_K_nextfile, LEX_NEXTFILE,	0,		0,	0},
{"or",		Op_builtin,    LEX_BUILTIN,	GAWKX,		do_or,	MPF(or)},
{"patsplit",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(2)|A(3)|A(4), do_patsplit,	0},
{"print",	Op_K_print,	 LEX_PRINT,	0,		0,	0},
{"printf",	Op_K_printf,	 LEX_PRINTF,	0,		0,	0},
{"rand",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(0),	do_rand,	MPF(rand)},
{"return",	Op_K_return,	 LEX_RETURN,	NOT_OLD,	0,	0},
{"rshift",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(2),	do_rshift,	MPF(rshift)},
{"sin",		Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(1),	do_sin,	MPF(sin)},
{"split",	Op_builtin,	 LEX_BUILTIN,	A(2)|A(3)|A(4),	do_split,	0},
{"sprintf",	Op_builtin,	 LEX_BUILTIN,	0,		do_sprintf,	0},
{"sqrt",	Op_builtin,	 LEX_BUILTIN,	A(1),		do_sqrt,	MPF(sqrt)},
{"srand",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(0)|A(1), do_srand,	MPF(srand)},
#if defined(GAWKDEBUG) || defined(ARRAYDEBUG) /* || ... */
{"stopme",	Op_builtin,	LEX_BUILTIN,	GAWKX|A(0)|DEBUG_USE,	stopme,		0},
#endif
{"strftime",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(0)|A(1)|A(2)|A(3), do_strftime,	0},
{"strtonum",	Op_builtin,    LEX_BUILTIN,	GAWKX|A(1),	do_strtonum, MPF(strtonum)},
{"sub",		Op_sub_builtin,	 LEX_BUILTIN,	NOT_OLD|A(2)|A(3), 0,	0},
{"substr",	Op_builtin,	 LEX_BUILTIN,	A(2)|A(3),	do_substr,	0},
{"switch",	Op_K_switch,	 LEX_SWITCH,	GAWKX|BREAK,	0,	0},
{"system",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(1),	do_system,	0},
{"systime",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(0),	do_systime,	0},
{"tolower",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(1),	do_tolower,	0},
{"toupper",	Op_builtin,	 LEX_BUILTIN,	NOT_OLD|A(1),	do_toupper,	0},
{"typeof",	Op_builtin,	 LEX_BUILTIN,	GAWKX|A(1)|A(2), do_typeof,	0},
{"while",	Op_K_while,	 LEX_WHILE,	BREAK|CONTINUE,	0,	0},
{"xor",		Op_builtin,    LEX_BUILTIN,	GAWKX,		do_xor,	MPF(xor)},
};

/* Variable containing the current shift state.  */
static mbstate_t cur_mbstate;
/* Ring buffer containing current characters.  */
#define MAX_CHAR_IN_RING_BUFFER 8
#define RING_BUFFER_SIZE (MAX_CHAR_IN_RING_BUFFER * MB_LEN_MAX)
static char cur_char_ring[RING_BUFFER_SIZE];
/* Index for ring buffers.  */
static int cur_ring_idx;
/* This macro means that last nextc() return a singlebyte character
   or 1st byte of a multibyte character.  */
#define nextc_is_1stbyte (cur_char_ring[cur_ring_idx] == 1)

/* getfname --- return name of a builtin function (for pretty printing) */

const char *
getfname(NODE *(*fptr)(int), bool prepend_awk)
{
	int i, j;
	static char buf[100];

	j = sizeof(tokentab) / sizeof(tokentab[0]);
	/* linear search, no other way to do it */
	for (i = 0; i < j; i++) {
		if (tokentab[i].ptr == fptr || tokentab[i].ptr2 == fptr) {
			if (prepend_awk && (tokentab[i].flags & GAWKX) != 0) {
				sprintf(buf, "awk::%s", tokentab[i].operator);
				return buf;
			}
			return tokentab[i].operator;
		}
	}

	return NULL;
}

/* negate_num --- negate a number in NODE */

void
negate_num(NODE *n)
{
#ifdef HAVE_MPFR
	int tval = 0;
#endif

	add_sign_to_num(n, '-');

	if (! is_mpg_number(n)) {
		n->numbr = -n->numbr;
		return;
	}

#ifdef HAVE_MPFR
	if (is_mpg_integer(n)) {
		if (! is_zero(n)) {
			mpz_neg(n->mpg_i, n->mpg_i);
			return;
		}

		/*
		 * 0 --> -0 conversion. Requires turning the MPG integer
		 * into an MPFR float.
		 */

		mpz_clear(n->mpg_i);	/* release the integer storage */

		/* Convert and fall through. */
		tval = mpfr_set_d(n->mpg_numbr, 0.0, ROUND_MODE);
		IEEE_FMT(n->mpg_numbr, tval);
		n->flags &= ~MPZN;
		n->flags |= MPFN;
	}

	/* mpfr float case */
	tval = mpfr_neg(n->mpg_numbr, n->mpg_numbr, ROUND_MODE);
	IEEE_FMT(n->mpg_numbr, tval);
#endif
}

/* add_sign_to_num --- make a constant unary plus or minus for profiling */

static void
add_sign_to_num(NODE *n, char sign)
{
	if ((n->flags & NUMCONSTSTR) != 0) {
		char *s;

		s = n->stptr;
		memmove(& s[1], & s[0], n->stlen + 1);
		s[0] = sign;
		n->stlen++;
	}
}

/* print_included_from --- print `Included from ..' file names and locations */

static void
print_included_from()
{
	int saveline, line;
	SRCFILE *s;

	/* suppress current file name, line # from `.. included from ..' msgs */
	saveline = sourceline;
	sourceline = 0;

	for (s = sourcefile; s != NULL && s->stype == SRC_INC; ) {
		s = s->next;
		if (s == NULL || s->fd <= INVALID_HANDLE)
			continue;
		line = s->srclines;

		/* if last token is NEWLINE, line number is off by 1. */
		if (s->lasttok == NEWLINE)
			line--;
		msg("%s %s:%d%c",
			s->prev == sourcefile ? "In file included from"
					  : "                 from",
			(s->stype == SRC_INC ||
				 s->stype == SRC_FILE) ? s->src : "cmd. line",
			line,
			s->stype == SRC_INC ? ',' : ':'
		);
	}
	sourceline = saveline;
}

/* warning_ln --- print a warning message with location */

static void
warning_ln(int line, const char *mesg, ...)
{
	va_list args;
	int saveline;

	saveline = sourceline;
	sourceline = line;
	print_included_from();
	va_start(args, mesg);
	err(false, _("warning: "), mesg, args);
	va_end(args);
	sourceline = saveline;
}

/* lintwarn_ln --- print a lint warning and location */

static void
lintwarn_ln(int line, const char *mesg, ...)
{
	va_list args;
	int saveline;

	saveline = sourceline;
	sourceline = line;
	print_included_from();
	va_start(args, mesg);
	if (lintfunc == r_fatal)
		err(true, _("fatal: "), mesg, args);
	else
		err(false, _("warning: "), mesg, args);
	va_end(args);
	sourceline = saveline;
	if (lintfunc == r_fatal)
		gawk_exit(EXIT_FATAL);
}

/* error_ln --- print an error message and location */

static void
error_ln(int line, const char *m, ...)
{
	va_list args;
	int saveline;

	saveline = sourceline;
	sourceline = line;
	print_included_from();
	errcount++;
	va_start(args, m);
	err(false, "error: ", m, args);
	va_end(args);
	sourceline = saveline;
}

/* yyerror --- print a syntax error message, show where */

static void
yyerror(const char *m, ...)
{
	va_list args;
	const char *mesg = NULL;
	char *bp, *cp;
	char *scan;
	char *buf;
	int count;
	static char end_of_file_line[] = "(END OF FILE)";
	static char syntax_error[] = "syntax error";
	static size_t syn_err_len = sizeof(syntax_error) - 1;
	bool generic_error = (strncmp(m, syntax_error, syn_err_len) == 0);

	print_included_from();

	errcount++;
	/* Find the current line in the input file */
	if (lexptr && lexeme) {
		if (thisline == NULL) {
			cp = lexeme;
			if (*cp == '\n') {
				if (cp > lexptr_begin)
					cp--;
				mesg = _("unexpected newline or end of string");
			}
			for (; cp != lexptr_begin && *cp != '\n'; --cp)
				continue;
			if (*cp == '\n')
				cp++;
			thisline = cp;
		}
		/* NL isn't guaranteed */
		bp = lexeme;
		if (bp < thisline)
			bp = thisline + 1;
		while (bp < lexend && *bp && *bp != '\n')
			bp++;
	} else {
		thisline = end_of_file_line;
		bp = thisline + strlen(thisline);
	}

	if (lexeof && mesg == NULL && generic_error) {
		msg("%s", end_of_file_line);
		mesg = _("source files / command-line arguments must contain complete functions or rules");
	} else
		msg("%.*s", (int) (bp - thisline), thisline);

	va_start(args, m);
	if (mesg == NULL)
		mesg = m;

	count = strlen(mesg) + 1;
	if (lexptr != NULL)
		count += (lexeme - thisline) + 2;
	ezalloc(buf, char *, count+1);

	bp = buf;

	if (lexptr != NULL) {
		scan = thisline;
		while (scan < lexeme)
			if (*scan++ == '\t')
				*bp++ = '\t';
			else
				*bp++ = ' ';
		*bp++ = '^';
		*bp++ = ' ';
	}
	strcpy(bp, mesg);
	err(false, "", buf, args);
	va_end(args);
	efree(buf);
	/* we don't use fatal(), that changes the exit status to 2 */
	exit(EXIT_FAILURE);
}

/* mk_program --- create a single list of instructions */

static INSTRUCTION *
mk_program()
{
	INSTRUCTION *cp, *tmp;

#define begin_block         rule_block[BEGIN]
#define end_block           rule_block[END]
#define prog_block          rule_block[Rule]
#define beginfile_block     rule_block[BEGINFILE]
#define endfile_block       rule_block[ENDFILE]

	if (end_block == NULL)
		end_block = list_create(ip_end);
	else
		(void) list_prepend(end_block, ip_end);

	if (! in_main_context()) {
		if (begin_block != NULL && prog_block != NULL)
			cp = list_merge(begin_block, prog_block);
		else
			cp = (begin_block != NULL) ? begin_block : prog_block;

		if (cp != NULL)
			(void) list_merge(cp, end_block);
		else
			cp = end_block;

		(void) list_append(cp, instruction(Op_stop));
		goto out;
	}

	if (endfile_block == NULL)
		endfile_block = list_create(ip_endfile);
	else {
		ip_rec->has_endfile = true;
		(void) list_prepend(endfile_block, ip_endfile);
	}

	if (beginfile_block == NULL)
		beginfile_block = list_create(ip_beginfile);
	else
		(void) list_prepend(beginfile_block, ip_beginfile);

	if (prog_block == NULL) {
		if (end_block->nexti == end_block->lasti
				&& beginfile_block->nexti == beginfile_block->lasti
				&& endfile_block->nexti == endfile_block->lasti
		) {
			/* no pattern-action and (real) end, beginfile or endfile blocks */
			bcfree(ip_rec);
			bcfree(ip_newfile);
			ip_rec = ip_newfile = NULL;

			list_append(beginfile_block, instruction(Op_after_beginfile));
			(void) list_append(endfile_block, instruction(Op_after_endfile));

			if (begin_block == NULL)     /* no program at all */
				cp = end_block;
			else
				cp = list_merge(begin_block, end_block);

			if (interblock_comment != NULL) {
				(void) list_append(cp, interblock_comment);
				interblock_comment = NULL;
			}

			(void) list_append(cp, ip_atexit);
			(void) list_append(cp, instruction(Op_stop));

			/* append beginfile_block and endfile_block for sole use
			 * in getline without redirection (Op_K_getline).
			 */

			(void) list_merge(cp, beginfile_block);
			(void) list_merge(cp, endfile_block);

			if (outer_comment != NULL) {
				cp = list_merge(list_create(outer_comment), cp);
				outer_comment = NULL;
			}

			if (interblock_comment != NULL) {
				(void) list_append(cp, interblock_comment);
				interblock_comment = NULL;
			}

			goto out;

		} else {
			/* install a do-nothing prog block */
			prog_block = list_create(instruction(Op_no_op));
		}
	}

	(void) list_append(endfile_block, instruction(Op_after_endfile));
	(void) list_prepend(prog_block, ip_rec);
	(void) list_append(prog_block, instruction(Op_jmp));
	prog_block->lasti->target_jmp = ip_rec;

	list_append(beginfile_block, instruction(Op_after_beginfile));

	cp = list_merge(beginfile_block, prog_block);
	(void) list_prepend(cp, ip_newfile);
	(void) list_merge(cp, endfile_block);
	(void) list_merge(cp, end_block);
	if (begin_block != NULL)
		cp = list_merge(begin_block, cp);

	if (outer_comment != NULL) {
		cp = list_merge(list_create(outer_comment), cp);
		outer_comment = NULL;
	}

	if (interblock_comment != NULL) {
		(void) list_append(cp, interblock_comment);
		interblock_comment = NULL;
	}

	(void) list_append(cp, ip_atexit);
	(void) list_append(cp, instruction(Op_stop));

out:
	/* delete the Op_list, not needed */
	tmp = cp->nexti;
	bcfree(cp);
	return tmp;

#undef begin_block
#undef end_block
#undef prog_block
#undef beginfile_block
#undef endfile_block
}

/* parse_program --- read in the program and convert into a list of instructions */

int
parse_program(INSTRUCTION **pcode, bool from_eval)
{
	int ret;

	called_from_eval = from_eval;

	/* pre-create non-local jump targets
	 * ip_end (Op_no_op) -- used as jump target for `exit'
	 * outside an END block.
	 */
	ip_end = instruction(Op_no_op);

	if (! in_main_context())
		ip_newfile = ip_rec = ip_atexit = ip_beginfile = ip_endfile = NULL;
	else {
		ip_endfile = instruction(Op_no_op);
		main_beginfile = ip_beginfile = instruction(Op_no_op);
		ip_rec = instruction(Op_get_record); /* target for `next', also ip_newfile */
		ip_newfile = bcalloc(Op_newfile, 2, 0); /* target for `nextfile' */
		ip_newfile->target_jmp = ip_end;
		ip_newfile->target_endfile = ip_endfile;
		(ip_newfile + 1)->target_get_record = ip_rec;
		ip_rec->target_newfile = ip_newfile;
		ip_atexit = instruction(Op_atexit);	/* target for `exit' in END block */
	}

	for (sourcefile = srcfiles->next; sourcefile->stype == SRC_EXTLIB;
			sourcefile = sourcefile->next)
		;

	lexeof = false;
	lexptr = NULL;
	lasttok = 0;
	memset(rule_block, 0, sizeof(rule_block));
	errcount = 0;
	tok = tokstart != NULL ? tokstart : tokexpand();

	ret = yyparse();
	*pcode = mk_program();

	/* avoid false source indications */
	source = NULL;
	sourceline = 0;
	if (ret == 0)	/* avoid spurious warning if parser aborted with YYABORT */
		check_funcs();

	if (do_posix && ! check_param_names())
		errcount++;

	if (args_array == NULL)
		emalloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *));
	else
		erealloc(args_array, NODE **, (max_args + 2) * sizeof(NODE *));

	return (ret || errcount);
}

/* free_srcfile --- free a SRCFILE struct */

void
free_srcfile(SRCFILE *thisfile)
{
	efree(thisfile->src);
	efree(thisfile);
}

/* do_add_srcfile --- add one item to srcfiles */

static SRCFILE *
do_add_srcfile(enum srctype stype, char *src, char *path, SRCFILE *thisfile)
{
	SRCFILE *s;

	ezalloc(s, SRCFILE *, sizeof(SRCFILE));
	s->src = estrdup(src, strlen(src));
	s->fullpath = path;
	s->stype = stype;
	s->fd = INVALID_HANDLE;
	s->next = thisfile;
	s->prev = thisfile->prev;
	thisfile->prev->next = s;
	thisfile->prev = s;
	return s;
}

/* add_srcfile --- add one item to srcfiles after checking if
 *				a source file exists and not already in list.
 */

SRCFILE *
add_srcfile(enum srctype stype, char *src, SRCFILE *thisfile, bool *already_included, int *errcode)
{
	SRCFILE *s;
	struct stat sbuf;
	char *path;
	int errno_val = 0;

	if (already_included)
		*already_included = false;
	if (errcode)
		*errcode = 0;
	if (stype == SRC_CMDLINE || stype == SRC_STDIN)
		return do_add_srcfile(stype, src, NULL, thisfile);

	path = find_source(src, & sbuf, & errno_val, stype == SRC_EXTLIB);
	if (path == NULL) {
		if (errcode) {
			*errcode = errno_val;
			return NULL;
		}
		/* use full messages to ease translation */
		fatal(stype != SRC_EXTLIB
			? _("cannot open source file `%s' for reading: %s")
			: _("cannot open shared library `%s' for reading: %s"),
				src,
				errno_val ? strerror(errno_val) : _("reason unknown"));
	}

	/* N.B. We do not eliminate duplicate SRC_FILE (-f) programs. */
	for (s = srcfiles->next; s != srcfiles; s = s->next) {
		if ((s->stype == SRC_FILE || s->stype == SRC_INC || s->stype == SRC_EXTLIB) && files_are_same(path, s)) {
			if (stype == SRC_INC || stype == SRC_EXTLIB) {
				/* eliminate duplicates */
				if ((stype == SRC_INC) && (s->stype == SRC_FILE))
					fatal(_("cannot include `%s' and use it as a program file"), src);

				if (do_lint) {
					int line = sourceline;
					/* Kludge: the line number may be off for `@include file'.
					 * Since, this function is also used for '-f file' in main.c,
					 * sourceline > 1 check ensures that the call is at
					 * parse time.
					 */
					if (sourceline > 1 && lasttok == NEWLINE)
						line--;
					lintwarn_ln(line,
						    stype != SRC_EXTLIB
						      ? _("already included source file `%s'")
						      : _("already loaded shared library `%s'"),
						    src);
				}
				efree(path);
				if (already_included)
					*already_included = true;
				return NULL;
			} else {
				/* duplicates are allowed for -f */
				if (s->stype == SRC_INC)
					fatal(_("cannot include `%s' and use it as a program file"), src);
				/* no need to scan for further matches, since
				 * they must be of homogeneous type */
				break;
			}
		}
	}

	s = do_add_srcfile(stype, src, path, thisfile);
	s->sbuf = sbuf;
	s->mtime = sbuf.st_mtime;
	return s;
}

/* include_source --- read program from source included using `@include' */

static bool
include_source(INSTRUCTION *file, void **srcfile_p)
{
	SRCFILE *s;
	char *src = file->lextok;
	int errcode;
	bool already_included;

	*srcfile_p = NULL;

	if (do_traditional || do_posix) {
		error_ln(file->source_line, _("@include is a gawk extension"));
		return false;
	}

	if (strlen(src) == 0) {
		if (do_lint)
			lintwarn_ln(file->source_line, _("empty filename after @include"));
		return true;
	}

	s = add_srcfile(SRC_INC, src, sourcefile, &already_included, &errcode);
	if (s == NULL) {
		if (already_included)
			return true;
		error_ln(file->source_line,
			_("cannot open source file `%s' for reading: %s"),
			src, errcode ? strerror(errcode) : _("reason unknown"));
		return false;
	}

	/* save scanner state for the current sourcefile */
	sourcefile->srclines = sourceline;
	sourcefile->lexptr = lexptr;
	sourcefile->lexend = lexend;
	sourcefile->lexptr_begin = lexptr_begin;
	sourcefile->lexeme = lexeme;
	sourcefile->lasttok = lasttok;
	sourcefile->namespace = current_namespace;

	/* included file becomes the current source */
	sourcefile = s;
	lexptr = NULL;
	sourceline = 0;
	source = NULL;
	lasttok = 0;
	lexeof = false;
	eof_warned = false;
	current_namespace = awk_namespace;
	*srcfile_p = (void *) s;
	return true;
}

/* load_library --- load a shared library */

static bool
load_library(INSTRUCTION *file, void **srcfile_p)
{
	SRCFILE *s;
	char *src = file->lextok;
	int errcode;
	bool already_included;

	*srcfile_p = NULL;

	if (do_traditional || do_posix) {
		error_ln(file->source_line, _("@load is a gawk extension"));
		return false;
	}


	if (strlen(src) == 0) {
		if (do_lint)
			lintwarn_ln(file->source_line, _("empty filename after @load"));
		return true;
	}

	if (do_pretty_print && ! do_profile) {
		// create a fake one, don't try to open the file
		s = do_add_srcfile(SRC_EXTLIB, src, src, sourcefile);
	} else {
		s = add_srcfile(SRC_EXTLIB, src, sourcefile, &already_included, &errcode);
		if (s == NULL) {
			if (already_included)
				return true;
			error_ln(file->source_line,
				_("cannot open shared library `%s' for reading: %s"),
				src, errcode ? strerror(errcode) : _("reason unknown"));
			return false;
		}

		load_ext(s->fullpath);
	}

	*srcfile_p = (void *) s;
	return true;
}

/* next_sourcefile --- read program from the next source in srcfiles */

static void
next_sourcefile()
{
	static int (*closefunc)(int fd) = NULL;

	if (closefunc == NULL) {
		char *cp = getenv("AWKREADFUNC");

		/* If necessary, one day, test value for different functions.  */
		if (cp == NULL)
			closefunc = close;
		else
			closefunc = one_line_close;
	}

	/*
	 * This won't be true if there's an invalid character in
	 * the source file or source string (e.g., user typo).
	 * Previous versions of gawk did not core dump in such a
	 * case.
	 *
	 * assert(lexeof == true);
	 */

	lexeof = false;
	eof_warned = false;
	sourcefile->srclines = sourceline;	/* total no of lines in current file */
	if (sourcefile->fd > INVALID_HANDLE) {
		if (sourcefile->fd != fileno(stdin))  /* safety */
			(*closefunc)(sourcefile->fd);
		sourcefile->fd = INVALID_HANDLE;
	}
	if (sourcefile->buf != NULL) {
		efree(sourcefile->buf);
		sourcefile->buf = NULL;
		sourcefile->lexptr_begin = NULL;
	}

	while ((sourcefile = sourcefile->next) != NULL) {
		if (sourcefile == srcfiles)
			return;
		if (sourcefile->stype != SRC_EXTLIB)
			break;
	}

	if (sourcefile->lexptr_begin != NULL) {
		/* resume reading from already opened file (postponed to process '@include') */
		lexptr = sourcefile->lexptr;
		lexend = sourcefile->lexend;
		lasttok = sourcefile->lasttok;
		lexptr_begin = sourcefile->lexptr_begin;
		lexeme = sourcefile->lexeme;
		sourceline = sourcefile->srclines;
		source = sourcefile->src;
		set_current_namespace(sourcefile->namespace);
	} else {
		lexptr = NULL;
		sourceline = 0;
		source = NULL;
		lasttok = 0;
		set_current_namespace(awk_namespace);
	}
}

/* get_src_buf --- read the next buffer of source program */

static char *
get_src_buf()
{
	int n;
	char *scan;
	bool newfile;
	int savelen;
	struct stat sbuf;

	static ssize_t (*readfunc)(int, void *, size_t) = NULL;

	if (readfunc == NULL) {
		char *cp = getenv("AWKREADFUNC");

		/* If necessary, one day, test value for different functions.  */
		if (cp == NULL)
			/*
			 * cast is to remove warnings on systems with
			 * different return types for read.
			 */
			readfunc = ( ssize_t(*)(int, void *, size_t) ) read;
		else
			readfunc = read_one_line;
	}

	newfile = false;
	if (sourcefile == srcfiles)
		return NULL;

	if (sourcefile->stype == SRC_CMDLINE) {
		if (sourcefile->bufsize == 0) {
			sourcefile->bufsize = strlen(sourcefile->src);
			lexptr = lexptr_begin = lexeme = sourcefile->src;
			lexend = lexptr + sourcefile->bufsize;
			sourceline = 1;
			if (sourcefile->bufsize == 0) {
				/*
				 * Yet Another Special case:
				 *	gawk '' /path/name
				 * Sigh.
				 */
				static bool warned = false;

				if (do_lint && ! warned) {
					warned = true;
					lintwarn(_("empty program text on command line"));
				}
				lexeof = true;
			}
		} else if (sourcefile->buf == NULL  && *(lexptr-1) != '\n') {
			/*
			 * The following goop is to ensure that the source
			 * ends with a newline and that the entire current
			 * line is available for error messages.
			 */
			int offset;
			char *buf;

			offset = lexptr - lexeme;
			for (scan = lexeme; scan > lexptr_begin; scan--)
				if (*scan == '\n') {
					scan++;
					break;
				}
			savelen = lexptr - scan;
			emalloc(buf, char *, savelen + 1);
			memcpy(buf, scan, savelen);
			thisline = buf;
			lexptr = buf + savelen;
			*lexptr = '\n';
			lexeme = lexptr - offset;
			lexptr_begin = buf;
			lexend = lexptr + 1;
			sourcefile->buf = buf;
		} else
			lexeof = true;
		return lexptr;
	}

	if (sourcefile->fd <= INVALID_HANDLE) {
		int fd;
		int l;

		source = sourcefile->src;
		if (source == NULL)
			return NULL;
		fd = srcopen(sourcefile);
		if (fd <= INVALID_HANDLE) {
			char *in;

			/* suppress file name and line no. in error mesg */
			in = source;
			source = NULL;
			error(_("cannot open source file `%s' for reading: %s"),
				in, strerror(errno));
			errcount++;
			lexeof = true;
			return sourcefile->src;
		}

		sourcefile->fd = fd;
		l = optimal_bufsize(fd, &sbuf);
		/*
		 * Make sure that something silly like
		 * 	AWKBUFSIZE=8 make check
		 * works ok.
		 */
#define A_DECENT_BUFFER_SIZE	128
		if (l < A_DECENT_BUFFER_SIZE)
			l = A_DECENT_BUFFER_SIZE;
#undef A_DECENT_BUFFER_SIZE
		sourcefile->bufsize = l;
		newfile = true;
		emalloc(sourcefile->buf, char *, sourcefile->bufsize);
		memset(sourcefile->buf, '\0', sourcefile->bufsize);	// keep valgrind happy
		lexptr = lexptr_begin = lexeme = sourcefile->buf;
		savelen = 0;
		sourceline = 1;
		thisline = NULL;
	} else {
		/*
		 * Here, we retain the current source line in the beginning of the buffer.
		 */
		int offset;
		for (scan = lexeme; scan > lexptr_begin; scan--)
			if (*scan == '\n') {
				scan++;
				break;
			}

		savelen = lexptr - scan;
		offset = lexptr - lexeme;

		if (savelen > 0) {
			/*
			 * Need to make sure we have room left for reading new text;
			 * grow the buffer (by doubling, an arbitrary choice), if the retained line
			 * takes up more than a certain percentage (50%, again an arbitrary figure)
			 * of the available space.
			 */

			if (savelen > sourcefile->bufsize / 2) { /* long line or token  */
				sourcefile->bufsize *= 2;
				erealloc(sourcefile->buf, char *, sourcefile->bufsize);
				scan = sourcefile->buf + (scan - lexptr_begin);
				lexptr_begin = sourcefile->buf;
			}

			thisline = lexptr_begin;
			memmove(thisline, scan, savelen);
			lexptr = thisline + savelen;
			lexeme = lexptr - offset;
		} else {
			savelen = 0;
			lexptr = lexeme = lexptr_begin;
			thisline = NULL;
		}
	}

	n = (*readfunc)(sourcefile->fd, lexptr, sourcefile->bufsize - savelen);
	if (n == -1) {
		error(_("cannot read source file `%s': %s"),
				source, strerror(errno));
		errcount++;
		lexeof = true;
	} else {
		lexend = lexptr + n;
		if (n == 0) {
			static bool warned = false;
			if (do_lint && newfile && ! warned) {
				warned = true;
				sourceline = 0;
				lintwarn(_("source file `%s' is empty"), source);
			}
			lexeof = true;
		}
	}
	return sourcefile->buf;
}

/* tokadd --- add a character to the token buffer */

#define	tokadd(x) (*tok++ = (x), tok == tokend ? tokexpand() : tok)

/* tokexpand --- grow the token buffer */

static char *
tokexpand()
{
	static size_t toksize;
	int tokoffset;

	if (tokstart != NULL) {
		tokoffset = tok - tokstart;
		toksize *= 2;
		erealloc(tokstart, char *, toksize);
		tok = tokstart + tokoffset;
	} else {
		toksize = 60;
		emalloc(tokstart, char *, toksize);
		tok = tokstart;
	}
	tokend = tokstart + toksize;
	return tok;
}

/* check_bad_char --- fatal if c isn't allowed in gawk source code */

/*
 * The error message was inspired by someone who decided to put
 * a physical \0 byte into the source code to see what would
 * happen and then filed a bug report about it.  Sigh.
 */

static void
check_bad_char(int c)
{
	/* allow escapes. needed for autoconf. bleah. */
	switch (c) {
	case '\a':
	case '\b':
	case '\f':
	case '\n':
	case '\r':
	case '\t':
		return;
	default:
		break;
	}

	if (iscntrl(c) && ! isspace(c))
		// This is a PEBKAC error, but we'll be nice and not say so.
		fatal(_("error: invalid character '\\%03o' in source code"), c & 0xFF);
}

/* nextc --- get the next input character */

// For namespaces, -e chunks must be syntactic units.
#define NO_CONTINUE_SOURCE_STRINGS	1

static int
nextc(bool check_for_bad)
{
	if (gawk_mb_cur_max > 1) {
again:
#ifdef NO_CONTINUE_SOURCE_STRINGS
		if (lexeof)
			return END_FILE;
#else
		if (lexeof) {
			if (sourcefile->next == srcfiles)
				return END_FILE;
			else
				next_sourcefile();
		}
#endif
		if (lexptr == NULL || lexptr >= lexend) {
			if (get_src_buf())
				goto again;
			return END_SRC;
		}

		/* Update the buffer index.  */
		cur_ring_idx = (cur_ring_idx == RING_BUFFER_SIZE - 1)? 0 :
			cur_ring_idx + 1;

		/* Did we already check the current character?  */
		if (cur_char_ring[cur_ring_idx] == 0) {
			/* No, we need to check the next character on the buffer.  */
			int idx, work_ring_idx = cur_ring_idx;
			mbstate_t tmp_state;
			size_t mbclen;

			for (idx = 0; lexptr + idx < lexend; idx++) {
				tmp_state = cur_mbstate;
				mbclen = mbrlen(lexptr, idx + 1, &tmp_state);

				if (mbclen == 1 || mbclen == (size_t)-1 || mbclen == 0) {
					/* It is a singlebyte character, non-complete multibyte
					   character or EOF.  We treat it as a singlebyte
					   character.  */
					cur_char_ring[work_ring_idx] = 1;
					break;
				} else if (mbclen == (size_t)-2) {
					/* It is not a complete multibyte character.  */
					cur_char_ring[work_ring_idx] = idx + 1;
				} else {
					/* mbclen > 1 */
					cur_char_ring[work_ring_idx] = mbclen;
					break;
				}
				work_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?
					0 : work_ring_idx + 1;
			}
			cur_mbstate = tmp_state;

			/* Put a mark on the position on which we write next character.  */
			work_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?
				0 : work_ring_idx + 1;
			cur_char_ring[work_ring_idx] = 0;
		}
		if (check_for_bad || *lexptr == '\0')
			check_bad_char(*lexptr);

		return (int) (unsigned char) *lexptr++;
	} else {
		do {
#ifdef NO_CONTINUE_SOURCE_STRINGS
			if (lexeof)
				return END_FILE;
#else
			if (lexeof) {
				if (sourcefile->next == srcfiles)
					return END_FILE;
				else
					next_sourcefile();
			}
#endif
			if (lexptr && lexptr < lexend) {
				if (check_for_bad || *lexptr == '\0')
					check_bad_char(*lexptr);
				return ((int) (unsigned char) *lexptr++);
			}
		} while (get_src_buf());
		return END_SRC;
	}
}
#undef NO_CONTINUE_SOURCE_STRINGS

/* pushback --- push a character back on the input */

static inline void
pushback(void)
{
	if (gawk_mb_cur_max > 1)
		cur_ring_idx = (cur_ring_idx == 0)? RING_BUFFER_SIZE - 1 :
			cur_ring_idx - 1;
	(! lexeof && lexptr && lexptr > lexptr_begin ? lexptr-- : lexptr);
}

/*
 * get_comment --- collect comment text.
 * 	Flag = EOL_COMMENT for end-of-line comments.
 * 	Flag = BLOCK_COMMENT for self-contained comments.
 */

static int
get_comment(enum commenttype flag, INSTRUCTION **comment_instruction)
{
	int c;
	int sl;
	char *p1;
	char *p2;

	tok = tokstart;
	tokadd('#');
	sl = sourceline;

	while (true) {
		while ((c = nextc(false)) != '\n' && c != END_FILE) {
			/* ignore \r characters */
			if (c != '\r')
				tokadd(c);
		}
		if (flag == EOL_COMMENT) {
			/* comment at end of line.  */
			if (c == '\n')
				tokadd(c);
			break;
		}
		if (c == '\n') {
			tokadd(c);
			sourceline++;
			do {
				c = nextc(false);
				if (c == '\n') {
					sourceline++;
					tokadd(c);
				}
			} while (c != END_FILE && isspace(c));
			if (c == END_FILE)
				break;
			else if (c != '#') {
				pushback();
				sourceline--;
				break;
			} else
				tokadd(c);
		} else
			break;
	}

	/* remove any trailing blank lines (consecutive \n) from comment */
	p1 = tok - 1;
	p2 = tok - 2;
	while (*p1 == '\n' && *p2 == '\n') {
		p1--;
		p2--;
		tok--;
	}

	(*comment_instruction) = bcalloc(Op_comment, 1, sl);
	(*comment_instruction)->source_file = source;
	(*comment_instruction)->memory = make_str_node(tokstart, tok - tokstart, 0);
	(*comment_instruction)->memory->comment_type = flag;

	return c;
}

/* allow_newline --- allow newline after &&, ||, ? and : */

static void
allow_newline(INSTRUCTION **new_comment)
{
	int c;

	for (;;) {
		c = nextc(true);
		if (c == END_FILE) {
			pushback();
			break;
		}
		if (c == '#') {
			if (do_pretty_print && ! do_profile) {
				/* collect comment byte code iff doing pretty print but not profiling.  */
				c = get_comment(EOL_COMMENT, new_comment);
			} else {
				while ((c = nextc(false)) != '\n' && c != END_FILE)
					continue;
			}
			if (c == END_FILE) {
				pushback();
				break;
			}
		}
		if (c == '\n')
			sourceline++;
		if (! isspace(c)) {
			pushback();
			break;
		}
	}
}

/* newline_eof --- return newline or EOF as needed and adjust variables */

/*
 * This routine used to be a macro, however GCC 4.6.2 warned about
 * the result of a computation not being used.  Converting to a function
 * removes the warnings.
 */

static int
newline_eof()
{
	/* NB: a newline at end does not start a source line. */
	if (lasttok != NEWLINE) {
                pushback();
		if (do_lint && ! eof_warned) {
        		lintwarn(_("source file does not end in newline"));
			eof_warned = true;
		}
		sourceline++;
		return NEWLINE;
	}

	sourceline--;
	eof_warned = false;
	return LEX_EOF;
}

/* yylex --- Read the input and turn it into tokens. */

static int
#ifdef USE_EBCDIC
yylex_ebcdic(void)
#else
yylex(void)
#endif
{
	int c;
	bool seen_e = false;		/* These are for numbers */
	bool seen_point = false;
	bool esc_seen;		/* for literal strings */
	int mid;
	int base;
	static bool did_newline = false;
	char *tokkey;
	bool inhex = false;
	bool intlstr = false;
	AWKNUM d;
	bool collecting_typed_regexp = false;
	static int qm_col_count = 0;

#define GET_INSTRUCTION(op) bcalloc(op, 1, sourceline)

#define NEWLINE_EOF newline_eof()

	yylval = (INSTRUCTION *) NULL;
	if (lasttok == SUBSCRIPT) {
		lasttok = 0;
		return SUBSCRIPT;
	}

	if (lasttok == LEX_EOF)		/* error earlier in current source, must give up !! */
		return 0;

	c = nextc(! want_regexp);
	if (c == END_SRC)
		return 0;
	if (c == END_FILE)
		return lasttok = NEWLINE_EOF;
	pushback();

	lexeme = lexptr;
	thisline = NULL;

collect_regexp:
	if (want_regexp) {
		int in_brack = 0;	/* count brackets, [[:alnum:]] allowed */
		int b_index = -1;
		int cur_index = 0;

		/*
		 * Here is what's ok with brackets:
		 *
		 * [..[..] []] [^]] [.../...]
		 * [...\[...] [...\]...] [...\/...]
		 *
		 * (Remember that all of the above are inside /.../)
		 *
		 * The code for \ handles \[, \] and \/.
		 *
		 * Otherwise, track the first open [ position, and if
		 * an embedded ] occurs, allow it to pass through
		 * if it's right after the first [ or after [^.
		 *
		 * Whew!
		 */

		want_regexp = false;
		tok = tokstart;
		for (;;) {
			c = nextc(false);

			cur_index = tok - tokstart;
			if (gawk_mb_cur_max == 1 || nextc_is_1stbyte) switch (c) {
			case '[':
				if (nextc(false) == ':' || in_brack == 0) {
					in_brack++;
					if (in_brack == 1)
						b_index = tok - tokstart;
				}
				pushback();
				break;
			case ']':
				if (in_brack > 0
				    && (cur_index == b_index + 1
					|| (cur_index == b_index + 2 && tok[-1] == '^')))
					; /* do nothing */
				else {
					in_brack--;
					if (in_brack == 0)
						b_index = -1;
				}
				break;
			case '\\':
				if ((c = nextc(false)) == END_FILE) {
					pushback();
					yyerror(_("unterminated regexp ends with `\\' at end of file"));
					goto end_regexp; /* kludge */
				}
				if (c == '\r')	/* allow MS-DOS files. bleah */
					c = nextc(true);
				if (c == '\n') {
					sourceline++;
					continue;
				} else {
					tokadd('\\');
					tokadd(c);
					continue;
				}
				break;
			case '/':	/* end of the regexp */
				if (in_brack > 0)
					break;
end_regexp:
				yylval = GET_INSTRUCTION(Op_token);
				yylval->lextok = estrdup(tokstart, tok - tokstart);
				if (do_lint) {
					int peek = nextc(true);

					pushback();
					if (peek == 'i' || peek == 's') {
						if (source)
							lintwarn(
						_("%s: %d: tawk regex modifier `/.../%c' doesn't work in gawk"),
								source, sourceline, peek);
						else
							lintwarn(
						_("tawk regex modifier `/.../%c' doesn't work in gawk"),
								peek);
					}
				}
				if (collecting_typed_regexp) {
					collecting_typed_regexp = false;
					lasttok = TYPED_REGEXP;
				} else
					lasttok = REGEXP;

				return lasttok;
			case '\n':
				pushback();
				yyerror(_("unterminated regexp"));
				goto end_regexp;	/* kludge */
			case END_FILE:
				pushback();
				yyerror(_("unterminated regexp at end of file"));
				goto end_regexp;	/* kludge */
			}
			tokadd(c);
		}
	}
retry:

	/* skipping \r is a hack, but windows is just too pervasive. sigh. */
	while ((c = nextc(true)) == ' ' || c == '\t' || c == '\r')
		continue;

	lexeme = lexptr ? lexptr - 1 : lexptr;
	thisline = NULL;
	tok = tokstart;

	if (gawk_mb_cur_max == 1 || nextc_is_1stbyte)
	switch (c) {
	case END_SRC:
		return 0;

	case END_FILE:
		return lasttok = NEWLINE_EOF;

	case '\n':
		sourceline++;
		return lasttok = NEWLINE;

	case '#':		/* it's a comment */
		yylval = NULL;
		if (do_pretty_print && ! do_profile) {
			/*
			 * Collect comment byte code iff doing pretty print
			 * but not profiling.
			 */
			INSTRUCTION *new_comment;

			if (lasttok == NEWLINE || lasttok == 0)
				c = get_comment(BLOCK_COMMENT, & new_comment);
			else
				c = get_comment(EOL_COMMENT, & new_comment);

			yylval = new_comment;

			if (c == END_FILE) {
				pushback();
				return lasttok = NEWLINE;
			}
		} else {
			while ((c = nextc(false)) != '\n') {
				if (c == END_FILE)
					return lasttok = NEWLINE_EOF;
			}
		}
		sourceline++;
		return lasttok = NEWLINE;

	case '@':
		c = nextc(true);
		if (c == '/') {
			want_regexp = true;
			collecting_typed_regexp = true;
			goto collect_regexp;
		}
		pushback();
		at_seen++;
		return lasttok = '@';

	case '\\':
#ifdef RELAXED_CONTINUATION
		/*
		 * This code purports to allow comments and/or whitespace
		 * after the `\' at the end of a line used for continuation.
		 * Use it at your own risk. We think it's a bad idea, which
		 * is why it's not on by default.
		 */
		yylval = NULL;
		if (! do_traditional) {
			INSTRUCTION *new_comment;

			/* strip trailing white-space and/or comment */
			while ((c = nextc(true)) == ' ' || c == '\t' || c == '\r')
				continue;
			if (c == '#') {
				static bool warned = false;

				if (do_lint && ! warned) {
					warned = true;
					lintwarn(
		_("use of `\\ #...' line continuation is not portable"));
				}
				if (do_pretty_print && ! do_profile) {
					c = get_comment(EOL_COMMENT, & new_comment);
					yylval = new_comment;
					return lasttok = c;
				} else {
					while ((c = nextc(false)) != '\n')
						if (c == END_FILE)
							break;
				}
			}
			pushback();
		}
#endif /* RELAXED_CONTINUATION */
		c = nextc(true);
		if (c == '\r')	/* allow MS-DOS files. bleah */
			c = nextc(true);
		if (c == '\n') {
			sourceline++;
			goto retry;
		} else {
			yyerror(_("backslash not last character on line"));
			return lasttok = LEX_EOF;
		}
		break;

	case '?':
		qm_col_count++;
		// fall through
	case ':':
		yylval = GET_INSTRUCTION(Op_cond_exp);
		if (qm_col_count > 0) {
			if (! do_posix) {
				INSTRUCTION *new_comment = NULL;
				allow_newline(& new_comment);
				yylval->comment = new_comment;
			}
			if (c == ':')
				qm_col_count--;
		}
		return lasttok = c;

		/*
		 * in_parens is undefined unless we are parsing a print
		 * statement (in_print), but why bother with a check?
		 */
	case ')':
		in_parens--;
		return lasttok = c;

	case '(':
		in_parens++;
		return lasttok = c;
	case '$':
		yylval = GET_INSTRUCTION(Op_field_spec);
		return lasttok = c;
	case '{':
		if (++in_braces == 1)
			firstline = sourceline;
		/* fall through */
	case ';':
	case ',':
	case '[':
		return lasttok = c;
	case ']':
		c = nextc(true);
		pushback();
		if (c == '[') {
			if (do_traditional)
				fatal(_("multidimensional arrays are a gawk extension"));
			if (do_lint_extensions)
				lintwarn(_("multidimensional arrays are a gawk extension"));
			yylval = GET_INSTRUCTION(Op_sub_array);
			lasttok = ']';
		} else {
			yylval = GET_INSTRUCTION(Op_subscript);
			lasttok = SUBSCRIPT;	/* end of subscripts */
		}
		return ']';

	case '*':
		if ((c = nextc(true)) == '=') {
			yylval = GET_INSTRUCTION(Op_assign_times);
			return lasttok = ASSIGNOP;
		} else if (do_posix) {
			pushback();
			yylval = GET_INSTRUCTION(Op_times);
			return lasttok = '*';
		} else if (c == '*') {
			/* make ** and **= aliases for ^ and ^= */
			static bool did_warn_op = false, did_warn_assgn = false;

			if (nextc(true) == '=') {
				if (! did_warn_assgn) {
					did_warn_assgn = true;
					if (do_lint)
						lintwarn(_("POSIX does not allow operator `%s'"), "**=");
					if (do_lint_old)
						lintwarn(_("operator `%s' is not supported in old awk"), "**=");
				}
				yylval = GET_INSTRUCTION(Op_assign_exp);
				return ASSIGNOP;
			} else {
				pushback();
				if (! did_warn_op) {
					did_warn_op = true;
					if (do_lint)
						lintwarn(_("POSIX does not allow operator `%s'"), "**");
					if (do_lint_old)
						lintwarn(_("operator `%s' is not supported in old awk"), "**");
				}
				yylval = GET_INSTRUCTION(Op_exp);
				return lasttok = '^';
			}
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_times);
		return lasttok = '*';

	case '/':
		if (nextc(false) == '=') {
			pushback();
			return lasttok = SLASH_BEFORE_EQUAL;
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_quotient);
		return lasttok = '/';

	case '%':
		if (nextc(true) == '=') {
			yylval = GET_INSTRUCTION(Op_assign_mod);
			return lasttok = ASSIGNOP;
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_mod);
		return lasttok = '%';

	case '^':
	{
		static bool did_warn_op = false, did_warn_assgn = false;

		if (nextc(true) == '=') {
			if (do_lint_old && ! did_warn_assgn) {
				did_warn_assgn = true;
				lintwarn(_("operator `%s' is not supported in old awk"), "^=");
			}
			yylval = GET_INSTRUCTION(Op_assign_exp);
			return lasttok = ASSIGNOP;
		}
		pushback();
		if (do_lint_old && ! did_warn_op) {
			did_warn_op = true;
			lintwarn(_("operator `%s' is not supported in old awk"), "^");
		}
		yylval = GET_INSTRUCTION(Op_exp);
		return lasttok = '^';
	}

	case '+':
		if ((c = nextc(true)) == '=') {
			yylval = GET_INSTRUCTION(Op_assign_plus);
			return lasttok = ASSIGNOP;
		}
		if (c == '+') {
			yylval = GET_INSTRUCTION(Op_symbol);
			return lasttok = INCREMENT;
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_plus);
		return lasttok = '+';

	case '!':
		if ((c = nextc(true)) == '=') {
			yylval = GET_INSTRUCTION(Op_notequal);
			return lasttok = RELOP;
		}
		if (c == '~') {
			yylval = GET_INSTRUCTION(Op_nomatch);
			return lasttok = MATCHOP;
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_symbol);
		return lasttok = '!';

	case '<':
		if (nextc(true) == '=') {
			yylval = GET_INSTRUCTION(Op_leq);
			return lasttok = RELOP;
		}
		yylval = GET_INSTRUCTION(Op_less);
		pushback();
		return lasttok = '<';

	case '=':
		if (nextc(true) == '=') {
			yylval = GET_INSTRUCTION(Op_equal);
			return lasttok = RELOP;
		}
		yylval = GET_INSTRUCTION(Op_assign);
		pushback();
		return lasttok = ASSIGN;

	case '>':
		if ((c = nextc(true)) == '=') {
			yylval = GET_INSTRUCTION(Op_geq);
			return lasttok = RELOP;
		} else if (c == '>') {
			yylval = GET_INSTRUCTION(Op_symbol);
			yylval->redir_type = redirect_append;
			return lasttok = IO_OUT;
		}
		pushback();
		if (in_print && in_parens == 0) {
			yylval = GET_INSTRUCTION(Op_symbol);
			yylval->redir_type = redirect_output;
			return lasttok = IO_OUT;
		}
		yylval = GET_INSTRUCTION(Op_greater);
		return lasttok = '>';

	case '~':
		yylval = GET_INSTRUCTION(Op_match);
		return lasttok = MATCHOP;

	case '}':
		/*
		 * Added did newline stuff.  Easier than
		 * hacking the grammar.
		 */
		if (did_newline) {
			did_newline = false;
			if (--in_braces == 0)
				lastline = sourceline;
			return lasttok = c;
		}
		did_newline = true;
		--lexptr;	/* pick up } next time */
		return lasttok = NEWLINE;

	case '"':
	string:
		esc_seen = false;
		/*
		 * Allow any kind of junk in quoted string,
		 * so pass false to nextc().
		 */
		while ((c = nextc(false)) != '"') {
			if (c == '\n') {
				pushback();
				yyerror(_("unterminated string"));
				return lasttok = LEX_EOF;
			}
			if ((gawk_mb_cur_max == 1 || nextc_is_1stbyte) &&
			    c == '\\') {
				c = nextc(true);
				if (c == '\r')	/* allow MS-DOS files. bleah */
					c = nextc(true);
				if (c == '\n') {
					if (do_posix)
						fatal(_("POSIX does not allow physical newlines in string values"));
					else if (do_lint)
						lintwarn(_("backslash string continuation is not portable"));
					sourceline++;
					continue;
				}
				esc_seen = true;
				if (! want_source || c != '"')
					tokadd('\\');
			}
			if (c == END_FILE) {
				pushback();
				yyerror(_("unterminated string"));
				return lasttok = LEX_EOF;
			}
			tokadd(c);
		}
		yylval = GET_INSTRUCTION(Op_token);
		if (want_source) {
			yylval->lextok = estrdup(tokstart, tok - tokstart);
			// See the comment in the production for @namespace.
			if (want_namespace)
				change_namespace(yylval->lextok);
			return lasttok = FILENAME;
		}

		yylval->opcode = Op_push_i;
		yylval->memory = make_str_node(tokstart,
					tok - tokstart, esc_seen ? SCAN : 0);
		if (intlstr) {
			yylval->memory->flags |= INTLSTR;
			intlstr = false;
			if (do_intl)
				dumpintlstr(yylval->memory->stptr, yylval->memory->stlen);
		}
		return lasttok = YSTRING;

	case '-':
		if ((c = nextc(true)) == '=') {
			yylval = GET_INSTRUCTION(Op_assign_minus);
			return lasttok = ASSIGNOP;
		}
		if (c == '-') {
			yylval = GET_INSTRUCTION(Op_symbol);
			return lasttok = DECREMENT;
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_minus);
		return lasttok = '-';

	case '.':
		c = nextc(true);
		pushback();
		if (! isdigit(c))
			return lasttok = '.';
		else
			c = '.';
		/* FALL THROUGH */
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		/* It's a number */
		for (;;) {
			bool gotnumber = false;

			tokadd(c);
			switch (c) {
			case 'x':
			case 'X':
				if (do_traditional)
					goto done;
				if (tok == tokstart + 2) {
					int peek = nextc(true);

					if (isxdigit(peek)) {
						inhex = true;
						pushback();	/* following digit */
					} else {
						pushback();	/* x or X */
						goto done;
					}
				}
				break;
			case '.':
				/* period ends exponent part of floating point number */
				if (seen_point || seen_e) {
					gotnumber = true;
					break;
				}
				seen_point = true;
				break;
			case 'e':
			case 'E':
				if (inhex)
					break;
				if (seen_e) {
					gotnumber = true;
					break;
				}
				seen_e = true;
				if ((c = nextc(true)) == '-' || c == '+') {
					int c2 = nextc(true);

					if (isdigit(c2)) {
						tokadd(c);
						tokadd(c2);
					} else {
						pushback();	/* non-digit after + or - */
						pushback();	/* + or - */
						pushback();	/* e or E */
					}
				} else if (! isdigit(c)) {
					pushback();	/* character after e or E */
					pushback();	/* e or E */
				} else {
					pushback();	/* digit */
				}
				break;
			case 'a':
			case 'A':
			case 'b':
			case 'B':
			case 'c':
			case 'C':
			case 'D':
			case 'd':
			case 'f':
			case 'F':
				if (do_traditional || ! inhex)
					goto done;
				/* fall through */
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
			done:
				gotnumber = true;
			}
			if (gotnumber)
				break;
			c = nextc(true);
		}
		pushback();

		tokadd('\0');
		yylval = GET_INSTRUCTION(Op_push_i);

		base = 10;
		if (! do_traditional) {
			base = get_numbase(tokstart, strlen(tokstart)-1, false);
			if (do_lint) {
				if (base == 8)
					lintwarn("numeric constant `%.*s' treated as octal",
						(int) strlen(tokstart)-1, tokstart);
				else if (base == 16)
					lintwarn("numeric constant `%.*s' treated as hexadecimal",
						(int) strlen(tokstart)-1, tokstart);
			}
		}

#ifdef HAVE_MPFR
		if (do_mpfr) {
			NODE *r;

			if (! seen_point && ! seen_e) {
				r = mpg_integer();
				mpg_strtoui(r->mpg_i, tokstart, strlen(tokstart), NULL, base);
				errno = 0;
			} else {
				int tval;
				r = mpg_float();
				tval = mpfr_strtofr(r->mpg_numbr, tokstart, NULL, base, ROUND_MODE);
				errno = 0;
				IEEE_FMT(r->mpg_numbr, tval);
			}
			yylval->memory = set_profile_text(r, tokstart, strlen(tokstart)-1);
			return lasttok = YNUMBER;
		}
#endif
		if (base != 10)
			d = nondec2awknum(tokstart, strlen(tokstart)-1, NULL);
		else
			d = atof(tokstart);
		yylval->memory = set_profile_text(make_number(d), tokstart, strlen(tokstart) - 1);
		if (d <= INT32_MAX && d >= INT32_MIN && d == (int32_t) d)
			yylval->memory->flags |= NUMINT;
		return lasttok = YNUMBER;

	case '&':
		if ((c = nextc(true)) == '&') {
			yylval = GET_INSTRUCTION(Op_and);
			INSTRUCTION *new_comment = NULL;
			allow_newline(& new_comment);
			yylval->comment = new_comment;

			return lasttok = LEX_AND;
		}
		pushback();
		yylval = GET_INSTRUCTION(Op_symbol);
		return lasttok = '&';

	case '|':
		if ((c = nextc(true)) == '|') {
			yylval = GET_INSTRUCTION(Op_or);
			INSTRUCTION *new_comment = NULL;
			allow_newline(& new_comment);
			yylval->comment = new_comment;

			return lasttok = LEX_OR;
		} else if (! do_traditional && c == '&') {
			yylval = GET_INSTRUCTION(Op_symbol);
			yylval->redir_type = redirect_twoway;

			return lasttok = (in_print && in_parens == 0 ? IO_OUT : IO_IN);
		}
		pushback();
		if (in_print && in_parens == 0) {
			yylval = GET_INSTRUCTION(Op_symbol);
			yylval->redir_type = redirect_pipe;
			return lasttok = IO_OUT;
		} else {
			yylval = GET_INSTRUCTION(Op_symbol);
			yylval->redir_type = redirect_pipein;
			return lasttok = IO_IN;
		}
	}

	if (! is_letter(c)) {
		yyerror(_("invalid char '%c' in expression"), c);
		return lasttok = LEX_EOF;
	}

	/*
	 * Lots of fog here.  Consider:
	 *
	 * print "xyzzy"$_"foo"
	 *
	 * Without the check for ` lasttok != '$' ', this is parsed as
	 *
	 * print "xxyzz" $(_"foo")
	 *
	 * With the check, it is "correctly" parsed as three
	 * string concatenations.  Sigh.  This seems to be
	 * "more correct", but this is definitely one of those
	 * occasions where the interactions are funny.
	 */
	if (! do_traditional && c == '_' && lasttok != '$') {
		if ((c = nextc(true)) == '"') {
			intlstr = true;
			goto string;
		}
		pushback();
		c = '_';
	}

	/* it's some type of name-type-thing.  Find its length. */
	tok = tokstart;
	while (c != END_FILE && is_identchar(c)) {
		tokadd(c);
		c = nextc(true);

		if (! do_traditional && c == ':') {
			int peek = nextc(true);

			if (peek == ':') {	// saw identifier::
				tokadd(c);
				tokadd(c);
				c = nextc(true);
			} else
				pushback();
				// then continue around the loop, c == ':'
		}
	}
	tokadd('\0');
	pushback();

	(void) validate_qualified_name(tokstart);

	/* See if it is a special token. */
	if ((mid = check_qualified_special(tokstart)) >= 0) {
		static int warntab[sizeof(tokentab) / sizeof(tokentab[0])];
		int class = tokentab[mid].class;

		switch (class) {
		case LEX_EVAL:
		case LEX_INCLUDE:
		case LEX_LOAD:
		case LEX_NAMESPACE:
			if (lasttok != '@')
				goto out;
		default:
			break;
		}

		/* allow parameter names to shadow the names of gawk extension built-ins */
		if ((tokentab[mid].flags & GAWKX) != 0) {
			NODE *f;

			switch (want_param_names) {
			case FUNC_HEADER:
				/* in header, defining parameter names */
				goto out;
			case FUNC_BODY:
				/* in body, name must be in symbol table for it to be a parameter */
				if ((f = lookup(tokstart)) != NULL) {
					if (f->type == Node_builtin_func)
						break;
					else
						goto out;
				}
				/* else
					fall through */
			case DONT_CHECK:
				/* regular code */
				break;
			default:
				cant_happen("bad value %d for want_param_names", (int) want_param_names);
				break;
			}
		}

		if (do_lint) {
			if (do_lint_extensions && (tokentab[mid].flags & GAWKX) != 0 && (warntab[mid] & GAWKX) == 0) {
				lintwarn(_("`%s' is a gawk extension"),
					tokentab[mid].operator);
				warntab[mid] |= GAWKX;
			}
			if ((tokentab[mid].flags & NOT_POSIX) != 0 && (warntab[mid] & NOT_POSIX) == 0) {
				lintwarn(_("POSIX does not allow `%s'"),
					tokentab[mid].operator);
				warntab[mid] |= NOT_POSIX;
			}
		}
		if (do_lint_old && (tokentab[mid].flags & NOT_OLD) != 0
				 && (warntab[mid] & NOT_OLD) == 0
		) {
			lintwarn(_("`%s' is not supported in old awk"),
					tokentab[mid].operator);
			warntab[mid] |= NOT_OLD;
		}

		if ((tokentab[mid].flags & BREAK) != 0)
			break_allowed++;
		if ((tokentab[mid].flags & CONTINUE) != 0)
			continue_allowed++;

		switch (class) {
		case LEX_NAMESPACE:
			want_namespace = true;
			// fall through
		case LEX_INCLUDE:
		case LEX_LOAD:
			want_source = true;
			break;
		case LEX_EVAL:
			if (in_main_context())
				goto out;
			emalloc(tokkey, char *, tok - tokstart + 1);
			tokkey[0] = '@';
			memcpy(tokkey + 1, tokstart, tok - tokstart);
			yylval = GET_INSTRUCTION(Op_token);
			yylval->lextok = tokkey;
			break;

		case LEX_FUNCTION:
		case LEX_BEGIN:
		case LEX_END:
		case LEX_BEGINFILE:
		case LEX_ENDFILE:
			yylval = bcalloc(tokentab[mid].value, 4, sourceline);
			break;

		case LEX_FOR:
		case LEX_WHILE:
		case LEX_DO:
		case LEX_SWITCH:
			if (! do_pretty_print)
				return lasttok = class;
			/* fall through */
		case LEX_CASE:
			yylval = bcalloc(tokentab[mid].value, 2, sourceline);
			break;

		/*
		 * These must be checked here, due to the LALR nature of the parser,
		 * the rules for continue and break may not be reduced until after
		 * a token that increments the xxx_allowed varibles is seen. Bleah.
		 */
		case LEX_CONTINUE:
			if (! continue_allowed) {
				error_ln(sourceline,
					_("`continue' is not allowed outside a loop"));
				errcount++;
			}
			goto make_instruction;

		case LEX_BREAK:
			if (! break_allowed) {
				error_ln(sourceline,
					_("`break' is not allowed outside a loop or switch"));
				errcount++;
			}
			goto make_instruction;

		default:
make_instruction:
			yylval = GET_INSTRUCTION(tokentab[mid].value);
			if (class == LEX_BUILTIN || class == LEX_LENGTH)
				yylval->builtin_idx = mid;
			break;
		}
		return lasttok = class;
	}
out:
	if (want_param_names == FUNC_HEADER)
		tokkey = estrdup(tokstart, tok - tokstart - 1);
	else
		tokkey = qualify_name(tokstart, tok - tokstart - 1);

	if (*lexptr == '(') {
		yylval = bcalloc(Op_token, 2, sourceline);
		yylval->lextok = tokkey;
		return lasttok = FUNC_CALL;
	} else {
		static bool goto_warned = false;

		yylval = GET_INSTRUCTION(Op_token);
		yylval->lextok = tokkey;

#define SMART_ALECK	1
		if (SMART_ALECK
		    && do_lint
		    && ! goto_warned
		    && tolower(tokkey[0]) == 'g'
		    && strcasecmp(tokkey, "goto") == 0) {
			goto_warned = true;
			lintwarn(_("`goto' considered harmful!"));
		}
		return lasttok = NAME;
	}

#undef GET_INSTRUCTION
#undef NEWLINE_EOF
}

/* It's EBCDIC in a Bison grammar, run for the hills!

   Or, convert single-character tokens coming out of yylex() from EBCDIC to
   ASCII values on-the-fly so that the parse tables need not be regenerated
   for EBCDIC systems.  */
#ifdef USE_EBCDIC
static int
yylex(void)
{
	static char etoa_xlate[256];
	static bool do_etoa_init = true;
	int tok;

	if (do_etoa_init)
	{
		for (tok = 0; tok < 256; tok++)
			etoa_xlate[tok] = (char) tok;
#ifdef HAVE___ETOA_L
		/* IBM helpfully provides this function.  */
		__etoa_l(etoa_xlate, sizeof(etoa_xlate));
#else
# error "An EBCDIC-to-ASCII translation function is needed for this system"
#endif
		do_etoa_init = false;
	}

	tok = yylex_ebcdic();

	if (tok >= 0 && tok <= 0xFF)
		tok = etoa_xlate[tok];

	return tok;
}
#endif /* USE_EBCDIC */

/* snode --- instructions for builtin functions. Checks for arg. count
             and supplies defaults where possible. */

static INSTRUCTION *
snode(INSTRUCTION *subn, INSTRUCTION *r)
{
	INSTRUCTION *arg;
	INSTRUCTION *ip;
	NODE *n;
	int nexp = 0;
	int args_allowed;
	int idx = r->builtin_idx;

	if (subn != NULL) {
		INSTRUCTION *tp;
		for (tp = subn->nexti; tp; tp = tp->nexti) {
			tp = tp->lasti;
			nexp++;
		}
		assert(nexp > 0);
	}

	/* check against how many args. are allowed for this builtin */
	args_allowed = tokentab[idx].flags & ARGS;
	if (args_allowed && (args_allowed & A(nexp)) == 0) {
		yyerror(_("%d is invalid as number of arguments for %s"),
				nexp, tokentab[idx].operator);
		return NULL;
	}

	/* special processing for sub, gsub and gensub */

	if (tokentab[idx].value == Op_sub_builtin) {
		const char *operator = tokentab[idx].operator;

		r->sub_flags = 0;

		arg = subn->nexti;		/* first arg list */
		(void) mk_rexp(arg);

		if (strcmp(operator, "gensub") != 0) {
			/* sub and gsub */

			if (strcmp(operator, "gsub") == 0)
				r->sub_flags |= GSUB;

			arg = arg->lasti->nexti;	/* 2nd arg list */
			if (nexp == 2) {
				INSTRUCTION *expr;

				expr = list_create(instruction(Op_push_i));
				expr->nexti->memory = set_profile_text(make_number(0.0), "0", 1);
				(void) mk_expression_list(subn,
						list_append(expr, instruction(Op_field_spec)));
			}

			arg = arg->lasti->nexti; 	/* third arg list */
			ip = arg->lasti;
			if (ip->opcode == Op_push_i) {
				if (do_lint)
					lintwarn(_("%s: string literal as last argument of substitute has no effect"),
						operator);
				r->sub_flags |=	LITERAL;
			} else {
				if (make_assignable(ip) == NULL)
					yyerror(_("%s third parameter is not a changeable object"),
						operator);
				else
					ip->do_reference = true;
			}

			r->expr_count = count_expressions(&subn, false);
			ip = subn->lasti;

			(void) list_append(subn, r);

			/* add after_assign code */
			if (ip->opcode == Op_push_lhs && ip->memory->type == Node_var && ip->memory->var_assign) {
				(void) list_append(subn, instruction(Op_var_assign));
				subn->lasti->assign_ctxt = Op_sub_builtin;
				subn->lasti->assign_var = ip->memory->var_assign;
			} else if (ip->opcode == Op_field_spec_lhs) {
				(void) list_append(subn, instruction(Op_field_assign));
				subn->lasti->assign_ctxt = Op_sub_builtin;
				subn->lasti->field_assign = (Func_ptr) 0;
				ip->target_assign = subn->lasti;
			} else if (ip->opcode == Op_subscript_lhs) {
				(void) list_append(subn, instruction(Op_subscript_assign));
				subn->lasti->assign_ctxt = Op_sub_builtin;
			}

			return subn;

		} else {
			/* gensub */

			r->sub_flags |= GENSUB;
			if (nexp == 3) {
				ip = instruction(Op_push_i);
				ip->memory = set_profile_text(make_number(0.0), "0", 1);
				(void) mk_expression_list(subn,
						list_append(list_create(ip), instruction(Op_field_spec)));
			}

			r->expr_count = count_expressions(&subn, false);
			return list_append(subn, r);
		}
	}

#ifdef HAVE_MPFR
	/* N.B.: If necessary, add special processing for alternate builtin, below */
	if (do_mpfr && tokentab[idx].ptr2)
		r->builtin =  tokentab[idx].ptr2;
	else
#endif
		r->builtin = tokentab[idx].ptr;

	/* special case processing for a few builtins */

	if (r->builtin == do_length) {
		if (nexp == 0) {
		    /* no args. Use $0 */

			INSTRUCTION *list;
			r->expr_count = 1;
			list = list_create(r);
			(void) list_prepend(list, instruction(Op_field_spec));
			(void) list_prepend(list, instruction(Op_push_i));
			list->nexti->memory = set_profile_text(make_number(0.0), "0", 1);
			return list;
		} else {
			arg = subn->nexti;
			if (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)
				arg->nexti->opcode = Op_push_arg;	/* argument may be array */
 		}
	} else if (r->builtin == do_isarray) {
		arg = subn->nexti;
		if (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)
			arg->nexti->opcode = Op_push_arg_untyped;	/* argument may be untyped */
	} else if (r->builtin == do_typeof) {
		arg = subn->nexti;
		if (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)
			arg->nexti->opcode = Op_push_arg_untyped;	/* argument may be untyped */
		if (nexp == 2) {	/* 2nd argument there */
			arg = subn->nexti->lasti->nexti;	/* 2nd arg list */
			ip = arg->lasti;
			if (ip->opcode == Op_push)
				ip->opcode = Op_push_array;
		}
#ifdef SUPPLY_INTDIV
	} else if (r->builtin == do_intdiv
#ifdef HAVE_MPFR
		   || r->builtin == MPF(intdiv)
#endif
			) {
		arg = subn->nexti->lasti->nexti->lasti->nexti;	/* 3rd arg list */
		ip = arg->lasti;
		if (ip->opcode == Op_push)
			ip->opcode = Op_push_array;
#endif /* SUPPLY_INTDIV */
	} else if (r->builtin == do_match) {
		static bool warned = false;

		arg = subn->nexti->lasti->nexti;	/* 2nd arg list */
		(void) mk_rexp(arg);

		if (nexp == 3) {	/* 3rd argument there */
			if (do_lint_extensions && ! warned) {
				warned = true;
				lintwarn(_("match: third argument is a gawk extension"));
			}
			if (do_traditional) {
				yyerror(_("match: third argument is a gawk extension"));
				return NULL;
			}

			arg = arg->lasti->nexti; 	/* third arg list */
			ip = arg->lasti;
			if (/*ip == arg->nexti  && */ ip->opcode == Op_push)
				ip->opcode = Op_push_array;
		}
	} else if (r->builtin == do_split) {
		arg = subn->nexti->lasti->nexti;	/* 2nd arg list */
		ip = arg->lasti;
		if (ip->opcode == Op_push)
			ip->opcode = Op_push_array;
		if (nexp == 2) {
			INSTRUCTION *expr;
			expr = list_create(instruction(Op_push));
			expr->nexti->memory = FS_node;
			(void) mk_expression_list(subn, expr);
		}
		arg = arg->lasti->nexti;
		n = mk_rexp(arg);
		if (nexp == 2)
			n->re_flags |= FS_DFLT;
		if (nexp == 4) {
			arg = arg->lasti->nexti;
			ip = arg->lasti;
			if (ip->opcode == Op_push)
				ip->opcode = Op_push_array;
		}
	} else if (r->builtin == do_patsplit) {
		arg = subn->nexti->lasti->nexti;	/* 2nd arg list */
		ip = arg->lasti;
		if (ip->opcode == Op_push)
			ip->opcode = Op_push_array;
		if (nexp == 2) {
			INSTRUCTION *expr;
			expr = list_create(instruction(Op_push));
			expr->nexti->memory = FPAT_node;
			(void) mk_expression_list(subn, expr);
		}
		arg = arg->lasti->nexti;
		n = mk_rexp(arg);
		if (nexp == 4) {
			arg = arg->lasti->nexti;
			ip = arg->lasti;
			if (ip->opcode == Op_push)
				ip->opcode = Op_push_array;
		}
	} else if (r->builtin == do_close) {
		static bool warned = false;
		if (nexp == 2) {
			if (do_lint_extensions && ! warned) {
				warned = true;
				lintwarn(_("close: second argument is a gawk extension"));
			}
			if (do_traditional) {
				yyerror(_("close: second argument is a gawk extension"));
				return NULL;
			}
		}
	} else if (do_intl					/* --gen-po */
			&& r->builtin == do_dcgettext		/* dcgettext(...) */
			&& subn->nexti->lasti->opcode == Op_push_i	/* 1st arg is constant */
			&& (subn->nexti->lasti->memory->flags & STRING) != 0) {	/* it's a string constant */
		/* ala xgettext, dcgettext("some string" ...) dumps the string */
		NODE *str = subn->nexti->lasti->memory;

		if ((str->flags & INTLSTR) != 0)
			warning(_("use of dcgettext(_\"...\") is incorrect: remove leading underscore"));
			/* don't dump it, the lexer already did */
		else
			dumpintlstr(str->stptr, str->stlen);
	} else if (do_intl					/* --gen-po */
			&& r->builtin == do_dcngettext		/* dcngettext(...) */
			&& subn->nexti->lasti->opcode == Op_push_i	/* 1st arg is constant */
			&& (subn->nexti->lasti->memory->flags & STRING) != 0	/* it's a string constant */
			&& subn->nexti->lasti->nexti->lasti->opcode == Op_push_i	/* 2nd arg is constant too */
			&& (subn->nexti->lasti->nexti->lasti->memory->flags & STRING) != 0) {	/* it's a string constant */
		/* ala xgettext, dcngettext("some string", "some plural" ...) dumps the string */
		NODE *str1 = subn->nexti->lasti->memory;
		NODE *str2 = subn->nexti->lasti->nexti->lasti->memory;

		if (((str1->flags | str2->flags) & INTLSTR) != 0)
			warning(_("use of dcngettext(_\"...\") is incorrect: remove leading underscore"));
		else
			dumpintlstr2(str1->stptr, str1->stlen, str2->stptr, str2->stlen);
	} else if (r->builtin == do_asort || r->builtin == do_asorti) {
		arg = subn->nexti;	/* 1st arg list */
		ip = arg->lasti;
		if (ip->opcode == Op_push)
			ip->opcode = Op_push_array;
		if (nexp >= 2) {
			arg = ip->nexti;
			ip = arg->lasti;
			if (ip->opcode == Op_push)
				ip->opcode = Op_push_array;
		}
	}
	else if (r->builtin == do_index) {
		arg = subn->nexti->lasti->nexti;	/* 2nd arg list */
		ip = arg->lasti;
		if (ip->opcode == Op_match_rec || ip->opcode == Op_push_re)
			fatal(_("index: regexp constant as second argument is not allowed"));
	}
#ifdef ARRAYDEBUG
	else if (r->builtin == do_adump) {
		ip = subn->nexti->lasti;
		if (ip->opcode == Op_push)
			ip->opcode = Op_push_array;
	}
#endif

	if (subn != NULL) {
		r->expr_count = count_expressions(&subn, false);
		return list_append(subn, r);
	}

	r->expr_count = 0;
	return list_create(r);
}


/* parms_shadow --- check if parameters shadow globals */

static int
parms_shadow(INSTRUCTION *pc, bool *shadow)
{
	int pcount, i;
	bool ret = false;
	NODE *func, *fp;
	char *fname;

	func = pc->func_body;
	fname = func->vname;
	fp = func->fparms;

#if 0	/* can't happen, already exited if error ? */
	if (fname == NULL || func == NULL)	/* error earlier */
		return false;
#endif

	pcount = func->param_cnt;

	if (pcount == 0)		/* no args, no problem */
		return 0;

	source = pc->source_file;
	sourceline = pc->source_line;
	/*
	 * Use warning() and not lintwarn() so that can warn
	 * about all shadowed parameters.
	 */
	for (i = 0; i < pcount; i++) {
		if (lookup(fp[i].param) != NULL) {
			warning(
	_("function `%s': parameter `%s' shadows global variable"),
					fname, fp[i].param);
			ret = true;
		}
	}

	*shadow |= ret;
	return 0;
}

/* valinfo --- dump var info */

void
valinfo(NODE *n, Func_print print_func, FILE *fp)
{
	if (n == Nnull_string)
		print_func(fp, "uninitialized scalar\n");
	else if ((n->flags & REGEX) != 0)
		print_func(fp, "@/%.*s/\n", n->stlen, n->stptr);
	else if ((n->flags & STRING) != 0) {
		pp_string_fp(print_func, fp, n->stptr, n->stlen, '"', false);
		print_func(fp, "\n");
	} else if ((n->flags & NUMBER) != 0) {
#ifdef HAVE_MPFR
		if (is_mpg_float(n))
			print_func(fp, "%s\n", mpg_fmt("%.17R*g", ROUND_MODE, n->mpg_numbr));
		else if (is_mpg_integer(n))
			print_func(fp, "%s\n", mpg_fmt("%Zd", n->mpg_i));
		else
#endif
		print_func(fp, "%.17g\n", n->numbr);
	} else
		print_func(fp, "?? flags %s\n", flags2str(n->flags));
}


/* dump_vars --- dump the symbol table */

void
dump_vars(const char *fname)
{
	FILE *fp;
	NODE **vars;

	if (fname == NULL)
		fp = stderr;
	else if (strcmp(fname, "-") == 0)
		fp = stdout;
	else if ((fp = fopen(fname, "w")) == NULL) {
		warning(_("could not open `%s' for writing: %s"), fname, strerror(errno));
		warning(_("sending variable list to standard error"));
		fp = stderr;
	}

	vars = variable_list();
	print_vars(vars, fprintf, fp);
	efree(vars);
	if (fp != stdout && fp != stderr && fclose(fp) != 0)
		warning(_("%s: close failed: %s"), fname, strerror(errno));
}

/* dump_funcs --- print all functions */

void
dump_funcs()
{
	NODE **funcs;
	funcs = function_list(true);
	(void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) pp_func, (void *) 0);
	efree(funcs);
}


/* shadow_funcs --- check all functions for parameters that shadow globals */

void
shadow_funcs()
{
	static int calls = 0;
	bool shadow = false;
	NODE **funcs;

	if (calls++ != 0)
		fatal(_("shadow_funcs() called twice!"));

	funcs = function_list(true);
	(void) foreach_func(funcs, (int (*)(INSTRUCTION *, void *)) parms_shadow, & shadow);
	efree(funcs);

	/* End with fatal if the user requested it.  */
	if (shadow && lintfunc == r_fatal)
		lintwarn(_("there were shadowed variables"));
}


/* mk_function --- finalize function definition node; remove parameters
 *	out of the symbol table.
 */

static INSTRUCTION *
mk_function(INSTRUCTION *fi, INSTRUCTION *def)
{
	NODE *thisfunc;

	thisfunc = fi->func_body;
	assert(thisfunc != NULL);

	/* add any pre-function comment to start of action for profile.c  */

	if (interblock_comment != NULL) {
		interblock_comment->source_line = 0;
		merge_comments(interblock_comment, fi->comment);
		fi->comment = interblock_comment;
		interblock_comment = NULL;
	}

	/*
	 * Add an implicit return at end;
	 * also used by 'return' command in debugger
	 */

	(void) list_append(def, instruction(Op_push_i));
	def->lasti->memory = dupnode(Nnull_string);
	(void) list_append(def, instruction(Op_K_return));

	if (trailing_comment != NULL) {
		(void) list_append(def, trailing_comment);
		trailing_comment = NULL;
	}

	if (do_pretty_print) {
		if (namespace_chain == NULL)
			push_ns_onto_namespace_chain(NULL);

		fi[3].nexti = namespace_chain;
		namespace_chain = NULL;
		(void) list_prepend(def, instruction(Op_exec_count));
	}

	/* fi->opcode = Op_func */
	(fi + 1)->firsti = def->nexti;
	(fi + 1)->lasti = def->lasti;
	(fi + 2)->first_line = fi->source_line;
	(fi + 2)->last_line = lastline;
	fi->nexti = def->nexti;
	bcfree(def);

	(void) list_append(rule_list, fi + 1);	/* debugging */

	/* update lint table info */
	func_use(thisfunc->vname, FUNC_DEFINE);

	/* remove params from symbol table */
	remove_params(thisfunc);
	return fi;
}

/* push_ns_onto_namespace_chain --- update the namespace chain */

static void
push_ns_onto_namespace_chain(INSTRUCTION *comment)
{
	INSTRUCTION *new_ns = instruction(Op_K_namespace);
	new_ns->comment = comment;
	new_ns->ns_name = estrdup(current_namespace, strlen(current_namespace));
	new_ns->nexti = namespace_chain;
	namespace_chain = new_ns;
}

/*
 * install_function:
 * install function name in the symbol table.
 * Extra work, build up and install a list of the parameter names.
 */

static int
install_function(char *fname, INSTRUCTION *fi, INSTRUCTION *plist)
{
	NODE *r, *f;
	int pcount = 0;

	r = lookup(fname);
	if (r != NULL) {
		error_ln(fi->source_line, _("function name `%s' previously defined"), fname);
		return -1;
	}

	if (plist != NULL)
		pcount = plist->lasti->param_count + 1;
	f = install_symbol(fname, Node_func);
	if (f->vname != fname) {
		// DON'T free fname, it's done later
		fname = f->vname;
	}

	fi->func_body = f;
	f->param_cnt = pcount;
	f->code_ptr = fi;
	f->fparms = NULL;
	if (pcount > 0) {
		char **pnames;
		pnames = check_params(fname, pcount, plist);	/* frees plist */
		f->fparms = make_params(pnames, pcount);
		efree(pnames);
		install_params(f);
	}
	return 0;
}


/* check_params --- build a list of function parameter names after
 *	making sure that the names are valid and there are no duplicates.
 */

static char **
check_params(char *fname, int pcount, INSTRUCTION *list)
{
	INSTRUCTION *p, *np;
	int i, j;
	char *name;
	char **pnames;

	assert(pcount > 0);

	emalloc(pnames, char **, pcount * sizeof(char *));

	for (i = 0, p = list->nexti; p != NULL; i++, p = np) {
		np = p->nexti;
		name = p->lextok;
		p->lextok = NULL;

		if (strcmp(name, fname) == 0) {
			/* check for function foo(foo) { ... }.  bleah. */
			error_ln(p->source_line,
				_("function `%s': cannot use function name as parameter name"), fname);
		} else if (is_std_var(name)) {
			error_ln(p->source_line,
				_("function `%s': parameter `%s': POSIX disallows using a special variable as a function parameter"),
					fname, name);
		} else if (strchr(name, ':') != NULL)
			error_ln(p->source_line,
				_("function `%s': parameter `%s' cannot contain a namespace"),
					fname, name);

		/* check for duplicate parameters */
		for (j = 0; j < i; j++) {
			if (strcmp(name, pnames[j]) == 0) {
				error_ln(p->source_line,
					_("function `%s': parameter #%d, `%s', duplicates parameter #%d"),
					fname, i + 1, name, j + 1);
			}
		}

		pnames[i] = name;
		bcfree(p);
	}
	bcfree(list);

	return pnames;
}


#ifdef HASHSIZE
undef HASHSIZE
#endif
#define HASHSIZE 1021

static struct fdesc {
	char *name;
	short used;
	short defined;
	short extension;
	struct fdesc *next;
} *ftable[HASHSIZE];

/* func_use --- track uses and definitions of functions */

static void
func_use(const char *name, enum defref how)
{
	struct fdesc *fp;
	int len;
	int ind;

	len = strlen(name);
	ind = hash(name, len, HASHSIZE, NULL);

	for (fp = ftable[ind]; fp != NULL; fp = fp->next)
		if (strcmp(fp->name, name) == 0)
			goto update_value;

	/* not in the table, fall through to allocate a new one */

	ezalloc(fp, struct fdesc *, sizeof(struct fdesc));
	emalloc(fp->name, char *, len + 1);
	strcpy(fp->name, name);
	fp->next = ftable[ind];
	ftable[ind] = fp;

update_value:
	if (how == FUNC_DEFINE)
		fp->defined++;
	else if (how == FUNC_EXT) {
		fp->defined++;
		fp->extension++;
	} else
		fp->used++;
}

/* track_ext_func --- add an extension function to the table */

void
track_ext_func(const char *name)
{
	func_use(name, FUNC_EXT);
}

/* check_funcs --- verify functions that are called but not defined */

static void
check_funcs()
{
	struct fdesc *fp, *next;
	int i;

	if (! in_main_context())
		goto free_mem;

	for (i = 0; i < HASHSIZE; i++) {
		for (fp = ftable[i]; fp != NULL; fp = fp->next) {
			if (do_lint && ! fp->extension) {
				/*
				 * Making this not a lint check and
				 * incrementing * errcount breaks old code.
				 * Sigh.
				 */
				if (fp->defined == 0)
					lintwarn(_("function `%s' called but never defined"),
						fp->name);

				if (fp->used == 0)
					lintwarn(_("function `%s' defined but never called directly"),
						fp->name);
			}
		}
	}

free_mem:
	/* now let's free all the memory */
	for (i = 0; i < HASHSIZE; i++) {
		for (fp = ftable[i]; fp != NULL; fp = next) {
			next = fp->next;
			efree(fp->name);
			efree(fp);
		}
		ftable[i] = NULL;
	}
}

/* param_sanity --- look for parameters that are regexp constants */

static void
param_sanity(INSTRUCTION *arglist)
{
	INSTRUCTION *argl, *arg;
	int i = 1;

	if (arglist == NULL)
		return;
	for (argl = arglist->nexti; argl; ) {
		arg = argl->lasti;
		if (arg->opcode == Op_match_rec)
			warning_ln(arg->source_line,
				_("regexp constant for parameter #%d yields boolean value"), i);
		argl = arg->nexti;
		i++;
	}
}

/* variable --- make sure NAME is in the symbol table */

NODE *
variable(int location, char *name, NODETYPE type)
{
	NODE *r;

	if ((r = lookup(name)) != NULL) {
		if (r->type == Node_func || r->type == Node_ext_func )
			error_ln(location, _("function `%s' called with space between name and `(',\nor used as a variable or an array"),
				r->vname);
	} else {
		/* not found */
		return install_symbol(name, type);
	}
	efree(name);
	return r;
}

/* make_regnode --- make a regular expression node */

NODE *
make_regnode(NODETYPE type, NODE *exp)
{
	NODE *n;

	assert(type == Node_regex || type == Node_dynregex);
	getnode(n);
	memset(n, 0, sizeof(NODE));
	n->type = type;
	n->re_cnt = 1;

	if (type == Node_regex) {
		n->re_reg[0] = make_regexp(exp->stptr, exp->stlen, false, true, false);
		if (n->re_reg[0] == NULL) {
			freenode(n);
			return NULL;
		}
		n->re_exp = exp;
		n->re_flags = CONSTANT;
	}
	return n;
}


/* mk_rexp --- make a regular expression constant */

static NODE *
mk_rexp(INSTRUCTION *list)
{
	INSTRUCTION *ip;

	ip = list->nexti;
	if (ip == list->lasti && ip->opcode == Op_match_rec)
		ip->opcode = Op_push_re;
	else if (ip == list->lasti && ip->opcode == Op_push_re)
		; /* do nothing --- @/.../ */
	else {
		ip = instruction(Op_push_re);
		ip->memory = make_regnode(Node_dynregex, NULL);
		ip->nexti = list->lasti->nexti;
		list->lasti->nexti = ip;
		list->lasti = ip;
	}
	return ip->memory;
}

#ifndef NO_LINT
/* isnoeffect --- when used as a statement, has no side effects */

static int
isnoeffect(OPCODE type)
{
	switch (type) {
	case Op_times:
	case Op_times_i:
	case Op_quotient:
	case Op_quotient_i:
	case Op_mod:
	case Op_mod_i:
	case Op_plus:
	case Op_plus_i:
	case Op_minus:
	case Op_minus_i:
	case Op_subscript:
	case Op_concat:
	case Op_exp:
	case Op_exp_i:
	case Op_unary_minus:
	case Op_field_spec:
	case Op_and_final:
	case Op_or_final:
	case Op_equal:
	case Op_notequal:
	case Op_less:
	case Op_greater:
	case Op_leq:
	case Op_geq:
	case Op_match:
	case Op_nomatch:
	case Op_match_rec:
	case Op_not:
	case Op_in_array:
		return true;
	// Additional opcodes that can be part of an expression
	// that has no effect:
	case Op_and:
	case Op_or:
	case Op_push:
	case Op_push_i:
	case Op_push_array:
	case Op_pop:
	case Op_lint_plus:
	case Op_exec_count:
		return true;
	default:
		break;	/* keeps gcc -Wall happy */
	}

	return false;
}
#endif /* NO_LINT */


/* make_assignable --- make this operand an assignable one if posiible */

static INSTRUCTION *
make_assignable(INSTRUCTION *ip)
{
	switch (ip->opcode) {
	case Op_push:
		ip->opcode = Op_push_lhs;
		return ip;
	case Op_field_spec:
		ip->opcode = Op_field_spec_lhs;
		return ip;
	case Op_subscript:
		ip->opcode = Op_subscript_lhs;
		return ip;
	case Op_field_assign:
		// no need to change the opcode, but do need to return
		// a non-NULL pointer.
		return ip;
	default:
		break;	/* keeps gcc -Wall happy */
	}
	return NULL;
}

/* stopme --- for debugging */

NODE *
stopme(int nargs ATTRIBUTE_UNUSED)
{
	return make_number(0.0);
}

/* dumpintlstr --- write out an initial .po file entry for the string */

static void
dumpintlstr(const char *str, size_t len)
{
	char *cp;

	/* See the GNU gettext distribution for details on the file format */

	if (source != NULL) {
		/* ala the gettext sources, remove leading `./'s */
		for (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)
			continue;
		printf("#: %s:%d\n", cp, sourceline);
	}

	printf("msgid ");
	pp_string_fp(fprintf, stdout, str, len, '"', true);
	putchar('\n');
	printf("msgstr \"\"\n\n");
	fflush(stdout);
}

/* dumpintlstr2 --- write out an initial .po file entry for the string and its plural */

static void
dumpintlstr2(const char *str1, size_t len1, const char *str2, size_t len2)
{
	char *cp;

	/* See the GNU gettext distribution for details on the file format */

	if (source != NULL) {
		/* ala the gettext sources, remove leading `./'s */
		for (cp = source; cp[0] == '.' && cp[1] == '/'; cp += 2)
			continue;
		printf("#: %s:%d\n", cp, sourceline);
	}

	printf("msgid ");
	pp_string_fp(fprintf, stdout, str1, len1, '"', true);
	putchar('\n');
	printf("msgid_plural ");
	pp_string_fp(fprintf, stdout, str2, len2, '"', true);
	putchar('\n');
	printf("msgstr[0] \"\"\nmsgstr[1] \"\"\n\n");
	fflush(stdout);
}

/* mk_binary --- instructions for binary operators */

static INSTRUCTION *
mk_binary(INSTRUCTION *s1, INSTRUCTION *s2, INSTRUCTION *op)
{
	INSTRUCTION *ip1,*ip2, *lint_plus;
	AWKNUM res;

	ip2 = s2->nexti;
	if (s2->lasti == ip2 && ip2->opcode == Op_push_i) {
	/* do any numeric constant folding */
		ip1 = s1->nexti;
		if (do_optimize
				&& ip1 == s1->lasti && ip1->opcode == Op_push_i
				&& (ip1->memory->flags & (MPFN|MPZN|STRCUR|STRING)) == 0
				&& (ip2->memory->flags & (MPFN|MPZN|STRCUR|STRING)) == 0
		) {
			NODE *n1 = ip1->memory, *n2 = ip2->memory;
			res = force_number(n1)->numbr;
			(void) force_number(n2);
			switch (op->opcode) {
			case Op_times:
				res *= n2->numbr;
				break;
			case Op_quotient:
				if ((n2->flags & NUMBER) != 0 && n2->numbr == 0.0) {
					/* don't fatalize, allow parsing rest of the input */
					error_ln(op->source_line, _("division by zero attempted"));
					goto regular;
				}

				res /= n2->numbr;
				break;
			case Op_mod:
				if ((n2->flags & NUMBER) != 0 && n2->numbr == 0.0) {
					/* don't fatalize, allow parsing rest of the input */
					error_ln(op->source_line, _("division by zero attempted in `%%'"));
					goto regular;
				}
#ifdef HAVE_FMOD
				res = fmod(res, n2->numbr);
#else	/* ! HAVE_FMOD */
				(void) modf(res / n2->numbr, &res);
				res = n1->numbr - res * n2->numbr;
#endif	/* ! HAVE_FMOD */
				break;
			case Op_plus:
				res += n2->numbr;
				break;
			case Op_minus:
				res -= n2->numbr;
				break;
			case Op_exp:
				res = calc_exp(res, n2->numbr);
				break;
			default:
				goto regular;
			}

			op->opcode = Op_push_i;
			// We don't need to call set_profile_text() here since
			// optimizing is disabled when doing pretty printing.
			op->memory = make_number(res);
			unref(n1);
			unref(n2);
			bcfree(ip1);
			bcfree(ip2);
			bcfree(s1);
			bcfree(s2);
			return list_create(op);
		} else {
		/* do basic arithmetic optimisation */
		/* convert (Op_push_i Node_val) + (Op_plus) to (Op_plus_i Node_val) */
			switch (op->opcode) {
			case Op_times:
				op->opcode = Op_times_i;
				break;
			case Op_quotient:
				if ((ip2->memory->flags & NUMBER) != 0 && ip2->memory->numbr == 0.0) {
					/* don't fatalize, allow parsing rest of the input */
					error_ln(op->source_line, _("division by zero attempted"));
					goto regular;
				}

				op->opcode = Op_quotient_i;
				break;
			case Op_mod:
				if ((ip2->memory->flags & NUMBER) != 0 && ip2->memory->numbr == 0.0) {
					/* don't fatalize, allow parsing rest of the input */
					error_ln(op->source_line, _("division by zero attempted in `%%'"));
					goto regular;
				}

				op->opcode = Op_mod_i;
				break;
			case Op_plus:
				if (do_lint)
					goto regular;
				op->opcode = Op_plus_i;
				break;
			case Op_minus:
				op->opcode = Op_minus_i;
				break;
			case Op_exp:
				op->opcode = Op_exp_i;
				break;
			default:
				goto regular;
			}

			op->memory = ip2->memory;
			bcfree(ip2);
			bcfree(s2);	/* Op_list */
			return list_append(s1, op);
		}
	}

regular:
	/* append lists s1, s2 and add `op' bytecode */
	(void) list_merge(s1, s2);
	if (do_lint && op->opcode == Op_plus) {
		lint_plus = instruction(Op_lint_plus);
		(void) list_append(s1, lint_plus);
	}
	return list_append(s1, op);
}

/* mk_boolean --- instructions for boolean and, or */

static INSTRUCTION *
mk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op)
{
	INSTRUCTION *tp;
	OPCODE opc, final_opc;

	opc = op->opcode;		/* Op_and or Op_or */
	final_opc = (opc == Op_or) ? Op_or_final : Op_and_final;

	add_lint(right, LINT_assign_in_cond);

	tp = left->lasti;

	if (tp->opcode != final_opc) {	/* x || y */
		list_append(right, instruction(final_opc));
		add_lint(left, LINT_assign_in_cond);
		(void) list_append(left, op);
		left->lasti->target_jmp = right->lasti;

		/* NB: target_stmt points to previous Op_and(Op_or) in a chain;
		 *     target_stmt only used in the parser (see below).
		 */

		left->lasti->target_stmt = left->lasti;
		right->lasti->target_stmt = left->lasti;
	} else {		/* optimization for x || y || z || ... */
		INSTRUCTION *ip;

		op->opcode = final_opc;
		(void) list_append(right, op);
		op->target_stmt = tp;
		tp->opcode = opc;
		tp->target_jmp = op;

		/* update jump targets */
		for (ip = tp->target_stmt; ; ip = ip->target_stmt) {
			assert(ip->opcode == opc);
			assert(ip->target_jmp == tp);
			/* if (ip->opcode == opc &&  ip->target_jmp == tp) */
			ip->target_jmp = op;
			if (ip->target_stmt == ip)
				break;
		}
	}

	return list_merge(left, right);
}

/* mk_condition --- if-else and conditional */

static INSTRUCTION *
mk_condition(INSTRUCTION *cond, INSTRUCTION *ifp, INSTRUCTION *true_branch,
		INSTRUCTION *elsep, INSTRUCTION *false_branch)
{
	/*
	 *    ----------------
	 *       cond
	 *    ----------------
	 * t: [Op_jmp_false f ]
	 *    ----------------
	 *       true_branch
	 *
	 *    ----------------
	 *    [Op_jmp y]
	 *    ----------------
	 * f:
	 *      false_branch
	 *    ----------------
	 * y: [Op_no_op]
	 *    ----------------
	 */

	INSTRUCTION *ip;
	bool setup_else_part = true;

	if (false_branch == NULL) {
		false_branch = list_create(instruction(Op_no_op));
		if (elsep == NULL) {		/* else { } */
			setup_else_part = false;
		}
	} else {
		/* assert(elsep != NULL); */

		/* avoid a series of no_op's: if .. else if .. else if .. */
		if (false_branch->lasti->opcode != Op_no_op)
			(void) list_append(false_branch, instruction(Op_no_op));
	}

	if (setup_else_part) {
		if (do_pretty_print) {
			(void) list_prepend(false_branch, elsep);
			false_branch->nexti->branch_end = false_branch->lasti;
			(void) list_prepend(false_branch, instruction(Op_exec_count));
		} else
			bcfree(elsep);
	}

	(void) list_prepend(false_branch, instruction(Op_jmp));
	false_branch->nexti->target_jmp = false_branch->lasti;

	add_lint(cond, LINT_assign_in_cond);
	ip = list_append(cond, instruction(Op_jmp_false));
	ip->lasti->target_jmp = false_branch->nexti->nexti;

	if (do_pretty_print) {
		(void) list_prepend(ip, ifp);
		(void) list_append(ip, instruction(Op_exec_count));
		ip->nexti->branch_if = ip->lasti;
		ip->nexti->branch_else = false_branch->nexti;
	} else
		bcfree(ifp);

	if (true_branch != NULL)
		list_merge(ip, true_branch);
	return list_merge(ip, false_branch);
}

enum defline { FIRST_LINE, LAST_LINE };

/* find_line -- find the first(last) line in a list of (pattern) instructions */

static int
find_line(INSTRUCTION *pattern, enum defline what)
{
	INSTRUCTION *ip;
	int lineno = 0;

	for (ip = pattern->nexti; ip; ip = ip->nexti) {
		if (what == LAST_LINE) {
			if (ip->source_line > lineno)
				lineno = ip->source_line;
		} else {	/* FIRST_LINE */
			if (ip->source_line > 0
					&& (lineno == 0 || ip->source_line < lineno))
				lineno = ip->source_line;
		}
		if (ip == pattern->lasti)
			break;
	}
	assert(lineno > 0);
	return lineno;
}

/* append_rule --- pattern-action instructions */

static INSTRUCTION *
append_rule(INSTRUCTION *pattern, INSTRUCTION *action)
{
	/*
	 *    ----------------
	 *       pattern
	 *    ----------------
	 *    [Op_jmp_false f ]
	 *    ----------------
	 *       action
	 *    ----------------
	 * f: [Op_no_op       ]
	 *    ----------------
	 */

	INSTRUCTION *rp;
	INSTRUCTION *tp;
	INSTRUCTION *ip;

	if (rule != Rule) {
		rp = pattern;
		if (do_pretty_print) {
			rp[3].nexti = namespace_chain;
			namespace_chain = NULL;
			(void) list_append(action, instruction(Op_no_op));
		}
		(rp + 1)->firsti = action->nexti;
		(rp + 1)->lasti = action->lasti;
		(rp + 2)->first_line = pattern->source_line;
		(rp + 2)->last_line = lastline;
		ip = list_prepend(action, rp);
		if (interblock_comment != NULL) {
			ip = list_prepend(ip, interblock_comment);
			interblock_comment = NULL;
		}
	} else {
		rp = bcalloc(Op_rule, 4, 0);
		rp->in_rule = Rule;
		rp->source_file = source;
		tp = instruction(Op_no_op);

		if (do_pretty_print) {
			rp[3].nexti = namespace_chain;
			namespace_chain = NULL;
		}

		if (pattern == NULL) {
			/* assert(action != NULL); */
			if (do_pretty_print)
				(void) list_prepend(action, instruction(Op_exec_count));
			(rp + 1)->firsti = action->nexti;
			(rp + 1)->lasti = tp;
			(rp + 2)->first_line = firstline;
			(rp + 2)->last_line = lastline;
			rp->source_line = firstline;
			ip = list_prepend(list_append(action, tp), rp);
		} else {
			(void) list_append(pattern, instruction(Op_jmp_false));
			pattern->lasti->target_jmp = tp;
			(rp + 2)->first_line = find_line(pattern, FIRST_LINE);
			rp->source_line = (rp + 2)->first_line;
			if (action == NULL) {
				(rp + 2)->last_line = find_line(pattern, LAST_LINE);
				action = list_create(instruction(Op_K_print_rec));
				if (do_pretty_print)
					action = list_prepend(action, instruction(Op_exec_count));
			} else
				(rp + 2)->last_line = lastline;

			if (interblock_comment != NULL) {	// was after previous action
				pattern = list_prepend(pattern, interblock_comment);
				interblock_comment = NULL;
			}

			if (do_pretty_print) {
				pattern = list_prepend(pattern, instruction(Op_exec_count));
				action = list_prepend(action, instruction(Op_exec_count));
			}

 			(rp + 1)->firsti = action->nexti;
			(rp + 1)->lasti = tp;
			ip = list_append(
					list_merge(list_prepend(pattern, rp),
						action),
					tp);
		}
	}

	list_append(rule_list, rp + 1);

	if (rule_block[rule] == NULL)
		rule_block[rule] = ip;
	else
		(void) list_merge(rule_block[rule], ip);

	return rule_block[rule];
}

/*
 * 3/2023:
 * mk_assignment() is called when an assignment statement is seen,
 * as an expression.  optimize_assignment() is called when an expression
 * is seen as statement (inside braces).
 *
 * When a field assignment is seen, it needs to be optizimed into
 * Op_store_field_exp or Op_store_field to avoid memory management
 * issues. Thus, the Op_field_spec_lhs -> Op_store_field_expr
 * change is done in mk_assignment. (Consider foo && $0 = $1, the
 * assignment is part of an expression.)
 *
 * If the assignment is in a statement, then optimize_assignment()
 * turn Op_store_field_expr into Op_store_field.
 */

/* mk_assignment --- assignment bytecodes */

static INSTRUCTION *
mk_assignment(INSTRUCTION *lhs, INSTRUCTION *rhs, INSTRUCTION *op)
{
	INSTRUCTION *tp;
	INSTRUCTION *ip;

	tp = lhs->lasti;
	switch (tp->opcode) {
	case Op_field_spec:
		tp->opcode = Op_field_spec_lhs;
		break;
	case Op_subscript:
		tp->opcode = Op_subscript_lhs;
		break;
	case Op_push:
	case Op_push_array:
		tp->opcode = Op_push_lhs;
		break;
	case Op_field_assign:
		yyerror(_("cannot assign a value to the result of a field post-increment expression"));
		break;
	default:
		yyerror(_("invalid target of assignment (opcode %s)"),
				opcode2str(tp->opcode));
		break;
	}

	tp->do_reference = (op->opcode != Op_assign);	/* check for uninitialized reference */

	if (rhs != NULL)
		ip = list_merge(rhs, lhs);
	else
		ip = lhs;

	if (tp->opcode != Op_field_spec_lhs || op->opcode != Op_assign)
		(void) list_append(ip, op);

	if (tp->opcode == Op_push_lhs
			&& tp->memory->type == Node_var
			&& tp->memory->var_assign
	) {
		tp->do_reference = false; /* no uninitialized reference checking
		                           * for a special variable.
		                           */
		(void) list_append(ip, instruction(Op_var_assign));
		ip->lasti->assign_var = tp->memory->var_assign;
	} else if (tp->opcode == Op_field_spec_lhs) {
		if (op->opcode == Op_assign) {
			bcfree(op);
			tp->opcode = Op_store_field_exp;
		} else {
			(void) list_append(ip, instruction(Op_field_assign));
			ip->lasti->field_assign = (Func_ptr) 0;
			tp->target_assign = ip->lasti;
		}
	} else if (tp->opcode == Op_subscript_lhs) {
		(void) list_append(ip, instruction(Op_subscript_assign));
	}

	return ip;
}

/* optimize_assignment --- peephole optimization for assignment */

static INSTRUCTION *
optimize_assignment(INSTRUCTION *exp)
{
	INSTRUCTION *i1, *i2, *i3;

	/*
	 * Optimize assignment statements array[subs] = x; var = x; $n = x;
	 * string concatenation of the form s = s t.
	 *
	 * 1) Array element assignment array[subs] = x:
	 *   Replaces Op_push_array + Op_subscript_lhs + Op_assign + Op_pop
	 *   with single instruction Op_store_sub.
	 *	 Limitation: 1 dimension and sub is simple var/value.
	 *
	 * 2) Simple variable assignment var = x:
	 *   Replaces Op_push_lhs + Op_assign + Op_pop with Op_store_var.
	 *
	 * 3) Field assignment $n = x:
	 *   Replaces Op_field_spec_lhs + Op_assign + Op_field_assign + Op_pop
	 *   with Op_store_field.
	 *
	 * 4) Optimization for string concatenation:
	 *   For cases like x = x y, uses realloc to include y in x;
	 *   also eliminates instructions Op_push_lhs and Op_pop.
	 */

	/*
	 * N.B.: do not append Op_pop instruction to the returned
	 * instruction list if optimized. None of these
	 * optimized instructions pushes the r-value of assignment
	 * onto the runtime stack.
	 */

	i2 = NULL;
	i1 = exp->lasti;

	if (i1->opcode == Op_store_field_exp) {
		i1->opcode = Op_store_field;
		return exp;
	}

	if (   i1->opcode != Op_assign
	    && i1->opcode != Op_field_assign)
		return list_append(exp, instruction(Op_pop));

	for (i2 = exp->nexti; i2 != i1; i2 = i2->nexti) {
		switch (i2->opcode) {
		case Op_concat:
			if (i2->nexti->opcode == Op_push_lhs    /* l.h.s is a simple variable */
				&& (i2->concat_flag & CSVAR) != 0   /* 1st exp in r.h.s is a simple variable;
				                                     * see Op_concat in the grammer above.
				                                     */
				&& i2->nexti->memory == exp->nexti->memory	 /* and the same as in l.h.s */
				&& i2->nexti->nexti == i1
				&& i1->opcode == Op_assign
			) {
				/* s = s ... optimization */

				/* avoid stuff like x = x (x = y) or x = x gsub(/./, "b", x);
				 * check for l-value reference to this variable in the r.h.s.
				 * Also, avoid function calls in general to guard against
				 * global variable assignment.
				 */

				for (i3 = exp->nexti->nexti; i3 != i2; i3 = i3->nexti) {
					if ((i3->opcode == Op_push_lhs && i3->memory == i2->nexti->memory)
							|| i3->opcode == Op_func_call)
						return list_append(exp, instruction(Op_pop)); /* no optimization */
				}

				/* remove the variable from r.h.s */
				i3 = exp->nexti;
				exp->nexti = i3->nexti;
				bcfree(i3);

				if (--i2->expr_count == 1)	/* one less expression in Op_concat */
					i2->opcode = Op_no_op;

				i3 = i2->nexti;
				assert(i3->opcode == Op_push_lhs);
				i3->opcode = Op_assign_concat;	/* change Op_push_lhs to Op_assign_concat */
				i3->nexti = NULL;
				bcfree(i1);          /* Op_assign */
				exp->lasti = i3;     /* update Op_list */
				return exp;
			}
			break;

		case Op_push_array:
			if (i2->nexti->nexti->opcode == Op_subscript_lhs) {
				i3 = i2->nexti->nexti;
				if (i3->sub_count == 1
						&& i3->nexti == i1
						&& i1->opcode == Op_assign
				) {
					/* array[sub] = .. */
					i3->opcode = Op_store_sub;
					i3->memory = i2->memory;
					i3->expr_count = 1;  /* sub_count shadows memory,
                                          * so use expr_count instead.
				                          */
					i3->nexti = NULL;
					i2->opcode = Op_no_op;
					bcfree(i1);          /* Op_assign */
					exp->lasti = i3;     /* update Op_list */
					return exp;
				}
			}
			break;

		case Op_push_lhs:
			if (i2->nexti == i1
					&& i1->opcode == Op_assign
			) {
				/* var = .. */
				i2->opcode = Op_store_var;
				i2->nexti = NULL;
				bcfree(i1);          /* Op_assign */
				exp->lasti = i2;     /* update Op_list */

				i3 = exp->nexti;
				if (i3->opcode == Op_push_i
					&& (i3->memory->flags & INTLSTR) == 0
					&& i3->nexti == i2
				) {
					/* constant initializer */
					i2->initval = i3->memory;
					bcfree(i3);
					exp->nexti = i2;
				} else
					i2->initval = NULL;

				return exp;
			}
			break;

		default:
			break;
		}
	}

	/* no optimization  */
	return list_append(exp, instruction(Op_pop));
}


/* mk_getline --- make instructions for getline */

static INSTRUCTION *
mk_getline(INSTRUCTION *op, INSTRUCTION *var, INSTRUCTION *redir, int redirtype)
{
	INSTRUCTION *ip;
	INSTRUCTION *tp;
	INSTRUCTION *asgn = NULL;

	/*
	 *  getline [var] < [file]
	 *
	 *  [ file (simp_exp)]
	 *  [ [ var ] ]
	 *  [ Op_K_getline_redir|NULL|redir_type|into_var]
	 *  [ [var_assign] ]
	 *
	 */

	if (redir == NULL) {
		int sline = op->source_line;
		bcfree(op);
		op = bcalloc(Op_K_getline, 2, sline);
		(op + 1)->target_endfile = ip_endfile;
		(op + 1)->target_beginfile = ip_beginfile;
	}

	if (var != NULL) {
		tp = make_assignable(var->lasti);
		assert(tp != NULL);

		/* check if we need after_assign bytecode */
		if (tp->opcode == Op_push_lhs
				&& tp->memory->type == Node_var
				&& tp->memory->var_assign
		) {
			asgn = instruction(Op_var_assign);
			asgn->assign_ctxt = op->opcode;
			asgn->assign_var = tp->memory->var_assign;
		} else if (tp->opcode == Op_field_spec_lhs) {
			asgn = instruction(Op_field_assign);
			asgn->assign_ctxt = op->opcode;
			asgn->field_assign = (Func_ptr) 0;   /* determined at run time */
			tp->target_assign = asgn;
		} else if (tp->opcode == Op_subscript_lhs) {
			asgn = instruction(Op_subscript_assign);
			asgn->assign_ctxt = op->opcode;
		}

		if (redir != NULL) {
			ip = list_merge(redir, var);
			(void) list_append(ip, op);
		} else
			ip = list_append(var, op);
	} else if (redir != NULL)
		ip = list_append(redir, op);
	else
		ip = list_create(op);
	op->into_var = (var != NULL);
	op->redir_type = (redir != NULL) ? redirtype : redirect_none;

	return (asgn == NULL ? ip : list_append(ip, asgn));
}


/* mk_for_loop --- for loop bytecodes */

static INSTRUCTION *
mk_for_loop(INSTRUCTION *forp, INSTRUCTION *init, INSTRUCTION *cond,
				INSTRUCTION *incr, INSTRUCTION *body)
{
	/*
	 *   ------------------------
	 *        init                 (may be NULL)
	 *   ------------------------
	 * x:
	 *        cond                 (Op_no_op if NULL)
	 *   ------------------------
	 *    [ Op_jmp_false tb      ]
	 *   ------------------------
	 *        body                 (may be NULL)
	 *   ------------------------
	 * tc:
	 *    incr                      (may be NULL)
	 *    [ Op_jmp x             ]
	 *   ------------------------
	 * tb:[ Op_no_op             ]
	 */

	INSTRUCTION *ip, *tbreak, *tcont;
	INSTRUCTION *jmp;
	INSTRUCTION *pp_cond;
	INSTRUCTION *ret;

	tbreak = instruction(Op_no_op);

	if (cond != NULL) {
		add_lint(cond, LINT_assign_in_cond);
		pp_cond = cond->nexti;
		ip = cond;
		(void) list_append(ip, instruction(Op_jmp_false));
		ip->lasti->target_jmp = tbreak;
	} else {
		pp_cond = instruction(Op_no_op);
		ip = list_create(pp_cond);
	}

	if (init != NULL)
		ip = list_merge(init, ip);

	if (do_pretty_print) {
		(void) list_append(ip, instruction(Op_exec_count));
		(forp + 1)->forloop_cond = pp_cond;
		(forp + 1)->forloop_body = ip->lasti;
	}

	if (body != NULL)
		(void) list_merge(ip, body);

	jmp = instruction(Op_jmp);
	jmp->target_jmp = pp_cond;
	if (incr == NULL)
		tcont = jmp;
	else {
		tcont = incr->nexti;
		(void) list_merge(ip, incr);
	}

	(void) list_append(ip, jmp);
	ret = list_append(ip, tbreak);
	fix_break_continue(ret, tbreak, tcont);

	if (do_pretty_print) {
		forp->target_break = tbreak;
		forp->target_continue = tcont;
		ret = list_prepend(ret, forp);
	}
	/* else
		forp is NULL */

	return ret;
}

/* add_lint --- add lint warning bytecode if needed */

static void
add_lint(INSTRUCTION *list, LINTTYPE linttype)
{
#ifndef NO_LINT
	INSTRUCTION *ip;
	bool no_effect = true;

	switch (linttype) {
	case LINT_assign_in_cond:
		ip = list->lasti;
		if (ip->opcode == Op_var_assign || ip->opcode == Op_field_assign) {
			assert(ip != list->nexti);
			for (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti)
				;
		}

		if (ip->opcode == Op_assign || ip->opcode == Op_assign_concat) {
			list_append(list, instruction(Op_lint));
			list->lasti->lint_type = linttype;
		}
		break;

	case LINT_no_effect:
		if (list->lasti->opcode == Op_pop && list->nexti != list->lasti) {
			int line = 0;

			// Get down to the last instruction ...
			for (ip = list->nexti; ip->nexti != list->lasti; ip = ip->nexti) {
				// ... along the way track line numbers, we will use the line
				// closest to the opcode if that opcode doesn't have one
				if (ip->source_line != 0)
					line = ip->source_line;

				// And check each opcode for no effect
				no_effect = no_effect && isnoeffect(ip->opcode);
			}

			// check the last one also
			no_effect = no_effect && isnoeffect(ip->opcode);

			// Only if all the traversed opcodes have no effect do we
			// produce a warning. This avoids warnings for things like
			// a == b && b = c.
			if (do_lint) {		/* parse-time warning */
				if (no_effect) {
					if (ip->source_line != 0)
						line = ip->source_line;
					lintwarn_ln(line, _("statement has no effect"));
				}
			}

			// We no longer place a run-time warning also. One warning
			// at parse time is enough.
		}
		break;

	default:
		break;
	}
#endif
}

/* mk_expression_list --- list of bytecode lists */

static INSTRUCTION *
mk_expression_list(INSTRUCTION *list, INSTRUCTION *s1)
{
	INSTRUCTION *r;

	/* we can't just combine all bytecodes, since we need to
	 * process individual expressions for a few builtins in snode() (-:
	 */

	/* -- list of lists     */
	/* [Op_list| ... ]------
	 *                       |
	 * [Op_list| ... ]   --  |
	 *  ...               |  |
	 *  ...       <-------   |
	 * [Op_list| ... ]   --  |
	 *  ...               |  |
	 *  ...               |  |
	 *  ...       <------- --
	 */

	assert(s1 != NULL && s1->opcode == Op_list);
	if (list == NULL) {
		list = instruction(Op_list);
		list->nexti = s1;
		list->lasti = s1->lasti;
		return list;
	}

	/* append expression to the end of the list */

	r = list->lasti;
	r->nexti = s1;
	list->lasti = s1->lasti;
	return list;
}

/* count_expressions --- fixup expression_list from mk_expression_list.
 *                       returns no of expressions in list. isarg is true
 *                       for function arguments.
 */

static int
count_expressions(INSTRUCTION **list, bool isarg)
{
	INSTRUCTION *expr;
	INSTRUCTION *r = NULL;
	int count = 0;

	if (*list == NULL)	/* error earlier */
		return 0;

	for (expr = (*list)->nexti; expr; ) {
		INSTRUCTION *t1, *t2;
		t1 = expr->nexti;
		t2 = expr->lasti;
		if (isarg && t1 == t2 && t1->opcode == Op_push)
			t1->opcode = Op_push_param;
		if (++count == 1)
			r = expr;
		else
			(void) list_merge(r, expr);
		expr = t2->nexti;
	}

	assert(count > 0);
	if (! isarg && count > max_args)
		max_args = count;
	bcfree(*list);
	*list = r;
	return count;
}

/* fix_break_continue --- fix up break & continue codes in loop bodies */

static void
fix_break_continue(INSTRUCTION *list, INSTRUCTION *b_target, INSTRUCTION *c_target)
{
	INSTRUCTION *ip;

	list->lasti->nexti = NULL;	/* just to make sure */

	for (ip = list->nexti; ip != NULL; ip = ip->nexti) {
		switch (ip->opcode) {
		case Op_K_break:
			if (ip->target_jmp == NULL)
				ip->target_jmp = b_target;
			break;

		case Op_K_continue:
			if (ip->target_jmp == NULL)
				ip->target_jmp = c_target;
			break;

		default:
			/* this is to keep the compiler happy. sheesh. */
			break;
		}
	}
}

static inline INSTRUCTION *
list_create(INSTRUCTION *x)
{
	INSTRUCTION *l;

	l = instruction(Op_list);
	l->nexti = x;
	l->lasti = x;
	return l;
}

static inline INSTRUCTION *
list_append(INSTRUCTION *l, INSTRUCTION *x)
{
#ifdef GAWKDEBUG
	if (l->opcode != Op_list)
		cant_happen("unexpected value %s for opcode", opcode2str(l->opcode));
#endif
	l->lasti->nexti = x;
	l->lasti = x;
	return l;
}

static inline INSTRUCTION *
list_prepend(INSTRUCTION *l, INSTRUCTION *x)
{
#ifdef GAWKDEBUG
	if (l->opcode != Op_list)
		cant_happen("unexpected value %s for opcode", opcode2str(l->opcode));
#endif
	x->nexti = l->nexti;
	l->nexti = x;
	return l;
}

static inline INSTRUCTION *
list_merge(INSTRUCTION *l1, INSTRUCTION *l2)
{
#ifdef GAWKDEBUG
	if (l1->opcode != Op_list)
		cant_happen("unexpected value %s for opcode", opcode2str(l1->opcode));
	if (l2->opcode != Op_list)
		cant_happen("unexpected value %s for opcode", opcode2str(l2->opcode));
#endif
	l1->lasti->nexti = l2->nexti;
	l1->lasti = l2->lasti;
	bcfree(l2);
	return l1;
}

/* See if name is a special token. */

int
check_special(const char *name)
{
	int low, high, mid;
	int i;
	int non_standard_flags = 0;
#ifdef USE_EBCDIC
	static bool did_sort = false;

	if (! did_sort) {
		qsort((void *) tokentab,
				sizeof(tokentab) / sizeof(tokentab[0]),
				sizeof(tokentab[0]), tokcompare);
		did_sort = true;
	}
#endif

	if (do_traditional)
		non_standard_flags |= GAWKX;
	if (do_posix)
		non_standard_flags |= NOT_POSIX;

	low = 0;
	high = (sizeof(tokentab) / sizeof(tokentab[0])) - 1;
	while (low <= high) {
		mid = (low + high) / 2;
		i = *name - tokentab[mid].operator[0];
		if (i == 0)
			i = strcmp(name, tokentab[mid].operator);

		if (i < 0)		/* token < mid */
			high = mid - 1;
		else if (i > 0)		/* token > mid */
			low = mid + 1;
		else {
			if ((tokentab[mid].flags & non_standard_flags) != 0)
				return -1;
			return mid;
		}
	}
	return -1;
}

/*
 * This provides a private version of functions that act like VMS's
 * variable-length record filesystem, where there was a bug on
 * certain source files.
 */

static FILE *fp = NULL;

/* read_one_line --- return one input line at a time. mainly for debugging. */

static ssize_t
read_one_line(int fd, void *buffer, size_t count)
{
	char buf[BUFSIZ];

	/* Minor potential memory leak here. Too bad. */
	if (fp == NULL) {
		fp = fdopen(fd, "r");
		if (fp == NULL) {
			fprintf(stderr, "ugh. fdopen: %s\n", strerror(errno));
			gawk_exit(EXIT_FAILURE);
		}
	}

	if (fgets(buf, sizeof buf, fp) == NULL)
		return 0;

	memcpy(buffer, buf, strlen(buf));
	return strlen(buf);
}

/* one_line_close --- close the open file being read with read_one_line() */

static int
one_line_close(int fd)
{
	int ret;

	if (fp == NULL || fd != fileno(fp))
		fatal("debugging read/close screwed up!");

	ret = fclose(fp);
	fp = NULL;
	return ret;
}


/* lookup_builtin --- find a builtin function or return NULL */

builtin_func_t
lookup_builtin(const char *name)
{
	if (strncmp(name, "awk::", 5) == 0)
		name += 5;

	int mid = check_special(name);

	if (mid == -1)
		return NULL;

	switch (tokentab[mid].class) {
	case LEX_BUILTIN:
	case LEX_LENGTH:
		break;
	default:
		return NULL;
	}

	/* And another special case... */
	if (tokentab[mid].value == Op_sub_builtin)
		return (builtin_func_t) do_sub;

#ifdef HAVE_MPFR
	if (do_mpfr && tokentab[mid].ptr2 != NULL)
		return tokentab[mid].ptr2;
#endif

	return tokentab[mid].ptr;
}

/* install_builtins --- add built-in functions to FUNCTAB */

void
install_builtins(void)
{
	int i, j;
	int flags_that_must_be_clear = DEBUG_USE;

	if (do_traditional)
		flags_that_must_be_clear |= GAWKX;

	if (do_posix)
		flags_that_must_be_clear |= NOT_POSIX;


	j = sizeof(tokentab) / sizeof(tokentab[0]);
	for (i = 0; i < j; i++) {
		if (   (tokentab[i].class == LEX_BUILTIN
		        || tokentab[i].class == LEX_LENGTH)
		    && (tokentab[i].flags & flags_that_must_be_clear) == 0) {
			(void) install_symbol(tokentab[i].operator, Node_builtin_func);
		}
	}
}

/*
 * 9/2014: Gawk cannot use <ctype.h> isalpha or isalnum when
 * parsing the program since that can let through non-English
 * letters.  So, we supply our own. !@#$%^&*()-ing locales!
 */

/* is_alpha --- return true if c is an English letter */

/*
 * The scene of the murder was grisly to look upon.  When the inspector
 * arrived, the sergeant turned to him and said, "Another programmer stabbed
 * in the back. He never knew what happened."
 *
 * The inspector replied, "Looks like the MO of isalpha, and his even meaner
 * big brother, isalnum. The Locale brothers."  The sergeant merely
 * shuddered in horror.
 */

bool
is_alpha(int c)
{
	switch (c) {
	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
	case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
	case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
	case 's': case 't': case 'u': case 'v': case 'w': case 'x':
	case 'y': case 'z':
	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
	case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
	case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
	case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
	case 'Y': case 'Z':
		return true;
	}
	return false;
}

/* is_alnum --- return true for alphanumeric, English only letters */

bool
is_alnum(int c)
{
	/* digit test is good for EBCDIC too. so there. */
	return (is_alpha(c) || ('0' <= c && c <= '9'));
}


/*
 * is_letter --- function to check letters
 *	isalpha() isn't good enough since it can look at the locale.
 * Underscore counts as a letter in awk identifiers
 */

bool
is_letter(int c)
{
	return (is_alpha(c) || c == '_');
}

/* is_identchar --- return true if c can be in an identifier */

bool
is_identchar(int c)
{
	return (is_alnum(c) || c == '_');
}

/* set_profile_text --- make a number that can be printed when profiling */

static NODE *
set_profile_text(NODE *n, const char *str, size_t len)
{
	if (do_pretty_print) {
		// two extra bytes: one for NUL termination, and another in
		// case we need to add a leading minus sign in add_sign_to_num
		emalloc(n->stptr, char *, len + 2);
		memcpy(n->stptr, str, len);
		n->stptr[len] = '\0';
		n->stlen = len;
		// Set STRCUR and n->stfmt for use when profiling
		// (i.e., actually running the program) so that
		// force_string() on this item will work ok.
		// Thanks and a tip of the hatlo to valgrind.
		n->flags |= (NUMCONSTSTR|STRCUR);
		n->stfmt = STFMT_UNUSED;
#ifdef HAVE_MPFR
		n->strndmode = MPFR_round_mode;
#endif
	}

	return n;
}

/*
 * merge_comments --- merge c2 into c1 and free c2 if successful.
 *	Allow c2 to be NULL, in which case just merged chained
 *	comments in c1.
 */

static void
merge_comments(INSTRUCTION *c1, INSTRUCTION *c2)
{
	assert(c1->opcode == Op_comment);

	if (c1->comment == NULL && c2 == NULL)	// nothing to do
		return;

	size_t total = c1->memory->stlen;
	if (c1->comment != NULL)
		total += 1 /* \n */ + c1->comment->memory->stlen;

	if (c2 != NULL) {
		assert(c2->opcode == Op_comment);
		total += 1 /* \n */ + c2->memory->stlen;
		if (c2->comment != NULL)
			total += c2->comment->memory->stlen + 1;
	}

	char *buffer;
	emalloc(buffer, char *, total + 1);

	strcpy(buffer, c1->memory->stptr);
	if (c1->comment != NULL) {
		strcat(buffer, "\n");
		strcat(buffer, c1->comment->memory->stptr);
	}

	if (c2 != NULL) {
		strcat(buffer, c2->memory->stptr);
		if (c2->comment != NULL) {
			strcat(buffer, "\n");
			strcat(buffer, c2->comment->memory->stptr);
		}

		unref(c2->memory);
		if (c2->comment != NULL) {
			unref(c2->comment->memory);
			bcfree(c2->comment);
			c2->comment = NULL;
		}
		bcfree(c2);
	}

	c1->memory->comment_type = BLOCK_COMMENT;
	free(c1->memory->stptr);
	c1->memory->stptr = buffer;
	c1->memory->stlen = strlen(buffer);

	// now free everything else
	if (c1->comment != NULL) {
		unref(c1->comment->memory);
		bcfree(c1->comment);
		c1->comment = NULL;
	}
}

/* make_braced_statements --- handle `l_brace statements r_brace' with comments */

static INSTRUCTION *
make_braced_statements(INSTRUCTION *lbrace, INSTRUCTION *stmts, INSTRUCTION *rbrace)
{
	INSTRUCTION *ip;

	if (stmts == NULL)
		ip = list_create(instruction(Op_no_op));
	else
		ip = stmts;

	if (lbrace != NULL) {
		INSTRUCTION *comment2 = lbrace->comment;
		if (comment2 != NULL) {
			ip = list_prepend(ip, comment2);
			lbrace->comment = NULL;
		}
		ip = list_prepend(ip, lbrace);
	}

	return ip;
}

/* validate_qualified_name --- make sure that a qualified name is built correctly */

/*
 * This routine returns upon first error, no need to produce multiple, possibly
 * conflicting / confusing error messages.
 */

bool
validate_qualified_name(char *token)
{
	char *cp, *cp2;

	// no colon, by definition it's well formed
	if ((cp = strchr(token, ':')) == NULL)
		return true;

	if (do_traditional || do_posix) {
		error_ln(sourceline, _("identifier %s: qualified names not allowed in traditional / POSIX mode"), token);
		return false;
	}

	if (cp[1] != ':') {	// could happen from command line
		error_ln(sourceline, _("identifier %s: namespace separator is two colons, not one"), token);
		return false;
	}

	if (! is_letter(cp[2])) {
		error_ln(sourceline,
				_("qualified identifier `%s' is badly formed"),
				token);
		return false;
	}

	if ((cp2 = strchr(cp+2, ':')) != NULL) {
		error_ln(sourceline,
			_("identifier `%s': namespace separator can only appear once in a qualified name"),
			token);
		return false;
	}

	return true;
}

/* check_qualified_special --- decide if a name is special or not */

static int
check_qualified_special(char *token)
{
	char *cp;

	if ((cp = strchr(token, ':')) == NULL && current_namespace == awk_namespace)
		return check_special(token);

	/*
	 * Now it's more complicated.  Here are the rules.
	 *
	 * 1. Namespace name cannot be a standard awk reserved word or function.
	 * 2. Subordinate part of the name cannot be a standard awk reserved word or function.
	 * 3. If the namespace part is explicitly "awk", return the result of check_special().
	 * 4. Else return -1 (gawk extensions allowed, we check standard awk in step 2).
	 */

	const struct token *tok;
	int i;
	if (cp == NULL) {	// namespace not awk, but a simple identifier
		i = check_special(token);
		if (i < 0)
			return i;

		tok = & tokentab[i];
		if ((tok->flags & GAWKX) != 0 && tok->class == LEX_BUILTIN)
			return -1;
		else
			return i;
	}

	char *ns, *end, *subname;
	ns = token;
	*(end = cp) = '\0';	// temporarily turn it into standalone string
	subname = end + 2;

	// First check the namespace part
	i = check_special(ns);
	if (i >= 0 && (tokentab[i].flags & GAWKX) == 0) {
		error_ln(sourceline, _("using reserved identifier `%s' as a namespace is not allowed"), ns);
		goto done;
	}

	// Now check the subordinate part
	i = check_special(subname);
	if (i >= 0 && (tokentab[i].flags & GAWKX) == 0 && strcmp(ns, awk_namespace) != 0) {
		error_ln(sourceline, _("using reserved identifier `%s' as second component of a qualified name is not allowed"), subname);
		goto done;
	}

	if (strcmp(ns, awk_namespace) == 0) {
		i = check_special(subname);
		if (i >= 0) {
			if ((tokentab[i].flags & GAWKX) != 0 && tokentab[i].class == LEX_BUILTIN)
				;	// gawk additional builtin function, is ok
			else
				error_ln(sourceline, _("using reserved identifier `%s' as second component of a qualified name is not allowed"), subname);
		}
	} else
		i = -1;
done:
	*end = ':';
	return i;
}

/* set_namespace --- update namespace data structures */

static void
set_namespace(INSTRUCTION *ns, INSTRUCTION *comment)
{
	if (ns == NULL)
		return;

	if (do_traditional || do_posix) {
		error_ln(ns->source_line, _("@namespace is a gawk extension"));
		efree(ns->lextok);
		bcfree(ns);
		return;
	}

	if (! is_valid_identifier(ns->lextok)) {
		error_ln(ns->source_line, _("namespace name `%s' must meet identifier naming rules"), ns->lextok);
		efree(ns->lextok);
		bcfree(ns);
		return;
	}

	int mid = check_special(ns->lextok);

	if (mid >= 0) {
		error_ln(ns->source_line, _("using reserved identifier `%s' as a namespace is not allowed"), ns->lextok);
		efree(ns->lextok);
		bcfree(ns);
		return;
	}

	// Actual changing of namespace is done earlier.
	// See comments in the production and in yylex().

	efree(ns->lextok);

	// save info and push on front of list of namespaces seen
	push_ns_onto_namespace_chain(comment);

	ns->lextok = NULL;
	bcfree(ns);

	return;
}

/* change_namespace --- change the current namespace */

static void
change_namespace(const char *new_namespace)
{
	/* error messages will come from set_namespace(), above */

	if (! is_valid_identifier(new_namespace))
		return;

	int mid = check_special(new_namespace);

	if (mid >= 0)
		return;

	if (strcmp(new_namespace, current_namespace) == 0)
		;	// nothing to do
	else if (strcmp(new_namespace, awk_namespace) == 0) {
		set_current_namespace(awk_namespace);
	} else {
		set_current_namespace(estrdup(new_namespace, strlen(new_namespace)));
	}

	namespace_changed = true;
}

/* qualify_name --- put name into namespace */

static char *
qualify_name(const char *name, size_t len)
{
	if (strchr(name, ':') != NULL)	// already qualified
		return estrdup(name, len);

	NODE *p = lookup(name);
	if (p != NULL && p->type == Node_param_list)
		return estrdup(name, len);

	if (current_namespace != awk_namespace && ! is_all_upper(name)) {
		size_t length = strlen(current_namespace) + 2 + len + 1;
		char *buf;

		emalloc(buf, char *, length);
		sprintf(buf, "%s::%s", current_namespace, name);

		return buf;
	}

	return estrdup(name, len);
}
/*
 * builtin.c - Builtin functions and various utility procedures.
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */


#include "awk.h"
#if defined(HAVE_FCNTL_H)
#include <fcntl.h>
#endif
#include "random.h"

#if defined(HAVE_POPEN_H)
#include "popen.h"
#endif

#ifndef CHAR_BIT
# define CHAR_BIT 8
#endif

/* The extra casts work around common compiler bugs.  */
#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
/* Note:  these assume that negative integers are represented internally
   via 2's complement, which is not mandated by C.  They also ignore the
   fact that signed integer arithmetic overflow can trigger exceptions,
   unlike unsigned which is guaranteed not to do so. */
#define TYPE_MINIMUM(t) ((t) (TYPE_SIGNED (t) \
			      ? ~ (uintmax_t) 0 << (sizeof (t) * CHAR_BIT - 1) \
			      : 0))
#define TYPE_MAXIMUM(t) ((t) (~ (t) 0 - TYPE_MINIMUM (t)))

#ifndef INTMAX_MIN
# define INTMAX_MIN TYPE_MINIMUM (intmax_t)
#endif
#ifndef UINTMAX_MAX
# define UINTMAX_MAX TYPE_MAXIMUM (uintmax_t)
#endif

#ifndef SIZE_MAX	/* C99 constant, can't rely on it everywhere */
#define SIZE_MAX ((size_t) -1)
#endif

/* Can declare these, since we always use the random shipped with gawk */
extern char *initstate(unsigned long seed, char *state, long n);
extern char *setstate(char *state);
extern long random(void);
extern void srandom(unsigned long seed);

extern NODE **args_array;
extern int max_args;
extern NODE **fields_arr;
extern bool output_is_tty;
extern FILE *output_fp;

static int gawk_system(const char *command);

#define POP_TWO_SCALARS(s1, s2) \
s2 = POP_SCALAR(); \
s1 = POP(); \
do { if (s1->type == Node_var_array) { \
DEREF(s2); \
fatal(_("attempt to use array `%s' in a scalar context"), array_vname(s1)); \
}} while (false)


/* check argument counts --- for use when called indirectly */

void
check_exact_args(int nargs, const char *fname, int count)
{
	if (nargs != count)
		fatal(_("%s: called with %d arguments"), fname, nargs);
}

void
check_args_min_max(int nargs, const char *fname, int min, int max)
{
	if (nargs < min || nargs > max)
		fatal(_("%s: called with %d arguments"), fname, nargs);
}

/*
 * Since we supply the version of random(), we know what
 * value to use here.
 */
#define GAWK_RANDOM_MAX 0x7fffffffL


/* wrerror --- handle a write or flush error */

static void
wrerror(FILE *fp, const char *from, struct redirect *rp)
{
	os_maybe_set_errno();

	/* for stdout, die with a real SIGPIPE, like other awks */
	if (fp == stdout && errno == EPIPE)
		die_via_sigpipe();

	/* otherwise die verbosely */
	if ((rp != NULL) ? is_non_fatal_redirect(rp->value, strlen(rp->value)) : is_non_fatal_std(fp))
		update_ERRNO_int(errno);
	else
		fatal(_("%s to \"%s\" failed: %s"), from,
			rp != NULL
				? rp->value
				: fp == stdout
					? _("standard output")
					: _("standard error"),
			errno ? strerror(errno) : _("reason unknown"));
}

/* efflush --- flush output with proper error handling */

void
efflush(FILE *fp, const char *from, struct redirect *rp)
{
	errno = 0;
	if (rp != NULL) {
		rp->output.gawk_fflush(fp, rp->output.opaque);
		if (rp->output.gawk_ferror(fp, rp->output.opaque))
			wrerror(fp, from, rp);
	} else {
		fflush(fp);
		if (ferror(fp))
			wrerror(fp, from, rp);
	}
}

/* efwrite --- like fwrite, but with error checking */

void
efwrite(const void *ptr,
	size_t size,
	size_t count,
	FILE *fp,
	const char *from,
	struct redirect *rp,
	bool flush)
{
	errno = 0;
	if (rp != NULL) {
		/*
		 * 7/2022: We need to also check ferror(); there can be times when write(2) fails but
		 * fwrite succeeds!  To do that, we make sure that rp->output.gawk_fwrite is not
		 * taken over by an extension before checking ferror().  From the bug report
		 * (https://lists.gnu.org/archive/html/bug-gawk/2022-07/msg00000.html):
		 *
		 * Minimal working example:
		 * yes | stdbuf -oL gawk '{print}' | head -n1 # Prints but hangs
		 * yes | stdbuf -o0 gawk '{print}' | head -n1 # OK
		 * yes | gawk '{print; fflush()}'  | head -n1 # OK
		 *
		 * After this change, all three work.
		 */
		bool err_on_write = (rp->output.gawk_fwrite(ptr, size, count, fp, rp->output.opaque) != count);
		bool err_on_fp = (rp->output.gawk_fwrite == gawk_fwrite && ferror(fp));

		if (err_on_write || err_on_fp) {
			wrerror(fp, from, rp);
			return;
		}
	} else if (fwrite(ptr, size, count, fp) != count || ferror(fp)) {
		wrerror(fp, from, rp);
		return;
	}
	if (flush
	  && ((fp == stdout && output_is_tty)
	      || (rp != NULL && (rp->flag & RED_FLUSH) != 0)))
		efflush(fp, from, rp);
}

/* do_exp --- exponential function */

NODE *
do_exp(int nargs)
{
	NODE *tmp;
	double d, res;

	check_exact_args(nargs, "exp", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "exp");
	d = force_number(tmp)->numbr;
	DEREF(tmp);
	errno = 0;
	res = exp(d);
	if (errno == ERANGE)
		warning(_("exp: argument %g is out of range"), d);
	return make_number((AWKNUM) res);
}

/* stdfile --- return fp for a standard file */

/*
 * This function allows `fflush("/dev/stdout")' to work.
 * The other files will be available via getredirect().
 * /dev/stdin is not included, since fflush is only for output.
 */

static FILE *
stdfile(const char *name, size_t len)
{
	if (len == 11) {
		if (strncmp(name, "/dev/stderr", 11) == 0)
			return stderr;
		else if (strncmp(name, "/dev/stdout", 11) == 0)
			return stdout;
	}

	return NULL;
}

/* do_fflush --- flush output, either named file or pipe or everything */

NODE *
do_fflush(int nargs)
{
	struct redirect *rp;
	NODE *tmp;
	FILE *fp;
	int status = 0;
	const char *file;
	int len;

	/*
	 * November, 2012.
	 * It turns out that circa 2002, when BWK
	 * added fflush() and fflush("") to his awk, he made both of
	 * them flush everything.
	 *
	 * Now, with our inside agent getting ready to try to get fflush()
	 * standardized in POSIX, we are going to make our awk consistent
	 * with his.  This should not really affect anyone, as flushing
	 * everything also flushes stdout.
	 *
	 * So. Once upon a time:
	 * 	fflush()	--- flush stdout
	 * 	fflush("")	--- flush everything
	 * Now, both calls flush everything.
	 */

	check_args_min_max(nargs, "fflush", 0, 1);

	/* fflush() */
	if (nargs == 0) {
		status = flush_io();	// ERRNO updated
		return make_number((AWKNUM) status);
	}

	tmp = POP_STRING();
	if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string argument"), "fflush");
	file = tmp->stptr;
	len = tmp->stlen;

	/* fflush("") */
	if (tmp->stlen == 0) {
		status = flush_io();	// ERRNO updated
		DEREF(tmp);
		return make_number((AWKNUM) status);
	}

	/* fflush("/some/path") */
	rp = getredirect(tmp->stptr, tmp->stlen);
	status = -1;
	if (rp != NULL) {
		if ((rp->flag & (RED_WRITE|RED_APPEND)) == 0) {
			if ((rp->flag & RED_PIPE) != 0)
				warning(_("fflush: cannot flush: pipe `%.*s' opened for reading, not writing"),
					len, file);
			else
				warning(_("fflush: cannot flush: file `%.*s' opened for reading, not writing"),
					len, file);
			DEREF(tmp);
			return make_number((AWKNUM) status);
		}
		fp = rp->output.fp;
		if (fp != NULL) {
			status = rp->output.gawk_fflush(fp, rp->output.opaque);

			if (status != 0) {
				if (! is_non_fatal_redirect(tmp->stptr, tmp->stlen))
					fatal(_("fflush: cannot flush file `%.*s': %s"),
						len, file, strerror(errno));
				update_ERRNO_int(errno);
			}
		} else if ((rp->flag & RED_TWOWAY) != 0)
				warning(_("fflush: cannot flush: two-way pipe `%.*s' has closed write end"),
					len, file);
	} else if ((fp = stdfile(tmp->stptr, tmp->stlen)) != NULL) {
		status = (non_fatal_flush_std_file(fp) == false);
	} else {
		status = -1;
		warning(_("fflush: `%.*s' is not an open file, pipe or co-process"), len, file);
	}
	DEREF(tmp);
	return make_number((AWKNUM) status);
}

/* strncasecmpmbs --- like strncasecmp (multibyte string version)  */

int
strncasecmpmbs(const unsigned char *s1, const unsigned char *s2, size_t n)
{
	size_t i1, i2, mbclen1, mbclen2, gap;
	wchar_t wc1, wc2;
	mbstate_t mbs1, mbs2;

	memset(& mbs1, 0, sizeof(mbs1));
	memset(& mbs2, 0, sizeof(mbs2));

	for (i1 = i2 = 0 ; i1 < n && i2 < n ;i1 += mbclen1, i2 += mbclen2) {
		if (is_valid_character(s1[i1])) {
			mbclen1 = 1;
			wc1 = btowc_cache(s1[i1]);
		} else {
			mbclen1 = mbrtowc(& wc1, (const char *)s1 + i1,
					  n - i1, & mbs1);
			if (mbclen1 == (size_t) -1 || mbclen1 == (size_t) -2 || mbclen1 == 0) {
				/* We treat it as a singlebyte character. */
				mbclen1 = 1;
				wc1 = btowc_cache(s1[i1]);
			}
		}
		if (is_valid_character(s2[i2])) {
			mbclen2 = 1;
			wc2 = btowc_cache(s2[i2]);
		} else {
			mbclen2 = mbrtowc(& wc2, (const char *)s2 + i2,
					  n - i2, & mbs2);
			if (mbclen2 == (size_t) -1 || mbclen2 == (size_t) -2 || mbclen2 == 0) {
				/* We treat it as a singlebyte character. */
				mbclen2 = 1;
				wc2 = btowc_cache(s2[i2]);
			}
		}
		if ((gap = towlower(wc1) - towlower(wc2)) != 0)
			/* s1 and s2 are not equivalent. */
			return gap;
	}
	/* s1 and s2 are equivalent. */
	return 0;
}

/* Inspect the buffer `src' and write the index of each byte to `dest'.
   Caller must allocate `dest'.
   e.g. str = <mb1(1)>, <mb1(2)>, a, b, <mb2(1)>, <mb2(2)>, <mb2(3)>, c
        where mb(i) means the `i'-th byte of a multibyte character.
		dest =       1,        2, 1, 1,        1,        2,        3. 1
*/
static void
index_multibyte_buffer(char* src, char* dest, int len)
{
	int idx, prev_idx;
	mbstate_t mbs, prevs;

	memset(& prevs, 0, sizeof(mbstate_t));
	for (idx = prev_idx = 0 ; idx < len ; idx++) {
		size_t mbclen;
		mbs = prevs;
		mbclen = mbrlen(src + prev_idx, idx - prev_idx + 1, & mbs);
		if (mbclen == (size_t) -1 || mbclen == 1 || mbclen == 0) {
			/* singlebyte character.  */
			mbclen = 1;
			prev_idx = idx + 1;
		} else if (mbclen == (size_t) -2) {
			/* a part of a multibyte character.  */
			mbclen = idx - prev_idx + 1;
		} else if (mbclen > 1) {
			/* the end of a multibyte character.  */
			prev_idx = idx + 1;
			prevs = mbs;
		} else {
			/* Can't reach.  */
		}
		dest[idx] = mbclen;
    }
}

/* do_index --- find index of a string */

NODE *
do_index(int nargs)
{
	NODE *s1, *s2;
	const char *p1, *p2;
	size_t l1, l2;
	long ret;
	bool do_single_byte = false;
	mbstate_t mbs1, mbs2;

	check_exact_args(nargs, "index", 2);

	if (gawk_mb_cur_max > 1) {
		memset(& mbs1, 0, sizeof(mbstate_t));
		memset(& mbs2, 0, sizeof(mbstate_t));
	}

	POP_TWO_SCALARS(s1, s2);

	if (do_lint) {
		if ((fixtype(s1)->flags & (STRING|USER_INPUT)) == 0)
			lintwarn(_("%s: received non-string first argument"), "index");
		if ((fixtype(s2)->flags & (STRING|USER_INPUT)) == 0)
			lintwarn(_("%s: received non-string second argument"), "index");
	}

	s1 = force_string(s1);
	s2 = force_string(s2);

	p1 = s1->stptr;
	p2 = s2->stptr;
	l1 = s1->stlen;
	l2 = s2->stlen;
	ret = 0;

	/*
	 * Icky special case, index(foo, "") should return 1,
	 * since both bwk awk and mawk do, and since match("foo", "")
	 * returns 1. This makes index("", "") work, too, fwiw.
	 */
	if (l2 == 0) {
		ret = 1;
		goto out;
	}

	if (gawk_mb_cur_max > 1) {
		s1 = force_wstring(s1);
		s2 = force_wstring(s2);
		/*
		 * If we don't have valid wide character strings, use
		 * the real bytes.
		 */
		do_single_byte = ((s1->wstlen == 0 && s1->stlen > 0)
					|| (s2->wstlen == 0 && s2->stlen > 0));
	}

	/* IGNORECASE will already be false if posix */
	if (IGNORECASE) {
		while (l1 > 0) {
			if (l2 > l1)
				break;
			if (! do_single_byte && gawk_mb_cur_max > 1) {
				const wchar_t *pos;

				pos = wcasestrstr(s1->wstptr, s1->wstlen, s2->wstptr, s2->wstlen);
				if (pos == NULL)
					ret = 0;
				else
					ret = pos - s1->wstptr + 1;	/* 1-based */
				goto out;
			} else {
				/*
				 * Could use tolower(*p1) == tolower(*p2) here.
				 * See discussion in eval.c as to why not.
				 */
				if (casetable[(unsigned char)*p1] == casetable[(unsigned char)*p2]
				    && (l2 == 1 || strncasecmp(p1, p2, l2) == 0)) {
					ret = 1 + s1->stlen - l1;
					break;
				}
				l1--;
				p1++;
			}
		}
	} else {
		while (l1 > 0) {
			if (l2 > l1)
				break;
			if (*p1 == *p2
			    && (l2 == 1 || (l2 > 0 && memcmp(p1, p2, l2) == 0))) {
				ret = 1 + s1->stlen - l1;
				break;
			}
			if (! do_single_byte && gawk_mb_cur_max > 1) {
				const wchar_t *pos;

				pos = wstrstr(s1->wstptr, s1->wstlen, s2->wstptr, s2->wstlen);
				if (pos == NULL)
					ret = 0;
				else
					ret = pos - s1->wstptr + 1;	/* 1-based */
				goto out;
			} else {
				l1--;
				p1++;
			}
		}
	}
out:
	DEREF(s1);
	DEREF(s2);
	return make_number((AWKNUM) ret);
}

/* double_to_int --- convert double to int, used several places */

double
double_to_int(double d)
{
	if (d >= 0)
		d = floor(d);
	else
		d = ceil(d);
	return d;
}

/* do_int --- convert double to int for awk */

NODE *
do_int(int nargs)
{
	NODE *tmp;
	double d;

	check_exact_args(nargs, "int", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "int");
	d = force_number(tmp)->numbr;
	d = double_to_int(d);
	DEREF(tmp);
	return make_number((AWKNUM) d);
}

/* do_isarray --- check if argument is array */

NODE *
do_isarray(int nargs)
{
	NODE *tmp;
	int ret = 1;

	check_exact_args(nargs, "isarray", 1);

	tmp = POP();

	if (tmp->type == Node_param_list) {
		tmp = GET_PARAM(tmp->param_cnt);
		if (tmp->type == Node_array_ref) {
			tmp = tmp->orig_array;
		}
	}

	if (tmp->type != Node_var_array) {
		ret = 0;
		// could be Node_var_new
		if (tmp->type == Node_val)
			DEREF(tmp);
	}
	return make_number((AWKNUM) ret);
}

/* do_length --- length of a string, array or $0 */

NODE *
do_length(int nargs)
{
	NODE *tmp;
	size_t len;

	check_exact_args(nargs, "length", 1);

	tmp = POP();
	if (tmp->type == Node_var_array) {
		static bool warned = false;
		unsigned long size;

		if (do_posix)
			fatal(_("length: received array argument"));
   		if (do_lint_extensions && ! warned) {
			warned = true;
			lintwarn(_("`length(array)' is a gawk extension"));
		}

		/*
		 * Support for deferred loading of array elements requires that
		 * we use the array length interface even though it isn't
		 * necessary for the built-in array types.
		 *
		 * 1/2015: The deferred arrays are gone, but this is probably
		 * still a good idea.
		 */

		size = assoc_length(tmp);
		return make_number(size);
	} else if (tmp->type == Node_var_new || tmp->type == Node_elem_new) {
		// this can happen from an indirect call
		DEREF(tmp);
		tmp = dupnode(Nnull_string);
	}

	assert(tmp->type == Node_val);

	if (do_lint && (fixtype(tmp)->flags & (STRING|USER_INPUT)) == 0)
		lintwarn(_("%s: received non-string argument"), "length");
	tmp = force_string(tmp);

	if (gawk_mb_cur_max > 1) {
		tmp = force_wstring(tmp);
		len = tmp->wstlen;
		/*
		 * If the bytes don't make a valid wide character
		 * string, fall back to the bytes themselves.
		 */
		 if (len == 0 && tmp->stlen > 0)
			 len = tmp->stlen;
	} else
		len = tmp->stlen;

	DEREF(tmp);
	return make_number((AWKNUM) len);
}

/* do_log --- the log function */

NODE *
do_log(int nargs)
{
	NODE *tmp;
	double d, arg;

	check_exact_args(nargs, "log", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "log");
	arg = force_number(tmp)->numbr;
	if (arg < 0.0)
		warning(_("%s: received negative argument %g"), "log", arg);
	d = log(arg);
	DEREF(tmp);
	return make_number((AWKNUM) d);
}

/* do_sqrt --- do the sqrt function */

NODE *
do_sqrt(int nargs)
{
	NODE *tmp;
	double arg;

	check_exact_args(nargs, "sqrt", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "sqrt");
	arg = (double) force_number(tmp)->numbr;
	DEREF(tmp);
	if (arg < 0.0)
		warning(_("%s: received negative argument %g"), "sqrt", arg);
	return make_number((AWKNUM) sqrt(arg));
}

/* do_substr --- do the substr function */

NODE *
do_substr(int nargs)
{
	NODE *t1;
	NODE *r;
	size_t indx;
	size_t length = 0;
	double d_index = 0, d_length = 0;
	size_t src_len;

	check_args_min_max(nargs, "substr", 2, 3);

	if (nargs == 3) {
		t1 = POP_NUMBER();
		if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric third argument"), "substr");
		d_length = get_number_d(t1);
		DEREF(t1);
	}

	t1 = POP_NUMBER();
	if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric second argument"), "substr");
	d_index = get_number_d(t1);
	DEREF(t1);

	t1 = POP_STRING();
	if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)
		lintwarn(_("%s: received non-string first argument"), "substr");

	if (nargs == 3) {
		if (! (d_length >= 1)) {
			if (do_lint == DO_LINT_ALL)
				lintwarn(_("substr: length %g is not >= 1"), d_length);
			else if (do_lint == DO_LINT_INVALID && ! (d_length >= 0))
				lintwarn(_("substr: length %g is not >= 0"), d_length);
			DEREF(t1);
			/*
			 * Return explicit null string instead of doing
			 * dupnode(Nnull_string) so that if the result
			 * is checked with the combination of length()
			 * and lint, no error is reported about using
			 * an uninitialized value. Same thing later, too.
			 */
			return make_string("", 0);
		}
		if (do_lint) {
			if (double_to_int(d_length) != d_length)
				lintwarn(
			_("substr: non-integer length %g will be truncated"),
					d_length);

			if (d_length > SIZE_MAX)
				lintwarn(
			_("substr: length %g too big for string indexing, truncating to %g"),
					d_length, (double) SIZE_MAX);
		}
		if (d_length < SIZE_MAX)
			length = d_length;
		else
			length = SIZE_MAX;
	}

	/* the weird `! (foo)' tests help catch NaN values. */
	if (! (d_index >= 1)) {
		if (do_lint)
			lintwarn(_("substr: start index %g is invalid, using 1"),
				 d_index);
		d_index = 1;
	}
	if (do_lint && double_to_int(d_index) != d_index)
		lintwarn(_("substr: non-integer start index %g will be truncated"),
			 d_index);

	/* awk indices are from 1, C's are from 0 */
	if (d_index <= SIZE_MAX)
		indx = d_index - 1;
	else
		indx = SIZE_MAX;

	if (nargs == 2) {	/* third arg. missing */
		/* use remainder of string */
		length = t1->stlen - indx;	/* default to bytes */
		if (gawk_mb_cur_max > 1) {
			t1 = force_wstring(t1);
			if (t1->wstlen > 0)	/* use length of wide char string if we have one */
				length = t1->wstlen - indx;
		}
		d_length = length;	/* set here in case used in diagnostics, below */
	}

	if (t1->stlen == 0) {
		/* substr("", 1, 0) produces a warning only if LINT_ALL */
		if (do_lint && (do_lint == DO_LINT_ALL || ((indx | length) != 0)))
			lintwarn(_("substr: source string is zero length"));
		DEREF(t1);
		return make_string("", 0);
	}

	/* get total len of input string, for following checks */
	if (gawk_mb_cur_max > 1) {
		t1 = force_wstring(t1);
		src_len = t1->wstlen;
	} else
		src_len = t1->stlen;

	if (indx >= src_len) {
		if (do_lint)
			lintwarn(_("substr: start index %g is past end of string"),
				d_index);
		DEREF(t1);
		return make_string("", 0);
	}
	if (length > src_len - indx) {
		if (do_lint)
			lintwarn(
	_("substr: length %g at start index %g exceeds length of first argument (%lu)"),
			d_length, d_index, (unsigned long int) src_len);
		length = src_len - indx;
	}

	/* force_wstring() already called */
	if (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)
		/* single byte case */
		r = make_string(t1->stptr + indx, length);
	else {
		/* multibyte case, more work */
		size_t result;
		wchar_t *wp;
		mbstate_t mbs;
		char *substr, *cp;

		/*
		 * Convert the wide chars in t1->wstptr back into m.b. chars.
		 * This is pretty grotty, but it's the most straightforward
		 * way to do things.
		 */
		memset(& mbs, 0, sizeof(mbs));
		emalloc(substr, char *, (length * gawk_mb_cur_max) + 1);
		wp = t1->wstptr + indx;
		for (cp = substr; length > 0; length--) {
			result = wcrtomb(cp, *wp, & mbs);
			if (result == (size_t) -1)	/* what to do? break seems best */
				break;
			cp += result;
			wp++;
		}
		*cp = '\0';
		r = make_str_node(substr, cp - substr, ALREADY_MALLOCED);
	}

	DEREF(t1);
	return r;
}

/* do_strftime --- format a time stamp */

NODE *
do_strftime(int nargs)
{
	NODE *t1, *t2, *t3, *ret;
	struct tm *tm;
	time_t fclock;
	double clock_val;
	char *bufp;
	size_t buflen, bufsize;
	char buf[BUFSIZ];
	const char *format;
	int formatlen;
	bool do_gmt;
	NODE *val = NULL;
	NODE *sub = NULL;
	char save = '\0';	// initialize to avoid compiler warnings
	static const time_t time_t_min = TYPE_MINIMUM(time_t);
	static const time_t time_t_max = TYPE_MAXIMUM(time_t);

	/* set defaults first */
	format = def_strftime_format;	/* traditional date format */
	formatlen = strlen(format);
	(void) time(& fclock);	/* current time of day */
	do_gmt = false;

	check_args_min_max(nargs, "strftime", 0, 3);

	if (PROCINFO_node != NULL) {
		sub = make_string("strftime", 8);
		val = in_array(PROCINFO_node, sub);
		unref(sub);

		if (val != NULL) {
			if (do_lint && (fixtype(val)->flags & (STRING|USER_INPUT)) == 0)
				lintwarn(_("strftime: format value in PROCINFO[\"strftime\"] has numeric type"));
			val = force_string(val);
			format = val->stptr;
			formatlen = val->stlen;
		}
	}

	t1 = t2 = t3 = NULL;
	if (nargs > 0) {	/* have args */
		NODE *tmp;

		if (nargs == 3) {
			t3 = POP_SCALAR();
			do_gmt = boolval(t3);
			// no lint check, we allow number or string to give us a boolean value
			DEREF(t3);
		}

		if (nargs >= 2) {
			t2 = POP_SCALAR();
			if (do_lint && (fixtype(t2)->flags & NUMBER) == 0)
				lintwarn(_("%s: received non-numeric second argument"), "strftime");
			(void) force_number(t2);
			clock_val = get_number_d(t2);
			fclock = (time_t) clock_val;
			/*
			 * Protect against negative value being assigned
			 * to unsigned time_t.
			 */
			if (clock_val < 0 && fclock > 0) {
				if (do_lint)
					lintwarn(_("strftime: second argument less than 0 or too big for time_t"));
				return make_string("", 0);
			}

			/* And check that the value is in range */
			if (clock_val < time_t_min || clock_val > time_t_max) {
				if (do_lint)
					lintwarn(_("strftime: second argument out of range for time_t"));
				return make_string("", 0);
			}

			DEREF(t2);
		}

		tmp = POP_SCALAR();
		if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string first argument"), "strftime");

		t1 = force_string(tmp);
		format = t1->stptr;
		formatlen = t1->stlen;
		if (formatlen == 0) {
			if (do_lint)
				lintwarn(_("strftime: received empty format string"));
			DEREF(t1);
			return make_string("", 0);
		}
		str_terminate(t1, save);
	}

	if (do_gmt)
		tm = gmtime(& fclock);
	else
		tm = localtime(& fclock);

	if (tm == NULL) {
		ret = make_string("", 0);
		goto done;
	}

	bufp = buf;
	bufsize = sizeof(buf);
	for (;;) {
		*bufp = '\0';
		buflen = strftime(bufp, bufsize, format, tm);
		/*
		 * buflen can be zero EITHER because there's not enough
		 * room in the string, or because the control command
		 * goes to the empty string. Make a reasonable guess that
		 * if the buffer is 1024 times bigger than the length of the
		 * format string, it's not failing for lack of room.
		 * Thanks to Paul Eggert for pointing out this issue.
		 */
		if (buflen > 0 || bufsize >= 1024 * formatlen)
			break;
		bufsize *= 2;
		if (bufp == buf)
			emalloc(bufp, char *, bufsize);
		else
			erealloc(bufp, char *, bufsize);
	}
	ret = make_string(bufp, buflen);
	if (bufp != buf)
		efree(bufp);
done:
	if (t1) {
		str_restore(t1, save);
		DEREF(t1);
	}
	return ret;
}

/* do_systime --- get the time of day */

NODE *
do_systime(int nargs ATTRIBUTE_UNUSED)
{
	time_t lclock;

	check_exact_args(nargs, "systime", 0);

#ifdef HAVE_CLOCK_GETTIME
	struct timespec the_time;

	(void) clock_gettime(CLOCK_REALTIME, & the_time);
	lclock = the_time.tv_sec;
#elif defined(HAVE_GETTIMEOFDAY)
	struct timeval the_time;

	(void) gettimeofday(& the_time, NULL);
	lclock = the_time.tv_sec;
#else
	(void) time(& lclock);
#endif
	return make_number((AWKNUM) lclock);
}

/* do_mktime --- turn a time string into a timestamp */

NODE *
do_mktime(int nargs)
{
	NODE *t1, *t2;
	struct tm then;
	long year;
	int month, day, hour, minute, second, count;
	int dst = -1; /* default is unknown */
	time_t then_stamp;
	char save;
	bool do_gmt;

	check_args_min_max(nargs, "mktime", 1, 2);

	if (nargs == 2) {
		t2 = POP_SCALAR();
		do_gmt = boolval(t2);
		DEREF(t2);
	}
	else
		do_gmt = false;
	t1 = POP_SCALAR();
	if (do_lint && (fixtype(t1)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string argument"), "mktime");
	t1 = force_string(t1);

	save = t1->stptr[t1->stlen];
	t1->stptr[t1->stlen] = '\0';

	count = sscanf(t1->stptr, "%ld %d %d %d %d %d %d",
		        & year, & month, & day,
			& hour, & minute, & second,
		        & dst);

	// 9/2021: I've been told that according to the ISO 8601-1:2019 spec,
	// hour cannot be 24. So the check for hour > 23 is valid.
	if (   do_lint /* Ready? Set! Go: */
	    && (   (second < 0 || second > 60)
		|| (minute < 0 || minute > 59)
		|| (hour < 0 || hour > 23)
		|| (day < 1 || day > 31)
		|| (month < 1 || month > 12) ))
			lintwarn(_("mktime: at least one of the values is out of the default range"));

	t1->stptr[t1->stlen] = save;
	DEREF(t1);

	if (count < 6
	    || month == INT_MIN
	    || year < INT_MIN + 1900
	    || year - 1900 > INT_MAX)
		return make_number((AWKNUM) -1);

	memset(& then, '\0', sizeof(then));
	then.tm_sec = second;
	then.tm_min = minute;
	then.tm_hour = hour;
	then.tm_mday = day;
	then.tm_mon = month - 1;
	then.tm_year = year - 1900;
	then.tm_isdst = dst;

	then_stamp = (do_gmt ? timegm(& then) : mktime(& then));
	return make_number((AWKNUM) then_stamp);
}

/* do_system --- run an external command */

NODE *
do_system(int nargs)
{
	NODE *tmp;
	AWKNUM ret = 0;		/* floating point on purpose, compat Unix awk */
	char *cmd;
	char save;
	int status;

	check_exact_args(nargs, "system", 1);

	if (do_sandbox)
		fatal(_("'system' function not allowed in sandbox mode"));

	(void) flush_io();     /* so output is synchronous with gawk's */
	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string argument"), "system");
	cmd = force_string(tmp)->stptr;

	if (cmd && *cmd) {
		/* insure arg to system is zero-terminated */
		save = cmd[tmp->stlen];
		cmd[tmp->stlen] = '\0';

		os_restore_mode(fileno(stdin));

		status = gawk_system(cmd);
		/*
		 * 3/2016. What to do with ret? It's never simple.
		 * POSIX says to use the full return value. BWK awk
		 * divides the result by 256.  That normally gives the
		 * exit status but gives a weird result for death-by-signal.
		 * So we compromise as follows:
		 */
		ret = status;
		if (status != -1) {
			if (do_posix)
				;	/* leave it alone, full 16 bits */
			else if (do_traditional)
#ifdef __MINGW32__
				ret = (((unsigned)status) & ~0xC0000000);
#else
				ret = (status / 256.0);
#endif
			else
				ret = sanitize_exit_status(status);
		}

		if ((BINMODE & BINMODE_INPUT) != 0)
			os_setbinmode(fileno(stdin), O_BINARY);

		cmd[tmp->stlen] = save;
	}
	DEREF(tmp);
	return make_number((AWKNUM) ret);
}

/* do_print --- print items, separated by OFS, terminated with ORS */

void
do_print(int nargs, int redirtype)
{
	struct redirect *rp = NULL;
	int errflg = 0;
	FILE *fp = NULL;
	int i;
	NODE *redir_exp = NULL;
	NODE *tmp = NULL;

	assert(nargs <= max_args);

	if (redirtype != 0) {
		redir_exp = PEEK(nargs);
		if (redir_exp->type != Node_val)
			fatal(_("attempt to use array `%s' in a scalar context"), array_vname(redir_exp));
		rp = redirect(redir_exp, redirtype, & errflg, true);
		if (rp != NULL) {
			if ((rp->flag & RED_TWOWAY) != 0 && rp->output.fp == NULL) {
				if (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {
					update_ERRNO_int(EBADF);
					return;
				}
				(void) close_rp(rp, CLOSE_ALL);
				fatal(_("print: attempt to write to closed write end of two-way pipe"));
			}
			fp = rp->output.fp;
		}
		else if (errflg) {
			update_ERRNO_int(errflg);
			return;
		}
	} else if (do_debug)	/* only the debugger can change the default output */
		fp = output_fp;
	else
		fp = stdout;

	for (i = 1; i <= nargs; i++) {
		tmp = args_array[i] = POP();
		if (tmp->type == Node_var_array) {
			while (--i > 0)
				DEREF(args_array[i]);
			fatal(_("attempt to use array `%s' in a scalar context"), array_vname(tmp));
		}
		// Let force_string_ofmt handle checking if things
		// are already valid.
		args_array[i] = force_string_ofmt(tmp);
		if (args_array[i] != tmp)
			DEREF(tmp);
	}

	if (redir_exp != NULL) {
		DEREF(redir_exp);
		decr_sp();
	}

	if (fp == NULL) {
		for (i = nargs; i > 0; i--)
			DEREF(args_array[i]);
		return;
	}

	for (i = nargs; i > 0; i--) {
		efwrite(args_array[i]->stptr, sizeof(char), args_array[i]->stlen, fp, "print", rp, false);
		DEREF(args_array[i]);
		if (i != 1 && OFSlen > 0)
			efwrite(OFS, sizeof(char), (size_t) OFSlen,
				fp, "print", rp, false);

	}
	if (ORSlen > 0)
		efwrite(ORS, sizeof(char), (size_t) ORSlen, fp, "print", rp, true);

	if (rp != NULL && (rp->flag & RED_TWOWAY) != 0)
		rp->output.gawk_fflush(rp->output.fp, rp->output.opaque);
}

/* do_print_rec --- special case printing of $0, for speed */

void
do_print_rec(int nargs, int redirtype)
{
	FILE *fp = NULL;
	NODE *f0;
	struct redirect *rp = NULL;
	int errflg = 0;
	NODE *redir_exp = NULL;

	assert(nargs == 0);
	if (redirtype != 0) {
		redir_exp = TOP();
		rp = redirect(redir_exp, redirtype, & errflg, true);
		if (rp != NULL) {
			if ((rp->flag & RED_TWOWAY) != 0 && rp->output.fp == NULL) {
				if (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {
					update_ERRNO_int(EBADF);
					return;
				}
				(void) close_rp(rp, CLOSE_ALL);
				fatal(_("print: attempt to write to closed write end of two-way pipe"));
			}
			fp = rp->output.fp;
		}
		DEREF(redir_exp);
		decr_sp();
	} else
		fp = output_fp;

	if (errflg) {
		update_ERRNO_int(errflg);
		return;
	}

	if (fp == NULL)
		return;

	if (! field0_valid || do_lint)	// lint check for field access in END
		(void) get_field(0L, NULL);

	f0 = fields_arr[0];

	if (do_lint && (f0->flags & NULL_FIELD) != 0)
		lintwarn(_("reference to uninitialized field `$%d'"), 0);

	efwrite(f0->stptr, sizeof(char), f0->stlen, fp, "print", rp, false);

	if (ORSlen > 0)
		efwrite(ORS, sizeof(char), (size_t) ORSlen, fp, "print", rp, true);

	if (rp != NULL && (rp->flag & RED_TWOWAY) != 0)
		rp->output.gawk_fflush(rp->output.fp, rp->output.opaque);
}


/* is_wupper --- function version of iswupper for passing function pointers */

static int
is_wupper(wchar_t c)
{
	return iswupper(c);
}

/* is_wlower --- function version of iswlower for passing function pointers */

static int
is_wlower(wchar_t c)
{
	return iswlower(c);
}

/* to_wupper --- function version of towupper for passing function pointers */

static int
to_wlower(wchar_t c)
{
	return towlower(c);
}

/* to_wlower --- function version of towlower for passing function pointers */

static int
to_wupper(wchar_t c)
{
	return towupper(c);
}

/* wide_change_case --- generic case converter for wide characters */

static void
wide_change_case(wchar_t *wstr,
			size_t wlen,
			int (*is_x)(wchar_t c),
			int (*to_y)(wchar_t c))
{
	size_t i;
	wchar_t *wcp;

	for (i = 0, wcp = wstr; i < wlen; i++, wcp++)
		if (is_x(*wcp))
			*wcp = to_y(*wcp);
}

/* wide_toupper --- map a wide string to upper case */

static void
wide_toupper(wchar_t *wstr, size_t wlen)
{
	wide_change_case(wstr, wlen, is_wlower, to_wupper);
}

/* wide_tolower --- map a wide string to lower case */

static void
wide_tolower(wchar_t *wstr, size_t wlen)
{
	wide_change_case(wstr, wlen, is_wupper, to_wlower);
}

/* do_tolower --- lower case a string */

NODE *
do_tolower(int nargs)
{
	NODE *t1, *t2;

	check_exact_args(nargs, "tolower", 1);

	t1 = POP_SCALAR();
	if (do_lint && (fixtype(t1)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string argument"), "tolower");
	t1 = force_string(t1);
	t2 = make_string(t1->stptr, t1->stlen);

	if (gawk_mb_cur_max == 1) {
		unsigned char *cp, *cp2;

		for (cp = (unsigned char *)t2->stptr,
		     cp2 = (unsigned char *)(t2->stptr + t2->stlen);
			cp < cp2; cp++)
			if (isupper(*cp))
				*cp = tolower(*cp);
	} else {
		force_wstring(t2);
		wide_tolower(t2->wstptr, t2->wstlen);
		wstr2str(t2);
	}

	DEREF(t1);
	return t2;
}

/* do_toupper --- upper case a string */

NODE *
do_toupper(int nargs)
{
	NODE *t1, *t2;

	check_exact_args(nargs, "toupper", 1);

	t1 = POP_SCALAR();
	if (do_lint && (fixtype(t1)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string argument"), "toupper");
	t1 = force_string(t1);
	t2 = make_string(t1->stptr, t1->stlen);

	if (gawk_mb_cur_max == 1) {
		unsigned char *cp, *cp2;

		for (cp = (unsigned char *)t2->stptr,
		     cp2 = (unsigned char *)(t2->stptr + t2->stlen);
			cp < cp2; cp++)
			if (islower(*cp))
				*cp = toupper(*cp);
	} else {
		force_wstring(t2);
		wide_toupper(t2->wstptr, t2->wstlen);
		wstr2str(t2);
	}

	DEREF(t1);
	return t2;
}

/* do_atan2 --- do the atan2 function */

NODE *
do_atan2(int nargs)
{
	NODE *t1, *t2;
	double d1, d2;

	check_exact_args(nargs, "atan2", 2);

	POP_TWO_SCALARS(t1, t2);
	if (do_lint) {
		if ((fixtype(t1)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric first argument"), "atan2");
		if ((fixtype(t2)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric second argument"), "atan2");
	}
	d1 = force_number(t1)->numbr;
	d2 = force_number(t2)->numbr;
	DEREF(t1);
	DEREF(t2);
	return make_number((AWKNUM) atan2(d1, d2));
}

/* do_sin --- do the sin function */

NODE *
do_sin(int nargs)
{
	NODE *tmp;
	double d;

	check_exact_args(nargs, "sin", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "sin");
	d = sin((double) force_number(tmp)->numbr);
	DEREF(tmp);
	return make_number((AWKNUM) d);
}

/* do_cos --- do the cos function */

NODE *
do_cos(int nargs)
{
	NODE *tmp;
	double d;

	check_exact_args(nargs, "cos", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "cos");
	d = cos((double) force_number(tmp)->numbr);
	DEREF(tmp);
	return make_number((AWKNUM) d);
}

/* do_rand --- do the rand function */

static bool firstrand = true;
/* Some systems require this array to be integer aligned. Sigh. */
#define SIZEOF_STATE 256
static uint32_t istate[SIZEOF_STATE/sizeof(uint32_t)];
static char *const state = (char *const) istate;

/* ARGSUSED */
NODE *
do_rand(int nargs ATTRIBUTE_UNUSED)
{
	double tmprand;

	check_exact_args(nargs, "rand", 0);

#define RAND_DIVISOR ((double)GAWK_RANDOM_MAX+1.0)
	if (firstrand) {
		(void) initstate((unsigned) 1, state, SIZEOF_STATE);
		/* don't need to srandom(1), initstate() does it for us. */
		firstrand = false;
		setstate(state);
	}
	/*
	 * Per historical practice and POSIX, return value N is
	 *
	 * 	0 <= n < 1
	 */
 	/*
	 * Date: Wed, 28 Aug 2013 17:52:46 -0700
	 * From: Bob Jewett <jewett@bill.scs.agilent.com>
	 *
 	 * Call random() twice to fill in more bits in the value
 	 * of the double.  Also, there is a bug in random() such
 	 * that when the values of successive values are combined
 	 * like (rand1*rand2)^2, (rand3*rand4)^2,  ...  the
 	 * resulting time series is not white noise.  The
 	 * following also seems to fix that bug.
 	 *
 	 * The add/subtract 0.5 keeps small bits from filling
 	 * below 2^-53 in the double, not that anyone should be
 	 * looking down there.
	 *
	 * Date: Wed, 25 Sep 2013 10:45:38 -0600 (MDT)
	 * From: "Nelson H. F. Beebe" <beebe@math.utah.edu>
	 * (4) The code is typical of many published fragments for converting
	 *     from integer to floating-point, and I discuss the serious pitfalls
	 *     in my book, because it leads to platform-dependent behavior at the
	 *     end points of the interval [0,1]
	 *
	 * (5) the documentation in the gawk info node says
	 *
	 *     `rand()'
	 * 	 Return a random number.  The values of `rand()' are uniformly
	 * 	 distributed between zero and one.  The value could be zero but is
	 * 	 never one.(1)
	 *
	 *     The division by RAND_DIVISOR may not guarantee that 1.0 is never
	 *     returned: the programmer forgot the platform-dependent issue of
	 *     rounding.
	 *
	 * For points 4 and 5, the safe way is a loop:
	 *
	 *         double
	 * 	   rand(void)		// return value in [0.0, 1.0)
	 *         {
	 * 	    value = internal_rand();
	 *
	 * 	    while (value == 1.0)
	 *                 value = internal_rand();
	 *
	 * 	    return (value);
	 *         }
 	 */

	do {
		long d1, d2;
		/*
		 * Do the calls in predictable order to avoid
		 * compiler differences in order of evaluation.
		 */
		d1 = random();
		d2 = random();
	 	tmprand = 0.5 + ( (d1/RAND_DIVISOR + d2) / RAND_DIVISOR );
		tmprand -= 0.5;
	} while (tmprand == 1.0);

 	return make_number((AWKNUM) tmprand);
}

/* do_srand --- seed the random number generator */

NODE *
do_srand(int nargs)
{
	NODE *tmp;
	static long save_seed = 1;
	long ret = save_seed;	/* SVR4 awk srand returns previous seed */

	if (firstrand) {
		(void) initstate((unsigned) 1, state, SIZEOF_STATE);
		/* don't need to srandom(1), we're changing the seed below */
		firstrand = false;
		(void) setstate(state);
	}

	check_args_min_max(nargs, "srand", 0, 1);

	if (nargs == 0)
		srandom((unsigned int) (save_seed = (long) time((time_t *) 0)));
	else {
		tmp = POP_SCALAR();
		if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric argument"), "srand");
		srandom((unsigned int) (save_seed = (long) force_number(tmp)->numbr));
		DEREF(tmp);
	}
	return make_number((AWKNUM) ret);
}

/* do_match --- match a regexp, set RSTART and RLENGTH,
 * 	optional third arg is array filled with text of
 * 	subpatterns enclosed in parens and start and len info.
 */

NODE *
do_match(int nargs)
{
	NODE *tre, *t1, *dest, *it;
	int rstart, len, ii;
	int rlength;
	Regexp *rp;
	regoff_t s;
	char *start;
	char *buf = NULL;
	char buff[100];
	size_t amt, oldamt = 0, ilen, slen;
	char *subsepstr;
	size_t subseplen;

	check_args_min_max(nargs, "match", 2, 3);

	dest = NULL;
	if (nargs == 3) {	/* 3rd optional arg for the subpatterns */
		dest = POP_PARAM();
		if (dest->type != Node_var_array)
			fatal(_("match: third argument is not an array"));
		check_symtab_functab(dest, "match",
				_("%s: cannot use %s as third argument"));
		assoc_clear(dest);
	}
	tre = POP();
	rp = re_update(tre);
	t1 = POP_STRING();
	if (do_lint && (fixtype(t1)->flags & (STRING|USER_INPUT)) == 0)
		lintwarn(_("%s: received non-string first argument"), "match");

	rstart = research(rp, t1->stptr, 0, t1->stlen, RE_NEED_START);
	if (rstart >= 0) {	/* match succeded */
		size_t *wc_indices = NULL;

		rlength = REEND(rp, t1->stptr) - RESTART(rp, t1->stptr);	/* byte length */
		if (gawk_mb_cur_max > 1) {
			t1 = str2wstr(t1, & wc_indices);
			rlength = wc_indices[rstart + rlength] - wc_indices[rstart];
			rstart = wc_indices[rstart];
		}

		rstart++;	/* now it's 1-based indexing */

		/* Build the array only if the caller wants the optional subpatterns */
		if (dest != NULL) {
			subsepstr = SUBSEP_node->var_value->stptr;
			subseplen = SUBSEP_node->var_value->stlen;

			for (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {
				/*
				 * Loop over all the subpats; some of them may have
				 * matched even if all of them did not.
				 */
				if ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {
					size_t subpat_start;
					size_t subpat_len;

					start = t1->stptr + s;
					subpat_start = s;
					subpat_len = len = SUBPATEND(rp, t1->stptr, ii) - s;
					if (gawk_mb_cur_max > 1) {
						subpat_start = wc_indices[s];
						subpat_len = wc_indices[s + len] - subpat_start;
					}

					it = make_string(start, len);
					it->flags |= USER_INPUT;
					assoc_set(dest, make_number((AWKNUM) (ii)), it);;

					sprintf(buff, "%d", ii);
					ilen = strlen(buff);
					amt = ilen + subseplen + strlen("length") + 1;

					if (oldamt == 0) {
						emalloc(buf, char *, amt);
					} else if (amt > oldamt) {
						erealloc(buf, char *, amt);
					}
					oldamt = amt;
					memcpy(buf, buff, ilen);
					memcpy(buf + ilen, subsepstr, subseplen);
					memcpy(buf + ilen + subseplen, "start", 6);

					slen = ilen + subseplen + 5;

					assoc_set(dest, make_string(buf, slen), make_number((AWKNUM) subpat_start + 1));

					memcpy(buf, buff, ilen);
					memcpy(buf + ilen, subsepstr, subseplen);
					memcpy(buf + ilen + subseplen, "length", 7);

					slen = ilen + subseplen + 6;

					assoc_set(dest, make_string(buf, slen), make_number((AWKNUM) subpat_len));
				}
			}

			efree(buf);
		}
		if (wc_indices != NULL)
			efree(wc_indices);
	} else {		/* match failed */
		rstart = 0;
		rlength = -1;
	}

	DEREF(t1);
	unref(RSTART_node->var_value);
	RSTART_node->var_value = make_number((AWKNUM) rstart);
	unref(RLENGTH_node->var_value);
	RLENGTH_node->var_value = make_number((AWKNUM) rlength);
	return make_number((AWKNUM) rstart);
}

/* do_sub --- do the work for sub, gsub, and gensub */

/*
 * Gsub can be tricksy; particularly when handling the case of null strings.
 * The following awk code was useful in debugging problems.  It is too bad
 * that it does not readily translate directly into the C code, below.
 *
 * #! /usr/local/bin/mawk -f
 *
 * BEGIN {
 * 	true = 1; false = 0
 * 	print "--->", mygsub("abc", "b+", "FOO")
 * 	print "--->", mygsub("abc", "x*", "X")
 * 	print "--->", mygsub("abc", "b*", "X")
 * 	print "--->", mygsub("abc", "c", "X")
 * 	print "--->", mygsub("abc", "c+", "X")
 * 	print "--->", mygsub("abc", "x*$", "X")
 * }
 *
 * function mygsub(str, regex, replace,	origstr, newstr, eosflag, nonzeroflag)
 * {
 * 	origstr = str;
 * 	eosflag = nonzeroflag = false
 * 	while (match(str, regex)) {
 * 		if (RLENGTH > 0) {	# easy case
 * 			nonzeroflag = true
 * 			if (RSTART == 1) {	# match at front of string
 * 				newstr = newstr replace
 * 			} else {
 * 				newstr = newstr substr(str, 1, RSTART-1) replace
 * 			}
 * 			str = substr(str, RSTART+RLENGTH)
 * 		} else if (nonzeroflag) {
 * 			# last match was non-zero in length, and at the
 * 			# current character, we get a zero length match,
 * 			# which we don't really want, so skip over it
 * 			newstr = newstr substr(str, 1, 1)
 * 			str = substr(str, 2)
 * 			nonzeroflag = false
 * 		} else {
 * 			# 0-length match
 * 			if (RSTART == 1) {
 * 				newstr = newstr replace substr(str, 1, 1)
 * 				str = substr(str, 2)
 * 			} else {
 * 				return newstr str replace
 * 			}
 * 		}
 * 		if (length(str) == 0)
 * 			if (eosflag)
 * 				break
 * 			else
 * 				eosflag = true
 * 	}
 * 	if (length(str) > 0)
 * 		newstr = newstr str	# rest of string
 *
 * 	return newstr
 * }
 */

/*
 * 1/2004:  The gawk sub/gsub behavior dates from 1996, when we proposed it
 * for POSIX.  The proposal fell through the cracks, and the 2001 POSIX
 * standard chose a more simple behavior.
 *
 * The relevant text is to be found on lines 6394-6407 (pages 166, 167) of the
 * 2001 standard:
 *
 * sub(ere, repl[, in ])
 *  Substitute the string repl in place of the first instance of the
 *  extended regular expression ERE in string in and return the number of
 *  substitutions. An ampersand ('&') appearing in the string repl shall
 *  be replaced by the string from in that matches the ERE. An ampersand
 *  preceded with a backslash ('\') shall be interpreted as the literal
 *  ampersand character. An occurrence of two consecutive backslashes shall
 *  be interpreted as just a single literal backslash character. Any other
 *  occurrence of a backslash (for example, preceding any other character)
 *  shall be treated as a literal backslash character. Note that if repl is a
 *  string literal (the lexical token STRING; see Grammar (on page 170)), the
 *  handling of the ampersand character occurs after any lexical processing,
 *  including any lexical backslash escape sequence processing. If in is
 *  specified and it is not an lvalue (see Expressions in awk (on page 156)),
 *  the behavior is undefined. If in is omitted, awk shall use the current
 *  record ($0) in its place.
 *
 * 11/2010: The text in the 2008 standard is the same as just quoted.
 * However, POSIX behavior is now the default.  This can change the behavior
 * of awk programs.  The old behavior is not available.
 *
 * 7/2011: Reverted backslash handling to what it used to be. It was in
 * gawk for too long. Should have known better.
 *
 * 9/2023: Update for matches of null strings around multibyte characters.
 */

/*
 * NB: `howmany' conflicts with a SunOS 4.x macro in <sys/param.h>.
 */

NODE *
do_sub(int nargs, unsigned int flags)
{
	char *scan;
	char *bp, *cp;
	char *buf = NULL;
	size_t buflen;
	char *matchend;
	size_t len;
	char *matchstart;
	char *text;
	size_t textlen = 0;
	char *repl;
	char *replend;
	size_t repllen;
	int sofar;
	int ampersands;
	int matches = 0;
	Regexp *rp;
	NODE *rep_node;		/* replacement text */
	NODE *target;		/* string to make sub. in; $0 if none given */
	NODE *tmp;
	NODE **lhs = NULL;
	long how_many = 1;	/* one substitution for sub, also gensub default */
	bool global;
	long current;
	bool lastmatchnonzero;
	char *mb_indices = NULL;

	if ((flags & GENSUB) != 0) {
		double d;
		NODE *glob_flag;

		check_exact_args(nargs, "gensub", 4);

		tmp = PEEK(3);
		rp = re_update(tmp);

		target = POP_STRING();	/* original string */

		glob_flag = POP_SCALAR();	/* value of global flag */
		if (   (glob_flag->flags & STRING) != 0
		    && glob_flag->stlen > 0
		    && (glob_flag->stptr[0] == 'g' || glob_flag->stptr[0] == 'G'))
			how_many = -1;
		else {
			(void) force_number(glob_flag);
			d = get_number_d(glob_flag);
			if (d < 1)
				how_many = 1;
			else if (d < LONG_MAX)
				how_many = d;
			else
				how_many = LONG_MAX;
			if (d <= 0) {
				(void) force_string(glob_flag);
				warning(_("gensub: third argument `%.*s' treated as 1"),
						(int) glob_flag->stlen,
						glob_flag->stptr);
			}
		}
		DEREF(glob_flag);
	} else {
		if ((flags & GSUB) != 0) {
			check_exact_args(nargs, "gsub", 3);
		} else {
			check_exact_args(nargs, "sub", 3);
		}

		/* take care of regexp early, in case re_update is fatal */

		tmp = PEEK(2);
		rp = re_update(tmp);

		if ((flags & GSUB) != 0)
			how_many = -1;

		/* original string */

		if ((flags & LITERAL) != 0)
			target = POP_STRING();
		else {
			lhs = POP_ADDRESS();
			target = force_string(*lhs);
		}
	}

	global = (how_many == -1);

	rep_node = POP_STRING();	/* replacement text */
	decr_sp();		/* regexp, already updated above */

	/* do the search early to avoid work on non-match */
	if (research(rp, target->stptr, 0, target->stlen, RE_NEED_START) == -1 ||
			RESTART(rp, target->stptr) > target->stlen)
		goto done;

	text = target->stptr;
	textlen = target->stlen;

	repl = rep_node->stptr;
	replend = repl + rep_node->stlen;
	repllen = replend - repl;

	ampersands = 0;

	/*
	 * Some systems' malloc() can't handle being called with an
	 * argument of zero.  Thus we have to have some special case
	 * code to check for `repllen == 0'.  This can occur for
	 * something like:
	 * 	sub(/foo/, "", mystring)
	 * for example.
	 */
	if (gawk_mb_cur_max > 1 && repllen > 0) {
		emalloc(mb_indices, char *, repllen * sizeof(char));
		index_multibyte_buffer(repl, mb_indices, repllen);
	}

	/* compute length of replacement string, number of ampersands */
	for (scan = repl; scan < replend; scan++) {
		if ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))
		    && (*scan == '&')) {
			repllen--;
			ampersands++;
		} else if (*scan == '\\') {
			if ((flags & GENSUB) != 0) {	/* gensub, behave sanely */
				if (isdigit((unsigned char) scan[1])) {
					ampersands++;
					scan++;
				} else {	/* \q for any q --> q */
					repllen--;
					scan++;
				}
			} else if (do_posix) {
				/* \& --> &, \\ --> \ */
				if (scan[1] == '&' || scan[1] == '\\') {
					repllen--;
					scan++;
				} /* else
					leave alone, it goes into the output */
			} else {
				/* gawk default behavior since 1996 */
				if (strncmp(scan, "\\\\\\&", 4) == 0
				    || strncmp(scan, "\\\\\\\\", 4) == 0) {	/* 2016: fixed */
					/* \\\& --> \& */
					/* \\\\ --> \\ */
					repllen -= 2;
					scan += 3;
				} else if (strncmp(scan, "\\\\&", 3) == 0) {
					/* \\& --> \<string> */
					ampersands++;
					repllen--;
					scan += 2;
				} else if (scan[1] == '&') {
					/* \& --> & */
					repllen--;
					scan++;
				} /* else
					leave alone, it goes into the output */
			}
		}
	}

	lastmatchnonzero = false;

	/* guesstimate how much room to allocate; +1 forces > 0 */
	buflen = textlen + (ampersands + 1) * repllen + 1;
	emalloc(buf, char *, buflen + 1);
	buf[buflen] = '\0';

	bp = buf;
	for (current = 1;; current++) {
		matches++;
		matchstart = target->stptr + RESTART(rp, target->stptr);
		matchend = target->stptr + REEND(rp, target->stptr);

		/*
		 * create the result, copying in parts of the original
		 * string. note that length of replacement string can
		 * vary since ampersand is actual text of regexp match.
		 */

		/*
		 * add 1 to len to handle "empty" case where
		 * matchend == matchstart and we force a match on a single
		 * char.  Use 'matchend - text' instead of 'matchstart - text'
		 * because we may not actually make any substitution depending
		 * on the 'global' and 'how_many' values.
		 */
		len = matchend - text + repllen
		      + ampersands * (matchend - matchstart) + 1;
		sofar = bp - buf;
		while (buflen < (sofar + len + 1)) {
			buflen *= 2;
			erealloc(buf, char *, buflen);
			bp = buf + sofar;
		}
		for (scan = text; scan < matchstart; scan++)
			*bp++ = *scan;
		if (global || current == how_many) {
			/*
			 * If the current match matched the null string,
			 * and the last match didn't and did a replacement,
			 * and the match of the null string is at the front of
			 * the text (meaning right after end of the previous
			 * replacement), then skip this one.
			 */
			if (matchstart == matchend
			    && lastmatchnonzero
			    && matchstart == text) {
				lastmatchnonzero = false;
				matches--;
				goto empty;
			}
			/*
			 * If replacing all occurrences, or this is the
			 * match we want, copy in the replacement text,
			 * making substitutions as we go.
			 */
			for (scan = repl; scan < replend; scan++)
				if (*scan == '&'
					/*
					 * Don't test repllen here. A simple "&" could
					 * end up with repllen == 0.
					 */
					&& (gawk_mb_cur_max == 1
						|| mb_indices[scan - repl] == 1)
				) {
						for (cp = matchstart; cp < matchend; cp++)
								*bp++ = *cp;
				} else if (*scan == '\\'
					&& (gawk_mb_cur_max == 1
						|| (repllen > 0 && mb_indices[scan - repl] == 1))
				) {
					if (flags & GENSUB) {	/* gensub, behave sanely */
						if (isdigit((unsigned char) scan[1])) {
							int dig = scan[1] - '0';
							if (dig < NUMSUBPATS(rp, target->stptr) && SUBPATSTART(rp, target->stptr, dig) != -1) {
								char *start, *end;

								start = target->stptr
								      + SUBPATSTART(rp, target->stptr, dig);
								end = target->stptr
								      + SUBPATEND(rp, target->stptr, dig);

								for (cp = start; cp < end; cp++)
									*bp++ = *cp;
							}
							scan++;
						} else if (scan+1 == replend) {
							*bp++ = *scan;
						} else	/* \q for any q --> q */
							*bp++ = *++scan;
					} else if (do_posix) {
						/* \& --> &, \\ --> \ */
						if (scan[1] == '&' || scan[1] == '\\')
							scan++;
						*bp++ = *scan;
					} else {
						/* gawk default behavior since 1996 */
						if (strncmp(scan, "\\\\\\&", 4) == 0
						    || strncmp(scan, "\\\\\\\\", 4) == 0) {	/* 2016: fixed */
							/* \\\& --> \& */
							/* \\\\ --> \\ */
							*bp++ = '\\';
							*bp++ = scan[3];
							scan += 3;
						} else if (strncmp(scan, "\\\\&", 3) == 0) {
							/* \\& --> \<string> */
							*bp++ = '\\';
							for (cp = matchstart; cp < matchend; cp++)
								*bp++ = *cp;
							scan += 2;
						} else if (scan[1] == '&') {
							/* \& --> & */
							*bp++ = '&';
							scan++;
						} else
							*bp++ = *scan;
					}
				} else
					*bp++ = *scan;
			if (matchstart != matchend)
				lastmatchnonzero = true;
		} else {
			/*
			 * don't want this match, skip over it by copying
			 * in current text.
			 */
			for (cp = matchstart; cp < matchend; cp++)
				*bp++ = *cp;
		}
	empty:
		/* catch the case of gsub(//, "blah", whatever), i.e. empty regexp */
		if (matchstart == matchend && matchend < text + textlen) {
			// copy in regular text
			if (gawk_mb_cur_max == 1) {
				*bp++ = *matchend;
				matchend++;
			} else {
				mbstate_t mbs;
				size_t i, j;

				memset(& mbs, 0, sizeof(mbs));
				j = mbrlen(matchend, (target->stptr + target->stlen) - matchend, & mbs);
				// FIXME: Error checking on the value of `j' would be a good idea....
				for (i = 0; i < j; i++)
					*bp++ = *matchend++;
			}
		}
		textlen = text + textlen - matchend;
		text = matchend;

#if 0
		if (bp - buf > sofar + len)
			fprintf(stderr, "debug: len = %zu, but used %ld\n", len, (long)((bp - buf) - (long)sofar));
#endif

		if ((current >= how_many && ! global)
		    || ((long) textlen <= 0 && matchstart == matchend)
		    || research(rp, target->stptr, text - target->stptr, textlen, RE_NEED_START) == -1)
			break;

	}
	sofar = bp - buf;
	if (buflen < (sofar + textlen + 1)) {
		buflen = sofar + textlen + 1;
		erealloc(buf, char *, buflen);
		bp = buf + sofar;
	}
	/*
	 * Note that text == matchend, since that assignment is made before
	 * exiting the 'for' loop above. Thus we copy in the rest of the
	 * original string.
	 */
	for (scan = text; scan < text + textlen; scan++)
		*bp++ = *scan;
	*bp = '\0';
	textlen = bp - buf;

	if (mb_indices != NULL)
		efree(mb_indices);

done:
	DEREF(rep_node);

	if ((matches == 0 || (flags & LITERAL) != 0) && buf != NULL) {
		efree(buf);
		buf = NULL;
	}

	if (flags & GENSUB) {
		if (matches > 0) {
			/* return the result string */
			DEREF(target);
			assert(buf != NULL);
			return make_str_node(buf, textlen, ALREADY_MALLOCED);
		} else if ((target->flags & STRING) == 0) {
			/* return a copy of original string */
			NODE *copy = make_str_node(target->stptr, target->stlen, 0);
			DEREF(target);
			return copy;
		}

		/* return the original string */
		return target;
	}

	/* For a string literal, must not change the original string. */
	if ((flags & LITERAL) != 0)
		DEREF(target);
	else if (matches > 0) {
		/*
		 * 8/2021: There's a bit of a song and dance here.  If someone does
		 *
		 * 	x = @/abc/
		 * 	sub(/b/, "x", x)
		 *
		 * What should the type of x be after the call? Does it get converted
		 * to string? Or does it remain a regexp?  We've decided to let it
		 * remain a regexp. In that case, we have to update the compiled
		 * regular expression that it holds.
		 */
		bool is_regex = ((target->flags & REGEX) != 0);

		unref(*lhs);		// nuke original value
		if (is_regex)
			*lhs = make_typed_regex(buf, textlen);
		else
			*lhs = make_str_node(buf, textlen, ALREADY_MALLOCED);
	}

	return make_number((AWKNUM) matches);
}

/* call_sub --- call do_sub indirectly */

NODE *
call_sub(const char *name, int nargs)
{
	unsigned int flags = 0;
	NODE *regex, *replace, *glob_flag;
	NODE **lhs, *rhs;
	NODE *zero = make_number(0.0);
	NODE *result;
	const char *fname = name;

	if (fname[0] == 'a')	// awk::...
		fname += 5;

	if (fname[0] == 'g') {
		if (fname[1] == 'e')
			flags = GENSUB;
		else
			flags = GSUB;
	}

	bool need_free = false;
	if (flags == 0 || flags == GSUB) {
		/* sub or gsub */
		if (nargs != 2)
			fatal(_("%s: can be called indirectly only with two arguments"), name);

		replace = POP_STRING();
		regex = POP();	/* the regex */
		/*
		 * push regex
		 * push replace
		 * push $0
		 */
		if ((regex->flags & REGEX) != 0)
			regex = regex->typed_re;
		else {
			regex = make_regnode(Node_regex, regex);
			need_free = true;
		}
		PUSH(regex);
		PUSH(replace);
		lhs = r_get_field(zero, (Func_ptr *) 0, true);
		nargs++;
		PUSH_ADDRESS(lhs);
	} else {
		/* gensub */
		if (nargs < 3 || nargs > 4)
			fatal(_("indirect call to gensub requires three or four arguments"));

		if (nargs == 4)
			rhs = POP();
		else
			rhs = NULL;
		glob_flag = POP_STRING();
		replace = POP_STRING();
		regex = POP();	/* the regex */
		/*
		 * push regex
		 * push replace
		 * push glob_flag
		 * if (nargs = 3) {
		 *	 push $0
		 *	 nargs++
		 * }
		 */
		if ((regex->flags & REGEX) != 0)
			regex = regex->typed_re;
		else {
			regex = make_regnode(Node_regex, regex);
			need_free = true;
		}
		PUSH(regex);
		PUSH(replace);
		PUSH(glob_flag);
		if (rhs == NULL) {
			lhs = r_get_field(zero, (Func_ptr *) 0, true);
			rhs = *lhs;
			UPREF(rhs);
			PUSH(rhs);
			nargs++;
		}
		else
			PUSH(rhs);
	}

	unref(zero);
	result = do_sub(nargs, flags);

	if (need_free) {
		refree(regex->re_reg[0]);
		if (regex->re_reg[1] != NULL)
			refree(regex->re_reg[1]);
		freenode(regex);
	}

	if (flags != GENSUB)
		reset_record();
	return result;
}

/* call_match --- call do_match indirectly */

NODE *
call_match(int nargs)
{
	NODE *regex, *text, *array;
	NODE *result;

	if (nargs < 2 || nargs > 3)
		fatal(_("indirect call to match requires two or three arguments"));

	regex = text = array = NULL;
	if (nargs == 3)
		array = POP();
	regex = POP();
	text = POP();

	bool need_free = false;
	if ((regex->flags & REGEX) != 0)
		regex = regex->typed_re;
	else if (regex->type == Node_var_new || regex->type == Node_elem_new) {
		if (regex->type == Node_elem_new)
			elem_new_reset(regex);
		else if (regex->vname != NULL)
			efree(regex->vname);
		memset(regex, 0, sizeof(*regex));
		regex->type = Node_dynregex;
		regex->re_exp = dupnode(Nnull_string);
	} else {
		regex = make_regnode(Node_regex, regex);
		need_free = true;
	}

	if (text->type == Node_var_new || text->type == Node_elem_new) {
		if (text->type == Node_elem_new)
			elem_new_reset(text);
		else if (text->vname != NULL)
			efree(text->vname);
		text = dupnode(Nnull_string);
	}

	PUSH(text);
	PUSH(regex);

	if (array)
		PUSH(array);

	result = do_match(nargs);

	if (need_free) {
		refree(regex->re_reg[0]);
		if (regex->re_reg[1] != NULL)
			refree(regex->re_reg[1]);
		freenode(regex);
	}

	return result;
}

/* call_split_func --- call do_split or do_pat_split indirectly */

NODE *
call_split_func(const char *name, int nargs)
{
	NODE *regex, *seps;
	NODE *result;
	const char *fname = name;

	regex = seps = NULL;
	if (nargs < 2 || nargs > 4)
		fatal(_("indirect call to %s requires two to four arguments"),
				name);

	if (fname[0] == 'a')	// awk::...
		fname += 5;

	if (nargs == 4)
		seps = POP();

	bool need_free = false;
	if (nargs >= 3) {
		regex = POP_STRING();
		if ((regex->flags & REGEX) != 0)
			regex = regex->typed_re;
		else {
			regex = make_regnode(Node_regex, regex);
			need_free = true;
		}
	} else {
		if (fname[0] == 's') {
			regex = make_regnode(Node_regex, FS_node->var_value);
			regex->re_flags |= FS_DFLT;
		} else
			regex = make_regnode(Node_regex, FPAT_node->var_value);

		need_free = true;
		nargs++;
	}

	/* Don't need to pop the string or the data array */

	PUSH(regex);

	if (seps)
		PUSH(seps);

	result = (fname[0] == 's') ? do_split(nargs) : do_patsplit(nargs);

	if (need_free) {
		refree(regex->re_reg[0]);
		if (regex->re_reg[1] != NULL)
			refree(regex->re_reg[1]);
		freenode(regex);
	}

	return result;
}

/* make_integer - Convert an integer to a number node.  */

static NODE *
make_integer(uintmax_t n)
{
	n = adjust_uint(n);

	return make_number((AWKNUM) n);
}

/* do_lshift --- perform a << operation */

NODE *
do_lshift(int nargs)
{
	NODE *s1, *s2;
	uintmax_t uval, ushift, res;
	AWKNUM val, shift;

	check_exact_args(nargs, "lshift", 2);

	POP_TWO_SCALARS(s1, s2);
	if (do_lint) {
		if ((fixtype(s1)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric first argument"), "lshift");
		if ((fixtype(s2)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric second argument"), "lshift");
	}

	val = force_number(s1)->numbr;
	shift = force_number(s2)->numbr;
	if (val < 0 || shift < 0)
		fatal(_("lshift(%f, %f): negative values are not allowed"), val, shift);

	if (do_lint) {
		if (double_to_int(val) != val || double_to_int(shift) != shift)
			lintwarn(_("lshift(%f, %f): fractional values will be truncated"), val, shift);
		if (shift >= sizeof(uintmax_t) * CHAR_BIT)
			lintwarn(_("lshift(%f, %f): too large shift value will give strange results"), val, shift);
	}

	DEREF(s1);
	DEREF(s2);

	uval = (uintmax_t) val;
	ushift = (uintmax_t) shift;

	res = uval << ushift;
	return make_integer(res);
}

/* do_rshift --- perform a >> operation */

NODE *
do_rshift(int nargs)
{
	NODE *s1, *s2;
	uintmax_t uval, ushift, res;
	AWKNUM val, shift;

	check_exact_args(nargs, "rshift", 2);

	POP_TWO_SCALARS(s1, s2);
	if (do_lint) {
		if ((fixtype(s1)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric first argument"), "rshift");
		if ((fixtype(s2)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric second argument"), "rshift");
	}

	val = force_number(s1)->numbr;
	shift = force_number(s2)->numbr;
	if (val < 0 || shift < 0)
		fatal(_("rshift(%f, %f): negative values are not allowed"), val, shift);

	if (do_lint) {
		if (double_to_int(val) != val || double_to_int(shift) != shift)
			lintwarn(_("rshift(%f, %f): fractional values will be truncated"), val, shift);
		if (shift >= sizeof(uintmax_t) * CHAR_BIT)
			lintwarn(_("rshift(%f, %f): too large shift value will give strange results"), val, shift);
	}

	DEREF(s1);
	DEREF(s2);

	uval = (uintmax_t) val;
	ushift = (uintmax_t) shift;

	res = uval >> ushift;
	return make_integer(res);
}

/* do_and --- perform an & operation */

NODE *
do_and(int nargs)
{
	NODE *s1;
	uintmax_t res, uval;
	AWKNUM val;

	res = ~(uintmax_t) 0;	/* start off with all ones */
	if (nargs < 2)
		fatal(_("%s: called with less than two arguments"), "and");

	for (; nargs > 0; nargs--) {
		s1 = POP_SCALAR();
		if (do_lint && (fixtype(s1)->flags & NUMBER) == 0)
			lintwarn(_("%s: argument %d is non-numeric"), "and", nargs);

		val = force_number(s1)->numbr;
		if (val < 0)
			fatal(_("%s: argument %d negative value %g is not allowed"), "and", nargs, val);

		uval = (uintmax_t) val;
		res &= uval;

		DEREF(s1);
	}

	return make_integer(res);
}

/* do_or --- perform an | operation */

NODE *
do_or(int nargs)
{
	NODE *s1;
	uintmax_t res, uval;
	AWKNUM val;

	res = 0;
	if (nargs < 2)
		fatal(_("%s: called with less than two arguments"), "or");

	for (; nargs > 0; nargs--) {
		s1 = POP_SCALAR();
		if (do_lint && (fixtype(s1)->flags & NUMBER) == 0)
			lintwarn(_("%s: argument %d is non-numeric"), "or", nargs);

		val = force_number(s1)->numbr;
		if (val < 0)
			fatal(_("%s: argument %d negative value %g is not allowed"), "or", nargs, val);

		uval = (uintmax_t) val;
		res |= uval;

		DEREF(s1);
	}

	return make_integer(res);
}

/* do_xor --- perform an ^ operation */

NODE *
do_xor(int nargs)
{
	NODE *s1;
	uintmax_t res, uval;
	AWKNUM val;

	if (nargs < 2)
		fatal(_("%s: called with less than two arguments"), "xor");

	res = 0;	/* start with all zeroes */
	for (; nargs > 0; nargs--) {
		s1 = POP_SCALAR();
		if (do_lint && (fixtype(s1)->flags & NUMBER) == 0)
			lintwarn(_("%s: argument %d is non-numeric"), "xor", nargs);

		val = force_number(s1)->numbr;
		if (val < 0)
			fatal(_("%s: argument %d negative value %g is not allowed"), "xor", nargs, val);

		uval = (uintmax_t) val;
		res ^= uval;

		DEREF(s1);
	}

	return make_integer(res);
}

/* do_compl --- perform a ~ operation */

NODE *
do_compl(int nargs)
{
	NODE *tmp;
	double d;
	uintmax_t uval;

	check_exact_args(nargs, "compl", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), "compl");
	d = force_number(tmp)->numbr;
	DEREF(tmp);

	if (d < 0)
		fatal(_("compl(%f): negative value is not allowed"), d);

	if (do_lint && double_to_int(d) != d)
		lintwarn(_("compl(%f): fractional value will be truncated"), d);

	uval = (uintmax_t) d;
	uval = ~ uval;
	return make_integer(uval);
}

/* do_strtonum --- the strtonum function */

NODE *
do_strtonum(int nargs)
{
	NODE *tmp;
	AWKNUM d;

	check_exact_args(nargs, "strtonum", 1);

	tmp = fixtype(POP_SCALAR());
	if ((tmp->flags & NUMBER) != 0)
		d = (AWKNUM) tmp->numbr;
	else if (get_numbase(tmp->stptr, tmp->stlen, use_lc_numeric) != 10)
		d = nondec2awknum(tmp->stptr, tmp->stlen, NULL);
	else
		d = (AWKNUM) force_number(tmp)->numbr;

	DEREF(tmp);
	return make_number((AWKNUM) d);
}

/* nondec2awknum --- convert octal or hex value to double */

/*
 * Because of awk's concatenation rules and the way awk.y:yylex()
 * collects a number, this routine has to be willing to stop on the
 * first invalid character.
 */

AWKNUM
nondec2awknum(char *str, size_t len, char **endptr)
{
	AWKNUM retval = 0.0;
	char save;
	short val;
	char *start = str;

	if (len >= 2 && *str == '0' && (str[1] == 'x' || str[1] == 'X')) {
		/*
		 * User called strtonum("0x") or some such,
		 * so just quit early.
		 */
		if (len <= 2) {
			if (endptr)
				*endptr = start;
			return (AWKNUM) 0.0;
		}

		for (str += 2, len -= 2; len > 0; len--, str++) {
			switch (*str) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				val = *str - '0';
				break;
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
				val = *str - 'a' + 10;
				break;
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
				val = *str - 'A' + 10;
				break;
			default:
				if (endptr)
					*endptr = str;
				goto done;
			}
			retval = (retval * 16) + val;
		}
		if (endptr)
			*endptr = str;
	} else if (len >= 1 && *str == '0') {
		int l;
		// preserve len in case we go to decimal
		for (l = len; l > 0; l--) {
			if (! isdigit((unsigned char) *str)) {
				if (endptr)
					*endptr = str;
				goto done;
			}
			else if (*str == '8' || *str == '9') {
				str = start;
				goto decimal;
			}
			retval = (retval * 8) + (*str - '0');
			str++;
		}
		if (endptr)
			*endptr = str;
	} else {
decimal:
		save = str[len];
		str[len] = '\0';
		retval = strtod(str, endptr);
		str[len] = save;
	}
done:
	return retval;
}

/* do_dcgettext, do_dcngettext --- handle i18n translations */

#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT

static int
localecategory_from_argument(NODE *t)
{
	static const struct category_table {
		int val;
		const char *name;
	} cat_tab[] = {
#ifdef LC_ALL
		{ LC_ALL,	"LC_ALL" },
#endif /* LC_ALL */
#ifdef LC_COLLATE
		{ LC_COLLATE,	"LC_COLLATE" },
#endif /* LC_COLLATE */
#ifdef LC_CTYPE
		{ LC_CTYPE,	"LC_CTYPE" },
#endif /* LC_CTYPE */
#ifdef LC_MESSAGES
		{ LC_MESSAGES,	"LC_MESSAGES" },
#endif /* LC_MESSAGES */
#ifdef LC_MONETARY
		{ LC_MONETARY,	"LC_MONETARY" },
#endif /* LC_MONETARY */
#ifdef LC_NUMERIC
		{ LC_NUMERIC,	"LC_NUMERIC" },
#endif /* LC_NUMERIC */
#ifdef LC_RESPONSE
		{ LC_RESPONSE,	"LC_RESPONSE" },
#endif /* LC_RESPONSE */
#ifdef LC_TIME
		{ LC_TIME,	"LC_TIME" },
#endif /* LC_TIME */
	};

	if (t != NULL) {
		int low, high, i, mid;
		char *category;
		int lc_cat = -1;

		char save = t->stptr[t->stlen];
		t->stptr[t->stlen] = '\0';
		category = t->stptr;

		/* binary search the table */
		low = 0;
		high = (sizeof(cat_tab) / sizeof(cat_tab[0])) - 1;
		while (low <= high) {
			mid = (low + high) / 2;
			i = strcmp(category, cat_tab[mid].name);

			if (i < 0)		/* category < mid */
				high = mid - 1;
			else if (i > 0)		/* category > mid */
				low = mid + 1;
			else {
				lc_cat = cat_tab[mid].val;
				break;
			}
		}
		t->stptr[t->stlen] = save;
		if (lc_cat == -1)	/* not there */
			fatal(_("dcgettext: `%s' is not a valid locale category"), category);

		return lc_cat;
	} else
		return LC_MESSAGES;
}

#endif

/*
 * awk usage is
 *
 * 	str = dcgettext(string [, domain [, category]])
 * 	str = dcngettext(string1, string2, number [, domain [, category]])
 *
 * Default domain is TEXTDOMAIN, default category is LC_MESSAGES.
 */

NODE *
do_dcgettext(int nargs)
{
	NODE *tmp, *t1, *t2 = NULL;
	char *string;
	char *the_result;
	size_t reslen;
#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT
	int lc_cat;
	char *domain;
	char save1 = '\0', save2 = '\0';

	check_args_min_max(nargs, "dcgettext", 1, 3);

	if (nargs == 3) {	/* third argument */
		tmp = POP_STRING();
		if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string third argument"), "dcgettext");
		lc_cat = localecategory_from_argument(tmp);
		DEREF(tmp);
	} else
		lc_cat = LC_MESSAGES;

	if (nargs >= 2) {  /* second argument */
		t2 = POP_STRING();
		if (do_lint && (fixtype(t2)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string second argument"), "dcgettext");
		domain = t2->stptr;
		str_terminate(t2, save2);
	} else
		domain = TEXTDOMAIN;
#else
	if (nargs == 3) {
		tmp = POP_STRING();
		if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string third argument"), "dcgettext");
		DEREF(tmp);
	}
	if (nargs >= 2) {
		t2 = POP_STRING();
		if (do_lint && (fixtype(t2)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string second argument"), "dcgettext");
		DEREF(t2);
	}
#endif

	t1 = POP_STRING();	/* first argument */
	if (do_lint && (fixtype(t1)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string first argument"), "dcgettext");
	string = t1->stptr;

#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT
	str_terminate(t1, save1);
	the_result = dcgettext(domain, string, lc_cat);
	str_restore(t1, save1);
	if (t2 != NULL) {
		str_restore(t2, save2);
		DEREF(t2);
	}
	reslen = strlen(the_result);
#else
	the_result = string;
	reslen = t1->stlen;
#endif
	DEREF(t1);
	return make_string(the_result, reslen);
}


NODE *
do_dcngettext(int nargs)
{
	NODE *tmp, *t1, *t2, *t3;
	char *string1, *string2;
	unsigned long number;
	AWKNUM d;
	char *the_result;
	size_t reslen;

#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT
	int lc_cat;
	char *domain;
	char save = '\0', save1 = '\0', save2 = '\0';
	bool saved_end = false;

	check_args_min_max(nargs, "dcngettext", 3, 5);

	if (nargs == 5) {	/* fifth argument */
		tmp = POP_STRING();
		if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string fifth argument"), "dcngettext");
		lc_cat = localecategory_from_argument(tmp);
		DEREF(tmp);
	} else
		lc_cat = LC_MESSAGES;

	t3 = NULL;
	if (nargs >= 4) {	/* fourth argument */
		t3 = POP_STRING();
		if (do_lint && (fixtype(t3)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string fourth argument"), "dcngettext");
		domain = t3->stptr;
		save = domain[t3->stlen];
		domain[t3->stlen] = '\0';
		saved_end = true;
	} else
		domain = TEXTDOMAIN;
#else
	if (nargs == 5) {
		tmp = POP_STRING();
		if (do_lint && (fixtype(tmp)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string fifth argument"), "dcngettext");
		DEREF(tmp);
	}
	if (nargs >= 4) {
		t3 = POP_STRING();
		if (do_lint && (fixtype(t3)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string fourth argument"), "dcngettext");
		DEREF(t3);
	}
#endif

	t2 = POP_NUMBER();	/* third argument */
	if (do_lint && (fixtype(t2)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric third argument"), "dcngettext");
	d = get_number_d(t2);
	DEREF(t2);

	number = (unsigned long) double_to_int(d);
	t2 = POP_STRING();	/* second argument */
	if (do_lint && (fixtype(t2)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string second argument"), "dcngettext");
	string2 = t2->stptr;
	t1 = POP_STRING();	/* first argument */
	if (do_lint && (fixtype(t1)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string first argument"), "dcngettext");
	string1 = t1->stptr;

#if ENABLE_NLS && defined(LC_MESSAGES) && HAVE_DCGETTEXT

	str_terminate(t1, save1);
	str_terminate(t2, save2);
	the_result = dcngettext(domain, string1, string2, number, lc_cat);
	reslen = strlen(the_result);
	str_restore(t1, save1);
	str_restore(t2, save2);
	if (saved_end)
		domain[t3->stlen] = save;
	if (t3 != NULL)
		DEREF(t3);
#else
	if (number == 1) {
		the_result = string1;
		reslen = t1->stlen;
	} else {
		the_result = string2;
		reslen = t2->stlen;
	}
#endif
	DEREF(t1);
	DEREF(t2);
	return make_string(the_result, reslen);
}

/* do_bindtextdomain --- set the directory for a text domain */

/*
 * awk usage is
 *
 * 	binding = bindtextdomain(dir [, domain])
 *
 * If dir is "", pass NULL to C version.
 * Default domain is TEXTDOMAIN.
 */

NODE *
do_bindtextdomain(int nargs)
{
	NODE *t1, *t2;
	const char *directory, *domain;
	const char *the_result;

	check_args_min_max(nargs, "bindtextdomain", 1, 2);

	t1 = t2 = NULL;
	/* set defaults */
	directory = NULL;
	domain = TEXTDOMAIN;
	char save = '\0', save1 = '\0';

	if (nargs == 2) {	/* second argument */
		t2 = POP_STRING();
		if (do_lint && (fixtype(t2)->flags & STRING) == 0)
			lintwarn(_("%s: received non-string second argument"), "bindtextdomain");
		domain = (const char *) t2->stptr;
		save = t2->stptr[t2->stlen];
		t2->stptr[t2->stlen] = '\0';
	}

	/* first argument */
	t1 = POP_STRING();
	if (do_lint && (fixtype(t1)->flags & STRING) == 0)
		lintwarn(_("%s: received non-string first argument"), "bindtextdomain");
	if (t1->stlen > 0) {
		directory = (const char *) t1->stptr;
		str_terminate(t1, save1);
	}

	the_result = bindtextdomain(domain, directory);
	if (directory)
		str_restore(t1, save1);

	DEREF(t1);
	if (t2 != NULL) {
		t2->stptr[t2->stlen] = save;
		DEREF(t2);
	}

	if (the_result == NULL)
		the_result = "";

	return make_string(the_result, strlen(the_result));
}

#ifdef SUPPLY_INTDIV
/* do_intdiv --- do integer division, return quotient and remainder in dest array */

/*
 * We define the semantics as:
 * 	numerator = int(numerator)
 *	denominator = int(denonmator)
 *	quotient = int(numerator / denomator)
 *	remainder = int(numerator % denomator)
 */

NODE *
do_intdiv(int nargs)
{
	NODE *numerator, *denominator, *result;
	double num, denom, quotient, remainder;

	check_exact_args(nargs, "intdiv", 3);

	result = POP_PARAM();
	if (result->type != Node_var_array)
		fatal(_("intdiv: third argument is not an array"));
	assoc_clear(result);

	denominator = POP_SCALAR();
	numerator = POP_SCALAR();

	if (do_lint) {
		if ((fixtype(numerator)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric first argument"), "intdiv");
		if ((fixtype(denominator)->flags & NUMBER) == 0)
			lintwarn(_("%s: received non-numeric second argument"), "intdiv");
	}

	(void) force_number(numerator);
	(void) force_number(denominator);
	num = double_to_int(get_number_d(numerator));
	denom = double_to_int(get_number_d(denominator));

	if (denom == 0.0)
		fatal(_("intdiv: division by zero attempted"));

	quotient = double_to_int(num / denom);
	/*
	 * FIXME: This code is duplicated, factor it out to a
	 * separate function.
	 */
#ifdef HAVE_FMOD
	remainder = fmod(num, denom);
#else	/* ! HAVE_FMOD */
	(void) modf(num / denom, & remainder);
	remainder = num - remainder * denom;
#endif	/* ! HAVE_FMOD */
	remainder = double_to_int(remainder);

	assoc_set(result, make_string("quotient", 8), make_number((AWKNUM) quotient));

	assoc_set(result, make_string("remainder", 9), make_number((AWKNUM) remainder));

	DEREF(denominator);
	DEREF(numerator);

	return make_number((AWKNUM) 0.0);
}
#endif /* SUPPLY_INTDIV */

/* do_typeof --- return a string with the type of the arg */

NODE *
do_typeof(int nargs)
{
	NODE *arg;
	const char *res = NULL;
	bool deref = true;
	NODE *dbg;

	check_args_min_max(nargs, "typeof", 1, 2);

	if (nargs == 2) {	/* 2nd optional arg for debugging */
		dbg = POP_PARAM();
		if (dbg->type != Node_var_array)
			fatal(_("typeof: second argument is not an array"));
		assoc_clear(dbg);
	}
	else
		dbg = NULL;
	arg = POP();

	if (arg->type == Node_param_list) {
		arg = GET_PARAM(arg->param_cnt);
		if (arg->type == Node_array_ref) {
			arg = arg->orig_array;
		}
	}

	switch (arg->type) {
	case Node_var_array:
		/* Node_var_array is never UPREF'ed */
		res = "array";
		deref = false;
		if (dbg) {
			assoc_set(dbg, make_string("array_type", 10), make_string(arg->array_funcs->name, strlen(arg->array_funcs->name)));
			if (arg == PROCINFO_node) {
				int i;
				for (i = 0; i < BLOCK_MAX; i++) {
					char *p;
					size_t nl = strlen(nextfree[i].name);
					/*
					 * save values before we create new
					 * array elements so that we have a
					 * snapshot at a consistent moment in
					 * time
					 */
					long hw = nextfree[i].highwater;
					long active;
#ifdef MEMDEBUG
					active = nextfree[i].active;
#else
					active = hw;
					{
						struct block_item *ip;
						for (ip = nextfree[i].freep; ip; ip = ip->freep)
							active--;
					}
#endif

#define SETVAL(X, V) {	\
	size_t l = nl + sizeof(#X);	\
	emalloc(p, char *, l+1);	\
	sprintf(p, "%s_" #X, nextfree[i].name);	\
	assoc_set(dbg, make_str_node(p, l, ALREADY_MALLOCED), make_number((AWKNUM) (V)));	\
}
					SETVAL(highwater, hw)
					SETVAL(active, active)
#undef SETVAL
				}
			}
		}
		break;
	case Node_var:
		/*
 		 * This can happen when a Node_elem_new gets turned into a Node_var.
		 * BEGIN {
		 * 	f(a["b"])
		 * 	print typeof(a["b"])
		 * }
		 *
		 * function f(x)
		 * {
		 * 	return x
		 * }
		 */
		arg = arg->var_value;
		// fall through
	case Node_val:
		switch (fixtype(arg)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {
		case NUMBER|BOOLVAL:
			res = "number|bool";
			break;
		case NUMBER:
			res = "number";
			break;
		case NUMBER|USER_INPUT:
			res = "strnum";
			break;
		case REGEX:
			res = "regexp";
			break;
		case STRING:
			res = "string";
			// fall through
		case NUMBER|STRING:
		{
			int flags = STRING|NUMBER|STRCUR|NUMCUR;

			if (   arg == Nnull_string		// unassigned scalar
			    || (arg->flags & NULL_FIELD) != 0	// unassigned field
			    || (arg->flags & flags) == flags) {	// Node_elem_new used as scalar value
				res = "unassigned";
				break;
			}
		}
			/* fall through */
		default:
			if (res == NULL) {
				warning(_("typeof detected invalid flags combination `%s'; please file a bug report"), flags2str(arg->flags));
				res = "unknown";
			}
			break;
		}
		if (dbg) {
			const char *s = flags2str(arg->flags);
			assoc_set(dbg, make_string("flags", 5), make_string(s, strlen(s)));
		}
		break;
	case Node_var_new:
	case Node_elem_new:
		res = "untyped";
		deref = false;
		break;
	case Node_array_ref:
		/*
		 *	function f(x) {
		 *	   print typeof(x)
		 *	   y = x
		 *	   print typeof(x)
		 *	}
		 *
		 *	BEGIN {
		 *	   print typeof(x)
		 *	   f(x)
		 *	}
		 */
		if (arg->orig_array->type == Node_var
		    && (arg->orig_array->var_value == Nnull_string
		        || (arg->orig_array->var_value->flags & NULL_FIELD) != 0)) {
			res = "unassigned";
		} else {
			res = "untyped";
		}
		deref = false;
		break;
	default:
		fatal(_("typeof: unknown argument type `%s'"),
				nodetype2str(arg->type));
		break;
	}

	if (deref)
		DEREF(arg);
	return make_string(res, strlen(res));
}

/* sanitize_exit_status --- convert a 16 bit Unix exit status into something reasonable */

int
sanitize_exit_status(int status)
{
	int ret = 0;

	if (WIFEXITED(status))
		ret = WEXITSTATUS(status); /* normal exit */
	else if (WIFSIGNALED(status)) {
		bool coredumped = false;
#ifdef WCOREDUMP
		coredumped = WCOREDUMP(status);
#endif
		/* use 256 since exit values are 8 bits */
		ret = WTERMSIG(status) + (coredumped ? 512 : 256);
	} else
		ret = 0;	/* shouldn't get here */

	return ret;
}

/* check_symtab_functab --- check if dest is SYMTAB or FUNCTAB, fatal if so */

void
check_symtab_functab(NODE *dest, const char *fname, const char *msg)
{
	if (dest == symbol_table)
		fatal(msg, fname, "SYMTAB");
	else if (dest == func_table)
		fatal(msg, fname, "FUNCTAB");
}

/* do_mkbool --- create boolean values */

NODE *
do_mkbool(int nargs)
{
	NODE *tmp;
	bool result;

	tmp = POP_SCALAR();
	result = boolval(tmp);
	DEREF(tmp);

	return make_bool_node(result);
}

/* gawk_system --- specialized version for gawk */

int
gawk_system(const char *command)
{
#if defined(VMS) || defined(__MINGW32__)
	return system(command);
#else /* ! (defined(VMS) || defined(__MINGW32__)) */
	pid_t childpid;
	int status;

	if ((childpid = fork()) == 0) {
		// child
		set_sigpipe_to_default();
		execl("/bin/sh", "sh", "-c", command, NULL);
		_exit(errno == ENOENT ? 127 : 126);
	} else {
		// parent
		status = wait_any(childpid);

		return status;
	}
#endif /* defined(VMS) || defined(__MINGW32__) */
}

#if 0
// test program

int main(int argc, char **argv)
{
	struct lconv *l;

	setlocale(LC_ALL, "");
	l = localeconv();

	const char *new = add_thousands("12345678901234567890.54321", l);
	printf("%s\n", new);
	free((void*) new);

	new = add_thousands("12345678901234567890", l);
	printf("%s\n", new);
	free((void*) new);

	return 0;
}
#endif
/*
 * eval.c - gawk bytecode interpreter
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2019, 2021-2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"
#include <math.h>

NODE **fcall_list = NULL;
long fcall_count = 0;
int currule = 0;
IOBUF *curfile = NULL;		/* current data file */
bool exiting = false;

int (*interpret)(INSTRUCTION *);
#define MAX_EXEC_HOOKS	10
static int num_exec_hook = 0;
static Func_pre_exec pre_execute[MAX_EXEC_HOOKS];
static Func_post_exec post_execute = NULL;

static double fix_nan_sign(double left, double right, double result);

extern void frame_popped();

int OFSlen;
int ORSlen;
int OFMTidx;
int CONVFMTidx;

static NODE *node_Boolean[2];

/* This rather ugly macro is for VMS C */
#ifdef C
#undef C
#endif
#define C(c) ((char)c)
/*
 * This table is used by the regexp routines to do case independent
 * matching. Basically, every ascii character maps to itself, except
 * uppercase letters map to lower case ones. This table has 256
 * entries, for ISO 8859-1. Note also that if the system this
 * is compiled on doesn't use 7-bit ascii, casetable[] should not be
 * defined to the linker, so gawk should not load.
 *
 * Do NOT make this array static, it is used in several spots, not
 * just in this file.
 *
 * 6/2004:
 * This table is also used for IGNORECASE for == and !=, and index().
 * Although with GLIBC, we could use tolower() everywhere and RE_ICASE
 * for the regex matcher, precomputing this table once gives us a
 * performance improvement.  I also think it's better for portability
 * to non-GLIBC systems.  All the world is not (yet :-) GNU/Linux.
 */
#if 'a' == 97	/* it's ascii */
char casetable[] = {
	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
	/* ' '     '!'     '"'     '#'     '$'     '%'     '&'     ''' */
	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
	/* '('     ')'     '*'     '+'     ','     '-'     '.'     '/' */
	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
	/* '0'     '1'     '2'     '3'     '4'     '5'     '6'     '7' */
	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
	/* '8'     '9'     ':'     ';'     '<'     '='     '>'     '?' */
	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
	/* '@'     'A'     'B'     'C'     'D'     'E'     'F'     'G' */
	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	/* 'H'     'I'     'J'     'K'     'L'     'M'     'N'     'O' */
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	/* 'P'     'Q'     'R'     'S'     'T'     'U'     'V'     'W' */
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	/* 'X'     'Y'     'Z'     '['     '\'     ']'     '^'     '_' */
	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
	/* '`'     'a'     'b'     'c'     'd'     'e'     'f'     'g' */
	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
	/* 'h'     'i'     'j'     'k'     'l'     'm'     'n'     'o' */
	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
	/* 'p'     'q'     'r'     's'     't'     'u'     'v'     'w' */
	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
	/* 'x'     'y'     'z'     '{'     '|'     '}'     '~' */
	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',

	/* Latin 1: */
	/*
	 * 4/2019: This is now overridden; in single byte locales
	 * we call load_casetable from main and it fills in the values
	 * based on the current locale. In particular, we want LC_ALL=C
	 * to work correctly for values >= 0200.
	 */
	C('\200'), C('\201'), C('\202'), C('\203'), C('\204'), C('\205'), C('\206'), C('\207'),
	C('\210'), C('\211'), C('\212'), C('\213'), C('\214'), C('\215'), C('\216'), C('\217'),
	C('\220'), C('\221'), C('\222'), C('\223'), C('\224'), C('\225'), C('\226'), C('\227'),
	C('\230'), C('\231'), C('\232'), C('\233'), C('\234'), C('\235'), C('\236'), C('\237'),
	C('\240'), C('\241'), C('\242'), C('\243'), C('\244'), C('\245'), C('\246'), C('\247'),
	C('\250'), C('\251'), C('\252'), C('\253'), C('\254'), C('\255'), C('\256'), C('\257'),
	C('\260'), C('\261'), C('\262'), C('\263'), C('\264'), C('\265'), C('\266'), C('\267'),
	C('\270'), C('\271'), C('\272'), C('\273'), C('\274'), C('\275'), C('\276'), C('\277'),
	C('\340'), C('\341'), C('\342'), C('\343'), C('\344'), C('\345'), C('\346'), C('\347'),
	C('\350'), C('\351'), C('\352'), C('\353'), C('\354'), C('\355'), C('\356'), C('\357'),
	C('\360'), C('\361'), C('\362'), C('\363'), C('\364'), C('\365'), C('\366'), C('\327'),
	C('\370'), C('\371'), C('\372'), C('\373'), C('\374'), C('\375'), C('\376'), C('\337'),
	C('\340'), C('\341'), C('\342'), C('\343'), C('\344'), C('\345'), C('\346'), C('\347'),
	C('\350'), C('\351'), C('\352'), C('\353'), C('\354'), C('\355'), C('\356'), C('\357'),
	C('\360'), C('\361'), C('\362'), C('\363'), C('\364'), C('\365'), C('\366'), C('\367'),
	C('\370'), C('\371'), C('\372'), C('\373'), C('\374'), C('\375'), C('\376'), C('\377'),
};
#elif defined(USE_EBCDIC)
char casetable[] = {
 /*00  NU    SH    SX    EX    PF    HT    LC    DL */
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
 /*08              SM    VT    FF    CR    SO    SI */
      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 /*10  DE    D1    D2    TM    RS    NL    BS    IL */
      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
 /*18  CN    EM    CC    C1    FS    GS    RS    US */
      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
 /*20  DS    SS    FS          BP    LF    EB    EC */
      0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
 /*28              SM    C2    EQ    AK    BL       */
      0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
 /*30              SY          PN    RS    UC    ET */
      0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 /*38                    C3    D4    NK          SU */
      0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
 /*40  SP                                           */
      0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 /*48             CENT    .     <     (     +     | */
      0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
 /*50   &                                           */
      0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 /*58               !     $     *     )     ;     ^ */
      0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
 /*60   -     /                                     */
      0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 /*68               |     ,     %     _     >     ? */
      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
 /*70                                               */
      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 /*78         `     :     #     @     '     =     " */
      0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
 /*80         a     b     c     d     e     f     g */
      0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
 /*88   h     i           {                         */
      0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
 /*90         j     k     l     m     n     o     p */
      0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
 /*98   q     r           }                         */
      0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
 /*A0         ~     s     t     u     v     w     x */
      0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
 /*A8   y     z                       [             */
      0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
 /*B0                                               */
      0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
 /*B8                                 ]             */
      0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
 /*C0   {     A     B     C     D     E     F     G */
      0xC0, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
 /*C8   H     I                                     */
      0x88, 0x89, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
 /*D0   }     J     K     L     M     N     O     P */
      0xD0, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
 /*D8   Q     R                                     */
      0x98, 0x99, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
 /*E0   \           S     T     U     V     W     X */
      0xE0, 0xE1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
 /*E8   Y     Z                                     */
      0xA8, 0xA9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
 /*F0   0     1     2     3     4     5     6     7 */
      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
 /*F8   8     9                                     */
      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};
#else
#include "You lose. You will need a translation table for your character set."
#endif

#undef C

/* load_casetable --- for a non-ASCII locale, redo the table */

void
load_casetable(void)
{
#if defined(LC_CTYPE)
	int i;
	static bool loaded = false;

	if (loaded || do_traditional)
		return;

	loaded = true;

#ifndef USE_EBCDIC
	/* use of isalpha is ok here (see is_alpha in awkgram.y) */
	for (i = 0200; i <= 0377; i++) {
		if (isalpha(i) && islower(i) && i != toupper(i))
			casetable[i] = toupper(i);
		else
			casetable[i] = i;
	}
#endif
#endif
}

/*
 * This table maps node types to strings for debugging.
 * KEEP IN SYNC WITH awk.h!!!!
 */

static const char *const nodetypes[] = {
	"Node_illegal",
	"Node_val",
	"Node_regex",
	"Node_dynregex",
	"Node_var",
	"Node_var_array",
	"Node_var_new",
	"Node_elem_new",
	"Node_param_list",
	"Node_func",
	"Node_ext_func",
	"Node_builtin_func",
	"Node_array_ref",
	"Node_array_tree",
	"Node_array_leaf",
	"Node_dump_array",
	"Node_arrayfor",
	"Node_frame",
	"Node_instruction",
	"Node_final --- this should never appear",
	NULL
};


/*
 * This table maps Op codes to strings.
 * KEEP IN SYNC WITH awk.h!!!!
 */

static struct optypetab {
	char *desc;
	char *operator;
} optypes[] = {
	{ "Op_illegal", NULL },
	{ "Op_times", " * " },
	{ "Op_times_i", " * " },
	{ "Op_quotient", " / " },
	{ "Op_quotient_i", " / " },
	{ "Op_mod", " % " },
	{ "Op_mod_i", " % " },
	{ "Op_plus", " + " },
	{ "Op_plus_i", " + " },
	{ "Op_minus", " - " },
	{ "Op_minus_i", " - " },
	{ "Op_exp", " ^ " },
	{ "Op_exp_i", " ^ " },
	{ "Op_concat", " " },
	{ "Op_line_range", NULL },
	{ "Op_cond_pair", ", " },
	{ "Op_subscript", "[]" },
	{ "Op_sub_array", "[]" },
	{ "Op_preincrement", "++" },
	{ "Op_predecrement", "--" },
	{ "Op_postincrement", "++" },
	{ "Op_postdecrement", "--" },
	{ "Op_unary_minus", "-" },
	{ "Op_unary_plus", "+" },
	{ "Op_field_spec", "$" },
	{ "Op_not", "! " },
	{ "Op_assign", " = " },
	{ "Op_store_var", " = " },
	{ "Op_store_sub", " = " },
	{ "Op_store_field", " = " },
	{ "Op_store_field_exp", " = " },
	{ "Op_assign_times", " *= " },
	{ "Op_assign_quotient", " /= " },
	{ "Op_assign_mod", " %= " },
	{ "Op_assign_plus", " += " },
	{ "Op_assign_minus", " -= " },
	{ "Op_assign_exp", " ^= " },
	{ "Op_assign_concat", " " },
	{ "Op_and", " && " },
	{ "Op_and_final", NULL },
	{ "Op_or", " || " },
	{ "Op_or_final", NULL },
	{ "Op_equal", " == " },
	{ "Op_notequal", " != " },
	{ "Op_less", " < " },
	{ "Op_greater", " > " },
	{ "Op_leq", " <= " },
	{ "Op_geq", " >= " },
	{ "Op_match", " ~ " },
	{ "Op_match_rec", NULL },
	{ "Op_nomatch", " !~ " },
	{ "Op_rule", NULL },
	{ "Op_K_case", "case" },
	{ "Op_K_default", "default" },
	{ "Op_K_break", "break" },
	{ "Op_K_continue", "continue" },
	{ "Op_K_print", "print" },
	{ "Op_K_print_rec", "print" },
	{ "Op_K_printf", "printf" },
	{ "Op_K_next", "next" },
	{ "Op_K_exit", "exit" },
	{ "Op_K_return", "return" },
	{ "Op_K_return_from_eval", "return" },
	{ "Op_K_delete", "delete" },
	{ "Op_K_delete_loop", NULL },
	{ "Op_K_getline_redir", "getline" },
	{ "Op_K_getline", "getline" },
	{ "Op_K_nextfile", "nextfile" },
	{ "Op_K_namespace", "@namespace" },
	{ "Op_builtin", NULL },
	{ "Op_sub_builtin", NULL },
	{ "Op_ext_builtin", NULL },
	{ "Op_in_array", " in " },
	{ "Op_func_call", NULL },
	{ "Op_indirect_func_call", NULL },
	{ "Op_push", NULL },
	{ "Op_push_arg", NULL },
	{ "Op_push_arg_untyped", NULL },
	{ "Op_push_i", NULL },
	{ "Op_push_re", NULL },
	{ "Op_push_array", NULL },
	{ "Op_push_param", NULL },
	{ "Op_push_lhs", NULL },
	{ "Op_subscript_lhs", "[]" },
	{ "Op_field_spec_lhs", "$" },
	{ "Op_no_op", NULL },
	{ "Op_pop", NULL },
	{ "Op_jmp", NULL },
	{ "Op_jmp_true", NULL },
	{ "Op_jmp_false", NULL },
	{ "Op_get_record", NULL },
	{ "Op_newfile", NULL },
	{ "Op_arrayfor_init", NULL },
	{ "Op_arrayfor_incr", NULL },
	{ "Op_arrayfor_final", NULL },
	{ "Op_var_update", NULL },
	{ "Op_var_assign", NULL },
	{ "Op_field_assign", NULL },
	{ "Op_subscript_assign", NULL },
	{ "Op_after_beginfile", NULL },
	{ "Op_after_endfile", NULL },
	{ "Op_func", NULL },
	{ "Op_comment", NULL },
	{ "Op_exec_count", NULL },
	{ "Op_breakpoint", NULL },
	{ "Op_lint", NULL },
	{ "Op_lint_plus", NULL },
	{ "Op_atexit", NULL },
	{ "Op_stop", NULL },
	{ "Op_token", NULL },
	{ "Op_symbol", NULL },
	{ "Op_list", NULL },
	{ "Op_K_do", "do" },
	{ "Op_K_for", "for" },
	{ "Op_K_arrayfor", "for" },
	{ "Op_K_while", "while" },
	{ "Op_K_switch", "switch" },
	{ "Op_K_if", "if" },
	{ "Op_K_else", "else" },
	{ "Op_K_function", "function" },
	{ "Op_cond_exp", NULL },
	{ "Op_parens", NULL },
	{ "Op_final --- this should never appear", NULL },
	{ NULL, NULL },
};

/* nodetype2str --- convert a node type into a printable value */

const char *
nodetype2str(NODETYPE type)
{
	static char buf[40];

	if (type >= Node_illegal && type <= Node_final)
		return nodetypes[(int) type];

	sprintf(buf, _("unknown nodetype %d"), (int) type);
	return buf;
}

/* opcode2str --- convert an opcode type into a printable value */

const char *
opcode2str(OPCODE op)
{
	if (op >= Op_illegal && op < Op_final)
		return optypes[(int) op].desc;
	fatal(_("unknown opcode %d"), (int) op);
	return "";	// keeps the compiler happy in some cases
}

/* op2str --- convert an opcode type to corresponding operator or keyword */

const char *
op2str(OPCODE op)
{
	if (op >= Op_illegal && op < Op_final) {
		if (optypes[(int) op].operator != NULL)
			return optypes[(int) op].operator;
		else
			fatal(_("opcode %s not an operator or keyword"),
					optypes[(int) op].desc);
	} else
		fatal(_("unknown opcode %d"), (int) op);
	return NULL;
}


/* flags2str --- make a flags value readable */

const char *
flags2str(int flagval)
{
	static const struct flagtab values[] = {
		{ MALLOC, "MALLOC" },
		{ STRING, "STRING" },
		{ STRCUR, "STRCUR" },
		{ NUMCUR, "NUMCUR" },
		{ NUMBER, "NUMBER" },
		{ USER_INPUT, "USER_INPUT" },
		{ BOOLVAL, "BOOL" },
		{ INTLSTR, "INTLSTR" },
		{ NUMINT, "NUMINT" },
		{ INTIND, "INTIND" },
		{ WSTRCUR, "WSTRCUR" },
		{ MPFN,	"MPFN" },
		{ MPZN,	"MPZN" },
		{ NO_EXT_SET, "NO_EXT_SET" },
		{ NULL_FIELD, "NULL_FIELD" },
		{ ARRAYMAXED, "ARRAYMAXED" },
		{ HALFHAT, "HALFHAT" },
		{ XARRAY, "XARRAY" },
		{ NUMCONSTSTR, "NUMCONSTSTR" },
		{ REGEX, "REGEX" },
		{ 0,	NULL },
	};

	return genflags2str(flagval, values);
}

/* genflags2str --- general routine to convert a flag value to a string */

const char *
genflags2str(int flagval, const struct flagtab *tab)
{
	static char buffer[BUFSIZ];
	char *sp;
	int i, space_left, space_needed;

	sp = buffer;
	space_left = BUFSIZ;
	for (i = 0; tab[i].name != NULL; i++) {
		if ((flagval & tab[i].val) != 0) {
			/*
			 * note the trick, we want 1 or 0 for whether we need
			 * the '|' character.
			 */
			space_needed = (strlen(tab[i].name) + (sp != buffer));
			if (space_left <= space_needed)
				fatal(_("buffer overflow in genflags2str"));

			if (sp != buffer) {
				*sp++ = '|';
				space_left--;
			}
			strcpy(sp, tab[i].name);
			/* note ordering! */
			space_left -= strlen(sp);
			sp += strlen(sp);
		}
	}

	*sp = '\0';
	return buffer;
}

/* posix_compare --- compare strings using strcoll */

static int
posix_compare(NODE *s1, NODE *s2)
{
	int ret;

	if (gawk_mb_cur_max == 1) {
		char save1, save2;
		const char *p1, *p2;

		save1 = s1->stptr[s1->stlen];
		s1->stptr[s1->stlen] = '\0';

		save2 = s2->stptr[s2->stlen];
		s2->stptr[s2->stlen] = '\0';

		p1 = s1->stptr;
		p2 = s2->stptr;

		for (;;) {
			size_t len;

			ret = strcoll(p1, p2);
			if (ret != 0)
				break;

			len = strlen(p1);
			p1 += len + 1;
			p2 += len + 1;

			if (p1 == s1->stptr + s1->stlen + 1) {
				if (p2 != s2->stptr + s2->stlen + 1)
					ret = -1;
				break;
			}
			if (p2 == s2->stptr + s2->stlen + 1) {
				ret = 1;
				break;
			}
		}

		s1->stptr[s1->stlen] = save1;
		s2->stptr[s2->stlen] = save2;
	}
	else {
		/* Similar logic, using wide characters */
		const wchar_t *p1, *p2;

		(void) force_wstring(s1);
		(void) force_wstring(s2);

		p1 = s1->wstptr;
		p2 = s2->wstptr;

		for (;;) {
			size_t len;

			ret = wcscoll(p1, p2);
			if (ret != 0)
				break;

			len = wcslen(p1);
			p1 += len + 1;
			p2 += len + 1;

			if (p1 == s1->wstptr + s1->wstlen + 1) {
				if (p2 != s2->wstptr + s2->wstlen + 1)
					ret = -1;
				break;
			}
			if (p2 == s2->wstptr + s2->wstlen + 1) {
				ret = 1;
				break;
			}
		}
	}

	return ret;
}


/* cmp_nodes --- compare two nodes, returning negative, 0, positive */

int
cmp_nodes(NODE *t1, NODE *t2, bool use_strcmp)
{
	int ret = 0;
	size_t len1, len2;
	int l, ldiff;

	if (t1 == t2)
		return 0;

	(void) fixtype(t1);
	(void) fixtype(t2);

	if ((t1->flags & NUMBER) != 0 && (t2->flags & NUMBER) != 0)
		return cmp_numbers(t1, t2);

	(void) force_string(t1);
	(void) force_string(t2);
	len1 = t1->stlen;
	len2 = t2->stlen;
	ldiff = len1 - len2;
	if (len1 == 0 || len2 == 0)
		return ldiff;

	if (do_posix && ! use_strcmp)
		return posix_compare(t1, t2);

	l = (ldiff <= 0 ? len1 : len2);
	if (IGNORECASE) {
		const unsigned char *cp1 = (const unsigned char *) t1->stptr;
		const unsigned char *cp2 = (const unsigned char *) t2->stptr;
		char save1 = t1->stptr[t1->stlen];
		char save2 = t2->stptr[t2->stlen];


		if (gawk_mb_cur_max > 1) {
			t1->stptr[t1->stlen] = t2->stptr[t2->stlen] = '\0';
			ret = strncasecmpmbs((const unsigned char *) cp1,
					     (const unsigned char *) cp2, l);
			t1->stptr[t1->stlen] = save1;
			t2->stptr[t2->stlen] = save2;
		} else {
			/* Could use tolower() here; see discussion above. */
			for (ret = 0; l-- > 0 && ret == 0; cp1++, cp2++)
				ret = casetable[*cp1] - casetable[*cp2];
		}
	} else
		ret = memcmp(t1->stptr, t2->stptr, l);

	ret = ret == 0 ? ldiff : ret;
	return ret;
}

/* push_frame --- push a frame NODE onto stack */

static void
push_frame(NODE *f)
{
	static long max_fcall;

	/* NB: frame numbering scheme as in GDB. frame_ptr => frame #0. */

	fcall_count++;
	if (fcall_list == NULL) {
		max_fcall = 10;
		emalloc(fcall_list, NODE **, (max_fcall + 1) * sizeof(NODE *));
	} else if (fcall_count == max_fcall) {
		max_fcall *= 2;
		erealloc(fcall_list, NODE **, (max_fcall + 1) * sizeof(NODE *));
	}

	if (fcall_count > 1)
		memmove(fcall_list + 2, fcall_list + 1, (fcall_count - 1) * sizeof(NODE *));
	fcall_list[1] = f;
}


/* pop_frame --- pop off a frame NODE*/

static void
pop_frame()
{
	if (fcall_count > 1)
		memmove(fcall_list + 1, fcall_list + 2, (fcall_count - 1) * sizeof(NODE *));
	fcall_count--;
	assert(fcall_count >= 0);
	if (do_debug)
		frame_popped();
}


/* dump_fcall_stack --- print a backtrace of the awk function calls */

void
dump_fcall_stack(FILE *fp)
{
	NODE *f, *func;
	long i = 0, k = 0;

	if (fcall_count == 0)
		return;
	fprintf(fp, _("\n\t# Function Call Stack:\n\n"));

	/* current frame */
	func = frame_ptr->func_node;
	fprintf(fp, "\t# %3ld. %s\n", k++, func->vname);

	/* outer frames except main */
	for (i = 1; i < fcall_count; i++) {
		f = fcall_list[i];
		func = f->func_node;
		fprintf(fp, "\t# %3ld. %s\n", k++, func->vname);
	}

	fprintf(fp, "\t# %3ld. -- main --\n", k);
}


/* set_IGNORECASE --- update IGNORECASE as appropriate */

void
set_IGNORECASE()
{
	static bool warned = false;

	if ((do_lint_extensions || do_traditional) && ! warned) {
		warned = true;
		lintwarn(_("`IGNORECASE' is a gawk extension"));
	}

	if (do_traditional)
		IGNORECASE = false;
   	else
		IGNORECASE = boolval(IGNORECASE_node->var_value);
	set_RS();	/* set_RS() calls set_FS() if need be, for us */
}

/* set_BINMODE --- set translation mode (OS/2, DOS, others) */

void
set_BINMODE()
{
	static bool warned = false;
	char *p;
	NODE *v = fixtype(BINMODE_node->var_value);

	if ((do_lint_extensions || do_traditional) && ! warned) {
		warned = true;
		lintwarn(_("`BINMODE' is a gawk extension"));
	}
	if (do_traditional)
		BINMODE = TEXT_TRANSLATE;
	else if ((v->flags & NUMBER) != 0) {
		BINMODE = get_number_si(v);
		/* Make sure the value is rational. */
		if (BINMODE < TEXT_TRANSLATE)
			BINMODE = TEXT_TRANSLATE;
		else if (BINMODE > BINMODE_BOTH)
			BINMODE = BINMODE_BOTH;
	} else if ((v->flags & STRING) != 0) {
		p = v->stptr;

		/*
		 * Allow only one of the following:
		 * "0", "1", "2", "3",
		 * "r", "w", "rw", "wr"
		 * ANYTHING ELSE goes to 3. So there.
		 */
		switch (v->stlen) {
		case 1:
			switch (p[0]) {
			case '0':
			case '1':
			case '2':
			case '3':
				BINMODE = p[0] - '0';
				break;
			case 'r':
				BINMODE = BINMODE_INPUT;
				break;
			case 'w':
				BINMODE = BINMODE_OUTPUT;
				break;
			default:
				BINMODE = BINMODE_BOTH;
				goto bad_value;
				break;
			}
			break;
		case 2:
			switch (p[0]) {
			case 'r':
				BINMODE = BINMODE_BOTH;
				if (p[1] != 'w')
					goto bad_value;
				break;
			case 'w':
				BINMODE = BINMODE_BOTH;
				if (p[1] != 'r')
					goto bad_value;
				break;
			}
			break;
		default:
	bad_value:
			lintwarn(_("BINMODE value `%s' is invalid, treated as 3"), p);
			break;
		}
	} else
		BINMODE = 3;		/* shouldn't happen */
}

/* set_OFS --- update OFS related variables when OFS assigned to */

void
set_OFS()
{
	static bool first = true;
	size_t new_ofs_len;

	if (first)	/* true when called from init_vars() in main() */
		first = false;
	else {
		/* rebuild $0 using OFS that was current when $0 changed */
		if (! field0_valid) {
			get_field(UNLIMITED - 1, NULL);
			rebuild_record();
		}
	}

	/*
	 * Save OFS value for use in building record and in printing.
	 * Can't just have OFS point into the OFS_node since it's
	 * already updated when we come into this routine, and we need
	 * the old value to rebuild the record (see above).
	 */
	OFS_node->var_value = force_string(OFS_node->var_value);
	new_ofs_len = OFS_node->var_value->stlen;

	if (OFS == NULL)
		emalloc(OFS, char *, new_ofs_len + 1);
	else if (OFSlen < new_ofs_len)
		erealloc(OFS, char *, new_ofs_len + 1);

	memcpy(OFS, OFS_node->var_value->stptr, OFS_node->var_value->stlen);
	OFSlen = new_ofs_len;
	OFS[OFSlen] = '\0';
}

/* set_ORS --- update ORS related variables when ORS assigned to */

void
set_ORS()
{
	ORS_node->var_value = force_string(ORS_node->var_value);
	ORS = ORS_node->var_value->stptr;
	ORSlen = ORS_node->var_value->stlen;
}

/* fmt_ok --- is the conversion format a valid one? */

NODE **fmt_list = NULL;
static int fmt_ok(NODE *n);
static int fmt_index(NODE *n);

static int
fmt_ok(NODE *n)
{
	NODE *tmp = force_string(n);
	const char *p = tmp->stptr;

#if ! defined(PRINTF_HAS_F_FORMAT) || PRINTF_HAS_F_FORMAT != 1
	static const char float_formats[] = "efgEG";
#else
	static const char float_formats[] = "efgEFG";
#endif
#if defined(HAVE_LOCALE_H)
	static const char flags[] = " +-#'";
#else
	static const char flags[] = " +-#";
#endif

	// We rely on the caller to zero-terminate n->stptr.

	if (*p++ != '%')
		return 0;
	while (*p && strchr(flags, *p) != NULL)	/* flags */
		p++;
	while (*p && isdigit((unsigned char) *p))	/* width - %*.*g is NOT allowed */
		p++;
	if (*p == '\0' || (*p != '.' && ! isdigit((unsigned char) *p)))
		return 0;
	if (*p == '.')
		p++;
	while (*p && isdigit((unsigned char) *p))	/* precision */
		p++;
	if (*p == '\0' || strchr(float_formats, *p) == NULL)
		return 0;
	if (*++p != '\0')
		return 0;
	return 1;
}

/* fmt_index --- track values of OFMT and CONVFMT to keep semantics correct */

static int
fmt_index(NODE *n)
{
	int ix = 0;
	static int fmt_num = 4;
	static int fmt_hiwater = 0;
	char save;

	if (fmt_list == NULL)
		emalloc(fmt_list, NODE **, fmt_num*sizeof(*fmt_list));
	n = force_string(n);

	save = n->stptr[n->stlen];
	n->stptr[n->stlen] = '\0';

	while (ix < fmt_hiwater) {
		if (cmp_nodes(fmt_list[ix], n, true) == 0)
			return ix;
		ix++;
	}

	/* not found */
	if (do_lint && ! fmt_ok(n))
		lintwarn(_("bad `%sFMT' specification `%s'"),
			    n == CONVFMT_node->var_value ? "CONV"
			  : n == OFMT_node->var_value ? "O"
			  : "", n->stptr);

	n->stptr[n->stlen] = save;

	if (fmt_hiwater >= fmt_num) {
		fmt_num *= 2;
		erealloc(fmt_list, NODE **, fmt_num * sizeof(*fmt_list));
	}
	fmt_list[fmt_hiwater] = dupnode(n);
	return fmt_hiwater++;
}

/* set_OFMT --- track OFMT correctly */

void
set_OFMT()
{
	OFMTidx = fmt_index(OFMT_node->var_value);
	OFMT = fmt_list[OFMTidx]->stptr;
}

/* set_CONVFMT --- track CONVFMT correctly */

void
set_CONVFMT()
{
	CONVFMTidx = fmt_index(CONVFMT_node->var_value);
	CONVFMT = fmt_list[CONVFMTidx]->stptr;
}

/* set_LINT --- update LINT as appropriate */

void
set_LINT()
{
#ifndef NO_LINT
	int old_lint = do_lint;
	NODE *n = fixtype(LINT_node->var_value);

	/* start with clean defaults */
	lintfunc = r_warning;
	do_flags &= ~(DO_LINT_ALL|DO_LINT_INVALID);

	if ((n->flags & STRING) != 0) {
		const char *lintval;
		size_t lintlen;

		lintval = n->stptr;
		lintlen = n->stlen;
		if (lintlen > 0) {
			if (lintlen == 7 && strncmp(lintval, "invalid", 7) == 0)
				do_flags |= DO_LINT_INVALID;
			else if (lintlen == 6 && strncmp(lintval, "no-ext", 6) == 0)
				do_flags &= ~DO_LINT_EXTENSIONS;
			else {
				do_flags |= DO_LINT_ALL;
				if (lintlen == 5 && strncmp(lintval, "fatal", 5) == 0)
					lintfunc = r_fatal;
			}
		}
	} else {
		if (! is_zero(n))
			do_flags |= DO_LINT_ALL;
	}

	/* explicitly use warning() here, in case lintfunc == r_fatal */
	if (old_lint != do_lint && old_lint && ! do_lint)
		warning(_("turning off `--lint' due to assignment to `LINT'"));

	/* inform plug-in api of change */
	update_ext_api();
#endif /* ! NO_LINT */
}

/* set_TEXTDOMAIN --- update TEXTDOMAIN variable when TEXTDOMAIN assigned to */

void
set_TEXTDOMAIN()
{
	NODE *tmp;

	tmp = TEXTDOMAIN_node->var_value = force_string(TEXTDOMAIN_node->var_value);
	TEXTDOMAIN = tmp->stptr;
	/*
	 * Note: don't call textdomain(); this value is for
	 * the awk program, not for gawk itself.
	 */
}

/* update_ERRNO_int --- update the value of ERRNO based on argument */

void
update_ERRNO_int(int errcode)
{
	const char *cp;

	update_PROCINFO_num("errno", errcode);
	if (errcode) {
		cp = strerror(errcode);
		cp = gettext(cp);
	} else
		cp = "";
	unref(ERRNO_node->var_value);
	ERRNO_node->var_value = make_string(cp, strlen(cp));
}

/* update_ERRNO_string --- update ERRNO */

void
update_ERRNO_string(const char *string)
{
	update_PROCINFO_num("errno", 0);
	unref(ERRNO_node->var_value);
	size_t len = strlen(string);
#if defined(USE_EBCDIC) && defined(ELIDE_IBM_ERROR_CODE)
	// skip over leading IBM error code
	// N.B. This code is untested
	if (isupper(string[0]) && isupper(string[1])) {
		while (*string && *string != ' ')
			string++;

		while (*string && *string == ' ')
			string++;

		len = strlen(string);
		if (string[len-1] == '.')
			len--;	// remove the final '.'
	}
#endif
	ERRNO_node->var_value = make_string(string, len);
}

/* unset_ERRNO --- eliminate the value of ERRNO */

void
unset_ERRNO(void)
{
	update_PROCINFO_num("errno", 0);
	unref(ERRNO_node->var_value);
	ERRNO_node->var_value = dupnode(Nnull_string);
}

/* update_NR --- update the value of NR */

void
update_NR()
{
#ifdef HAVE_MPFR
	if (is_mpg_number(NR_node->var_value))
		(void) mpg_update_var(NR_node);
	else
#endif
	if (NR_node->var_value->numbr != NR) {
		unref(NR_node->var_value);
		NR_node->var_value = make_number(NR);
	}
}

/* update_NF --- update the value of NF */

void
update_NF()
{
	long l;

	l = get_number_si(NF_node->var_value);
	if (NF == -1 || l != NF) {
		if (NF == -1)
			(void) get_field(UNLIMITED - 1, NULL); /* parse record */
		unref(NF_node->var_value);
		NF_node->var_value = make_number(NF);
	}
}

/* update_FNR --- update the value of FNR */

void
update_FNR()
{
#ifdef HAVE_MPFR
	if (is_mpg_number(FNR_node->var_value))
		(void) mpg_update_var(FNR_node);
	else
#endif
	if (FNR_node->var_value->numbr != FNR) {
		unref(FNR_node->var_value);
		FNR_node->var_value = make_number(FNR);
	}
}


NODE *frame_ptr;        /* current frame */
STACK_ITEM *stack_ptr = NULL;
STACK_ITEM *stack_bottom;
STACK_ITEM *stack_top;
static unsigned long STACK_SIZE = 256;    /* initial size of stack */
int max_args = 0;       /* maximum # of arguments to printf, print, sprintf,
                         * or # of array subscripts, or adjacent strings
                         * to be concatenated.
                         */
NODE **args_array = NULL;

/* grow_stack --- grow the size of runtime stack */

/* N.B. stack_ptr points to the topmost occupied location
 *      on the stack, not the first free location.
 */

STACK_ITEM *
grow_stack()
{
	STACK_SIZE *= 2;
	erealloc(stack_bottom, STACK_ITEM *, STACK_SIZE * sizeof(STACK_ITEM));
	stack_top = stack_bottom + STACK_SIZE - 1;
	stack_ptr = stack_bottom + STACK_SIZE / 2;
	return stack_ptr;
}

/*
 * r_get_lhs:
 * This returns a POINTER to a node pointer (var's value).
 * used to store the var's new value.
 */

NODE **
r_get_lhs(NODE *n, bool reference)
{
	bool isparam = false;

	if (n->type == Node_param_list) {
		isparam = true;
		n = GET_PARAM(n->param_cnt);
	}

	switch (n->type) {
	case Node_var_array:
		fatal(_("attempt to use array `%s' in a scalar context"),
				array_vname(n));
		return NULL;	// silence compiler warnings
	case Node_array_ref:
		if (n->orig_array->type == Node_var_array)
			fatal(_("attempt to use array `%s' in a scalar context"),
					array_vname(n));
		if (n->orig_array->type != Node_var) {
			n->orig_array->type = Node_var;
			n->orig_array->var_value = dupnode(Nnull_string);
		}
		/* fall through */
	case Node_var_new:
		n->type = Node_var;
		n->var_value = dupnode(Nnull_string);
		break;

	case Node_elem_new:
		efree(n->stptr);
		n->stptr = NULL;
		n->stlen = 0;
		n->type = Node_var;
		n->var_value = dupnode(Nnull_string);
		break;

	case Node_var:
		break;

	default:
		cant_happen("unexpected variable type %s", nodetype2str(n->type));
	}

	if (do_lint && reference && var_uninitialized(n))
		lintwarn((isparam ?
			_("reference to uninitialized argument `%s'") :
			_("reference to uninitialized variable `%s'")),
				n->vname);
	return & n->var_value;
}


/* r_get_field --- get the address of a field node */

NODE **
r_get_field(NODE *n, Func_ptr *assign, bool reference)
{
	long field_num;
	NODE **lhs;

	if (assign)
		*assign = NULL;
	if (do_lint) {
		if ((fixtype(n)->flags & NUMBER) == 0) {
			lintwarn(_("attempt to field reference from non-numeric value"));
			if (n->stlen == 0)
				lintwarn(_("attempt to field reference from null string"));
		}
	}

	(void) force_number(n);
	field_num = get_number_si(n);

	if (field_num < 0)
		fatal(_("attempt to access field %ld"), field_num);

	if (field_num == 0 && field0_valid) {		/* short circuit */
		lhs = &fields_arr[0];
		if (assign)
			*assign = reset_record;
	} else
		lhs = get_field(field_num, assign);
	if (do_lint && reference && ((*lhs)->flags & NULL_FIELD) != 0)
		lintwarn(_("reference to uninitialized field `$%ld'"),
			      field_num);
	return lhs;
}


/*
 * calc_exp_posint --- calculate x^n for positive integral n,
 * using exponentiation by squaring without recursion.
 */

static AWKNUM
calc_exp_posint(AWKNUM x, long n)
{
	AWKNUM mult = 1;

	while (n > 1) {
		if ((n % 2) == 1)
			mult *= x;
		x *= x;
		n /= 2;
	}
	return mult * x;
}

/* calc_exp --- calculate x1^x2 */

AWKNUM
calc_exp(AWKNUM x1, AWKNUM x2)
{
	long lx;

	if ((lx = x2) == x2) {		/* integer exponent */
		if (lx == 0)
			return 1;
		return (lx > 0) ? calc_exp_posint(x1, lx)
				: 1.0 / calc_exp_posint(x1, -lx);
	}
	return (AWKNUM) pow((double) x1, (double) x2);
}


/* setup_frame --- setup new frame for function call */

static INSTRUCTION *
setup_frame(INSTRUCTION *pc)
{
	NODE *r = NULL;
	NODE *m, *f, *fp;
	NODE **sp = NULL;
	int pcount, arg_count, i, j;

	f = pc->func_body;
	pcount = f->param_cnt;
	fp = f->fparms;
	arg_count = (pc + 1)->expr_count;

	if (pcount > 0) {
		ezalloc(sp, NODE **, pcount * sizeof(NODE *));
	}

	/* check for extra args */
	if (arg_count > pcount) {
		warning(
			_("function `%s' called with more arguments than declared"),
       			f->vname);
		do {
			r = POP();
			if (r->type == Node_val)
				DEREF(r);
		} while (--arg_count > pcount);
	}

	for (i = 0, j = arg_count - 1; i < pcount; i++, j--) {
		getnode(r);
		memset(r, 0, sizeof(NODE));
		sp[i] = r;

		if (i >= arg_count) {
			/* local variable */
			r->type = Node_var_new;
			r->vname = fp[i].param;
			continue;
		}

		m = PEEK(j); /* arguments in reverse order on runtime stack */

		if (m->type == Node_param_list)
			m = GET_PARAM(m->param_cnt);

		/* $0 needs to be passed by value to a function */
		if (m == fields_arr[0]) {
			NODE *copy;

			copy = dupnode(m);	// will be real copy
			DEREF(m);
			m = copy;
		}

		switch (m->type) {
		case Node_var_new:
		case Node_var_array:
		case Node_elem_new:
			r->type = Node_array_ref;
			r->orig_array = r->prev_array = m;
			break;

		case Node_array_ref:
			r->type = Node_array_ref;
			r->orig_array = m->orig_array;
			r->prev_array = m;
			break;

		case Node_var:
			/* Untyped (Node_var_new) variable as param became a
			 * scalar during evaluation of expression for a
			 * subsequent param.
			 */
			r->type = Node_var;
			r->var_value = dupnode(Nnull_string);
			break;

		case Node_regex:
		case Node_dynregex:
			// 1/2025:
			// These are weird; they can happen through
			// indirect calls to some of the builtins, so
			// handle them if we get them by ....
			// ... falling through! Yay!
		case Node_val:
			r->type = Node_var;
			r->var_value = m;
			break;

		case Node_func:
		case Node_builtin_func:
		case Node_ext_func:
			r->type = Node_var;
			r->var_value = make_string(m->vname, strlen(m->vname));
			break;

		default:
			cant_happen("unexpected parameter type %s", nodetype2str(m->type));
		}
		r->vname = fp[i].param;
	}

	stack_adj(-arg_count);	/* adjust stack pointer */

	if (pc->opcode == Op_indirect_func_call) {
		r = POP();	/* indirect var */
		DEREF(r);
	}

	frame_ptr->vname = source;	/* save current source */

	if (do_profile || do_debug)
		push_frame(frame_ptr);

	/* save current frame in stack */
	PUSH(frame_ptr);

	/* setup new frame */
	getnode(frame_ptr);
	memset(frame_ptr, '\0', sizeof(NODE));
	frame_ptr->type = Node_frame;
	frame_ptr->stack = sp;
	frame_ptr->prev_frame_size = (stack_ptr - stack_bottom); /* size of the previous stack frame */
	frame_ptr->func_node = f;
	frame_ptr->vname = NULL;
	frame_ptr->reti = pc; /* on return execute pc->nexti */

	return f->code_ptr;
}


/* restore_frame --- clean up the stack and update frame */

static INSTRUCTION *
restore_frame(NODE *fp)
{
	NODE *r;
	NODE **sp;
	int n;
	NODE *func;
	INSTRUCTION *ri;

	func = frame_ptr->func_node;
	n = func->param_cnt;
	sp = frame_ptr->stack;

	for (; n > 0; n--) {
		r = *sp++;
		if (r->type == Node_var)     /* local variable */
			DEREF(r->var_value);
		else if (r->type == Node_var_array)     /* local array */
			assoc_clear(r);
		freenode(r);
	}

	if (frame_ptr->stack != NULL)
		efree(frame_ptr->stack);
	ri = frame_ptr->reti;     /* execution in calling frame
	                           * resumes from ri->nexti.
	                           */
	freenode(frame_ptr);
	if (do_profile || do_debug)
		pop_frame();

	/* restore frame */
	frame_ptr = fp;
	/* restore source */
	source = fp->vname;
	fp->vname = NULL;

	return ri->nexti;
}


/* free_arrayfor --- free 'for (var in array)' related data */

static inline void
free_arrayfor(NODE *r)
{
	if (r->for_list != NULL) {
		NODE *n;
		size_t num_elems = r->for_list_size;
		NODE **list = r->for_list;
		while (num_elems > 0) {
			n = list[--num_elems];
			unref(n);
		}
		efree(list);
	}
	freenode(r);
}


/*
 * unwind_stack --- pop items off the run-time stack;
 *	'n' is the # of items left in the stack.
 */

INSTRUCTION *
unwind_stack(long n)
{
	NODE *r;
	INSTRUCTION *cp = NULL;
	STACK_ITEM *sp;

	if (stack_empty())
		return NULL;

	sp = stack_bottom + n;

	if (stack_ptr < sp)
		return NULL;

	while ((r = POP()) != NULL) {
		switch (r->type) {
		case Node_frame:
			cp = restore_frame(r);
			break;
		case Node_arrayfor:
			free_arrayfor(r);
			break;
		case Node_val:
			DEREF(r);
			break;
		case Node_instruction:
			freenode(r);
			break;
		default:
			/*
			 * Check `exiting' and don't produce an error for
			 * cases like:
			 *	func     _fn0() { exit }
			 *	BEGIN { ARRAY[_fn0()] }
			 */
			if (in_main_context() && ! exiting)
				fatal(_("unwind_stack: unexpected type `%s'"),
						nodetype2str(r->type));
			/* else
				* Node_var_array,
				* Node_param_list,
				* Node_var (e.g: trying to use scalar for array)
				* Node_regex/Node_dynregex
				* ?
			 */
			break;
		}

		if (stack_ptr < sp)
			break;
	}
	return cp;
}


/* pop_fcall --- pop off the innermost frame */
#define pop_fcall()	unwind_stack(frame_ptr->prev_frame_size)

/* pop the run-time stack */
#define pop_stack()	(void) unwind_stack(0)


static inline bool
eval_condition(NODE *t)
{
	if (t == node_Boolean[false])
		return false;

	if (t == node_Boolean[true])
		return true;

	return boolval(t);
}

static bool cmp_doubles(const NODE *t1, const NODE *t2, scalar_cmp_t comparison_type);
extern bool mpg_cmp_as_numbers(const NODE *t1, const NODE *t2, scalar_cmp_t comparison_type);

/* cmp_scalars -- compare two nodes on the stack */

static bool
cmp_scalars(scalar_cmp_t comparison_type)
{
	NODE *t1, *t2;
	int di;
	bool ret = false;

	t2 = POP_SCALAR();
	t1 = TOP();

	t1 = elem_new_to_scalar(t1);
	t2 = elem_new_to_scalar(t2);

	t1 = fixtype(t1);
	t2 = fixtype(t2);

	if (t1->type == Node_var_array) {
		DEREF(t2);
		fatal(_("attempt to use array `%s' in a scalar context"), array_vname(t1));
	}

	if ((t1->flags & (STRING|REGEX)) != 0 || (t2->flags & (STRING|REGEX)) != 0) {
		bool use_strcmp = (comparison_type == SCALAR_EQ || comparison_type == SCALAR_NEQ);
		di = cmp_nodes(t1, t2, use_strcmp);

		switch (comparison_type) {
		case SCALAR_EQ:
			ret = (di == 0);
			break;
		case SCALAR_NEQ:
			ret = (di != 0);
			break;
		case SCALAR_LT:
			ret = (di < 0);
			break;
		case SCALAR_LE:
			ret = (di <= 0);
			break;
		case SCALAR_GT:
			ret = (di > 0);
			break;
		case SCALAR_GE:
			ret = (di >= 0);
			break;
		default:
			cant_happen("invalid value %d in cmp_scalars", (int) comparison_type);
			break;
		}
	} else {
#ifdef HAVE_MPFR
		if (do_mpfr)
			ret = mpg_cmp_as_numbers(t1, t2, comparison_type);
		else
#endif
			ret = cmp_doubles(t1, t2, comparison_type);
	}

	DEREF(t1);
	DEREF(t2);
	return ret;
}


/* cmp_doubles --- compare two doubles */

static bool
cmp_doubles(const NODE *t1, const NODE *t2, scalar_cmp_t comparison_type)
{
	/*
	 * This routine provides numeric comparisons that should work
	 * the same as in C.  It should NOT be used for sorting.
	 */

	bool t1_nan = isnan(t1->numbr);
	bool t2_nan = isnan(t2->numbr);
	int ret = false;

	if ((t1_nan || t2_nan) && comparison_type != SCALAR_NEQ)
		return false;

	switch (comparison_type) {
	case SCALAR_EQ:
		ret = (t1->numbr == t2->numbr);
		break;
	case SCALAR_NEQ:
		ret = (t1->numbr != t2->numbr);
		break;
	case SCALAR_LT:
		ret = (t1->numbr < t2->numbr);
		break;
	case SCALAR_LE:
		ret = (t1->numbr <= t2->numbr);
		break;
	case SCALAR_GT:
		ret = (t1->numbr > t2->numbr);
		break;
	case SCALAR_GE:
		ret = (t1->numbr >= t2->numbr);
		break;
	default:
		cant_happen("invalid value %d in cmp_doubles", (int) comparison_type);
		break;
	}

	return ret;
}


/* op_assign --- assignment operators excluding = */

static void
op_assign(OPCODE op)
{
	NODE **lhs;
	NODE *t1, *t2;
	AWKNUM x = 0.0, x1, x2;

	lhs = POP_ADDRESS();
	t1 = *lhs;
	x1 = force_number(t1)->numbr;

	t2 = TOP_SCALAR();
	x2 = force_number(t2)->numbr;
	DEREF(t2);

	switch (op) {
	case Op_assign_plus:
		x = x1 + x2;
		break;
	case Op_assign_minus:
		x = x1 - x2;
		break;
	case Op_assign_times:
		x = x1 * x2;
		break;
	case Op_assign_quotient:
		if (x2 == (AWKNUM) 0) {
			decr_sp();
			fatal(_("division by zero attempted in `/='"));
		}
		x = x1 / x2;
		break;
	case Op_assign_mod:
		if (x2 == (AWKNUM) 0) {
			decr_sp();
			fatal(_("division by zero attempted in `%%='"));
		}
#ifdef HAVE_FMOD
		x = fmod(x1, x2);
#else   /* ! HAVE_FMOD */
		(void) modf(x1 / x2, &x);
		x = x1 - x2 * x;
#endif  /* ! HAVE_FMOD */
		break;
	case Op_assign_exp:
		x = calc_exp((double) x1, (double) x2);
		break;
	default:
		break;
	}

	if (t1->valref == 1 && t1->flags == (MALLOC|NUMCUR|NUMBER)) {
		/* optimization */
		t1->numbr = x;
	} else {
		unref(t1);
		t1 = *lhs = make_number(x);
	}

	UPREF(t1);
	REPLACE(t1);
}

/* PUSH_CODE --- push a code onto the runtime stack */

void
PUSH_CODE(INSTRUCTION *cp)
{
	NODE *r;
	getnode(r);
	memset(r, '\0', sizeof(NODE));
	r->type = Node_instruction;
	r->code_ptr = cp;
	PUSH(r);
}

/* POP_CODE --- pop a code off the runtime stack */

INSTRUCTION *
POP_CODE()
{
	NODE *r;
	INSTRUCTION *cp;
	r = POP();
	cp = r->code_ptr;
	freenode(r);
	return cp;
}


/*
 * Implementation of BEGINFILE and ENDFILE requires saving an execution
 * state and the ability to return to that state. The state is
 * defined by the instruction triggering the BEGINFILE/ENDFILE rule, the
 * run-time stack, the rule and the source file. The source line is available in
 * the instruction and hence is not considered a part of the execution state.
 */


typedef struct exec_state {
	struct exec_state *next;

	INSTRUCTION *cptr;  /* either getline (Op_K_getline) or the
	                     * implicit "open-file, read-record" loop (Op_newfile).
	                     */

	int rule;           /* rule for the INSTRUCTION */

	long stack_size;    /* For this particular usage, it is sufficient to save
	                     * only the size of the call stack. We do not
	                     * store the actual stack pointer to avoid problems
	                     * in case the stack gets realloc-ed.
	                     */

	const char *source; /* source file for the INSTRUCTION */
} EXEC_STATE;

static EXEC_STATE exec_state_stack;

/* push_exec_state --- save an execution state on stack */

static void
push_exec_state(INSTRUCTION *cp, int rule, char *src, STACK_ITEM *sp)
{
	EXEC_STATE *es;

	emalloc(es, EXEC_STATE *, sizeof(EXEC_STATE));
	es->rule = rule;
	es->cptr = cp;
	es->stack_size = (sp - stack_bottom) + 1;
	es->source = src;
	es->next = exec_state_stack.next;
	exec_state_stack.next = es;
}


/* pop_exec_state --- pop one execution state off the stack */

static INSTRUCTION *
pop_exec_state(int *rule, char **src, long *sz)
{
	INSTRUCTION *cp;
	EXEC_STATE *es;

	es = exec_state_stack.next;
	if (es == NULL)
		return NULL;
	cp = es->cptr;
	if (rule != NULL)
		*rule = es->rule;
	if (src != NULL)
		*src = (char *) es->source;
	if (sz != NULL)
		*sz = es->stack_size;
	exec_state_stack.next = es->next;
	efree(es);
	return cp;
}


/* register_exec_hook --- add exec hooks in the interpreter. */

int
register_exec_hook(Func_pre_exec preh, Func_post_exec posth)
{
	int pos = 0;

	/*
	 * multiple post-exec hooks aren't supported. post-exec hook is mainly
	 * for use by the debugger.
	 */

	if (! preh || (post_execute && posth))
		return false;

	if (num_exec_hook == MAX_EXEC_HOOKS)
		return false;

	/*
	 * Add to the beginning of the array but do not displace the
	 * debugger hook if it exists.
	 */
	if (num_exec_hook > 0) {
		pos = !! do_debug;
		if (num_exec_hook > pos)
			memmove(pre_execute + pos + 1, pre_execute + pos,
					(num_exec_hook - pos) * sizeof (preh));
	}
	pre_execute[pos] = preh;
	num_exec_hook++;

	if (posth)
		post_execute = posth;

	return true;
}


/* interpreter routine when not debugging */
#include "interpret.h"

/* interpreter routine with exec hook(s). Used when debugging and/or with MPFR. */
#define r_interpret h_interpret
#define EXEC_HOOK 1
#include "interpret.h"
#undef EXEC_HOOK
#undef r_interpret


void
init_interpret()
{
	long newval;

	if ((newval = getenv_long("GAWK_STACKSIZE")) > 0)
		STACK_SIZE = newval;

	emalloc(stack_bottom, STACK_ITEM *, STACK_SIZE * sizeof(STACK_ITEM));
	stack_ptr = stack_bottom - 1;
	stack_top = stack_bottom + STACK_SIZE - 1;

	/* initialize frame pointer */
	getnode(frame_ptr);
	memset(frame_ptr, '\0', sizeof(NODE));
	frame_ptr->type = Node_frame;
	frame_ptr->stack = NULL;
	frame_ptr->func_node = NULL;	/* in main */
	frame_ptr->vname = NULL;

	/* initialize true and false nodes */
	node_Boolean[false] = make_number(0.0);
	node_Boolean[true] = make_number(1.0);
	if (! is_mpg_number(node_Boolean[false])) {
		node_Boolean[false]->flags |= NUMINT;
		node_Boolean[true]->flags |= NUMINT;
	}

	/*
	 * Select the interpreter routine. The version without
	 * any exec hook support (r_interpret) is faster by about
	 * 5%, or more depending on the opcodes.
	 */

	if (num_exec_hook > 0)
		interpret = h_interpret;
	else
		interpret = r_interpret;
}

/* elem_new_reset --- clear the elemnew_parent and elemnew_vname fields of a Node_elem_new. */

void
elem_new_reset(NODE *n)
{
	assert(n->type == Node_elem_new);

	if (n->elemnew_vname != NULL) {
		efree(n->elemnew_vname);
		n->elemnew_vname = NULL;
	}
	n->elemnew_parent = NULL;
	n->vname = NULL;
}

/* elem_new_to_scalar --- convert Node_elem_new to untyped scalar */

NODE *
elem_new_to_scalar(NODE *n)
{
	if (n->type != Node_elem_new)
		return n;

	elem_new_reset(n);

	if (n->valref > 1) {
		unref(n);
		return dupnode(Nnull_string);
	}

	n->type = Node_val;

	return n;
}

/* fix_nan_sign --- fix NaN sign on RiscV */

// See the thread starting at
// https://lists.gnu.org/archive/html/bug-gawk/2022-09/msg00005.html
// for why we need this function.

static double
fix_nan_sign(double left, double right, double result)
{
	if (isnan(left) && signbit(left))
		return copysign(result, -1.0);
	else if (isnan(right) && signbit(right))
		return copysign(result, -1.0);
	else
		return result;
}
/*
 * field.c - routines for dealing with fields and record parsing
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2023, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

/*
 * In case that the system doesn't have isblank().
 * Don't bother with autoconf ifdef junk, just force it.
 * See dfa.c and regex_internal.h and regcomp.c. Bleah.
 */
static int
is_blank(int c)
{
	return c == ' ' || c == '\t';
}

typedef void (* Setfunc)(long, char *, long, NODE *);

/* is the API currently overriding the default parsing mechanism? */
static bool api_parser_override = false;
typedef long (*parse_field_func_t)(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static parse_field_func_t parse_field;
/*
 * N.B. The normal_parse_field function pointer contains the parse_field value
 * that should be used except when API field parsing is overriding the default
 * field parsing mechanism.
 */
static parse_field_func_t normal_parse_field;
static long re_parse_field(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static long def_parse_field(long, char **, int, NODE *,
			      Regexp *, Setfunc, NODE *, NODE *, bool);
static long null_parse_field(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static long sc_parse_field(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static long fw_parse_field(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static long comma_parse_field(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static const awk_fieldwidth_info_t *api_fw = NULL;
static long fpat_parse_field(long, char **, int, NODE *,
			     Regexp *, Setfunc, NODE *, NODE *, bool);
static void set_element(long num, char * str, long len, NODE *arr);
static void grow_fields_arr(long num);
static void set_field(long num, char *str, long len, NODE *dummy);
static void set_comma_field(long num, char *str, long len, NODE *dummy);
static void purge_record(void);

static char *parse_extent;	/* marks where to restart parse of record */
static long parse_high_water = 0; /* field number that we have parsed so far */
static long nf_high_water = 0;	/* size of fields_arr */
static bool resave_fs;
static NODE *save_FS;		/* save current value of FS when line is read,
				 * to be used in deferred parsing
				 */
static NODE *save_FPAT;		/* save current value of FPAT when line is read,
				 * to be used in deferred parsing
				 */
static awk_fieldwidth_info_t *FIELDWIDTHS = NULL;

NODE **fields_arr;		/* array of pointers to the field nodes */
bool field0_valid;		/* $(>0) has not been changed yet */
static int default_FS;		/* true when FS == " " */
static Regexp *FS_re_yes_case = NULL;
static Regexp *FS_re_no_case = NULL;
static Regexp *FS_regexp = NULL;
static Regexp *FPAT_re_yes_case = NULL;
static Regexp *FPAT_re_no_case = NULL;
static Regexp *FPAT_regexp = NULL;
NODE *Null_field = NULL;

#define clear_mpfr(n) ((n)->flags &= ~(MPFN | MPZN | NUMCUR))

/* init_fields --- set up the fields array to start with */

void
init_fields()
{
	emalloc(fields_arr, NODE **, sizeof(NODE *));

	fields_arr[0] = make_string("", 0);
	fields_arr[0]->flags |= NULL_FIELD;

	parse_extent = fields_arr[0]->stptr;
	save_FS = dupnode(FS_node->var_value);

	Null_field = make_string("", 0);
	Null_field->flags = (STRCUR|STRING|NULL_FIELD); /* do not set MALLOC */

	field0_valid = true;
}

/* init_csv_fields --- set up to handle --csv */

void
init_csv_fields(void)
{
	if (do_csv)
		parse_field = comma_parse_field;
}

/* grow_fields --- acquire new fields as needed */

static void
grow_fields_arr(long num)
{
	int t;
	NODE *n;

	erealloc(fields_arr, NODE **, (num + 1) * sizeof(NODE *));
	for (t = nf_high_water + 1; t <= num; t++) {
		getnode(n);
		*n = *Null_field;
		fields_arr[t] = n;
	}
	nf_high_water = num;
}

/* set_field --- set the value of a particular field */

/*ARGSUSED*/
static void
set_field(long num,
	char *str,
	long len,
	NODE *dummy ATTRIBUTE_UNUSED)	/* just to make interface same as set_element */
{
	NODE *n;

	if (num > nf_high_water)
		grow_fields_arr(num);
	n = fields_arr[num];
	n->stptr = str;
	n->stlen = len;
	n->flags = (STRCUR|STRING|USER_INPUT);	/* do not set MALLOC */
}

/* set_comma_field --- set the value of a particular field, coming from CSV */

/*ARGSUSED*/
static void
set_comma_field(long num,
	char *str,
	long len,
	NODE *dummy ATTRIBUTE_UNUSED)	/* just to make interface same as set_element */
{
	NODE *n;
	NODE *val = make_string(str, len);

	if (num > nf_high_water)
		grow_fields_arr(num);
	n = fields_arr[num];
	n->stptr = val->stptr;
	n->stlen = val->stlen;
	n->flags = (STRCUR|STRING|USER_INPUT|MALLOC);
	freenode(val);
}

/* rebuild_record --- Someone assigned a value to $(something).
			Fix up $0 to be right */

void
rebuild_record()
{
	/*
	 * use explicit unsigned longs for lengths, in case
	 * a size_t isn't big enough.
	 */
	unsigned long tlen;
	NODE *tmp;
	char *ops;
	char *cops;
	long i;

	assert(NF != -1);

	tlen = 0;
	for (i = NF; i > 0; i--) {
		tmp = fields_arr[i];
		tmp = force_string(tmp);
		tlen += tmp->stlen;
	}
	tlen += (NF - 1) * OFSlen;
	if ((long) tlen < 0)
		tlen = 0;
	emalloc(ops, char *, tlen + 1);
	cops = ops;
	ops[0] = '\0';
	for (i = 1;  i <= NF; i++) {
		free_wstr(fields_arr[i]);
		tmp = fields_arr[i];
		/* copy field */
		if (tmp->stlen == 1)
			*cops++ = tmp->stptr[0];
		else if (tmp->stlen != 0) {
			memcpy(cops, tmp->stptr, tmp->stlen);
			cops += tmp->stlen;
		}
		/* copy OFS */
		if (i != NF) {
			if (OFSlen == 1)
				*cops++ = *OFS;
			else if (OFSlen != 0) {
				memcpy(cops, OFS, OFSlen);
				cops += OFSlen;
			}
		}
	}
	tmp = make_str_node(ops, tlen, ALREADY_MALLOCED);

	/*
	 * Since we are about to unref fields_arr[0], we want to find
	 * any fields that still point into it, and have them point
	 * into the new field zero.  This has to be done intelligently,
	 * so that unrefing a field doesn't try to unref into the old $0.
	 */
	for (cops = ops, i = 1; i <= NF; i++) {
		NODE *r = fields_arr[i];
		/*
		 * There is no reason to copy malloc'ed fields to point into
		 * the new $0 buffer, although that's how previous versions did
		 * it. It seems faster to leave the malloc'ed fields in place.
		 */
		if (r->stlen > 0 && (r->flags & MALLOC) == 0) {
			NODE *n;
			getnode(n);

			*n = *r;
			if (r->valref > 1) {
				/*
				 * This can and does happen.  It seems clear that
				 * we can't leave r's stptr pointing into the
				 * old $0 buffer that we are about to unref.
				 */
				emalloc(r->stptr, char *, r->stlen + 1);
				memcpy(r->stptr, cops, r->stlen);
				r->stptr[r->stlen] = '\0';
				r->flags |= MALLOC;

				n->valref = 1;	// reset in the new field to start it off correctly!
			}

			n->stptr = cops;
			clear_mpfr(n);
			unref(r);
			fields_arr[i] = n;
			assert((n->flags & WSTRCUR) == 0);
		}
		cops += fields_arr[i]->stlen + OFSlen;
	}

	assert((fields_arr[0]->flags & MALLOC) == 0
		? fields_arr[0]->valref == 1
		: true);

	unref(fields_arr[0]);

	fields_arr[0] = tmp;
	field0_valid = true;
}

/*
 * set_record:
 * setup $0, but defer parsing rest of line until reference is made to $(>0)
 * or to NF.  At that point, parse only as much as necessary.
 *
 * Manage a private buffer for the contents of $0.  Doing so keeps us safe
 * if `getline var' decides to rearrange the contents of the IOBUF that
 * $0 might have been pointing into.  The cost is the copying of the buffer;
 * but better correct than fast.
 */
void
set_record(const char *buf, size_t cnt, const awk_fieldwidth_info_t *fw)
{
	NODE *n;
	static char *databuf;
	static size_t databuf_size;
#define INITIAL_SIZE	512
#define MAX_SIZE	((size_t) ~0)	/* maximally portable ... */

	purge_record();

	/* buffer management: */
	if (databuf_size == 0) {	/* first time */
		ezalloc(databuf, char *, INITIAL_SIZE);
		databuf_size = INITIAL_SIZE;
	}
	/*
	 * Make sure there's enough room. Since we sometimes need
	 * to place a sentinel at the end, we make sure
	 * databuf_size is > cnt after allocation.
	 */
	if (cnt >= databuf_size) {
		do {
			if (databuf_size > MAX_SIZE/2)
				fatal(_("input record too large"));
			databuf_size *= 2;
		} while (cnt >= databuf_size);
		erealloc(databuf, char *, databuf_size);
		memset(databuf, '\0', databuf_size);
	}
	/* copy the data */
	if (cnt != 0) {
		memcpy(databuf, buf, cnt);
	}

	/*
	 * Add terminating '\0' so that C library routines
	 * will know when to stop.
	 */
	databuf[cnt] = '\0';

	/* manage field 0: */
	assert((fields_arr[0]->flags & MALLOC) == 0
		? fields_arr[0]->valref == 1
		: true);

	unref(fields_arr[0]);
	getnode(n);
	memset(n, '\0', sizeof(NODE));
	n->stptr = databuf;
	n->stlen = cnt;
	n->valref = 1;
	n->type = Node_val;
	n->stfmt = STFMT_UNUSED;
#ifdef HAVE_MPFR
	n->strndmode = MPFR_round_mode;
#endif
	n->flags = (STRING|STRCUR|USER_INPUT);	/* do not set MALLOC */
	fields_arr[0] = n;
	if (fw != api_fw) {
		if ((api_fw = fw) != NULL) {
			if (! api_parser_override) {
				api_parser_override = true;
				parse_field = fw_parse_field;
				update_PROCINFO_str("FS", "API");
			}
		} else if (api_parser_override) {
			api_parser_override = false;
			parse_field = normal_parse_field;
			update_PROCINFO_str("FS", current_field_sep_str());
		}
	}

#undef INITIAL_SIZE
#undef MAX_SIZE
}

/* reset_record --- start over again with current $0 */

void
reset_record()
{
	fields_arr[0] = force_string(fields_arr[0]);
	purge_record();
	if (api_parser_override) {
		api_parser_override = false;
		parse_field = normal_parse_field;
		update_PROCINFO_str("FS", current_field_sep_str());
	}
}

/*
 * purge_record --- throw away the fields, make sure that
 * 	individual nodes remain valid.
 */

static void
purge_record()
{
	int i;

	NF = -1;
	for (i = 1; i <= parse_high_water; i++) {
		NODE *n;
		NODE *r = fields_arr[i];
		if ((r->flags & MALLOC) == 0 && r->valref > 1) {
			/* This can and does happen. We must copy the string! */
			const char *save = r->stptr;
			emalloc(r->stptr, char *, r->stlen + 1);
			memcpy(r->stptr, save, r->stlen);
			r->stptr[r->stlen] = '\0';
			r->flags |= MALLOC;
		}
		unref(r);
		getnode(n);
		*n = *Null_field;
		fields_arr[i] = n;
	}

	parse_high_water = 0;
	/*
	 * $0 = $0 should resplit using the current value of FS.
	 */
	if (resave_fs) {
		resave_fs = false;
		unref(save_FS);
		save_FS = dupnode(FS_node->var_value);
	}

	field0_valid = true;
}

/* set_NF --- handle what happens to $0 and fields when NF is changed */

void
set_NF()
{
	int i;
	long nf;
	NODE *n;

	assert(NF != -1);

	(void) force_number(NF_node->var_value);
	nf = get_number_si(NF_node->var_value);
	if (nf < 0)
		fatal(_("NF set to negative value"));

	static bool warned = false;
	if (do_lint && NF > nf && ! warned) {
		warned = true;
		lintwarn(_("decrementing NF is not portable to many awk versions"));
	}

	NF = nf;

	if (NF > nf_high_water)
		grow_fields_arr(NF);
	if (parse_high_water < NF) {
		for (i = parse_high_water + 1; i >= 0 && i <= NF; i++) {
			unref(fields_arr[i]);
			getnode(n);
			*n = *Null_field;
			fields_arr[i] = n;
		}
		parse_high_water = NF;
	} else if (parse_high_water > 0) {
		for (i = NF + 1; i >= 0 && i <= parse_high_water; i++) {
			unref(fields_arr[i]);
			getnode(n);
			*n = *Null_field;
			fields_arr[i] = n;
		}
		parse_high_water = NF;
	}
	field0_valid = false;
}

/*
 * re_parse_field --- parse fields using a regexp.
 *
 * This is called both from get_field() and from do_split()
 * via (*parse_field)().  This variation is for when FS is a regular
 * expression -- either user-defined or because RS=="" and FS==" "
 */
static long
re_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs ATTRIBUTE_UNUSED,
	Regexp *rp,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *sep_arr,  /* array of field separators (maybe NULL) */
	bool in_middle)
{
	char *scan = *buf;
	long nf = parse_high_water;
	char *field;
	char *end = scan + len;
	int regex_flags = RE_NEED_START;
	char *sep;
	size_t mbclen = 0;
	mbstate_t mbs;

	memset(&mbs, 0, sizeof(mbstate_t));

	if (in_middle)
		regex_flags |= RE_NO_BOL;

	if (up_to == UNLIMITED)
		nf = 0;
	if (len == 0)
		return nf;

	bool default_field_splitting = (RS_is_null && default_FS);

	if (default_field_splitting) {
		sep = scan;
		while (scan < end && (*scan == ' ' || *scan == '\t' || *scan == '\n'))
			scan++;
		if (sep_arr != NULL && sep < scan)
			set_element(nf, sep, (long)(scan - sep), sep_arr);
	}

	if (rp == NULL) /* use FS */
		rp = FS_regexp;

	field = scan;
	while (scan < end
	       && research(rp, scan, 0, (end - scan), regex_flags) != -1
	       && nf < up_to) {
		regex_flags |= RE_NO_BOL;
		if (REEND(rp, scan) == RESTART(rp, scan)) {   /* null match */
			if (gawk_mb_cur_max > 1)	{
				mbclen = mbrlen(scan, end-scan, &mbs);
				if ((mbclen == 1) || (mbclen == (size_t) -1)
					|| (mbclen == (size_t) -2) || (mbclen == 0)) {
					/* We treat it as a singlebyte character.  */
					mbclen = 1;
				}
				scan += mbclen;
			} else
				scan++;
			if (scan == end) {
				(*set)(++nf, field, (long)(scan - field), n);
				up_to = nf;
				break;
			}
			continue;
		}
		(*set)(++nf, field,
		       (long)(scan + RESTART(rp, scan) - field), n);
		if (sep_arr != NULL)
	    		set_element(nf, scan + RESTART(rp, scan),
           			(long) (REEND(rp, scan) - RESTART(rp, scan)), sep_arr);
		scan += REEND(rp, scan);
		field = scan;
		if (scan == end && ! default_field_splitting)	/* FS at end of record */
			(*set)(++nf, field, 0L, n);
	}
	if (nf != up_to && scan < end) {
		(*set)(++nf, scan, (long)(end - scan), n);
		scan = end;
	}
	*buf = scan;
	return nf;
}

/*
 * def_parse_field --- default field parsing.
 *
 * This is called both from get_field() and from do_split()
 * via (*parse_field)().  This variation is for when FS is a single space
 * character.
 */

static long
def_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs,
	Regexp *rp ATTRIBUTE_UNUSED,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *sep_arr,  /* array of field separators (maybe NULL) */
	bool in_middle ATTRIBUTE_UNUSED)
{
	char *scan = *buf;
	long nf = parse_high_water;
	char *field;
	char *end = scan + len;
	char sav;
	char *sep;

	if (up_to == UNLIMITED)
		nf = 0;
	if (len == 0)
		return nf;

	/*
	 * Nasty special case. If FS set to "", return whole record
	 * as first field. This is not worth a separate function.
	 */
	if (fs->stlen == 0) {
		(*set)(++nf, *buf, len, n);
		*buf += len;
		return nf;
	}

	/* before doing anything save the char at *end */
	sav = *end;
	/* because it will be destroyed now: */

	*end = ' ';	/* sentinel character */
	sep = scan;
	for (; nf < up_to; scan++) {
		/*
		 * special case:  fs is single space, strip leading whitespace
		 */
		while (scan < end && (*scan == ' ' || *scan == '\t' || *scan == '\n'))
			scan++;

		if (sep_arr != NULL && scan > sep)
			set_element(nf, sep, (long) (scan - sep), sep_arr);

		if (scan >= end)
			break;

		field = scan;

		while (*scan != ' ' && *scan != '\t' && *scan != '\n')
			scan++;

		(*set)(++nf, field, (long)(scan - field), n);

		if (scan == end)
			break;

		sep = scan;
	}

	/* everything done, restore original char at *end */
	*end = sav;

	*buf = scan;
	return nf;
}

/*
 * null_parse_field --- each character is a separate field
 *
 * This is called both from get_field() and from do_split()
 * via (*parse_field)().  This variation is for when FS is the null string.
 */
static long
null_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs ATTRIBUTE_UNUSED,
	Regexp *rp ATTRIBUTE_UNUSED,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *sep_arr,  /* array of field separators (maybe NULL) */
	bool in_middle ATTRIBUTE_UNUSED)
{
	char *scan = *buf;
	long nf = parse_high_water;
	char *end = scan + len;

	if (up_to == UNLIMITED)
		nf = 0;
	if (len == 0)
		return nf;

	if (gawk_mb_cur_max > 1) {
		mbstate_t mbs;
		memset(&mbs, 0, sizeof(mbstate_t));
		for (; nf < up_to && scan < end;) {
			size_t mbclen = mbrlen(scan, end-scan, &mbs);
			if ((mbclen == 1) || (mbclen == (size_t) -1)
				|| (mbclen == (size_t) -2) || (mbclen == 0)) {
				/* We treat it as a singlebyte character.  */
				mbclen = 1;
			}
			if (sep_arr != NULL && nf > 0)
				set_element(nf, scan, 0L, sep_arr);
			(*set)(++nf, scan, mbclen, n);
			scan += mbclen;
		}
	} else {
		for (; nf < up_to && scan < end; scan++) {
			if (sep_arr != NULL && nf > 0)
				set_element(nf, scan, 0L, sep_arr);
			(*set)(++nf, scan, 1L, n);
		}
	}

	*buf = scan;
	return nf;
}

/*
 * sc_parse_field --- single character field separator
 *
 * This is called both from get_field() and from do_split()
 * via (*parse_field)().  This variation is for when FS is a single character
 * other than space.
 */
static long
sc_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs,
	Regexp *rp ATTRIBUTE_UNUSED,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *sep_arr,  /* array of field separators (maybe NULL) */
	bool in_middle ATTRIBUTE_UNUSED)
{
	char *scan = *buf;
	char fschar;
	long nf = parse_high_water;
	char *field;
	char *end = scan + len;
	char sav;
	size_t mbclen = 0;
	mbstate_t mbs;

	memset(&mbs, 0, sizeof(mbstate_t));

	if (up_to == UNLIMITED)
		nf = 0;
	if (len == 0)
		return nf;

	if (RS_is_null && fs->stlen == 0)
		fschar = '\n';
	else
		fschar = fs->stptr[0];

	/* before doing anything save the char at *end */
	sav = *end;
	/* because it will be destroyed now: */
	*end = fschar;	/* sentinel character */

	for (; nf < up_to;) {
		field = scan;
		if (gawk_mb_cur_max > 1) {
			while (*scan != fschar) {
				mbclen = mbrlen(scan, end-scan, &mbs);
				if ((mbclen == 1) || (mbclen == (size_t) -1)
					|| (mbclen == (size_t) -2) || (mbclen == 0)) {
					/* We treat it as a singlebyte character.  */
					mbclen = 1;
				}
				scan += mbclen;
			}
		} else {
			while (*scan != fschar)
				scan++;
		}
		(*set)(++nf, field, (long)(scan - field), n);
		if (scan == end)
			break;
		if (sep_arr != NULL)
			set_element(nf, scan, 1L, sep_arr);
		scan++;
		if (scan == end) {	/* FS at end of record */
			(*set)(++nf, field, 0L, n);
			break;
		}
	}

	/* everything done, restore original char at *end */
	*end = sav;

	*buf = scan;
	return nf;
}

/*
 * comma_parse_field --- CSV parsing same as BWK awk.
 *
 * This is called both from get_field() and from do_split()
 * via (*parse_field)().  This variation is for when FS is a comma,
 * we do very basic CSV parsing, the same as BWK awk.
 */

static long
comma_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs,
	Regexp *rp ATTRIBUTE_UNUSED,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *sep_arr,  /* array of field separators (maybe NULL) */
	bool in_middle ATTRIBUTE_UNUSED)
{
	char *scan = *buf;
	static const char comma = ',';
	long nf = parse_high_water;
	char *end = scan + len;

	static char *newfield = NULL;
	static size_t buflen = 0;

	if (newfield == NULL) {
		emalloc(newfield, char *, BUFSIZ);
		buflen = BUFSIZ;
	}

	if (set == set_field)	// not an array element
		set = set_comma_field;

	if (up_to == UNLIMITED)
		nf = 0;

	if (len == 0) {
		// Don't set the field.
		//	echo | gawk --csv '{ print NF }'
		// should print 0.
		return nf;
	}

	for (; nf < up_to;) {
		char *new_end = newfield;
		memset(newfield, '\0', buflen);

		while (*scan != comma && scan < end) {
			if (*scan == '"') {
				for (scan++; scan < end;) {
					// grow buffer if needed
					if (new_end >= newfield + buflen) {
						size_t offset = buflen;

						buflen *= 2;
						erealloc(newfield, char *, buflen);
						new_end = newfield + offset;
					}

					if (*scan == '"' && scan[1] == '"') {	// "" -> "
						*new_end++ = '"';
						scan += 2;
					} else if (*scan == '"' && (scan == end-1 || scan[1] == comma)) {
						// close of quoted string
						scan++;
						break;
					} else {
						*new_end++ = *scan++;
					}
				}
			} else {
				// unquoted field
				while (*scan != comma && scan < end) {
					// grow buffer if needed
					if (new_end >= newfield + buflen) {
						size_t offset = buflen;

						buflen *= 2;
						erealloc(newfield, char *, buflen);
						new_end = newfield + offset;
					}
					*new_end++ = *scan++;
				}
			}
		}

		(*set)(++nf, newfield, (long)(new_end - newfield), n);

		if (scan == end)
			break;

		if (scan == *buf) {
			scan++;
			continue;
		}

		scan++;
		if (scan == end) {	/* FS at end of record */
			(*set)(++nf, newfield, 0L, n);
			break;
		}
	}

	*buf = scan;
	return nf;
}

/*
 * calc_mbslen --- calculate the length in bytes of a multi-byte string
 * containing len characters.
 */

static size_t
calc_mbslen(char *scan, char *end, size_t len, mbstate_t *mbs)
{

	size_t mbclen;
	char *mbscan = scan;

	while (len-- > 0 && mbscan < end) {
		mbclen = mbrlen(mbscan, end - mbscan, mbs);
		if (!(mbclen > 0 && mbclen <= (size_t)(end - mbscan)))
			/*
			 * We treat it as a singlebyte character. This should
			 * catch error codes 0, (size_t) -1, and (size_t) -2.
			 */
			mbclen = 1;
		mbscan += mbclen;
	}
	return mbscan - scan;
}

/*
 * fw_parse_field --- field parsing using FIELDWIDTHS spec
 *
 * This is called from get_field() via (*parse_field)().
 * This variation is for fields are fixed widths.
 */
static long
fw_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs ATTRIBUTE_UNUSED,
	Regexp *rp ATTRIBUTE_UNUSED,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *dummy ATTRIBUTE_UNUSED, /* sep_arr not needed here: hence dummy */
	bool in_middle ATTRIBUTE_UNUSED)
{
	char *scan = *buf;
	long nf = parse_high_water;
	char *end = scan + len;
	const awk_fieldwidth_info_t *fw;
	mbstate_t mbs;
	size_t skiplen;
	size_t flen;

	fw = (api_parser_override ? api_fw : FIELDWIDTHS);

	if (up_to == UNLIMITED)
		nf = 0;
	if (len == 0)
		return nf;
	if (gawk_mb_cur_max > 1 && fw->use_chars) {
		/*
		 * Reset the shift state. Arguably, the shift state should
		 * be part of the file state and carried forward at all times,
		 * but nobody has complained so far, so this may not matter
		 * in practice.
		 */
		memset(&mbs, 0, sizeof(mbstate_t));
		while (nf < up_to && scan < end) {
			if (nf >= fw->nf) {
				*buf = end;
				return nf;
			}
			scan += calc_mbslen(scan, end, fw->fields[nf].skip, &mbs);
			flen = calc_mbslen(scan, end, fw->fields[nf].len, &mbs);
			(*set)(++nf, scan, (long) flen, n);
			scan += flen;
		}
	} else {
		while (nf < up_to && scan < end) {
			if (nf >= fw->nf) {
				*buf = end;
				return nf;
			}
			skiplen = fw->fields[nf].skip;
			if (skiplen > end - scan)
				skiplen = end - scan;
			scan += skiplen;
			flen = fw->fields[nf].len;
			if (flen > end - scan)
				flen = end - scan;
			(*set)(++nf, scan, (long) flen, n);
			scan += flen;
		}
	}
	*buf = scan;
	return nf;
}

/* invalidate_field0 --- $0 needs reconstruction */

static void
invalidate_field0()
{
	field0_valid = false;
}

/* get_field --- return a particular $n */

/* assign is not NULL if this field is on the LHS of an assign */

NODE **
get_field(long requested, Func_ptr *assign)
{
	bool in_middle = false;
	static bool warned = false;
	extern int currule;
	NODE *saved_fs;
	Regexp *fs_regexp;

	if (do_lint && currule == END && ! warned) {
		warned = true;
		lintwarn(_("accessing fields from an END rule may not be portable"));
	}

	/*
	 * if requesting whole line but some other field has been altered,
	 * then the whole line must be rebuilt
	 */
	if (requested == 0) {
		if (! field0_valid) {
			/* first, parse remainder of input record */
			if (NF == -1) {
				in_middle = (parse_high_water != 0);
				if (current_field_sep() == Using_FPAT) {
					saved_fs = save_FPAT;
					fs_regexp = FPAT_regexp;
				} else {
					saved_fs = save_FS;
					fs_regexp = FS_regexp;
				}
				NF = (*parse_field)(UNLIMITED - 1, &parse_extent,
		    			fields_arr[0]->stlen -
					(parse_extent - fields_arr[0]->stptr),
					saved_fs, fs_regexp, set_field,
					(NODE *) NULL,
					(NODE *) NULL,
					in_middle);
				parse_high_water = NF;
			}
			rebuild_record();
		}
		if (assign != NULL)
			*assign = reset_record;
		return &fields_arr[0];
	}

	/* assert(requested > 0); */

#if 0
	if (assign != NULL)
		field0_valid = false;		/* $0 needs reconstruction */
#else
	/*
	 * Keep things uniform. Also, mere intention of assigning something
	 * to $n should not make $0 invalid. Makes sense to invalidate $0
	 * after the actual assignment is performed. Not a real issue in
	 * the interpreter otherwise, but causes problem in the
	 * debugger when watching or printing fields.
	 */

	if (assign != NULL)
		*assign = invalidate_field0;	/* $0 needs reconstruction */
#endif

	if (requested <= parse_high_water)	/* already parsed this field */
		return &fields_arr[requested];

	if (NF == -1) {	/* have not yet parsed to end of record */
		/*
		 * parse up to requested fields, calling set_field() for each,
		 * saving in parse_extent the point where the parse left off
		 */
		if (parse_high_water == 0)	/* starting at the beginning */
			parse_extent = fields_arr[0]->stptr;
		else
			in_middle = true;
		parse_high_water = (*parse_field)(requested, &parse_extent,
		     fields_arr[0]->stlen - (parse_extent - fields_arr[0]->stptr),
		     save_FS, NULL, set_field, (NODE *) NULL, (NODE *) NULL, in_middle);

		/*
		 * if we reached the end of the record, set NF to the number of
		 * fields so far.  Note that requested might actually refer to
		 * a field that is beyond the end of the record, but we won't
		 * set NF to that value at this point, since this is only a
		 * reference to the field and NF only gets set if the field
		 * is assigned to -- this case is handled below
		 */
		if (parse_extent == fields_arr[0]->stptr + fields_arr[0]->stlen)
			NF = parse_high_water;
		if (requested == UNLIMITED - 1)	/* UNLIMITED-1 means set NF */
			requested = parse_high_water;
	}
	if (parse_high_water < requested) { /* requested beyond end of record */
		if (assign != NULL) {	/* expand record */
			if (requested > nf_high_water)
				grow_fields_arr(requested);

			NF = requested;
			parse_high_water = requested;
		} else
			return &Null_field;
	}

	return &fields_arr[requested];
}

/* set_element --- set an array element, used by do_split() */

static void
set_element(long num, char *s, long len, NODE *n)
{
	NODE *it;
	NODE *sub;

	it = make_string(s, len);
	it->flags |= USER_INPUT;
	sub = make_number((AWKNUM) (num));
	assoc_set(n, sub, it);
}

/* do_split --- implement split(), semantics are same as for field splitting */

NODE *
do_split(int nargs)
{
	NODE *src, *arr, *sep, *fs, *tmp, *sep_arr = NULL;
	char *s;
	long (*parseit)(long, char **, int, NODE *,
			 Regexp *, Setfunc, NODE *, NODE *, bool);
	Regexp *rp = NULL;

	check_args_min_max(nargs, "split", 3, 4);

	if (nargs == 4) {
		static bool warned = false;

		if (do_traditional || do_posix) {
			fatal(_("split: fourth argument is a gawk extension"));
		}
		sep_arr = POP_PARAM();
		if (sep_arr->type != Node_var_array)
			fatal(_("split: fourth argument is not an array"));
		check_symtab_functab(sep_arr, "split",
				_("%s: cannot use %s as fourth argument"));
		if ((do_lint_extensions || do_lint_old) && ! warned) {
			warned = true;
			lintwarn(_("split: fourth argument is a gawk extension"));
		}
	}

	sep = POP();
	arr = POP_PARAM();
	if (arr->type != Node_var_array)
		fatal(_("split: second argument is not an array"));
	check_symtab_functab(arr, "split",
			_("%s: cannot use %s as second argument"));

	if (sep_arr != NULL) {
		if (sep_arr == arr)
			fatal(_("split: cannot use the same array for second and fourth args"));

		/* This checks need to be done before clearing any of the arrays */
		for (tmp = sep_arr->parent_array; tmp != NULL; tmp = tmp->parent_array)
			if (tmp == arr)
				fatal(_("split: cannot use a subarray of second arg for fourth arg"));
		for (tmp = arr->parent_array; tmp != NULL; tmp = tmp->parent_array)
			if (tmp == sep_arr)
				fatal(_("split: cannot use a subarray of fourth arg for second arg"));
		assoc_clear(sep_arr);
	}
	assoc_clear(arr);

	src = TOP_STRING();
	if (src->stlen == 0) {
		/*
		 * Skip the work if first arg is the null string.
		 */
		tmp = POP_SCALAR();
		DEREF(tmp);
		return make_number((AWKNUM) 0);
	}

	if ((sep->flags & REGEX) != 0)
		sep = sep->typed_re;

	if (do_csv && (sep->re_flags & FS_DFLT) != 0 && nargs == 3) {
		fs = NULL;
		parseit = comma_parse_field;
	} else if ((sep->re_flags & FS_DFLT) != 0
	    && current_field_sep() == Using_FS
	    && ! RS_is_null) {
		parseit = parse_field;
		fs = force_string(FS_node->var_value);
		rp = FS_regexp;
	} else {
		fs = sep->re_exp;

		if (fs->stlen == 0) {
			static bool warned = false;

			parseit = null_parse_field;

			if (do_lint && ! warned) {
				warned = true;
				lintwarn(_("split: null string for third arg is a non-standard extension"));
			}
		} else if (fs->stlen == 1) {
			if ((sep->re_flags & CONSTANT) == 0 && fs->stptr[0] == ' ') {
				parseit = def_parse_field;
			} else
				parseit = sc_parse_field;
		} else {
			parseit = re_parse_field;
			rp = re_update(sep);
		}
	}

	s = src->stptr;
	tmp = make_number((AWKNUM) (*parseit)(UNLIMITED, &s, (int) src->stlen,
					     fs, rp, set_element, arr, sep_arr, false));

	src = POP_SCALAR();	/* really pop off stack */
	DEREF(src);
	return tmp;
}

/*
 * do_patsplit --- implement patsplit(), semantics are same as for field
 *		   splitting with FPAT.
 */

NODE *
do_patsplit(int nargs)
{
	NODE *src, *arr, *sep, *fpat, *tmp, *sep_arr = NULL;
	char *s;
	Regexp *rp = NULL;

	check_args_min_max(nargs, "patsplit", 3, 4);

	if (nargs == 4) {
		sep_arr = POP_PARAM();
		if (sep_arr->type != Node_var_array)
			fatal(_("patsplit: fourth argument is not an array"));
		check_symtab_functab(sep_arr, "patsplit",
				_("%s: cannot use %s as fourth argument"));
	}
	sep = POP();
	arr = POP_PARAM();
	if (arr->type != Node_var_array)
		fatal(_("patsplit: second argument is not an array"));
	check_symtab_functab(arr, "patsplit",
			_("%s: cannot use %s as second argument"));

	src = POP_SCALAR();
	if (src->type == Node_param_list) {
		src = GET_PARAM(src->param_cnt);
		if (src->type == Node_array_ref)
			src = src->orig_array;
		if (src->type == Node_var_new || src->type == Node_elem_new) {
			if (src->type == Node_elem_new)
				elem_new_reset(src);
			src->type = Node_var;
			src->valref = 1;
			src->var_value = dupnode(Nnull_string);
		}
	}

	if ((sep->flags & REGEX) != 0)
		sep = sep->typed_re;

	fpat = sep->re_exp;
	if (fpat->stlen == 0)
		fatal(_("patsplit: third argument must be non-null"));

	if (sep_arr != NULL) {
		if (sep_arr == arr)
			fatal(_("patsplit: cannot use the same array for second and fourth args"));

		/* These checks need to be done before clearing any of the arrays */
		for (tmp = sep_arr->parent_array; tmp != NULL; tmp = tmp->parent_array)
			if (tmp == arr)
				fatal(_("patsplit: cannot use a subarray of second arg for fourth arg"));
		for (tmp = arr->parent_array; tmp != NULL; tmp = tmp->parent_array)
			if (tmp == sep_arr)
				fatal(_("patsplit: cannot use a subarray of fourth arg for second arg"));
		assoc_clear(sep_arr);
	}
	assoc_clear(arr);

	if (src->stlen == 0) {
		/*
		 * Skip the work if first arg is the null string.
		 */
		tmp = make_number((AWKNUM) 0);
	} else {
		rp = re_update(sep);
		s = src->stptr;
		tmp = make_number((AWKNUM) fpat_parse_field(UNLIMITED, &s,
				(int) src->stlen, fpat, rp,
				set_element, arr, sep_arr, false));
	}

	DEREF(src);
	return tmp;
}

/* set_parser --- update the current (non-API) parser */

static void
set_parser(parse_field_func_t func)
{
	/*
	 * Setting FS does nothing if CSV mode, warn in that case,
	 * but don't warn on first call which happens at initialization.
	 */
	static bool first_time = true;
	static bool warned = false;

	if (! first_time && do_csv) {
		if (! warned) {
			warned = true;
			warning(_("assignment to FS/FIELDWIDTHS/FPAT has no effect when using --csv"));
		}
		return;
	}

	normal_parse_field = func;
	if (! api_parser_override && parse_field != func) {
		parse_field = func;
	        update_PROCINFO_str("FS", current_field_sep_str());
	}

	if (first_time)
		first_time = false;
}

/* set_FIELDWIDTHS --- handle an assignment to FIELDWIDTHS */

void
set_FIELDWIDTHS()
{
	char *scan;
	char *end;
	int i;
	static int fw_alloc = 4;
	static bool warned = false;
	bool fatal_error = false;
	NODE *tmp;

	if (do_lint_extensions && ! warned) {
		warned = true;
		lintwarn(_("`FIELDWIDTHS' is a gawk extension"));
	}
	if (do_traditional)	/* quick and dirty, does the trick */
		return;

	/*
	 * If changing the way fields are split, obey least-surprise
	 * semantics, and force $0 to be split totally.
	 */
	if (fields_arr != NULL)
		(void) get_field(UNLIMITED - 1, 0);

	set_parser(fw_parse_field);
	tmp = force_string(FIELDWIDTHS_node->var_value);
	scan = tmp->stptr;

	if (FIELDWIDTHS == NULL) {
		emalloc(FIELDWIDTHS, awk_fieldwidth_info_t *, awk_fieldwidth_info_size(fw_alloc));
		FIELDWIDTHS->use_chars = awk_true;
	}
	FIELDWIDTHS->nf = 0;
	for (i = 0; ; i++) {
		unsigned long int tmp;
		if (i >= fw_alloc) {
			fw_alloc *= 2;
			erealloc(FIELDWIDTHS, awk_fieldwidth_info_t *, awk_fieldwidth_info_size(fw_alloc));
		}
		/* Ensure that there is no leading `-' sign.  Otherwise,
		   strtoul would accept it and return a bogus result.  */
		while (is_blank(*scan)) {
			++scan;
		}
		if (*scan == '-') {
			fatal_error = true;
			break;
		}
		if (*scan == '\0')
			break;

		// Look for skip value. We allow N:M and N:*.
		/*
		 * Detect an invalid base-10 integer, a valid value that
		 * is followed by something other than a blank or '\0',
		 * or a value that is not in the range [1..UINT_MAX].
		 */
		errno = 0;
		tmp = strtoul(scan, &end, 10);
		if (errno == 0 && *end == ':' && (0 < tmp && tmp <= UINT_MAX)) {
			FIELDWIDTHS->fields[i].skip = tmp;
			scan = end + 1;
			if (*scan == '-' || is_blank(*scan)) {
				fatal_error = true;
				break;
			}
			// try scanning for field width
			tmp = strtoul(scan, &end, 10);
		}
		else
			FIELDWIDTHS->fields[i].skip = 0;

		if (errno != 0
		    	|| (*end != '\0' && ! is_blank(*end))
				|| !(0 < tmp && tmp <= UINT_MAX)
		) {
			if (*scan == '*') {
				for (scan++; is_blank(*scan); scan++)
					continue;

				if (*scan != '\0')
					fatal(_("`*' must be the last designator in FIELDWIDTHS"));

				FIELDWIDTHS->fields[i].len = UINT_MAX;
				FIELDWIDTHS->nf = i+1;
			}
			else
				fatal_error = true;
			break;
		}
		FIELDWIDTHS->fields[i].len = tmp;
		FIELDWIDTHS->nf = i+1;
		scan = end;
		/* Skip past any trailing blanks.  */
		while (is_blank(*scan)) {
			++scan;
		}
		if (*scan == '\0')
			break;
	}

	if (fatal_error)
		fatal(_("invalid FIELDWIDTHS value, for field %d, near `%s'"),
			      i + 1, scan);
}

/* set_FS --- handle things when FS is assigned to */

void
set_FS()
{
	char buf[10];
	NODE *fs;
	static NODE *save_fs = NULL;
	static NODE *save_rs = NULL;
	bool remake_re = true;

	/*
	 * If changing the way fields are split, obey least-surprise
	 * semantics, and force $0 to be split totally.
	 */
	if (fields_arr != NULL)
		(void) get_field(UNLIMITED - 1, 0);

	/* It's possible that only IGNORECASE changed, or FS = FS */
	/*
	 * This comparison can't use cmp_nodes(), which pays attention
	 * to IGNORECASE, and that's not what we want.
	 */
	if (save_fs
		&& FS_node->var_value->stlen == save_fs->stlen
		&& memcmp(FS_node->var_value->stptr, save_fs->stptr, save_fs->stlen) == 0
		&& save_rs
		&& RS_node->var_value->stlen == save_rs->stlen
		&& memcmp(RS_node->var_value->stptr, save_rs->stptr, save_rs->stlen) == 0) {
		if (FS_regexp != NULL)
			FS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);

		/* FS = FS */
		if (current_field_sep() == Using_FS) {
			return;
		} else {
			remake_re = false;
			goto choose_fs_function;
		}
	}

	unref(save_fs);
	save_fs = dupnode(FS_node->var_value);
	unref(save_rs);
	save_rs = dupnode(RS_node->var_value);
	resave_fs = true;

	/*
	 * If FS_re_no_case assignment is fatal (make_regexp in remake_re)
	 * FS_regexp will be NULL with a non-null FS_re_yes_case.
	 * refree() handles null argument; no need for `if (FS_regexp != NULL)' below.
	 * Please do not remerge.
	 */
	refree(FS_re_yes_case);
	refree(FS_re_no_case);
	FS_re_yes_case = FS_re_no_case = FS_regexp = NULL;


choose_fs_function:
	buf[0] = '\0';
	default_FS = false;
	fs = force_string(FS_node->var_value);

	if (! do_traditional && fs->stlen == 0) {
		static bool warned = false;

		set_parser(null_parse_field);

		if (do_lint_extensions && ! warned) {
			warned = true;
			lintwarn(_("null string for `FS' is a gawk extension"));
		}
	} else if (fs->stlen > 1 || (fs->flags & REGEX) != 0) {
		if (do_lint_old)
			lintwarn(_("old awk does not support regexps as value of `FS'"));
		set_parser(re_parse_field);
	} else if (RS_is_null) {
		/* we know that fs->stlen <= 1 */
		set_parser(sc_parse_field);
		if (fs->stlen == 1) {
			if (fs->stptr[0] == ' ') {
				default_FS = true;
				strcpy(buf, "[ \t\n]+");
			} else if (fs->stptr[0] == '\\') {
				/* yet another special case */
				strcpy(buf, "[\\\\\n]");
			} else if (fs->stptr[0] == '\0') {
				/* and yet another special case */
				strcpy(buf, "[\\000\n]");
			} else if (fs->stptr[0] != '\n') {
				sprintf(buf, "[%c\n]", fs->stptr[0]);
			}
		}
	} else {
		set_parser(def_parse_field);

		if (fs->stlen == 1) {
			if (fs->stptr[0] == ' ')
				default_FS = true;
			else if (fs->stptr[0] == '\\')
				/* same special case */
				strcpy(buf, "[\\\\]");
			else
				set_parser(sc_parse_field);
		}
	}
	if (remake_re) {
		refree(FS_re_yes_case);
		refree(FS_re_no_case);
		FS_re_yes_case = FS_re_no_case = FS_regexp = NULL;

		if (buf[0] != '\0') {
			FS_re_yes_case = make_regexp(buf, strlen(buf), false, true, true);
			FS_re_no_case = make_regexp(buf, strlen(buf), true, true, true);
			FS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);
			set_parser(re_parse_field);
		} else if (parse_field == re_parse_field) {
			FS_re_yes_case = make_regexp(fs->stptr, fs->stlen, false, true, true);
			FS_re_no_case = make_regexp(fs->stptr, fs->stlen, true, true, true);
			FS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);
		} else
			FS_re_yes_case = FS_re_no_case = FS_regexp = NULL;
	}

	/*
	 * For FS = "c", we don't use IGNORECASE. But we must use
	 * re_parse_field to get the character and the newline as
	 * field separators.
	 */
	if (fs->stlen == 1 && parse_field == re_parse_field)
		FS_regexp = FS_re_yes_case;
}

/* current_field_sep --- return the field separator type */

field_sep_type
current_field_sep()
{
	if (api_parser_override)
		return Using_API;
	else if (parse_field == fw_parse_field)
		return Using_FIELDWIDTHS;
	else if (parse_field == fpat_parse_field)
		return Using_FPAT;
	else
		return Using_FS;
}

/* current_field_sep_str --- return the field separator type as a string */

const char *
current_field_sep_str()
{
	if (api_parser_override)
		return "API";
	else if (parse_field == fw_parse_field)
		return "FIELDWIDTHS";
	else if (parse_field == fpat_parse_field)
		return "FPAT";
	else
		return "FS";
}

/* update_PROCINFO_str --- update PROCINFO[sub] with string value */

void
update_PROCINFO_str(const char *subscript, const char *str)
{
	NODE *tmp;

	if (PROCINFO_node == NULL)
		return;
	tmp = make_string(subscript, strlen(subscript));
	assoc_set(PROCINFO_node, tmp, make_string(str, strlen(str)));
}

/* update_PROCINFO_num --- update PROCINFO[sub] with numeric value */

void
update_PROCINFO_num(const char *subscript, AWKNUM val)
{
	NODE *tmp;

	if (PROCINFO_node == NULL)
		return;
	tmp = make_string(subscript, strlen(subscript));
	assoc_set(PROCINFO_node, tmp, make_number(val));
}

/* set_FPAT --- handle an assignment to FPAT */

void
set_FPAT()
{
	static bool warned = false;
	bool remake_re = true;
	NODE *fpat;

	if (do_lint_extensions && ! warned) {
		warned = true;
		lintwarn(_("`FPAT' is a gawk extension"));
	}
	if (do_traditional)	/* quick and dirty, does the trick */
		return;

	/*
	 * If changing the way fields are split, obey least-suprise
	 * semantics, and force $0 to be split totally.
	 */
	if (fields_arr != NULL)
		(void) get_field(UNLIMITED - 1, 0);

	/* It's possible that only IGNORECASE changed, or FPAT = FPAT */
	/*
	 * This comparison can't use cmp_nodes(), which pays attention
	 * to IGNORECASE, and that's not what we want.
	 */
	if (save_FPAT
		&& FPAT_node->var_value->stlen == save_FPAT->stlen
		&& memcmp(FPAT_node->var_value->stptr, save_FPAT->stptr, save_FPAT->stlen) == 0) {
		if (FPAT_regexp != NULL)
			FPAT_regexp = (IGNORECASE ? FPAT_re_no_case : FPAT_re_yes_case);

		/* FPAT = FPAT */
		if (current_field_sep() == Using_FPAT) {
			return;
		} else {
			remake_re = false;
			goto set_fpat_function;
		}
	}

	unref(save_FPAT);
	save_FPAT = dupnode(FPAT_node->var_value);
	refree(FPAT_re_yes_case);
	refree(FPAT_re_no_case);
	FPAT_re_yes_case = FPAT_re_no_case = FPAT_regexp = NULL;

set_fpat_function:
	fpat = force_string(FPAT_node->var_value);
	set_parser(fpat_parse_field);

	if (remake_re) {
		refree(FPAT_re_yes_case);
		refree(FPAT_re_no_case);
		FPAT_re_yes_case = FPAT_re_no_case = FPAT_regexp = NULL;

		FPAT_re_yes_case = make_regexp(fpat->stptr, fpat->stlen, false, true, true);
		FPAT_re_no_case = make_regexp(fpat->stptr, fpat->stlen, true, true, true);
		FPAT_regexp = (IGNORECASE ? FPAT_re_no_case : FPAT_re_yes_case);
	}
}

/*
 * increment_scan --- macro to move scan pointer ahead by one character.
 * 			Implementation varies if doing MBS or not.
 */

#define increment_scan(scanp, len) incr_scan(scanp, len, & mbs)

/* incr_scan --- MBS version of increment_scan() */

static void
incr_scan(char **scanp, size_t len, mbstate_t *mbs)
{
	size_t mbclen = 0;

	if (gawk_mb_cur_max > 1) {
		mbclen = mbrlen(*scanp, len, mbs);
		if (   (mbclen == 1)
		    || (mbclen == (size_t) -1)
		    || (mbclen == (size_t) -2)
		    || (mbclen == 0)) {
			/* We treat it as a singlebyte character.  */
			mbclen = 1;
		}
		*scanp += mbclen;
	} else
		(*scanp)++;
}

/*
 * fpat_parse_field --- parse fields using a regexp.
 *
 * This is called both from get_field() and from do_patsplit()
 * via (*parse_field)().  This variation is for when FPAT is a regular
 * expression -- use the value to find field contents.
 *
 * The FPAT parsing logic is a bit difficult to specify. In particular
 * to allow null fields at certain locations. To make the code as robust
 * as possible, an awk reference implementation was written and tested
 * as a first step, and later recoded in C, preserving its structure as
 * much as possible.
 *
 * # Reference implementation of the FPAT record parsing.
 * #
 * # Each loop iteration identifies a (separator[n-1],field[n]) pair.
 * # Each loop iteration must consume some characters, except for the first field.
 * # So a null field is only valid as a first field or after a non-null separator.
 * # A null record has no fields (not a single null field).
 *
 * function refpatsplit(string, fields, pattern, seps,
 *         parse_start, sep_start, field_start, field_length, field_found, nf) # locals
 * {
 *     # Local state variables:
 *     # - parse_start: pointer to the first not yet consumed character
 *     # - sep_start: pointer to the beginning of the parsed separator
 *     # - field start: pointer to the beginning of the parsed field
 *     # - field length: length of the parsed field
 *     # - field_found: flag for succesful field match
 *     # - nf: Number of fields found so far
 *
 *     # Prepare for parsing
 *     parse_start = 1   # first not yet parsed char
 *     nf = 0            # fields found so far
 *     delete fields
 *     delete seps
 *
 *     # Loop that consumes the whole record
 *     while (parse_start <= length(string)) {  # still something to parse
 *
 *         # first attempt to match the next field
 *         sep_start = parse_start
 *         field_found = match(substr(string, parse_start), pattern)
 *
 *         # check for an invalid null field and retry one character away
 *         if (nf > 0 && field_found && RSTART == 1 && RLENGTH == 0) {
 *             parse_start++
 *             field_found = match(substr(string, parse_start), pattern)
 *         }
 *
 *         # store the (sep[n-1],field[n]) pair
 *         if (field_found) {
 *             field_start = parse_start + RSTART - 1
 *             field_length = RLENGTH
 *             seps[nf] = substr(string, sep_start, field_start-sep_start)
 *             fields[++nf] = substr(string, field_start, field_length)
 *             parse_start = field_start + field_length
 *
 *         # store the final extra sep after the last field
 *         } else {
 *             seps[nf] = substr(string, sep_start)
 *             parse_start = length(string) + 1
 *         }
 *     }
 *
 *     return nf
 * }
 */
static long
fpat_parse_field(long up_to,	/* parse only up to this field number */
	char **buf,	/* on input: string to parse; on output: point to start next */
	int len,
	NODE *fs ATTRIBUTE_UNUSED,
	Regexp *rp,
	Setfunc set,	/* routine to set the value of the parsed field */
	NODE *n,
	NODE *sep_arr,  /* array of field separators (may be NULL) */
	bool in_middle)
{
	char *scan = *buf;
	long nf = parse_high_water;
	char *start;
	char *end = scan + len;
	int regex_flags = RE_NEED_START;
	mbstate_t mbs;
	char* field_start;
	bool field_found = false;

	memset(&mbs, 0, sizeof(mbstate_t));

	if (up_to == UNLIMITED)
		nf = 0;

	if (len == 0)
		return nf;

	if (rp == NULL) /* use FPAT */
		rp = FPAT_regexp;

	while (scan < end && nf < up_to) {  /* still something to parse */

		/* first attempt to match the next field */
		start = scan;
		field_found = research(rp, scan, 0, (end - scan), regex_flags) != -1;

		/* check for an invalid null field and retry one character away */
		if (nf > 0 && field_found && REEND(rp, scan) == 0) { /* invalid null field */
			increment_scan(& scan, end - scan);
			field_found = research(rp, scan, 0, (end - scan), regex_flags) != -1;
		}

		/* store the (sep[n-1],field[n]) pair */
		if (field_found) {
			field_start = scan + RESTART(rp, scan);
			if (sep_arr != NULL) { /* store the separator */
				if (field_start == start) /* match at front */
					set_element(nf, start, 0L, sep_arr);
				else
					set_element(nf,
						start,
						(long) (field_start - start),
						sep_arr);
			}
			/* field is text that matched */
			(*set)(++nf,
				field_start,
				(long)(REEND(rp, scan) - RESTART(rp, scan)),
				n);
			scan += REEND(rp, scan);

		} else {
			/*
			 * No match, store the final extra separator after
			 * the last field.
			 */
			if (sep_arr != NULL)
				set_element(nf, start, (long) (end - start), sep_arr);
			scan = end;
		}
	}

	/*
	 * If the last field extends up to the end of the record, generate
	 * a null trailing separator
	 */
	if (sep_arr != NULL && scan == end && field_found)
		set_element(nf, scan, 0L, sep_arr);

	*buf = scan;
	return nf;
}
/*
 * gawkapi.c -- Implement the functions defined for gawkapi.h
 */

/*
 * Copyright (C) 2012-2019, 2021-2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

/* Declare some globals used by api_get_file: */
extern IOBUF *curfile;
extern INSTRUCTION *main_beginfile;
extern int currule;

static awk_bool_t node_to_awk_value(NODE *node, awk_value_t *result, awk_valtype_t wanted);
static const char *valtype2str(awk_valtype_t type);
static NODE *ns_lookup(const char *name_space, const char *name, char **full_name);

/*
 * api_get_argument --- get the count'th paramater, zero-based.
 *
 * Returns false if count is out of range, or if actual paramater
 * does not match what is specified in wanted. In the latter
 * case, fills in result->val_type with the actual type.
 */

static awk_bool_t
api_get_argument(awk_ext_id_t id, size_t count,
			awk_valtype_t wanted, awk_value_t *result)
{
#ifdef DYNAMIC
	NODE *arg;

	if (result == NULL)
		return awk_false;

	(void) id;

	/* set up default result */
	memset(result, 0, sizeof(*result));
	result->val_type = AWK_UNDEFINED;

	/*
	 * Song and dance here.  get_array_argument() and get_scalar_argument()
	 * will force a change in type of a parameter that is Node_var_new.
	 *
	 * Start by looking at the unadulterated argument as it was passed.
	 */
	arg = get_argument(count);
	if (arg == NULL)
		return awk_false;

	/* if type is undefined */
	if (arg->type == Node_var_new || arg->type == Node_elem_new) {
		if (wanted == AWK_UNDEFINED)
			return awk_true;
		else if (wanted == AWK_ARRAY)
			goto array;
		else
			goto scalar;
	}

	/* at this point, we have real type */
	if (arg->type == Node_var_array || arg->type == Node_array_ref) {
		if (wanted == AWK_UNDEFINED)
			return awk_true;
		else if (wanted != AWK_ARRAY)
			return awk_false;
		goto array;
	} else
		goto scalar;

array:
	/* get the array here */
	arg = get_array_argument(arg, count);
	if (arg == NULL)
		return awk_false;

	return node_to_awk_value(arg, result, wanted);

scalar:
	/* at this point we have a real type that is not an array */
	arg = get_scalar_argument(arg, count);
	if (arg == NULL)
		return awk_false;

	return node_to_awk_value(arg, result, wanted);
#else
	return awk_false;
#endif
}

/* api_set_argument --- convert an argument to an array */

static awk_bool_t
api_set_argument(awk_ext_id_t id,
		size_t count,
		awk_array_t new_array)
{
#ifdef DYNAMIC
	NODE *arg;
	NODE *array = (NODE *) new_array;

	(void) id;

	if (array == NULL || array->type != Node_var_array)
		return awk_false;

	if (   (arg = get_argument(count)) == NULL
	    || (arg->type != Node_var_new && arg->type != Node_elem_new))
		return awk_false;

	arg = get_array_argument(arg, count);
	if (arg == NULL)
		return awk_false;

	array->vname = arg->vname;
	*arg = *array;
	freenode(array);

	return awk_true;
#else
	return awk_false;
#endif
}

/* awk_value_to_node --- convert a value into a NODE */

NODE *
awk_value_to_node(const awk_value_t *retval)
{
	NODE *ext_ret_val = NULL;
	NODE *v;
#ifdef HAVE_MPFR
	int tval = 0;
#endif

	if (retval == NULL)
		fatal(_("awk_value_to_node: received null retval"));

	switch (retval->val_type) {
	case AWK_ARRAY:
		ext_ret_val = (NODE *) retval->array_cookie;
		break;
	case AWK_UNDEFINED:
		ext_ret_val = dupnode(Nnull_string);
		break;
	case AWK_BOOL:
		ext_ret_val = make_bool_node(retval->bool_value != awk_false);
		break;
	case AWK_NUMBER:
		switch (retval->num_type) {
		case AWK_NUMBER_TYPE_DOUBLE:
			ext_ret_val = make_number(retval->num_value);
			break;
		case AWK_NUMBER_TYPE_MPFR:
#ifdef HAVE_MPFR
			if (! do_mpfr)
				fatal(_("awk_value_to_node: not in MPFR mode"));
			ext_ret_val = make_number_node(MPFN);
			mpfr_init(ext_ret_val->mpg_numbr);
			tval = mpfr_set(ext_ret_val->mpg_numbr, (mpfr_srcptr) retval->num_ptr, ROUND_MODE);
			IEEE_FMT(ext_ret_val->mpg_numbr, tval);
			mpfr_clear(retval->num_ptr);
#else
			fatal(_("awk_value_to_node: MPFR not supported"));
#endif
			break;
		case AWK_NUMBER_TYPE_MPZ:
#ifdef HAVE_MPFR
			if (! do_mpfr)
				fatal(_("awk_value_to_node: not in MPFR mode"));
			ext_ret_val = make_number_node(MPZN);
			mpz_init(ext_ret_val->mpg_i);
			mpz_set(ext_ret_val->mpg_i, (mpz_ptr) retval->num_ptr);
			mpz_clear(retval->num_ptr);
#else
			fatal(_("awk_value_to_node: MPFR not supported"));
#endif
			break;
		default:
			fatal(_("awk_value_to_node: invalid number type `%d'"), retval->num_type);
			break;
		}
		break;
	case AWK_STRING:
		ext_ret_val = make_str_node(retval->str_value.str,
				retval->str_value.len, ALREADY_MALLOCED);
		break;
	case AWK_STRNUM:
		ext_ret_val = make_str_node(retval->str_value.str,
				retval->str_value.len, ALREADY_MALLOCED);
		ext_ret_val->flags |= USER_INPUT;
		break;
	case AWK_REGEX:
		ext_ret_val = make_typed_regex(retval->str_value.str,
				retval->str_value.len);
		break;
	case AWK_SCALAR:
		v = (NODE *) retval->scalar_cookie;
		if (v->type != Node_var)
			ext_ret_val = NULL;
		else
			ext_ret_val = dupnode(v->var_value);
		break;
	case AWK_VALUE_COOKIE:
		ext_ret_val = dupnode((NODE *)(retval->value_cookie));
		break;
	default:	/* any invalid type */
		ext_ret_val = NULL;
		break;
	}

	return ext_ret_val;
}

/* Functions to print messages */

/* api_fatal --- print a fatal message and exit */

static void
api_fatal(awk_ext_id_t id, const char *format, ...)
{
	va_list args;

	(void) id;

	va_start(args, format);
	err(true, _("fatal: "), format, args);
	va_end(args);
}

/* api_nonfatal --- print a non fatal error message */

static void
api_nonfatal(awk_ext_id_t id, const char *format, ...)
{
	va_list args;

	(void) id;

	va_start(args, format);
	err(false, _("error: "), format, args);
	va_end(args);
}

/* api_warning --- print a warning message */

static void
api_warning(awk_ext_id_t id, const char *format, ...)
{
	va_list args;

	(void) id;

	va_start(args, format);
	err(false, _("warning: "), format, args);
	va_end(args);
}

/* api_lintwarn --- print a lint warning message and exit if appropriate */

static void
api_lintwarn(awk_ext_id_t id, const char *format, ...)
{
	va_list args;

	(void) id;

	va_start(args, format);
	if (lintfunc == r_fatal) {
		err(true, _("fatal: "), format, args);
	} else {
		err(false, _("warning: "), format, args);
	}
	va_end(args);
}

/* api_register_input_parser --- register an input_parser; for opening files read-only */

static void
api_register_input_parser(awk_ext_id_t id, awk_input_parser_t *input_parser)
{
	(void) id;

	if (input_parser == NULL)
		return;

	register_input_parser(input_parser);
}

/* api_register_output_wrapper --- register an output wrapper, for writing files / two-way pipes */

static void api_register_output_wrapper(awk_ext_id_t id,
		awk_output_wrapper_t *output_wrapper)
{
	(void) id;

	if (output_wrapper == NULL)
		return;

	register_output_wrapper(output_wrapper);
}

/* api_register_two_way_processor --- register a processor for two way I/O */

static void
api_register_two_way_processor(awk_ext_id_t id,
		awk_two_way_processor_t *two_way_processor)
{
	(void) id;

	if (two_way_processor == NULL)
		return;

	register_two_way_processor(two_way_processor);
}

/* Functions to update ERRNO */

/* api_update_ERRNO_int --- update ERRNO with an integer value */

static void
api_update_ERRNO_int(awk_ext_id_t id, int errno_val)
{
	(void) id;

	update_ERRNO_int(errno_val);
}

/* api_update_ERRNO_string --- update ERRNO with a string value */

static void
api_update_ERRNO_string(awk_ext_id_t id,
			const char *string)
{
	(void) id;

	if (string == NULL)
		return;

	update_ERRNO_string(string);
}

/* api_unset_ERRNO --- unset ERRNO */

static void
api_unset_ERRNO(awk_ext_id_t id)
{
	(void) id;

	unset_ERRNO();
}


/* api_add_ext_func --- add a function to the interpreter, returns true upon success */

static awk_bool_t
api_add_ext_func(awk_ext_id_t id,
		const char *name_space,
		awk_ext_func_t *func)
{
	(void) id;

	if (func == NULL)
		return awk_false;

	if (name_space == NULL)
		fatal(_("add_ext_func: received NULL name_space parameter"));

#ifdef DYNAMIC
	return make_builtin(name_space, func);
#else
	return awk_false;
#endif
}

/* Stuff for exit handler - do it as linked list */

struct ext_exit_handler {
	struct ext_exit_handler *next;
	void (*funcp)(void *data, int exit_status);
	void *arg0;
};
static struct ext_exit_handler *list_head = NULL;

/* run_ext_exit_handlers --- run the extension exit handlers, LIFO order */

void
run_ext_exit_handlers(int exitval)
{
	struct ext_exit_handler *p, *next;

	for (p = list_head; p != NULL; p = next) {
		next = p->next;
		p->funcp(p->arg0, exitval);
		free(p);
	}
	list_head = NULL;
}

/* api_awk_atexit --- add an exit call back */

static void
api_awk_atexit(awk_ext_id_t id,
		void (*funcp)(void *data, int exit_status),
		void *arg0)
{
	struct ext_exit_handler *p;

	(void) id;

	if (funcp == NULL)
		return;

	/* allocate memory */
	emalloc(p, struct ext_exit_handler *, sizeof(struct ext_exit_handler));

	/* fill it in */
	p->funcp = funcp;
	p->arg0 = arg0;

	/* add to linked list, LIFO order */
	p->next = list_head;
	list_head = p;
}

static struct {
	char **strings;
	size_t i, size;
} scopy;

/* free_api_string_copies --- release memory used by string copies */

void
free_api_string_copies()
{
	size_t i;

	for (i = 0; i < scopy.i; i++)
		free(scopy.strings[i]);
	scopy.i = 0;
}

/* assign_string --- return a string node with NUL termination */

static inline void
assign_string(NODE *node, awk_value_t *val, awk_valtype_t val_type)
{
	val->val_type = val_type;
	if (node->stptr[node->stlen] != '\0') {
		/*
		 * This is an unterminated field string, so make a copy.
		 * This should happen only for $n where n > 0 and n < NF.
		 */
		char *s;

		assert((node->flags & MALLOC) == 0);
		if (scopy.i == scopy.size) {
			/* expand list */
			if (scopy.size == 0)
				scopy.size = 8;	/* initial size */
			else
				scopy.size *= 2;
			erealloc(scopy.strings, char **, scopy.size * sizeof(char *));
		}
		emalloc(s, char *, node->stlen + 1);
		memcpy(s, node->stptr, node->stlen);
		s[node->stlen] = '\0';
		val->str_value.str = scopy.strings[scopy.i++] = s;
	}
	else
		val->str_value.str = node->stptr;
	val->str_value.len = node->stlen;
}

/* assign_number -- return a number node */

#define assign_double(val) \
	val->num_value = node->numbr; \
	val->num_type = AWK_NUMBER_TYPE_DOUBLE; \
	val->num_ptr = NULL

static inline void
assign_number(NODE *node, awk_value_t *val)
{
	val->val_type = AWK_NUMBER;

#ifndef HAVE_MPFR
	assign_double(val);
#else
	switch (node->flags & (MPFN|MPZN)) {
	case 0:
		assign_double(val);
		break;
	case MPFN:
		val->num_value = mpfr_get_d(node->mpg_numbr, ROUND_MODE);
		val->num_type = AWK_NUMBER_TYPE_MPFR;
		val->num_ptr = &node->mpg_numbr;
		break;
	case MPZN:
		val->num_value = mpz_get_d(node->mpg_i);
		val->num_type = AWK_NUMBER_TYPE_MPZ;
		val->num_ptr = &node->mpg_i;
		break;
	default:
		fatal(_("node_to_awk_value: detected invalid numeric flags combination `%s'; please file a bug report"), flags2str(node->flags));
		break;
	}
#endif
}
#undef assign_double

/* assign_regex --- return a regex node */

static inline void
assign_regex(NODE *node, awk_value_t *val)
{
	/* a REGEX node cannot be an unterminated field string */
	assert((node->flags & MALLOC) != 0);
	assert(node->stptr[node->stlen] == '\0');
	val->str_value.str = node->stptr;
	val->str_value.len = node->stlen;
	val->val_type = AWK_REGEX;
}

/* assign_bool --- return a bool node */

static inline void
assign_bool(NODE *node, awk_value_t *val)
{
	assert((node->flags & BOOLVAL) != 0);
	val->val_type = AWK_BOOL;
	val->bool_value = get_number_si(node) != 0 ? awk_true : awk_false;
}

/* node_to_awk_value --- convert a node into a value for an extension */

static awk_bool_t
node_to_awk_value(NODE *node, awk_value_t *val, awk_valtype_t wanted)
{
	awk_bool_t ret = awk_false;

	if (node == NULL)
		fatal(_("node_to_awk_value: received null node"));

	if (val == NULL)
		fatal(_("node_to_awk_value: received null val"));

	switch (node->type) {
	case Node_var_new:	/* undefined variable */
	case Node_elem_new:	/* undefined element */
		val->val_type = AWK_UNDEFINED;
		if (wanted == AWK_UNDEFINED) {
			ret = awk_true;
		}
		break;

	case Node_var:
		/* a scalar value */
		if (wanted == AWK_SCALAR) {
			val->val_type = AWK_SCALAR;
			val->scalar_cookie = (void *) node;
			ret = awk_true;
			break;
		}

		node = node->var_value;
		/* FALL THROUGH */
	case Node_val:
		/* a scalar value */
		switch (wanted) {
		case AWK_BOOL:
			if ((node->flags & BOOLVAL) != 0) {
				assign_bool(node, val);
				ret = awk_true;
			} else
				ret = awk_false;
			break;

		case AWK_NUMBER:
			if ((node->flags & REGEX) != 0)
				val->val_type = AWK_REGEX;
			else {
				(void) force_number(node);
				assign_number(node, val);
				ret = awk_true;
			}
			break;

		case AWK_STRNUM:
			switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {
			case NUMBER|BOOLVAL:
				val->val_type = AWK_BOOL;
				break;
			case STRING:
				val->val_type = AWK_STRING;
				break;
			case NUMBER:
				(void) force_string(node);
				/* fall through */
			case NUMBER|USER_INPUT:
				assign_string(node, val, AWK_STRNUM);
				ret = awk_true;
				break;
			case REGEX:
				val->val_type = AWK_REGEX;
				break;
			case NUMBER|STRING:
				// this can come from a Node_elem_new, as well as Nnull_string
				val->val_type = AWK_UNDEFINED;
				break;
			default:
				warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));
				val->val_type = AWK_UNDEFINED;
				break;
			}
			break;

		case AWK_STRING:
			(void) force_string(node);
			assign_string(node, val, AWK_STRING);
			ret = awk_true;
			break;

		case AWK_REGEX:
			switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {
			case STRING:
				val->val_type = AWK_STRING;
				break;
			case NUMBER|BOOLVAL:
				val->val_type = AWK_BOOL;
				break;
			case NUMBER:
				val->val_type = AWK_NUMBER;
				break;
			case NUMBER|USER_INPUT:
				val->val_type = AWK_STRNUM;
				break;
			case REGEX:
				assign_regex(node, val);
				ret = awk_true;
				break;
			case NUMBER|STRING:
				// this can come from a Node_elem_new, as well as Nnull_string
				val->val_type = AWK_UNDEFINED;
				break;
			default:
				warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));
				val->val_type = AWK_UNDEFINED;
				break;
			}
			break;

		case AWK_SCALAR:
			switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {
			case NUMBER|BOOLVAL:
				val->val_type = AWK_BOOL;
				break;
			case STRING:
				val->val_type = AWK_STRING;
				break;
			case NUMBER:
				val->val_type = AWK_NUMBER;
				break;
			case NUMBER|USER_INPUT:
				val->val_type = AWK_STRNUM;
				break;
			case REGEX:
				val->val_type = AWK_REGEX;
				break;
			case NUMBER|STRING:
				// this can come from a Node_elem_new, as well as Nnull_string
				val->val_type = AWK_UNDEFINED;
				break;
			default:
				warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));
				val->val_type = AWK_UNDEFINED;
				break;
			}
			break;

		case AWK_UNDEFINED:
			/* return true and actual type for request of undefined */
			switch (fixtype(node)->flags & (STRING|NUMBER|USER_INPUT|REGEX|BOOLVAL)) {
			case NUMBER|BOOLVAL:
				assign_bool(node, val);
				ret = awk_true;
				break;
			case STRING:
				assign_string(node, val, AWK_STRING);
				ret = awk_true;
				break;
			case NUMBER:
				assign_number(node, val);
				ret = awk_true;
				break;
			case NUMBER|USER_INPUT:
				assign_string(node, val, AWK_STRNUM);
				ret = awk_true;
				break;
			case REGEX:
				assign_regex(node, val);
				ret = awk_true;
				break;
			case NUMBER|STRING:
				// this can come from a Node_elem_new, as well as Nnull_string
				val->val_type = AWK_UNDEFINED;
				ret = awk_true;
				break;
			default:
				warning(_("node_to_awk_value detected invalid flags combination `%s'; please file a bug report"), flags2str(node->flags));
				val->val_type = AWK_UNDEFINED;
				break;
			}
			break;

		case AWK_ARRAY:
		case AWK_VALUE_COOKIE:
			break;
		}
		break;

	case Node_var_array:
		val->val_type = AWK_ARRAY;
		if (wanted == AWK_ARRAY || wanted == AWK_UNDEFINED) {
			val->array_cookie = node;
			ret = awk_true;
		} else
			ret = awk_false;
		break;

	default:
		val->val_type = AWK_UNDEFINED;
		ret = awk_false;
		break;
	}

	return ret;
}

/*
 * Symbol table access:
 * 	- No access to special variables (NF, etc.)
 * 	- One special exception: PROCINFO.
 *	- Use sym_update() to change a value, including from UNDEFINED
 *	  to scalar or array.
 */
/*
 * Lookup a variable, fills in value. No messing with the value
 * returned. Returns false if the variable doesn't exist
 * or the wrong type was requested.
 * In the latter case, fills in vaule->val_type with the real type.
 * Built-in variables (except PROCINFO) may not be accessed by an extension.
 */

/* api_sym_lookup --- look up a symbol */

static awk_bool_t
api_sym_lookup(awk_ext_id_t id,
		const char *name_space,
		const char *name,
		awk_valtype_t wanted,
		awk_value_t *result)
{
	NODE *node;

	update_global_values();		/* make sure stuff like NF, NR, are up to date */

	if (   name == NULL
	    || *name == '\0'
	    || result == NULL
	    || ! is_valid_identifier(name)
	    || name_space == NULL
	    || (name_space[0] != '\0' && ! is_valid_identifier(name_space)))
		return awk_false;

	if ((node = ns_lookup(name_space, name, NULL)) == NULL)
		return awk_false;

	if (is_off_limits_var(name))	/* a built-in variable */
		node->flags |= NO_EXT_SET;

	return node_to_awk_value(node, result, wanted);
}

/* api_sym_lookup_scalar --- retrieve the current value of a scalar */

static awk_bool_t
api_sym_lookup_scalar(awk_ext_id_t id,
			awk_scalar_t cookie,
			awk_valtype_t wanted,
			awk_value_t *result)
{
	NODE *node = (NODE *) cookie;

	if (node == NULL
	    || result == NULL
	    || node->type != Node_var)
		return awk_false;

	update_global_values();	/* make sure stuff like NF, NR, are up to date */

	return node_to_awk_value(node, result, wanted);
}

/* api_sym_update --- update a symbol's value, see gawkapi.h for semantics */

static awk_bool_t
api_sym_update(awk_ext_id_t id,
		const char *name_space,
		const char *name,
		awk_value_t *value)
{
	NODE *node;
	NODE *array_node;

	if (   name == NULL
	    || *name == '\0'
	    || value == NULL
	    || ! is_valid_identifier(name)
	    || name_space == NULL
	    || (name_space[0] != '\0' && ! is_valid_identifier(name_space)))
		return awk_false;

	switch (value->val_type) {
	case AWK_NUMBER:
	case AWK_STRNUM:
	case AWK_STRING:
	case AWK_REGEX:
	case AWK_UNDEFINED:
	case AWK_ARRAY:
	case AWK_SCALAR:
	case AWK_VALUE_COOKIE:
		break;

	default:
		/* fatal(_("api_sym_update: invalid value for type of new value (%d)"), value->val_type); */
		return awk_false;
	}

	char *full_name = NULL;
	node = ns_lookup(name_space, name, & full_name);

	if (node == NULL) {
		/* new value to be installed */
		if (value->val_type == AWK_ARRAY) {
			array_node = awk_value_to_node(value);
			node = install_symbol(full_name, Node_var_array);
			array_node->vname = node->vname;
			*node = *array_node;
			freenode(array_node);
			value->array_cookie = node;	/* pass new cookie back to extension */
		} else {
			/* regular variable */
			node = install_symbol(full_name, Node_var);
			node->var_value = awk_value_to_node(value);
		}

		return awk_true;
	}

	/*
	 * If we get here, then it exists already.  Any valid type is
	 * OK except for AWK_ARRAY (unless it is in Node_var_new undefined
	 * state, in which case an array is OK).
	 */
	if (   (node->flags & NO_EXT_SET) != 0
	    || is_off_limits_var(full_name)) {	/* most built-in vars not allowed */
		node->flags |= NO_EXT_SET;
		efree((void *) full_name);
		return awk_false;
	}

	efree((void *) full_name);

	if (value->val_type == AWK_ARRAY) {
		if (node->type == Node_var_new) {
			/* special gymnastics to convert untyped to an array */
			array_node = awk_value_to_node(value);
			array_node->vname = node->vname;
			unref(node->var_value);
			*node = *array_node;
			freenode(array_node);
			value->array_cookie = node;	/* pass new cookie back to extension */
			return awk_true;
		}
	} else if (node->type == Node_var
		   || node->type == Node_var_new
		   || node->type == Node_elem_new) {
		unref(node->var_value);
		node->var_value = awk_value_to_node(value);
		if ((node->type == Node_var_new || node->type == Node_elem_new)
		    && value->val_type != AWK_UNDEFINED) {
			if (node->type == Node_elem_new) {
				elem_new_reset(node);
			}
			node->type = Node_var;
		}
		return awk_true;
	}

	return awk_false;
}

/* api_sym_update_scalar --- update a scalar cookie */

static awk_bool_t
api_sym_update_scalar(awk_ext_id_t id,
			awk_scalar_t cookie,
			awk_value_t *value)
{
	NODE *node = (NODE *) cookie;

	if (value == NULL
	    || node == NULL
	    || node->type != Node_var
	    || (node->flags & NO_EXT_SET) != 0)
		return awk_false;

	/*
	 * Optimization: if valref is 1, and the new value is a string or
	 * a number, we can avoid calling unref and then making a new node
	 * by simply installing the new value.  First, we follow the same
	 * recipe used by node.c:r_unref to wipe the current values, and then
	 * we copy the logic from r_make_number or make_str_node to install
	 * the new value.
	 */
	switch (value->val_type) {
	case AWK_NUMBER:
		if (node->var_value->valref == 1 && ! do_mpfr) {
			NODE *r = node->var_value;

			/* r_unref: */
			if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
				efree(r->stptr);
			free_wstr(r);

			/* r_make_number: */
			r->numbr = value->num_value;
			r->flags = MALLOC|NUMBER|NUMCUR;
			r->stptr = NULL;
			r->stlen = 0;
			return awk_true;
		}
		break;

	case AWK_STRING:
	case AWK_STRNUM:
		if (node->var_value->valref == 1) {
			NODE *r = node->var_value;

			/* r_unref: */
			if ((r->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
				efree(r->stptr);

			mpfr_unset(r);
			free_wstr(r);

			/* make_str_node(s, l, ALREADY_MALLOCED): */
			r->numbr = 0;
			r->flags = (MALLOC|STRING|STRCUR);
			if (value->val_type == AWK_STRNUM)
				r->flags |= USER_INPUT;
			r->stfmt = STFMT_UNUSED;
			r->stptr = value->str_value.str;
			r->stlen = value->str_value.len;
#ifdef HAVE_MPFR
			r->strndmode = MPFR_round_mode;
#endif
			return awk_true;
		}
		break;

	case AWK_REGEX:
	case AWK_UNDEFINED:
	case AWK_SCALAR:
	case AWK_VALUE_COOKIE:
		break;


	default:	/* AWK_ARRAY or invalid type */
		return awk_false;
	}

	/* do it the hard (slow) way */
	unref(node->var_value);
	node->var_value = awk_value_to_node(value);
	return awk_true;
}

/*
 * valid_subscript_type --- test if a type is allowed for an array subscript.
 *
 * Any scalar value is fine, so only AWK_ARRAY (or an invalid type) is illegal.
 */

static inline bool
valid_subscript_type(awk_valtype_t valtype)
{
	switch (valtype) {
	case AWK_UNDEFINED:
	case AWK_NUMBER:
	case AWK_STRNUM:
	case AWK_STRING:
	case AWK_REGEX:
	case AWK_SCALAR:
	case AWK_VALUE_COOKIE:
		return true;
	default:	/* AWK_ARRAY or an invalid type */
		return false;
	}
}

/* Array management */
/*
 * api_get_array_element --- teturn the value of an element - read only!
 *
 * Use set_array_element to change it.
 */

static awk_bool_t
api_get_array_element(awk_ext_id_t id,
		awk_array_t a_cookie,
		const awk_value_t *const index,
		awk_valtype_t wanted,
		awk_value_t *result)
{
	NODE *array = (NODE *) a_cookie;
	NODE *subscript;
	NODE **aptr;

	/* don't check for index len zero, null str is ok as index */
	if (   array == NULL
	    || array->type != Node_var_array
	    || result == NULL
	    || index == NULL
	    || ! valid_subscript_type(index->val_type))
		return awk_false;

	subscript = awk_value_to_node(index);

	/* if it doesn't exist, return false */
	if (in_array(array, subscript) == NULL) {
		unref(subscript);
		return awk_false;
	}

	aptr = assoc_lookup(array, subscript);

	if (aptr == NULL) {	/* can't happen */
		unref(subscript);
		return awk_false;
	}

	unref(subscript);

	return node_to_awk_value(*aptr, result, wanted);
}

/*
 * api_set_array_element --- change (or create) element in existing array
 *	with element->index and element->value.
 */

static awk_bool_t
api_set_array_element(awk_ext_id_t id, awk_array_t a_cookie,
					const awk_value_t *const index,
					const awk_value_t *const value)
{
	NODE *array = (NODE *)a_cookie;
	NODE *tmp;
	NODE *elem;

	/* don't check for index len zero, null str is ok as index */
	if (   array == NULL
	    || array->type != Node_var_array
	    || (array->flags & NO_EXT_SET) != 0
	    || index == NULL
	    || value == NULL
	    || ! valid_subscript_type(index->val_type))
		return awk_false;

	tmp = awk_value_to_node(index);
	elem = awk_value_to_node(value);
	if (elem->type == Node_var_array) {
		elem->parent_array = array;
		elem->vname = estrdup(index->str_value.str,
					index->str_value.len);
	}
	assoc_set(array, tmp, elem);

	return awk_true;
}

/*
 * remove_element --- remove an array element
 *		common code used by multiple functions
 */

static void
remove_element(NODE *array, NODE *subscript)
{
	NODE *val;

	if (array == NULL)
		fatal(_("remove_element: received null array"));

	if (subscript == NULL)
		fatal(_("remove_element: received null subscript"));

	val = in_array(array, subscript);

	if (val == NULL)
		return;

	if (val->type == Node_var_array) {
		assoc_clear(val);
		/* cleared a sub-array, free Node_var_array */
		efree(val->vname);
		freenode(val);
	} else
		unref(val);

	(void) assoc_remove(array, subscript);
}

/*
 * api_del_array_element --- remove the element with the given index.
 *	Return success if removed or if element did not exist.
 */

static awk_bool_t
api_del_array_element(awk_ext_id_t id,
		awk_array_t a_cookie, const awk_value_t* const index)
{
	NODE *array, *sub;

	array = (NODE *) a_cookie;
	if (   array == NULL
	    || array->type != Node_var_array
	    || (array->flags & NO_EXT_SET) != 0
	    || index == NULL
	    || ! valid_subscript_type(index->val_type))
		return awk_false;

	sub = awk_value_to_node(index);
	remove_element(array, sub);
	unref(sub);

	return awk_true;
}

/*
 * api_get_element_count --- retrieve total number of elements in array.
 *	Return false if some kind of error.
 */

static awk_bool_t
api_get_element_count(awk_ext_id_t id,
		awk_array_t a_cookie, size_t *count)
{
	NODE *node = (NODE *) a_cookie;

	if (count == NULL || node == NULL || node->type != Node_var_array)
		return awk_false;

	*count = node->table_size;
	return awk_true;
}

/* api_create_array --- create a new array cookie to which elements may be added */

static awk_array_t
api_create_array(awk_ext_id_t id)
{
	NODE *n;

	getnode(n);
	memset(n, 0, sizeof(NODE));
	null_array(n);

	return (awk_array_t) n;
}

/* api_clear_array --- clear out an array */

static awk_bool_t
api_clear_array(awk_ext_id_t id, awk_array_t a_cookie)
{
	NODE *node = (NODE *) a_cookie;

	if (   node == NULL
	    || node->type != Node_var_array
	    || (node->flags & NO_EXT_SET) != 0)
		return awk_false;

	assoc_clear(node);
	return awk_true;
}

/* api_destroy_array --- destroy an array */

static awk_bool_t
api_destroy_array(awk_ext_id_t id, awk_array_t a_cookie)
{
	if (! api_clear_array(id, a_cookie))
		return awk_false;
	freenode((NODE *) a_cookie);
	return awk_true;
}

/* api_flatten_array_typed --- flatten out an array so that it can be looped over easily. */

static awk_bool_t
api_flatten_array_typed(awk_ext_id_t id,
		awk_array_t a_cookie,
		awk_flat_array_t **data,
		awk_valtype_t index_type, awk_valtype_t value_type)
{
	NODE **list;
	size_t i, j;
	NODE *array = (NODE *) a_cookie;
	size_t alloc_size;

	if (   array == NULL
	    || array->type != Node_var_array
	    || assoc_empty(array)
	    || data == NULL)
		return awk_false;

	alloc_size = sizeof(awk_flat_array_t) +
			(array->table_size - 1) * sizeof(awk_element_t);

	ezalloc(*data, awk_flat_array_t *, alloc_size);

	list = assoc_list(array, "@unsorted", ASORTI);

	(*data)->opaque1 = array;
	(*data)->opaque2 = list;
	(*data)->count = array->table_size;

	for (i = j = 0; i < 2 * array->table_size; i += 2, j++) {
		NODE *index, *value;

		index = list[i];
		value = list[i + 1]; /* number or string or subarray */

		/* Convert index and value to API types. */
		if (! node_to_awk_value(index,
				& (*data)->elements[j].index, index_type)) {
			fatal(_("api_flatten_array_typed: could not convert index %d to %s"),
						(int) i, valtype2str(index_type));
		}
		if (! node_to_awk_value(value,
				& (*data)->elements[j].value, value_type)) {
			fatal(_("api_flatten_array_typed: could not convert value %d to %s"),
						(int) i, valtype2str(value_type));
		}
	}
	return awk_true;
}

/*
 * api_release_flattened_array --- release array memory,
 *	delete any marked elements. Count must match what
 *	gawk thinks the size is.
 */

static awk_bool_t
api_release_flattened_array(awk_ext_id_t id,
		awk_array_t a_cookie,
		awk_flat_array_t *data)
{
	NODE *array = (NODE *) a_cookie;
	NODE **list;
	size_t i, j, k;

	if (   array == NULL
	    || array->type != Node_var_array
	    || data == NULL
	    || array != (NODE *) data->opaque1
	    || data->count != array->table_size
	    || data->opaque2 == NULL)
		return awk_false;

	list = (NODE **) data->opaque2;

	/* free index nodes */
	for (i = j = 0, k = 2 * array->table_size; i < k; i += 2, j++) {
		/* Delete items flagged for delete. */
		if (   (data->elements[j].flags & AWK_ELEMENT_DELETE) != 0
		    && (array->flags & NO_EXT_SET) == 0) {
			remove_element(array, list[i]);
		}
		unref(list[i]);
	}

	efree(list);
	efree(data);

	return awk_true;
}

/* api_create_value --- create a cached value */

static awk_bool_t
api_create_value(awk_ext_id_t id, awk_value_t *value,
		awk_value_cookie_t *result)
{
	if (value == NULL || result == NULL)
		return awk_false;

	switch (value->val_type) {
	case AWK_NUMBER:
	case AWK_STRNUM:
	case AWK_STRING:
	case AWK_REGEX:
		break;
	default:
		/* reject anything other than a simple scalar */
		return awk_false;
	}

	return (awk_bool_t) ((*result = awk_value_to_node(value)) != NULL);
}

/* api_release_value --- release a cached value */

static awk_bool_t
api_release_value(awk_ext_id_t id, awk_value_cookie_t value)
{
	NODE *val = (NODE *) value;

	if (val == NULL)
		return awk_false;

	unref(val);
	return awk_true;
}

/* api_get_mpfr --- allocate an mpfr_ptr */

static void *
api_get_mpfr(awk_ext_id_t id)
{
#ifdef HAVE_MPFR
	mpfr_ptr p;
	emalloc(p, mpfr_ptr, sizeof(mpfr_t));
	mpfr_init(p);
	return p;
#else
	fatal(_("api_get_mpfr: MPFR not supported"));
	return NULL;	// silence compiler warning
#endif
}

/* api_get_mpz --- allocate an mpz_ptr */

static void *
api_get_mpz(awk_ext_id_t id)
{
#ifdef HAVE_MPFR
	mpz_ptr p;
	emalloc(p, mpz_ptr, sizeof (mpz_t));

	mpz_init(p);
	return p;
#else
	fatal(_("api_get_mpfr: MPFR not supported"));
	return NULL;	// silence compiler warning
#endif
}

/* api_get_file --- return a handle to an existing or newly opened file */

static awk_bool_t
api_get_file(awk_ext_id_t id, const char *name, size_t namelen, const char *filetype,
		int fd, const awk_input_buf_t **ibufp, const awk_output_buf_t **obufp)
{
	const struct redirect *f;
	int flag;	/* not used, sigh */
	enum redirval redirtype;

	if (name == NULL || namelen == 0) {
		if (curfile == NULL) {
			INSTRUCTION *pc;
			int save_rule;
			char *save_source;

			if (nextfile(& curfile, false) <= 0)
				return awk_false;

			pc = main_beginfile;
			/* save execution state */
			save_rule = currule;
			save_source = source;

			for (;;) {
				if (pc == NULL)
					fatal(_("cannot find end of BEGINFILE rule"));
				if (pc->opcode == Op_after_beginfile)
					break;
				pc = pc->nexti;
			}
			pc->opcode = Op_stop;
		        (void) (*interpret)(main_beginfile);
			pc->opcode = Op_after_beginfile;
			after_beginfile(& curfile);
			/* restore execution state */
			currule = save_rule;
			source = save_source;
		}
		*ibufp = &curfile->public;
		*obufp = NULL;

		return awk_true;
	}

	redirtype = redirect_none;
	switch (filetype[0]) {
	case '<':
		if (filetype[1] == '\0')
			redirtype = redirect_input;
		break;
	case '>':
		switch (filetype[1]) {
		case '\0':
			redirtype = redirect_output;
			break;
		case '>':
			if (filetype[2] == '\0')
				redirtype = redirect_append;
			break;
		}
		break;
	case '|':
		if (filetype[2] == '\0') {
			switch (filetype[1]) {
			case '>':
				redirtype = redirect_pipe;
				break;
			case '<':
				redirtype = redirect_pipein;
				break;
			case '&':
				redirtype = redirect_twoway;
				break;
			}
		}
		break;
	}

	if (redirtype == redirect_none) {
		warning(_("cannot open unrecognized file type `%s' for `%s'"),
			filetype, name);
		return awk_false;
	}

	if ((f = redirect_string(name, namelen, 0, redirtype, &flag, fd, false)) == NULL)
		return awk_false;

	*ibufp = f->iop ? & f->iop->public : NULL;
	*obufp = f->output.fp ? & f->output : NULL;
	return awk_true;
}

/*
 * Register a version string for this extension with gawk.
 */

struct version_info {
	const char *version;
	struct version_info *next;
};

static struct version_info *vi_head;

/* api_register_ext_version --- add an extension version string to the list */

static void
api_register_ext_version(awk_ext_id_t id, const char *version)
{
	struct version_info *info;

	if (version == NULL)
		return;

	(void) id;

	emalloc(info, struct version_info *, sizeof(struct version_info));
	info->version = version;
	info->next = vi_head;
	vi_head = info;
}

/* the struct api */
gawk_api_t api_impl = {
	/* data */
	GAWK_API_MAJOR_VERSION,	/* major and minor versions */
	GAWK_API_MINOR_VERSION,

#ifdef HAVE_MPFR
	__GNU_MP_VERSION,
	__GNU_MP_VERSION_MINOR,
	MPFR_VERSION_MAJOR,
	MPFR_VERSION_MINOR,
#else
	0, 0, 0, 0,
#endif

	{ 0 },			/* do_flags */

	/* registration functions */
	api_add_ext_func,
	api_register_input_parser,
	api_register_output_wrapper,
	api_register_two_way_processor,
	api_awk_atexit,
	api_register_ext_version,

	/* message printing functions */
	api_fatal,
	api_warning,
	api_lintwarn,
	api_nonfatal,

	/* updating ERRNO */
	api_update_ERRNO_int,
	api_update_ERRNO_string,
	api_unset_ERRNO,

	/* Function arguments */
	api_get_argument,
	api_set_argument,

	/* Accessing and installing variables and constants */
	api_sym_lookup,
	api_sym_update,

	/* Accessing and modifying variables via scalar cookies */
	api_sym_lookup_scalar,
	api_sym_update_scalar,

	/* Cached values */
	api_create_value,
	api_release_value,

	/* Array management */
	api_get_element_count,
	api_get_array_element,
	api_set_array_element,
	api_del_array_element,
	api_create_array,
	api_clear_array,
	api_flatten_array_typed,
	api_release_flattened_array,

	/* Memory allocation */
	malloc,
	calloc,
	realloc,
	free,
	api_get_mpfr,
	api_get_mpz,

	/* Find/open a file */
	api_get_file,

	/* Additional array hook to destroy an array */
	api_destroy_array,
};

/* init_ext_api --- init the extension API */

void
init_ext_api()
{
	/* force values to 1 / 0 */
	api_impl.do_flags[gawk_do_lint] = (do_lint ? 1 : 0);
	api_impl.do_flags[gawk_do_traditional] = (do_traditional ? 1 : 0);
	api_impl.do_flags[gawk_do_profile] = (do_profile ? 1 : 0);
	api_impl.do_flags[gawk_do_sandbox] = (do_sandbox ? 1 : 0);
	api_impl.do_flags[gawk_do_debug] = (do_debug ? 1 : 0);
	api_impl.do_flags[gawk_do_mpfr] = (do_mpfr ? 1 : 0);
	api_impl.do_flags[gawk_do_csv] = (do_csv ? 1 : 0);
}

/* update_ext_api --- update the variables in the API that can change */

void
update_ext_api()
{
	api_impl.do_flags[0] = (do_lint ? 1 : 0);
}

/* print_ext_versions --- print the list */

extern void
print_ext_versions(void)
{
	struct version_info *p;

	for (p = vi_head; p != NULL; p = p->next)
		printf("%s\n", p->version);
}

/* valtype2str --- return a printable representation of a value type */

static const char *
valtype2str(awk_valtype_t type)
{
	static char buf[100];

	// Important: keep in same order as in gawkapi.h!
	static const char *values[] = {
		"AWK_UNDEFINED",
		"AWK_NUMBER",
		"AWK_STRING",
		"AWK_REGEX",
		"AWK_STRNUM",
		"AWK_ARRAY",
		"AWK_SCALAR",
		"AWK_VALUE_COOKIE",
	};

	if (AWK_UNDEFINED <= type && type <= AWK_VALUE_COOKIE)
		return values[(int) type];

	sprintf(buf, "unknown type! (%d)", (int) type);

	return buf;
}

/* ns_lookup --- correctly build name before looking it up */

static NODE *
ns_lookup(const char *name_space, const char *name, char **fullname)
{
	assert(name_space != NULL);
	assert(name != NULL);

	if (name_space[0] == '\0' || strcmp(name_space, awk_namespace) == 0) {
		if (fullname != NULL)
			*fullname = estrdup(name, strlen(name));
		return lookup(name);
	}

	size_t len = strlen(name_space) + 2 + strlen(name) + 1;
	char *buf;
	emalloc(buf, char *, len);
	sprintf(buf, "%s::%s", name_space, name);

	NODE *f = lookup(buf);
	if (fullname != NULL)
		*fullname = buf;
	else
		efree((void *) buf);

	return f;
}
/*
 * io.c --- routines for dealing with input and output and records
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

#ifdef HAVE_SYS_PARAM_H
#undef RE_DUP_MAX	/* avoid spurious conflict w/regex.h */
#include <sys/param.h>
#endif /* HAVE_SYS_PARAM_H */
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif /* HAVE_SYS_IOCTL_H */

#ifndef O_ACCMODE
#define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
#endif

#ifndef HAVE_GETDTABLESIZE
#define getdtablesize()	(1024)	/* should be big enough */
#endif

#if ! defined(S_ISREG) && defined(S_IFREG)
#define	S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif

#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif
#ifdef HAVE_STROPTS_H
#include <stropts.h>
#endif

#ifdef HAVE_SOCKETS

#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#else
#include <socket.h>
#endif /* HAVE_SYS_SOCKET_H */

#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>

#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif

#else /* ! HAVE_NETINET_IN_H */
#include <in.h>
#endif /* HAVE_NETINET_IN_H */

#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif /* HAVE_NETDB_H */

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif	/* HAVE_SYS_SELECT_H */

#ifndef HAVE_GETADDRINFO
#include "missing_d/getaddrinfo.h"
#endif

#ifndef AI_ADDRCONFIG	/* not everyone has this symbol */
#define AI_ADDRCONFIG 0
#endif /* AI_ADDRCONFIG */

#ifndef HAVE_SOCKADDR_STORAGE
#define sockaddr_storage sockaddr	/* for older systems */
#endif /* HAVE_SOCKADDR_STORAGE */

#endif /* HAVE_SOCKETS */

#ifndef AF_UNSPEC
#define AF_UNSPEC 0
#endif
#ifndef AF_INET
#define AF_INET 2
#endif
#ifndef AF_INET6
#define AF_INET6 10
#endif

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif

#if defined(HAVE_POPEN_H)
#include "popen.h"
#endif

#ifndef ENFILE
#define ENFILE EMFILE
#endif

#if defined(VMS)
#include <ssdef.h>
#ifndef SS$_EXBYTLM
#define SS$_EXBYTLM 0x2a14  /* VMS 8.4 seen */
#endif
#include <rmsdef.h>
#define closemaybesocket(fd)	close(fd)
#endif

#ifdef HAVE_SOCKETS

#ifndef SHUT_RD
# ifdef SD_RECEIVE
#  define SHUT_RD	SD_RECEIVE
# else
#  define SHUT_RD	0
# endif
#endif

#ifndef SHUT_WR
# ifdef SD_SEND
#  define SHUT_WR	SD_SEND
# else
#  define SHUT_WR	1
# endif
#endif

#ifndef SHUT_RDWR
# ifdef SD_BOTH
#  define SHUT_RDWR	SD_BOTH
# else
#  define SHUT_RDWR	2
# endif
#endif

/* MinGW defines non-trivial macros on pc/socket.h.  */
#ifndef FD_TO_SOCKET
# define FD_TO_SOCKET(fd)	(fd)
# define closemaybesocket(fd)	close(fd)
#endif

#ifndef SOCKET_TO_FD
# define SOCKET_TO_FD(s)	(s)
# define SOCKET			int
#endif

#else /* HAVE_SOCKETS */

#ifndef closemaybesocket
# define closemaybesocket(fd)	close(fd)
#endif

#endif /* HAVE_SOCKETS */

#ifndef HAVE_SETSID
#define setsid()	/* nothing */
#endif /* HAVE_SETSID */

#if defined(_AIX)
#undef TANDEM	/* AIX defines this in one of its header files */
#endif

#ifdef __MINGW32__
# ifndef PIPES_SIMULATED
#  define pipe(fds)	_pipe(fds, 0, O_NOINHERIT)
# endif
#endif

#ifdef HAVE_MPFR
/* increment NR or FNR */
#define INCREMENT_REC(X)	(do_mpfr && X == (LONG_MAX - 1)) ? \
				(mpz_add_ui(M##X, M##X, 1), X = 0) : X++
#else
#define INCREMENT_REC(X)	X++
#endif

/* Several macros to make the code a bit clearer. */
#define at_eof(iop)     (((iop)->flag & IOP_AT_EOF) != 0)
#define has_no_data(iop)        ((iop)->dataend == NULL)
#define no_data_left(iop)	((iop)->off >= (iop)->dataend)
#define buffer_has_all_data(iop) ((iop)->dataend - (iop)->off == (iop)->public.sbuf.st_size)

/*
 * The key point to the design is to split out the code that searches through
 * a buffer looking for the record and the terminator into separate routines,
 * with a higher-level routine doing the reading of data and buffer management.
 * This makes the code easier to manage; the buffering code is the same
 * independent of how we find a record.  Communication is via the return
 * value:
 */

typedef enum recvalues {
        REC_OK,         /* record and terminator found, recmatch struct filled in */
        NOTERM,         /* no terminator found, give me more input data */
        TERMATEND,      /* found terminator at end of buffer */
        TERMNEAREND     /* found terminator close to end of buffer, for when
			   the RE might match more data further in
			   the file. */
} RECVALUE;

/*
 * Between calls to a scanning routine, the state is stored in
 * an enum scanstate variable.  Not all states apply to all
 * variants, but the higher code doesn't really care.
 */

typedef enum scanstate {
        NOSTATE,        /* scanning not started yet (all) */
        INLEADER,       /* skipping leading data (RS = "") */
        INDATA,         /* in body of record (all) */
        INTERM          /* scanning terminator (RS = "", RS = regexp) */
} SCANSTATE;

/*
 * When a record is seen (REC_OK or TERMATEND), the following
 * structure is filled in.
 */

struct recmatch {
        char *start;    /* record start */
        size_t len;     /* length of record */
        char *rt_start; /* start of terminator */
        size_t rt_len;  /* length of terminator */
};


static int iop_close(IOBUF *iop);
static void close_one(void);
static int close_redir(struct redirect *rp, bool exitwarn, two_way_close_type how);
static IOBUF *gawk_popen(const char *cmd, struct redirect *rp);
static FILE *gawk_popen_write(const char *cmd);
static int gawk_popen_write_close(FILE *fp);
static IOBUF *iop_alloc(int fd, const char *name, int errno_val);
static IOBUF *iop_finish(IOBUF *iop);
static int gawk_pclose(struct redirect *rp);
static int str2mode(const char *mode);
static int two_way_open(const char *str, struct redirect *rp, int extfd);
static bool pty_vs_pipe(const char *command);
static void find_input_parser(IOBUF *iop);
static bool find_output_wrapper(awk_output_buf_t *outbuf);
static void init_output_wrapper(awk_output_buf_t *outbuf);
static bool find_two_way_processor(const char *name, struct redirect *rp);
static bool avoid_flush(const char *name);

static RECVALUE rs1scan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state);
static RECVALUE rsnullscan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state);
static RECVALUE rsrescan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state);
static RECVALUE csvscan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state);

static RECVALUE (*matchrec)(IOBUF *iop, struct recmatch *recm, SCANSTATE *state) = rs1scan;

static int get_a_record(char **out, size_t *len, IOBUF *iop, int *errcode, const awk_fieldwidth_info_t **field_width);

static void free_rp(struct redirect *rp);

struct inet_socket_info {
	int family;		/* AF_UNSPEC, AF_INET, or AF_INET6 */
	int protocol;		/* SOCK_STREAM or SOCK_DGRAM */
	/*
	 * N.B. If we used 'char *' or 'const char *' pointers to the
	 * substrings, it would trigger compiler warnings about the casts
	 * in either inetfile() or devopen().  So we use offset/len to
	 * avoid that.
	 */
	struct {
		int offset;
		int len;
	} localport, remotehost, remoteport;
};

static bool inetfile(const char *str, size_t len, struct inet_socket_info *isn);

static NODE *in_PROCINFO(const char *pidx1, const char *pidx2, NODE **full_idx);
static long get_read_timeout(IOBUF *iop);
static ssize_t read_with_timeout(int fd, void *buf, size_t size);

static bool read_can_timeout = false;
static long read_timeout;
static long read_default_timeout;

static struct redirect *red_head = NULL;
static NODE *RS = NULL;
static Regexp *RS_re[2];	/* index 0 - don't ignore case, index 1, do */
static Regexp *RS_regexp;

static const char nonfatal[] = "NONFATAL";

bool RS_is_null;

extern NODE *ARGC_node;
extern NODE *ARGV_node;
extern NODE *ARGIND_node;
extern NODE **fields_arr;

/* init_io --- set up timeout related variables */

void
init_io()
{
	long tmout;

	/* Only MinGW has a non-trivial implementation of this.  */
	init_sockets();

	/*
	 * N.B.: all these hacks are to minimize the effect
	 * on programs that do not care about timeout.
	 */

	/* Parse the env. variable only once */
	tmout = getenv_long("GAWK_READ_TIMEOUT");
	if (tmout > 0) {
		read_default_timeout = tmout;
		read_can_timeout = true;
	}

	/*
	 * PROCINFO entries for timeout are dynamic;
	 * We can't be any more specific than this.
	 */
	if (PROCINFO_node != NULL)
		read_can_timeout = true;
}

/* init_csv_records --- set up for CSV handling */

void
init_csv_records(void)
{
	if (do_csv)
		matchrec = csvscan;
}


#if defined(__MINGW32__) || defined(__CYGWIN__)
/* binmode --- convert BINMODE to string for fopen */

static const char *
binmode(const char *mode)
{
	switch (mode[0]) {
	case 'r':
		if ((BINMODE & BINMODE_INPUT) != 0)
			mode = "rb";
		break;
	case 'w':
	case 'a':
		if ((BINMODE & BINMODE_OUTPUT) != 0)
			mode = (mode[0] == 'w' ? "wb" : "ab");
		break;
	}
	return mode;
}
#else
#define binmode(mode)	(mode)
#endif

#ifdef VMS
/* File pointers have an extra level of indirection, and there are cases where
   `stdin' can be null.  That can crash gawk if fileno() is used as-is.  */
static int vmsrtl_fileno(FILE *);
static int vmsrtl_fileno(fp) FILE *fp; { return fileno(fp); }
#undef fileno
#define fileno(FP) (((FP) && *(FP)) ? vmsrtl_fileno(FP) : -1)
#endif	/* VMS */

/* after_beginfile --- reset necessary state after BEGINFILE has run */

void
after_beginfile(IOBUF **curfile)
{
	IOBUF *iop;

	iop = *curfile;
	assert(iop != NULL);

	/*
	 * Input parsers could have been changed by BEGINFILE,
	 * so delay check until now.
	 */

	find_input_parser(iop);

	if (! iop->valid) {
		const char *fname;
		int errcode;
		bool valid;

		fname = iop->public.name;
		errcode = iop->errcode;
		valid = iop->valid;
		errno = 0;
		update_ERRNO_int(errcode);
		iop_close(iop);
		*curfile = NULL;
		if (! valid && errcode == EISDIR && ! do_traditional) {
			warning(_("command line argument `%s' is a directory: skipped"), fname);
			return;		/* read next file */
		}
		fatal(_("cannot open file `%s' for reading: %s"),
				fname, strerror(errcode));
	}
}

/* nextfile --- move to the next input data file */
/*
 * Return value > 0 ----> run BEGINFILE block
 * *curfile = NULL  ----> hit EOF, run ENDFILE block
 */

int
nextfile(IOBUF **curfile, bool skipping)
{
	static long i = 1;
	static bool files = false;
	NODE *arg, *tmp;
	const char *fname;
	int fd = INVALID_HANDLE;
	int errcode = 0;
	IOBUF *iop = *curfile;

	if (skipping) {			/* for 'nextfile' call */
		errcode = 0;
		if (iop != NULL) {
			errcode = iop->errcode;
			(void) iop_close(iop);
		}
		*curfile = NULL;
		return (errcode == 0);
	}

	if (iop != NULL) {
		if (at_eof(iop)) {
			assert(iop->public.fd != INVALID_HANDLE);
			(void) iop_close(iop);
			*curfile = NULL;
			return 1;	/* run endfile block */
		} else
			return 0;
	}

	for (; i < get_number_si(ARGC_node->var_value);  i++) {
		tmp = make_number((AWKNUM) i);
		(void) force_string(tmp);
		arg = in_array(ARGV_node, tmp);
		unref(tmp);
		if (arg == NULL || arg->stlen == 0)
			continue;
		arg = force_string(arg);
		if (! do_traditional) {
			unref(ARGIND_node->var_value);
			ARGIND_node->var_value = make_number((AWKNUM) i);
		}

		if (! arg_assign(arg->stptr, false)) {
			files = true;
			fname = arg->stptr;

			/* manage the awk variables: */
			unref(FILENAME_node->var_value);
			FILENAME_node->var_value = dupnode(arg);
#ifdef HAVE_MPFR
			if (is_mpg_number(FNR_node->var_value))
				mpz_set_ui(MFNR, 0);
#endif
			FNR = 0;

			/* IOBUF management: */
			errno = 0;
			fd = devopen(fname, binmode("r"));
			if (fd == INVALID_HANDLE && errno == EMFILE) {
				close_one();
				close_one();
				fd = devopen(fname, binmode("r"));
			}
			errcode = errno;
			if (! do_traditional)
				update_ERRNO_int(errno);
			iop = iop_alloc(fd, fname, errcode);
			*curfile = iop_finish(iop);
			if (iop->public.fd == INVALID_HANDLE)
				iop->errcode = errcode;
			else if (iop->valid)
				iop->errcode = 0;

			if (! do_traditional && iop->errcode != 0)
				update_ERRNO_int(iop->errcode);

			return ++i;	/* run beginfile block */
		}
	}

	if (files == false) {
		files = true;
		/* no args. -- use stdin */
		/* FNR is init'ed to 0 */
		errno = 0;
		if (! do_traditional)
			update_ERRNO_int(errno);

		unref(FILENAME_node->var_value);
		FILENAME_node->var_value = make_string("-", 1);
		FILENAME_node->var_value->flags |= USER_INPUT; /* be pedantic */
		fname = "-";
		iop = iop_alloc(fileno(stdin), fname, 0);
		*curfile = iop_finish(iop);

		if (iop->public.fd == INVALID_HANDLE) {
			errcode = errno;
			errno = 0;
			update_ERRNO_int(errno);
			(void) iop_close(iop);
			*curfile = NULL;
			fatal(_("cannot open file `%s' for reading: %s"),
					fname, strerror(errcode));
		}
		return ++i;	/* run beginfile block */
	}

	return -1;	/* end of input, run end block or Op_atexit */
}

/* set_FNR --- update internal FNR from awk variable */

void
set_FNR()
{
	NODE *n = FNR_node->var_value;
	(void) force_number(n);
#ifdef HAVE_MPFR
	if (is_mpg_number(n))
		FNR = mpg_set_var(FNR_node);
	else
#endif
	FNR = get_number_si(n);
}

/* set_NR --- update internal NR from awk variable */

void
set_NR()
{
	NODE *n = NR_node->var_value;
	(void) force_number(n);
#ifdef HAVE_MPFR
	if (is_mpg_number(n))
		NR = mpg_set_var(NR_node);
	else
#endif
	NR = get_number_si(n);
}

/* inrec --- This reads in a record from the input file */

bool
inrec(IOBUF *iop, int *errcode)
{
	char *begin;
	size_t cnt;
	bool retval;
	const awk_fieldwidth_info_t *field_width = NULL;

	if (at_eof(iop) && no_data_left(iop))
		retval = false;
	else if ((iop->flag & IOP_CLOSED) != 0)
		retval = false;
	else
		/* Note that get_a_record may return -2 when I/O would block */
		retval = (get_a_record(& begin, & cnt, iop, errcode, & field_width) == 0);

	if (retval) {
		INCREMENT_REC(NR);
		INCREMENT_REC(FNR);
		set_record(begin, cnt, field_width);
		if (*errcode > 0)
			retval = false;
	}

	return retval;
}

/* remap_std_file --- reopen a standard descriptor on /dev/null */

static int
remap_std_file(int oldfd)
{
	int newfd;
	int ret = -1;

	/*
	 * Give OS-specific routines in gawkmisc.c a chance to interpret
	 * "/dev/null" as appropriate for their platforms.
	 */
	newfd = os_devopen("/dev/null", O_RDWR);
	if (newfd == INVALID_HANDLE)
		newfd = open("/dev/null", O_RDWR);
	if (newfd >= 0) {
		/* if oldfd is open, dup2() will close oldfd for us first. */
		ret = dup2(newfd, oldfd);
		// close unconditionally, calling code assumes it
		close(newfd);
	} else
		ret = 0;

	return ret;
}

/* iop_close --- close an open IOP */

static int
iop_close(IOBUF *iop)
{
	int ret = 0;

	if (iop == NULL)
		return 0;

	errno = 0;

	iop->flag &= ~IOP_AT_EOF;
	iop->flag |= IOP_CLOSED;	/* there may be dangling pointers */
	iop->dataend = NULL;
	/*
	 * Closing standard files can cause crufty code elsewhere to lose.
	 * So we remap the standard file to /dev/null.
	 * Thanks to Jim Meyering for the suggestion.
	 */
	if (iop->public.close_func != NULL)
		iop->public.close_func(&iop->public);

	if (iop->public.fd != INVALID_HANDLE) {
		if (iop->public.fd == fileno(stdin)
		    || iop->public.fd == fileno(stdout)
		    || iop->public.fd == fileno(stderr))
			ret = remap_std_file(iop->public.fd);
		else
			ret = closemaybesocket(iop->public.fd);
	}

	if (ret == -1)
		warning(_("close of fd %d (`%s') failed: %s"), iop->public.fd,
				iop->public.name, strerror(errno));
	/*
	 * Be careful -- $0 may still reference the buffer even though
	 * an explicit close is being done; in the future, maybe we
	 * can do this a bit better.
	 */
	if (iop->buf) {
		if ((fields_arr[0]->stptr >= iop->buf)
		    && (fields_arr[0]->stptr < (iop->buf + iop->size))) {
			NODE *t;

			t = make_string(fields_arr[0]->stptr,
					fields_arr[0]->stlen);
			unref(fields_arr[0]);
			fields_arr[0] = t;
			/*
			 * This used to be here:
			 *
			 * reset_record();
			 *
			 * Don't do that; reset_record() throws away all fields,
			 * saves FS etc.  We just need to make sure memory isn't
			 * corrupted and that references to $0 and fields work.
			 */
		}
		efree(iop->buf);
		iop->buf = NULL;
	}
	efree(iop);
	return ret == -1 ? 1 : 0;
}

/* redflags2str --- turn redirection flags into a string, for debugging */

const char *
redflags2str(int flags)
{
	static const struct flagtab redtab[] = {
		{ RED_FILE,	"RED_FILE" },
		{ RED_PIPE,	"RED_PIPE" },
		{ RED_READ,	"RED_READ" },
		{ RED_WRITE,	"RED_WRITE" },
		{ RED_APPEND,	"RED_APPEND" },
		{ RED_FLUSH,	"RED_FLUSH" },
		{ RED_EOF,	"RED_EOF" },
		{ RED_TWOWAY,	"RED_TWOWAY" },
		{ RED_PTY,	"RED_PTY" },
		{ RED_SOCKET,	"RED_SOCKET" },
		{ RED_TCP,	"RED_TCP" },
		{ 0, NULL }
	};

	if (flags == RED_NONE)
		return "RED_NONE";

	return genflags2str(flags, redtab);
}

/* check_duplicated_redirections --- see if the same name used differently */

static void
check_duplicated_redirections(const char *name, size_t len,
		redirect_flags_t oldflags, redirect_flags_t newflags)
{
	static struct mixture {
		redirect_flags_t common;
		redirect_flags_t mode;
		redirect_flags_t other_mode;
		const char *message;
	} mixtures[] = {
		{ RED_FILE, RED_READ, RED_WRITE,
			gettext_noop("`%.*s' used for input file and for output file") },
		{ RED_READ, RED_FILE, RED_PIPE,
			gettext_noop("`%.*s' used for input file and input pipe") },
		{ RED_READ, RED_FILE, RED_TWOWAY,
			gettext_noop("`%.*s' used for input file and two-way pipe") },
		{ RED_NONE, (RED_FILE|RED_READ), (RED_PIPE|RED_WRITE),
			gettext_noop("`%.*s' used for input file and output pipe") },
		{ (RED_FILE|RED_WRITE), (RED_FILE|RED_WRITE), RED_APPEND,
			gettext_noop("unnecessary mixing of `>' and `>>' for file `%.*s'") },
		{ RED_NONE, (RED_FILE|RED_WRITE), (RED_PIPE|RED_READ),
			gettext_noop("`%.*s' used for input pipe and output file") },
		{ RED_WRITE, RED_FILE, RED_PIPE,
			gettext_noop("`%.*s' used for output file and output pipe") },
		{ RED_WRITE, RED_FILE, RED_TWOWAY,
			gettext_noop("`%.*s' used for output file and two-way pipe") },
		{ RED_PIPE, RED_READ, RED_WRITE,
			gettext_noop("`%.*s' used for input pipe and output pipe") },
		{ RED_READ, RED_PIPE, RED_TWOWAY,
			gettext_noop("`%.*s' used for input pipe and two-way pipe") },
		{ RED_WRITE, RED_PIPE, RED_TWOWAY,
			gettext_noop("`%.*s' used for output pipe and two-way pipe") },
	};
	int i = 0, j = sizeof(mixtures) / sizeof(mixtures[0]);

	oldflags &= ~(RED_FLUSH|RED_EOF|RED_PTY);
	newflags &= ~(RED_FLUSH|RED_EOF|RED_PTY);

	for (i = 0; i < j; i++) {
		bool both_have_common = \
			(   (oldflags & mixtures[i].common) == mixtures[i].common
			 && (newflags & mixtures[i].common) == mixtures[i].common);
		bool old_has_mode = (oldflags & mixtures[i].mode) == mixtures[i].mode;
		bool new_has_mode = (newflags & mixtures[i].mode) == mixtures[i].mode;
		bool old_has_other_mode = (oldflags & mixtures[i].other_mode) == mixtures[i].other_mode;
		bool new_has_other_mode = (newflags & mixtures[i].other_mode) == mixtures[i].other_mode;

		if (   both_have_common
		    && oldflags != newflags
		    && (   (old_has_mode || new_has_mode)
			&& (old_has_other_mode || new_has_other_mode)))
		{
			lintwarn(_(mixtures[i].message), len, name);
			return;
		}
	}
}

/* redirect_string --- Redirection for printf and print commands, use string info */

struct redirect *
redirect_string(const char *str, size_t explen, bool not_string,
		int redirtype, int *errflg, int extfd, bool failure_fatal)
{
	struct redirect *rp;
	redirect_flags_t tflag = RED_NONE;
	redirect_flags_t outflag = RED_NONE;
	const char *direction = "to";
	const char *mode;
	int fd;
	const char *what = NULL;
	bool new_rp = false;
#ifdef HAVE_SOCKETS
	struct inet_socket_info isi;
#endif
	static struct redirect *save_rp = NULL;	/* hold onto rp that should
	                                         * be freed for reuse
	                                         */
	int save_errno;

	if (do_sandbox)
		fatal(_("redirection not allowed in sandbox mode"));

	switch (redirtype) {
	case redirect_append:
		tflag = RED_APPEND;
		/* FALL THROUGH */
	case redirect_output:
		outflag = (RED_FILE|RED_WRITE);
		tflag |= outflag;
		if (redirtype == redirect_output)
			what = ">";
		else
			what = ">>";
		break;
	case redirect_pipe:
		tflag = (RED_PIPE|RED_WRITE);
		what = "|";
		break;
	case redirect_pipein:
		tflag = (RED_PIPE|RED_READ);
		what = "|";
		break;
	case redirect_input:
		tflag = (RED_FILE|RED_READ);
		what = "<";
		break;
	case redirect_twoway:
		tflag = (RED_READ|RED_WRITE|RED_TWOWAY);
		what = "|&";
		break;
	default:
		cant_happen("invalid redirection type %d", (int) redirtype);
	}
	if (do_lint && not_string)
		lintwarn(_("expression in `%s' redirection is a number"),
			what);

	if (explen < 1 || str == NULL || *str == '\0')
		fatal(_("expression for `%s' redirection has null string value"),
			what);

	if (do_lint && (strncmp(str, "0", explen) == 0
			|| strncmp(str, "1", explen) == 0))
		lintwarn(_("filename `%.*s' for `%s' redirection may be result of logical expression"),
				(int) explen, str, what);

#ifdef HAVE_SOCKETS
	/*
	 * Use /inet4 to force IPv4, /inet6 to force IPv6, and plain
	 * /inet will be whatever we get back from the system.
	 */
	if (inetfile(str, explen, & isi)) {
		tflag |= RED_SOCKET;
		if (isi.protocol == SOCK_STREAM)
			tflag |= RED_TCP;	/* use shutdown when closing */
	}
#endif /* HAVE_SOCKETS */

	for (rp = red_head; rp != NULL; rp = rp->next) {
#ifndef PIPES_SIMULATED
		/*
		 * This is an efficiency hack.  We want to
		 * recover the process slot for dead children,
		 * if at all possible.  Messing with signal() for
		 * SIGCLD leads to lots of headaches.  However, if
		 * we've gotten EOF from a child input pipeline, it's
		 * a good bet that the child has died. So recover it.
		 */
		if ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {
			if (rp->pid != -1)
#ifdef __MINGW32__
				/* MinGW cannot wait for any process.  */
				wait_any(rp->pid);
#else
				wait_any(0);
#endif
		}
#endif /* PIPES_SIMULATED */

		/* now check for a match */
		if (strlen(rp->value) == explen
		    && memcmp(rp->value, str, explen) == 0) {
			if (do_lint) {
				check_duplicated_redirections(rp->value, explen,
						(redirect_flags_t) rp->flag, (redirect_flags_t) tflag);
			}

			if (((rp->flag & ~(RED_FLUSH|RED_EOF|RED_PTY)) == tflag
			    || (outflag != 0
				&& (rp->flag & (RED_FILE|RED_WRITE)) == outflag))) {
				break;
			}
		}
	}

	if (rp == NULL) {
		char *newstr;
		new_rp = true;
		if (save_rp != NULL) {
			rp = save_rp;
			efree(rp->value);
		} else
			emalloc(rp, struct redirect *, sizeof(struct redirect));
		emalloc(newstr, char *, explen + 1);
		memcpy(newstr, str, explen);
		newstr[explen] = '\0';
		str = newstr;
		rp->value = newstr;
		rp->flag =  (redirect_flags_t) tflag;
		init_output_wrapper(& rp->output);
		rp->output.name = str;
		rp->iop = NULL;
		rp->pid = -1;
		rp->status = 0;
	} else
		str = rp->value;	/* get \0 terminated string */
	save_rp = rp;

	while (rp->output.fp == NULL && rp->iop == NULL) {
		if (! new_rp && (rp->flag & RED_EOF) != 0) {
			/*
			 * Encountered EOF on file or pipe -- must be cleared
			 * by explicit close() before reading more
			 */
			save_rp = NULL;
			return rp;
		}
		mode = NULL;
		errno = 0;
		switch (redirtype) {
		case redirect_output:
			mode = binmode("w");
			if ((rp->flag & RED_USED) != 0)
				mode = (rp->mode[1] == 'b') ? "ab" : "a";
			break;
		case redirect_append:
			mode = binmode("a");
			break;
		case redirect_pipe:
			if (extfd >= 0) {
				warning(_("get_file cannot create pipe `%s' with fd %d"), str, extfd);
				return NULL;
			}
			/* synchronize output before new pipe */
			(void) flush_io();

			os_restore_mode(fileno(stdin));
			/*
			 * Don't check failure_fatal; see input pipe below.
			 * Note that the failure happens upon failure to fork,
			 * using a non-existant program will still succeed the
			 * popen().
			 */
			if ((rp->output.fp = gawk_popen_write(str)) == NULL)
				fatal(_("cannot open pipe `%s' for output: %s"),
						str, strerror(errno));

			/* set close-on-exec */
			os_close_on_exec(fileno(rp->output.fp), str, "pipe", "to");

			// Allow the user to say they don't want pipe output
			// to be flushed all the time.
			if (! avoid_flush(str))
				rp->flag |= RED_FLUSH;
			break;
		case redirect_pipein:
			if (extfd >= 0) {
				warning(_("get_file cannot create pipe `%s' with fd %d"), str, extfd);
				return NULL;
			}
			direction = "from";
			if (gawk_popen(str, rp) == NULL)
				fatal(_("cannot open pipe `%s' for input: %s"),
					str, strerror(errno));
			break;
		case redirect_input:
			direction = "from";
			fd = (extfd >= 0) ? extfd : devopen(str, binmode("r"));
			save_errno = errno;
			/* don't fail before letting registered
			   parsers a chance to take control */
			rp->iop = iop_alloc(fd, str, errno);
			find_input_parser(rp->iop);
			iop_finish(rp->iop);
			if (! rp->iop->valid) {
				if (fd == INVALID_HANDLE && save_errno == EISDIR) {
					*errflg = EISDIR;
					iop_close(rp->iop);
					rp->iop = NULL;
					/* do not free rp, saving it for reuse (save_rp = rp) */
					return NULL;
				}
				if (! do_traditional && rp->iop->errcode != 0)
					update_ERRNO_int(rp->iop->errcode);
				iop_close(rp->iop);
				rp->iop = NULL;
			}
			break;
		case redirect_twoway:
#ifndef HAVE_SOCKETS
			if (extfd >= 0) {
				warning(_("get_file socket creation not supported on this platform for `%s' with fd %d"), str, extfd);
				return NULL;
			}
#endif
			direction = "to/from";
			if (! two_way_open(str, rp, extfd)) {
				if (! failure_fatal || is_non_fatal_redirect(str, explen)) {
					*errflg = errno;
					/* do not free rp, saving it for reuse (save_rp = rp) */
					return NULL;
				} else
					fatal(_("cannot open two way pipe `%s' for input/output: %s"),
							str, strerror(errno));
			}
			break;
		default:
			cant_happen("invalid redirection type %d", (int) redirtype);
		}

		if (mode != NULL) {
			errno = 0;
			rp->output.mode = mode;
			fd = (extfd >= 0) ? extfd : devopen(str, mode);

			if (fd > INVALID_HANDLE) {
				if (fd == fileno(stdin))
					rp->output.fp = stdin;
				else if (fd == fileno(stdout))
					rp->output.fp = stdout;
				else if (fd == fileno(stderr))
					rp->output.fp = stderr;
				else {
					const char *omode = mode;
#if defined(F_GETFL) && defined(O_APPEND)
					int fd_flags;

					fd_flags = fcntl(fd, F_GETFL);
					if (fd_flags != -1 && (fd_flags & O_APPEND) == O_APPEND)
						omode = binmode("a");
#endif
					os_close_on_exec(fd, str, "file", "");
					rp->output.fp = fdopen(fd, (const char *) omode);
					rp->mode = (const char *) mode;
					/* don't leak file descriptors */
					if (rp->output.fp == NULL)
						close(fd);
				}
				if (rp->output.fp != NULL && os_isatty(fd))
					rp->flag |= RED_FLUSH;

				/* Move rp to the head of the list. */
				if (! new_rp && red_head != rp) {
					if ((rp->prev->next = rp->next) != NULL)
						rp->next->prev = rp->prev;
					red_head->prev = rp;
					rp->prev = NULL;
					rp->next = red_head;
					red_head = rp;
				}
			}
			find_output_wrapper(& rp->output);
		}

		if (rp->output.fp == NULL && rp->iop == NULL) {
			/* too many files open -- close one and try again */
			if (errno == EMFILE || errno == ENFILE)
				close_one();
#ifdef VMS
			/* Alpha/VMS V7.1+ C RTL is returning these instead
			   of EMFILE (haven't tried other post-V6.2 systems) */
			else if ((errno == EIO || errno == EVMSERR) &&
                                 (vaxc$errno == SS$_EXQUOTA ||
                                  vaxc$errno == SS$_EXBYTLM ||
                                  vaxc$errno == RMS$_ACC ||
				  vaxc$errno == RMS$_SYN)) {
				close_one();
				close_one();
			}
#endif
			else {
				/*
				 * Some other reason for failure.
				 *
				 * On redirection of input from a file,
				 * just return an error, so e.g. getline
				 * can return -1.  For output to file,
				 * complain. The shell will complain on
				 * a bad command to a pipe.
				 *
				 * 12/2014: Take nonfatal settings in PROCINFO into account.
				 */
				if (errflg != NULL)
					*errflg = errno;
				if (failure_fatal && ! is_non_fatal_redirect(str, explen) &&
				    (redirtype == redirect_output
				     || redirtype == redirect_append)) {
					/* multiple messages make life easier for translators */
					if (*direction == 'f')
						fatal(_("cannot redirect from `%s': %s"),
					    		str, strerror(errno));
					else
						fatal(_("cannot redirect to `%s': %s"),
							str, strerror(errno));
				} else {
					/* do not free rp, saving it for reuse (save_rp = rp) */
					return NULL;
				}
			}
		}
	}

	if (new_rp) {
		/*
		 * It opened successfully, hook it into the list.
		 * Maintain the list in most-recently-used first order.
		 */
		if (red_head != NULL)
			red_head->prev = rp;
		rp->prev = NULL;
		rp->next = red_head;
		red_head = rp;
	}
	save_rp = NULL;
	return rp;
}

/* redirect --- Redirection for printf and print commands */

struct redirect *
redirect(NODE *redir_exp, int redirtype, int *errflg, bool failure_fatal)
{
	bool not_string = ((fixtype(redir_exp)->flags & STRING) == 0);

	redir_exp = force_string(redir_exp);
	return redirect_string(redir_exp->stptr, redir_exp->stlen, not_string,
				redirtype, errflg, -1, failure_fatal);
}

/* getredirect --- find the struct redirect for this file or pipe */

struct redirect *
getredirect(const char *str, int len)
{
	struct redirect *rp;

	for (rp = red_head; rp != NULL; rp = rp->next)
		if (strlen(rp->value) == len && memcmp(rp->value, str, len) == 0)
			return rp;

	return NULL;
}

/* is_non_fatal_std --- return true if fp is stdout/stderr and nonfatal */

bool
is_non_fatal_std(FILE *fp)
{
	if (in_PROCINFO(nonfatal, NULL, NULL))
		return true;

	/* yucky logic. sigh. */
	if (fp == stdout) {
		return (   in_PROCINFO("-", nonfatal, NULL) != NULL
		        || in_PROCINFO("/dev/stdout", nonfatal, NULL) != NULL);
	} else if (fp == stderr) {
		return (in_PROCINFO("/dev/stderr", nonfatal, NULL) != NULL);
	}

	return false;
}

/* is_non_fatal_redirect --- return true if redirected I/O should be nonfatal */

bool
is_non_fatal_redirect(const char *str, size_t len)
{
	bool ret;
	char save;
	char *s = (char *) str;

	save = s[len];
	s[len] = '\0';

	ret = in_PROCINFO(nonfatal, NULL, NULL) != NULL
	       || in_PROCINFO(s, nonfatal, NULL) != NULL;

	s[len] = save;

	return ret;
}

/* close_one --- temporarily close an open file to re-use the fd */

static void
close_one()
{
	struct redirect *rp;
	struct redirect *rplast = NULL;

	static bool warned = false;

	if (do_lint && ! warned) {
		warned = true;
		lintwarn(_("reached system limit for open files: starting to multiplex file descriptors"));
	}

	/* go to end of list first, to pick up least recently used entry */
	for (rp = red_head; rp != NULL; rp = rp->next)
		rplast = rp;
	/* now work back up through the list */
	for (rp = rplast; rp != NULL; rp = rp->prev) {
		/* don't close standard files! */
		if (rp->output.fp == NULL || rp->output.fp == stderr || rp->output.fp == stdout)
			continue;

		if ((rp->flag & (RED_FILE|RED_WRITE)) == (RED_FILE|RED_WRITE)) {
			rp->flag |= RED_USED;
			errno = 0;
			if (rp->output.gawk_fclose(rp->output.fp, rp->output.opaque) != 0)
				warning(_("close of `%s' failed: %s"),
					rp->value, strerror(errno));
			rp->output.fp = NULL;
			break;
		}
	}
	if (rp == NULL)
		/* surely this is the only reason ??? */
		fatal(_("too many pipes or input files open"));
}

/* do_close --- completely close an open file or pipe */

NODE *
do_close(int nargs)
{
	NODE *tmp, *tmp2;
	struct redirect *rp;
	two_way_close_type how = CLOSE_ALL;	/* default */

	if (nargs == 2) {
		/* 2nd arg if present: "to" or "from" for two-way pipe */
		/* DO NOT use _() on the strings here! */
		char save;

		tmp2 = POP_STRING();
		save = tmp2->stptr[tmp2->stlen];
		tmp2->stptr[tmp2->stlen] = '\0';
		if (strcasecmp(tmp2->stptr, "to") == 0)
			how = CLOSE_TO;
		else if (strcasecmp(tmp2->stptr, "from") == 0)
			how = CLOSE_FROM;
		else {
			DEREF(tmp2);
			fatal(_("close: second argument must be `to' or `from'"));
		}
		tmp2->stptr[tmp2->stlen] = save;
		DEREF(tmp2);
	}

	tmp = POP_STRING(); 	/* 1st arg: redir to close */

	for (rp = red_head; rp != NULL; rp = rp->next) {
		if (strlen(rp->value) == tmp->stlen
		    && memcmp(rp->value, tmp->stptr, tmp->stlen) == 0)
			break;
	}

	if (rp == NULL) {	/* no match, return -1 */
		char *cp;

		if (do_lint)
			lintwarn(_("close: `%.*s' is not an open file, pipe or co-process"),
				(int) tmp->stlen, tmp->stptr);

		if (! do_traditional) {
			/* update ERRNO manually, using errno = ENOENT is a stretch. */
			cp = _("close of redirection that was never opened");
			update_ERRNO_string(cp);
		}

		DEREF(tmp);
		return make_number((AWKNUM) -1.0);
	}
	DEREF(tmp);
	fflush(stdout);	/* synchronize regular output */
	tmp = make_number((AWKNUM) close_redir(rp, false, how));
	rp = NULL;
	/*
	 * POSIX says close() returns 0 on success, non-zero otherwise.
	 * For POSIX, at this point we just return 0.  Otherwise we
	 * return the exit status of the process or of pclose(), depending.
	 * Down in the call tree of close_redir(), we rationalize the
	 * value like we do for system().
	 */
	if (do_posix) {
		unref(tmp);
		tmp = make_number((AWKNUM) 0);
	}
	return tmp;
}

/* close_rp --- separate function to just do closing */

int
close_rp(struct redirect *rp, two_way_close_type how)
{
	int status = 0;

	errno = 0;
	if ((rp->flag & RED_TWOWAY) != 0) {	/* two-way pipe */
		/* write end: */
		if ((how == CLOSE_ALL || how == CLOSE_TO) && rp->output.fp != NULL) {
#ifdef HAVE_SOCKETS
			if ((rp->flag & RED_TCP) != 0)
				(void) shutdown(fileno(rp->output.fp), SHUT_WR);
#endif /* HAVE_SOCKETS */

			if ((rp->flag & RED_PTY) != 0) {
				rp->output.gawk_fwrite("\004\n", sizeof("\004\n") - 1, 1, rp->output.fp, rp->output.opaque);
				rp->output.gawk_fflush(rp->output.fp, rp->output.opaque);
			}
			status = rp->output.gawk_fclose(rp->output.fp, rp->output.opaque);
			rp->output.fp = NULL;
		}

		/* read end: */
		if (how == CLOSE_ALL || how == CLOSE_FROM) {
			if ((rp->flag & RED_SOCKET) != 0 && rp->iop != NULL) {
#ifdef HAVE_SOCKETS
				if ((rp->flag & RED_TCP) != 0)
					(void) shutdown(rp->iop->public.fd, SHUT_RD);
#endif /* HAVE_SOCKETS */
				(void) iop_close(rp->iop);
			} else
				/* status already sanitized */
				status = gawk_pclose(rp);

			rp->iop = NULL;
		}
	} else if ((rp->flag & (RED_PIPE|RED_WRITE)) == (RED_PIPE|RED_WRITE)) {
		/* write to pipe */
		status = sanitize_exit_status(gawk_popen_write_close(rp->output.fp));
		if ((BINMODE & BINMODE_INPUT) != 0)
			os_setbinmode(fileno(stdin), O_BINARY);

		rp->output.fp = NULL;
	} else if (rp->output.fp != NULL) {	/* write to file */
		status = rp->output.gawk_fclose(rp->output.fp, rp->output.opaque);
		rp->output.fp = NULL;
	} else if (rp->iop != NULL) {	/* read from pipe/file */
		if ((rp->flag & RED_PIPE) != 0)		/* read from pipe */
			status = gawk_pclose(rp);
			/* gawk_pclose sets rp->iop to null */
		else {					/* read from file */
			status = iop_close(rp->iop);
			rp->iop = NULL;
		}
	}

	return status;
}

/* close_redir --- close an open file or pipe */

static int
close_redir(struct redirect *rp, bool exitwarn, two_way_close_type how)
{
	int status = 0;

	if (rp == NULL)
		return 0;
	if ((rp->flag & RED_WRITE) && rp->output.fp)
		/* flush before closing to leverage special error handling */
		efflush(rp->output.fp, "flush", rp);
	if (rp->output.fp == stdout || rp->output.fp == stderr)
		goto checkwarn;		/* bypass closing, remove from list */

	if (do_lint && (rp->flag & RED_TWOWAY) == 0 && how != CLOSE_ALL)
		lintwarn(_("close: redirection `%s' not opened with `|&', second argument ignored"),
				rp->value);

	status = close_rp(rp, how);

	if (status != 0) {
		int save_errno = errno;
		char *s = strerror(save_errno);

		/*
		 * BWK's awk, as far back as SVR4 (1989) would check
		 * and warn about the status of close.  However, when
		 * we did this we got too many complaints, so we moved
		 * it to be under lint control.
		 */
		if (do_lint) {
			if ((rp->flag & RED_PIPE) != 0)
				lintwarn(_("failure status (%d) on pipe close of `%s': %s"),
					 status, rp->value, s);
			else if ((rp->flag & RED_TWOWAY) != 0)
				lintwarn(_("failure status (%d) on two-way pipe close of `%s': %s"),
					 status, rp->value, s);
			else
				lintwarn(_("failure status (%d) on file close of `%s': %s"),
					 status, rp->value, s);
		}

		if (! do_traditional) {
			/* set ERRNO too so that program can get at it */
			update_ERRNO_int(save_errno);
		}
	}

checkwarn:
	if (exitwarn) {
		/*
		 * Don't use lintwarn() here.  If lint warnings are fatal,
		 * doing so prevents us from closing other open redirections.
		 *
		 * Using multiple full messages instead of string parameters
		 * for the types makes message translation easier.
		 */
		if ((rp->flag & RED_SOCKET) != 0)
			warning(_("no explicit close of socket `%s' provided"),
				rp->value);
		else if ((rp->flag & RED_TWOWAY) != 0)
			warning(_("no explicit close of co-process `%s' provided"),
				rp->value);
		else if ((rp->flag & RED_PIPE) != 0)
			warning(_("no explicit close of pipe `%s' provided"),
				rp->value);
		else
			warning(_("no explicit close of file `%s' provided"),
				rp->value);
	}

	/* remove it from the list if closing both or both ends have been closed */
	if (how == CLOSE_ALL || (rp->iop == NULL && rp->output.fp == NULL)) {
		if (rp->next != NULL)
			rp->next->prev = rp->prev;
		if (rp->prev != NULL)
			rp->prev->next = rp->next;
		else
			red_head = rp->next;
		free_rp(rp);
	}

	return status;
}

/* non_fatal_flush_std_file --- flush a standard output file allowing for nonfatal setting */

bool
non_fatal_flush_std_file(FILE *fp)
{
	int status = fflush(fp);

	if (status != 0) {
		bool is_fatal = ! is_non_fatal_std(fp);

		if (is_fatal) {
			os_maybe_set_errno();

			if (errno == EPIPE)
				die_via_sigpipe();
			else
				fatal(fp == stdout
					? _("fflush: cannot flush standard output: %s")
					: _("fflush: cannot flush standard error: %s"),
						strerror(errno));
		} else {
			update_ERRNO_int(errno);
			warning(fp == stdout
				? _("error writing standard output: %s")
				: _("error writing standard error: %s"),
					strerror(errno));
		}
		return false;
	}

	return true;
}

/* flush_io --- flush all open output files */

int
flush_io()
{
	struct redirect *rp;
	int status = 0;

	errno = 0;
	if (! non_fatal_flush_std_file(stdout))	// ERRNO updated
		status++;

	errno = 0;
	if (! non_fatal_flush_std_file(stderr))	// ERRNO updated
		status++;


	// now for all open redirections
	for (rp = red_head; rp != NULL; rp = rp->next) {
		void (*messagefunc)(const char *mesg, ...) = r_fatal;

		/* flush both files and pipes, what the heck */
		if ((rp->flag & RED_WRITE) != 0 && rp->output.fp != NULL) {
			if (rp->output.gawk_fflush(rp->output.fp, rp->output.opaque) != 0) {
				update_ERRNO_int(errno);

				if (is_non_fatal_redirect(rp->value, strlen(rp->value)))
					messagefunc = r_warning;

				if ((rp->flag & RED_PIPE) != 0)
					messagefunc(_("pipe flush of `%s' failed: %s"),
						rp->value, strerror(errno));
				else if ((rp->flag & RED_TWOWAY) != 0)
					messagefunc(_("co-process flush of pipe to `%s' failed: %s"),
						rp->value, strerror(errno));
				else
					messagefunc(_("file flush of `%s' failed: %s"),
						rp->value, strerror(errno));
				status++;
			}
		}
	}
	if (status != 0)
		status = -1;	/* canonicalize it */
	return status;
}

/* close_io --- close all open files, called when exiting */

int
close_io(bool *stdio_problem, bool *got_EPIPE)
{
	struct redirect *rp;
	struct redirect *next;
	int status = 0;

	*stdio_problem = *got_EPIPE = false;
	errno = 0;
	for (rp = red_head; rp != NULL; rp = next) {
		next = rp->next;
		/*
		 * close_redir() will print a message if needed.
		 * if do_lint, warn about lack of explicit close
		 */
		if (close_redir(rp, do_lint, CLOSE_ALL))
			status++;
		rp = NULL;
	}
	/*
	 * Some of the non-Unix os's have problems doing an fclose()
	 * on stdout and stderr.  Since we don't really need to close
	 * them, we just flush them, and do that across the board.
	 */
	*stdio_problem = false;
	/* we don't warn about stdout/stderr if EPIPE, but we do error exit */
	if (fflush(stdout) != 0) {
		os_maybe_set_errno();

		if (errno != EPIPE)
			warning(_("error writing standard output: %s"), strerror(errno));
		else
			*got_EPIPE = true;

		status++;
		*stdio_problem = true;
	}
	if (fflush(stderr) != 0) {
		os_maybe_set_errno();

		if (errno != EPIPE)
			warning(_("error writing standard error: %s"), strerror(errno));
		else
			*got_EPIPE = true;

		status++;
		*stdio_problem = true;
	}
	return status;
}

/* str2mode --- convert a string mode to an integer mode */

static int
str2mode(const char *mode)
{
	int ret;
	const char *second = & mode[1];

	if (*second == 'b')
		second++;

	switch(mode[0]) {
	case 'r':
		ret = O_RDONLY;
		if (*second == '+' || *second == 'w')
			ret = O_RDWR;
		break;

	case 'w':
		ret = O_WRONLY|O_CREAT|O_TRUNC;
		if (*second == '+' || *second == 'r')
			ret = O_RDWR|O_CREAT|O_TRUNC;
		break;

	case 'a':
		ret = O_WRONLY|O_APPEND|O_CREAT;
		if (*second == '+')
			ret = O_RDWR|O_APPEND|O_CREAT;
		break;

	default:
		ret = 0;		/* lint */
		cant_happen("invalid open mode \"%s\"", mode);
	}
	if (strchr(mode, 'b') != NULL)
		ret |= O_BINARY;
	return ret;
}

#ifdef HAVE_SOCKETS

/* socketopen --- open a socket and set it into connected state */

static int
socketopen(int family, int type, const char *localpname,
	const char *remotepname, const char *remotehostname, bool *hard_error)
{
	struct addrinfo *lres, *lres0;
	struct addrinfo lhints;
	struct addrinfo *rres, *rres0;
	struct addrinfo rhints;

	int lerror, rerror;

	int socket_fd = INVALID_HANDLE;
	int any_remote_host = (strcmp(remotehostname, "0") == 0);

	memset(& lhints, '\0', sizeof (lhints));

	lhints.ai_socktype = type;
	lhints.ai_family = family;

	/*
         * If only the loopback interface is up and hints.ai_flags has
	 * AI_ADDRCONFIG, getaddrinfo() will succeed and return all wildcard
	 * addresses, but only if hints.ai_family == AF_UNSPEC
	 *
	 * Do return the wildcard address in case the loopback interface
	 * is the only one that is up (and
	 * hints.ai_family == either AF_INET4 or AF_INET6)
         */
	lhints.ai_flags = AI_PASSIVE;
	if (lhints.ai_family == AF_UNSPEC)
		lhints.ai_flags |= AI_ADDRCONFIG;

	lerror = getaddrinfo(NULL, localpname, & lhints, & lres);
	if (lerror) {
		if (strcmp(localpname, "0") != 0) {
#ifdef HAVE_GAI_STRERROR
			warning(_("local port %s invalid in `/inet': %s"), localpname,
					gai_strerror(lerror));
#else
			warning(_("local port %s invalid in `/inet'"), localpname);
#endif
			*hard_error = true;
			return INVALID_HANDLE;
		}
		lres0 = NULL;
		lres = & lhints;
	} else
		lres0 = lres;

	while (lres != NULL) {
		memset (& rhints, '\0', sizeof (rhints));
		rhints.ai_flags = lhints.ai_flags;
		rhints.ai_socktype = lhints.ai_socktype;
		rhints.ai_family = lhints.ai_family;
		rhints.ai_protocol = lhints.ai_protocol;

		rerror = getaddrinfo(any_remote_host ? NULL : remotehostname,
				remotepname, & rhints, & rres);
		if (rerror) {
			if (lres0 != NULL)
				freeaddrinfo(lres0);
#ifdef HAVE_GAI_STRERROR
			warning(_("remote host and port information (%s, %s) invalid: %s"), remotehostname, remotepname,
					gai_strerror(rerror));
#else
			warning(_("remote host and port information (%s, %s) invalid"), remotehostname, remotepname);
#endif
			*hard_error = true;
			return INVALID_HANDLE;
		}
		rres0 = rres;
		socket_fd = INVALID_HANDLE;
		while (rres != NULL) {
			socket_fd = socket(rres->ai_family,
				rres->ai_socktype, rres->ai_protocol);
			if (socket_fd < 0 || socket_fd == INVALID_HANDLE)
				goto nextrres;

			if (type == SOCK_STREAM) {
				int on = 1;
#ifdef SO_LINGER
				struct linger linger;
				memset(& linger, '\0', sizeof(linger));
#endif
				setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR,
					(char *) & on, sizeof(on));
#ifdef SO_LINGER
				linger.l_onoff = 1;
				/* linger for 30/100 second */
				linger.l_linger = 30;
				setsockopt(socket_fd, SOL_SOCKET, SO_LINGER,
					(char *) & linger, sizeof(linger));
#endif
			}
			if (bind(socket_fd, lres->ai_addr, lres->ai_addrlen) != 0)
				goto nextrres;

			if (! any_remote_host) { /* not ANY => create a client */
				if (connect(socket_fd, rres->ai_addr, rres->ai_addrlen) == 0)
					break;
			} else { /* remote host is ANY => create a server */
				if (type == SOCK_STREAM) {
					int clientsocket_fd = INVALID_HANDLE;

					struct sockaddr_storage remote_addr;
					socklen_t namelen = sizeof(remote_addr);

					if (listen(socket_fd, 1) >= 0
					    && (clientsocket_fd = accept(socket_fd,
						(struct sockaddr *) & remote_addr,
						& namelen)) >= 0) {
						closemaybesocket(socket_fd);
						socket_fd = clientsocket_fd;
						break;
					}
				} else if (type == SOCK_DGRAM) {
#ifdef MSG_PEEK
					char buf[10];
					struct sockaddr_storage remote_addr;
					socklen_t read_len = sizeof(remote_addr);

					if (recvfrom(socket_fd, buf, 1, MSG_PEEK,
						(struct sockaddr *) & remote_addr,
							& read_len) >= 0
							&& read_len
							&& connect(socket_fd,
						(struct sockaddr *) & remote_addr,
								read_len) == 0)
							break;
#endif
				}
			}

nextrres:
			if (socket_fd != INVALID_HANDLE)
				closemaybesocket(socket_fd);
			socket_fd = INVALID_HANDLE;
			rres = rres->ai_next;
		}
		freeaddrinfo(rres0);
		if (socket_fd != INVALID_HANDLE)
			break;
		lres = lres->ai_next;
	}
	if (lres0)
		freeaddrinfo(lres0);

	return socket_fd;
}
#endif /* HAVE_SOCKETS */


/* devopen_simple --- handle "-", /dev/std{in,out,err}, /dev/fd/N */

/*
 * 9/2014: Flow here is a little messy.
 *
 * For do_posix, we don't allow any of the special filenames.
 *
 * For do_traditional, we allow /dev/{stdin,stdout,stderr} since BWK awk
 * (and mawk) support them.  But we don't allow /dev/fd/N or /inet.
 *
 * Note that for POSIX systems os_devopen() is a no-op.
 */

int
devopen_simple(const char *name, const char *mode, bool try_real_open)
{
	int openfd;
	char *cp;
	char *ptr;
	int flag = 0;

	if (strcmp(name, "-") == 0) {
		if (mode[0] == 'r')
			return fileno(stdin);
		else
			return fileno(stdout);
	}

	flag = str2mode(mode);
	openfd = INVALID_HANDLE;

	if (do_posix)
		goto done;

	if ((openfd = os_devopen(name, flag)) != INVALID_HANDLE) {
		os_close_on_exec(openfd, name, "file", "");
		return openfd;
	}

	if (strncmp(name, "/dev/", 5) == 0) {
		cp = (char *) name + 5;

		if (strcmp(cp, "stdin") == 0 && (flag & O_ACCMODE) == O_RDONLY)
			openfd = fileno(stdin);
		else if (strcmp(cp, "stdout") == 0 && (flag & O_ACCMODE) == O_WRONLY)
			openfd = fileno(stdout);
		else if (strcmp(cp, "stderr") == 0 && (flag & O_ACCMODE) == O_WRONLY)
			openfd = fileno(stderr);
		else if (do_traditional)
			goto done;
		else if (strncmp(cp, "fd/", 3) == 0) {
			struct stat sbuf;

			cp += 3;
			openfd = (int) strtoul(cp, & ptr, 10);
			if (openfd <= INVALID_HANDLE || ptr == cp
			    || fstat(openfd, & sbuf) < 0)
				openfd = INVALID_HANDLE;
		}
		/* do not set close-on-exec for inherited fd's */
	}
done:
	if (try_real_open)
		openfd = open(name, flag, 0666);

	return openfd;
}

/* devopen --- handle /dev/std{in,out,err}, /dev/fd/N, /inet, regular files */

/*
 * Strictly speaking, "name" is not a "const char *" because we temporarily
 * change the string.
 */

int
devopen(const char *name, const char *mode)
{
	int openfd;
	int flag;
	struct inet_socket_info isi;
	int save_errno = 0;

	openfd = devopen_simple(name, mode, false);
	if (openfd != INVALID_HANDLE)
		return openfd;

	flag = str2mode(mode);

	if (do_traditional) {
		goto strictopen;
	} else if (inetfile(name, strlen(name), & isi)) {
#ifdef HAVE_SOCKETS
#define DEFAULT_RETRIES 20
		static unsigned long def_retries = DEFAULT_RETRIES;
		static bool first_time = true;
		unsigned long retries = 0;
		static long msleep = 1000;
		bool hard_error = false;
		bool non_fatal = is_non_fatal_redirect(name, strlen(name));
		char save;
		char *cp = (char *) name;

		/* socketopen requires NUL-terminated strings */
		cp[isi.localport.offset+isi.localport.len] = '\0';
		cp[isi.remotehost.offset+isi.remotehost.len] = '\0';
		save = cp[isi.remoteport.offset+isi.remoteport.len];
		cp[isi.remoteport.offset+isi.remoteport.len] = '\0';

		if (first_time) {
			char *cp, *end;
			unsigned long count = 0;
			char *ms2;

			first_time = false;
			if ((cp = getenv("GAWK_SOCK_RETRIES")) != NULL) {
				count = strtoul(cp, & end, 10);
				if (end != cp && count > 0)
					def_retries = count;
			}

			/*
			 * Env var is in milliseconds, paramter to usleep()
			 * is microseconds, make the conversion. Default is
			 * 1 millisecond.
			 */
			if ((ms2 = getenv("GAWK_MSEC_SLEEP")) != NULL) {
				msleep = strtol(ms2, & end, 10);
				if (end == ms2 || msleep < 0)
					msleep = 1000;
				else
					msleep *= 1000;
			}
		}
		/*
		 * PROCINFO["NONFATAL"] or PROCINFO[name, "NONFATAL"] overrrides
		 * GAWK_SOCK_RETRIES.  The explicit code in the program carries
		 * a bigger stick than the environment variable does.
		 */
		retries = non_fatal ? 1 : def_retries;

		errno = 0;
		do {
			openfd = socketopen(isi.family, isi.protocol, name+isi.localport.offset,
					name+isi.remoteport.offset, name+isi.remotehost.offset,
					& hard_error);
			retries--;
		} while (openfd == INVALID_HANDLE && ! hard_error && retries > 0 && usleep(msleep) == 0);
		save_errno = errno;

		/* restore original name string */
		cp[isi.localport.offset+isi.localport.len] = '/';
		cp[isi.remotehost.offset+isi.remotehost.len] = '/';
		cp[isi.remoteport.offset+isi.remoteport.len] = save;
#else /* ! HAVE_SOCKETS */
		fatal(_("TCP/IP communications are not supported"));
#endif /* HAVE_SOCKETS */
	}

strictopen:
	if (openfd == INVALID_HANDLE) {
		openfd = open(name, flag, 0666);
		/*
		 * ENOENT means there is no such name in the filesystem.
		 * Therefore it's ok to propagate up the error from
		 * getaddrinfo() that's in save_errno.
		 */
		if (openfd == INVALID_HANDLE && errno == ENOENT && save_errno)
			errno = save_errno;
	}
#if defined(__MINGW32__)
	if (openfd == INVALID_HANDLE && errno == EACCES) {
		/* On OS/2 and Windows directory access via open() is
		   not permitted.  */
		struct stat buf;

		if (! inetfile(name, strlen(name), NULL)
		    && stat(name, & buf) == 0 && S_ISDIR(buf.st_mode))
			errno = EISDIR;
	}
#endif
	if (openfd != INVALID_HANDLE) {
		if (openfd > fileno(stderr))
			os_close_on_exec(openfd, name, "file", "");
	}

	return openfd;
}

#if defined(HAVE_TERMIOS_H)
/* push_pty_line_disciplines --- push line disciplines if we work that way */

// Factors out common code for the two versions of fork_and_open_slave_pty().

static void
push_pty_line_disciplines(int slave)
{
#ifdef I_PUSH
	/*
	 * Push the necessary modules onto the slave to
	 * get terminal semantics.  Check that they aren't
	 * already there to avoid hangs on said "limited" systems.
	 */
#ifdef I_FIND
	if (ioctl(slave, I_FIND, "ptem") == 0)
#endif
		ioctl(slave, I_PUSH, "ptem");
#ifdef I_FIND
	if (ioctl(slave, I_FIND, "ldterm") == 0)
#endif
		ioctl(slave, I_PUSH, "ldterm");
#endif
}

/* set_slave_pty_attributes --- set terminal attributes for slave pty */

// Factors out common code for the two versions of fork_and_open_slave_pty().

static void
set_slave_pty_attributes(int slave)
{
	struct termios st;

	tcgetattr(slave, & st);
	st.c_iflag &= ~(ISTRIP | IGNCR | INLCR | IXOFF);
	st.c_iflag |= (ICRNL | IGNPAR | BRKINT | IXON);
	st.c_oflag &= ~OPOST;
	st.c_cflag &= ~CSIZE;
	st.c_cflag |= CREAD | CS8 | CLOCAL;
	st.c_lflag &= ~(ECHO | ECHOE | ECHOK | NOFLSH | TOSTOP);
	st.c_lflag |= ISIG;

	/* Set some control codes to default values */
#ifdef VINTR
	st.c_cc[VINTR] = '\003';        /* ^c */
#endif
#ifdef VQUIT
	st.c_cc[VQUIT] = '\034';        /* ^| */
#endif
#ifdef VERASE
	st.c_cc[VERASE] = '\177';       /* ^? */
#endif
#ifdef VKILL
	st.c_cc[VKILL] = '\025';        /* ^u */
#endif
#ifdef VEOF
	st.c_cc[VEOF] = '\004'; /* ^d */
#endif
	tcsetattr(slave, TCSANOW, & st);
}


/* fork_and_open_slave_pty --- handle forking the child and slave pty setup */

/*
 * January, 2018:
 * This is messy. AIX and HP-UX require that the slave pty be opened and
 * set up in the child.  Everything else wants it to be done in the parent,
 * before the fork.  Thus we have two different versions of the routine that
 * do the same thing, but in different orders.  This is not pretty, but it
 * seems to be the simplest thing to do.
 */

static bool
fork_and_open_slave_pty(const char *slavenam, int master, const char *command, pid_t *pid)
{
	int slave;
	int save_errno;

#if defined _AIX || defined __hpux
	/*
	 * We specifically open the slave only in the child. This allows
	 * AIX and HP0UX to work.  The open is specifically without O_NOCTTY
	 * in order to make the slave become the controlling terminal.
	 */

	switch (*pid = fork()) {
	case 0:
		/* Child process */
		setsid();

		if ((slave = open(slavenam, O_RDWR)) < 0) {
			close(master);
			fatal(_("could not open `%s', mode `%s'"),
				slavenam, "r+");
		}

		push_pty_line_disciplines(slave);
		set_slave_pty_attributes(slave);

		if (close(master) == -1)
			fatal(_("close of master pty failed: %s"), strerror(errno));
		if (close(1) == -1)
			fatal(_("close of stdout in child failed: %s"),
				strerror(errno));
		if (dup(slave) != 1)
			fatal(_("moving slave pty to stdout in child failed (dup: %s)"), strerror(errno));
		if (close(0) == -1)
			fatal(_("close of stdin in child failed: %s"),
				strerror(errno));
		if (dup(slave) != 0)
			fatal(_("moving slave pty to stdin in child failed (dup: %s)"), strerror(errno));
		if (close(slave))
			fatal(_("close of slave pty failed: %s"), strerror(errno));

		/* stderr does NOT get dup'ed onto child's stdout */

		set_sigpipe_to_default();

		execl("/bin/sh", "sh", "-c", command, NULL);
		_exit(errno == ENOENT ? 127 : 126);

	case -1:
		save_errno = errno;
		close(master);
		errno = save_errno;
		return false;

	default:
		return true;
	}

#else

	if ((slave = open(slavenam, O_RDWR)) < 0) {
		close(master);
		fatal(_("could not open `%s', mode `%s'"),
			slavenam, "r+");
	}

	push_pty_line_disciplines(slave);
	set_slave_pty_attributes(slave);

	switch (*pid = fork()) {
	case 0:
		/* Child process */
		setsid();

#ifdef TIOCSCTTY
		ioctl(slave, TIOCSCTTY, 0);
#endif

		if (close(master) == -1)
			fatal(_("close of master pty failed: %s"), strerror(errno));
		if (close(1) == -1)
			fatal(_("close of stdout in child failed: %s"),
				strerror(errno));
		if (dup(slave) != 1)
			fatal(_("moving slave pty to stdout in child failed (dup: %s)"), strerror(errno));
		if (close(0) == -1)
			fatal(_("close of stdin in child failed: %s"),
				strerror(errno));
		if (dup(slave) != 0)
			fatal(_("moving slave pty to stdin in child failed (dup: %s)"), strerror(errno));
		if (close(slave))
			fatal(_("close of slave pty failed: %s"), strerror(errno));

		/* stderr does NOT get dup'ed onto child's stdout */

		signal(SIGPIPE, SIG_DFL);

		execl("/bin/sh", "sh", "-c", command, NULL);
		_exit(errno == ENOENT ? 127 : 126);

	case -1:
		save_errno = errno;
		close(master);
		close(slave);
		errno = save_errno;
		return false;

	}

	/* parent */
	if (close(slave) != 0) {
		close(master);
		(void) kill(*pid, SIGKILL);
		fatal(_("close of slave pty failed: %s"), strerror(errno));
	}

	return true;
#endif
}

#endif /* defined(HAVE_TERMIOS_H) */

/* two_way_open --- open a two way communications channel */

static int
two_way_open(const char *str, struct redirect *rp, int extfd)
{
	static bool no_ptys = false;

#ifdef HAVE_SOCKETS
	/* case 1: socket */
	if (extfd >= 0 || inetfile(str, strlen(str), NULL)) {
		int fd, newfd;

		fd = (extfd >= 0) ? extfd : devopen(str, "rw");
		if (fd == INVALID_HANDLE)
			return false;
		if ((BINMODE & BINMODE_OUTPUT) != 0)
			os_setbinmode(fd, O_BINARY);
		rp->output.fp = fdopen(fd, binmode("wb"));
		if (rp->output.fp == NULL) {
			close(fd);
			return false;
		}
		newfd = dup(fd);
		if (newfd < 0) {
			rp->output.gawk_fclose(rp->output.fp, rp->output.opaque);
			return false;
		}
		if ((BINMODE & BINMODE_INPUT) != 0)
			os_setbinmode(newfd, O_BINARY);
		os_close_on_exec(fd, str, "socket", "to/from");
		os_close_on_exec(newfd, str, "socket", "to/from");
		rp->iop = iop_alloc(newfd, str, 0);
		rp->output.name = str;
		find_input_parser(rp->iop);
		iop_finish(rp->iop);
		if (! rp->iop->valid) {
			if (! do_traditional && rp->iop->errcode != 0)
				update_ERRNO_int(rp->iop->errcode);
			iop_close(rp->iop);
			rp->iop = NULL;
			rp->output.gawk_fclose(rp->output.fp, rp->output.opaque);
			return false;
		}
		rp->flag |= RED_SOCKET;
		return true;
	}
#endif /* HAVE_SOCKETS */

	/* case 2: see if an extension wants it */
	if (find_two_way_processor(str, rp))
		return true;

#if defined(HAVE_TERMIOS_H)
	/* case 3: use ptys for two-way communications to child */
	if (! no_ptys && pty_vs_pipe(str)) {
		static bool initialized = false;
		static char first_pty_letter;
#if defined(HAVE_GRANTPT) && ! defined(HAVE_POSIX_OPENPT)
		static int have_dev_ptmx;
#endif
		char slavenam[32];
		char c;
		int master, dup_master;
		pid_t pid;
		struct stat statb;
		/* Use array of chars to avoid ASCII / EBCDIC issues */
		static char pty_chars[] = "pqrstuvwxyzabcdefghijklmno";
		int i;

		if (! initialized) {
			initialized = true;
#if defined(HAVE_GRANTPT) && ! defined(HAVE_POSIX_OPENPT)
			have_dev_ptmx = (stat("/dev/ptmx", & statb) >= 0);
#endif
			i = 0;
			do {
				c = pty_chars[i++];
				sprintf(slavenam, "/dev/pty%c0", c);
				if (stat(slavenam, & statb) >= 0) {
					first_pty_letter = c;
					break;
				}
			} while (pty_chars[i] != '\0');
		}

#ifdef HAVE_GRANTPT
#ifdef HAVE_POSIX_OPENPT
		{
			master = posix_openpt(O_RDWR|O_NOCTTY);
#else
		if (have_dev_ptmx) {
			master = open("/dev/ptmx", O_RDWR);
#endif
			if (master >= 0) {
				char *tem;

				grantpt(master);
				unlockpt(master);
				tem = ptsname(master);
				if (tem != NULL) {
					strcpy(slavenam, tem);
					goto got_the_pty;
				}
				(void) close(master);
			}
		}
#endif

		if (first_pty_letter) {
			/*
			 * Assume /dev/ptyXNN and /dev/ttyXN naming system.
			 * The FIRST_PTY_LETTER gives the first X to try.
			 * We try in the sequence FIRST_PTY_LETTER, ..,
			 * 'z', 'a', .., FIRST_PTY_LETTER.
			 * Is this worthwhile, or just over-zealous?
			 */
			c = first_pty_letter;
			do {
				int i;
				char *cp;

				for (i = 0; i < 16; i++) {
					sprintf(slavenam, "/dev/pty%c%x", c, i);
					if (stat(slavenam, & statb) < 0) {
						no_ptys = true;	/* bypass all this next time */
						goto use_pipes;
					}

					if ((master = open(slavenam, O_RDWR)) >= 0) {
						slavenam[sizeof("/dev/") - 1] = 't';
						if (access(slavenam, R_OK | W_OK) == 0)
							goto got_the_pty;
						close(master);
					}
				}
				/* move to next character */
				cp = strchr(pty_chars, c);
				if (cp[1] != '\0')
					cp++;
				else
					cp = pty_chars;
				c = *cp;
			} while (c != first_pty_letter);
		} else
			no_ptys = true;

		/* Couldn't find a pty. Fall back to using pipes. */
		goto use_pipes;

	got_the_pty:

		/* this is the parent */
		if (! fork_and_open_slave_pty(slavenam, master, str, & pid))
			fatal(_("could not create child process or open pty"));

		rp->pid = pid;
		rp->iop = iop_alloc(master, str, 0);
		find_input_parser(rp->iop);
		iop_finish(rp->iop);
		if (! rp->iop->valid) {
			if (! do_traditional && rp->iop->errcode != 0)
				update_ERRNO_int(rp->iop->errcode);
			iop_close(rp->iop);
			rp->iop = NULL;
			(void) kill(pid, SIGKILL);
			return false;
		}

		rp->output.name = str;
		/*
		 * Force read and write ends of two-way connection to
		 * be different fd's so they can be closed independently.
		 */
		rp->output.mode = "w";
		if ((dup_master = dup(master)) < 0
		    || (rp->output.fp = fdopen(dup_master, "w")) == NULL) {
			iop_close(rp->iop);
			rp->iop = NULL;
			(void) close(master);
			(void) kill(pid, SIGKILL);
			if (dup_master > 0)
				(void) close(dup_master);
			return false;
		} else
			find_output_wrapper(& rp->output);
		rp->flag |= RED_PTY;
		os_close_on_exec(master, str, "pipe", "from");
		os_close_on_exec(dup_master, str, "pipe", "to");
		first_pty_letter = '\0';	/* reset for next command */
		return true;
	}
#endif /* defined(HAVE_TERMIOS_H) */

use_pipes:
#ifndef PIPES_SIMULATED		/* real pipes */
	/* case 4: two way pipe to a child process */
    {
	int ptoc[2], ctop[2];
	int pid;
	int save_errno;
#if defined(__MINGW32__)
	int save_stdout, save_stdin;
	char *qcmd = NULL;
#endif

	if (pipe(ptoc) < 0)
		return false;	/* errno set, diagnostic from caller */

	if (pipe(ctop) < 0) {
		save_errno = errno;
		close(ptoc[0]);
		close(ptoc[1]);
		errno = save_errno;
		return false;
	}

#if defined(__MINGW32__)
	save_stdin = dup(0);	/* duplicate stdin */
	save_stdout = dup(1);	/* duplicate stdout */

	if (save_stdout == -1 || save_stdin == -1) {
		/* if an error occurs close all open file handles */
		save_errno = errno;
		if (save_stdin != -1)
			close(save_stdin);
		if (save_stdout != -1)
			close(save_stdout);
		close(ptoc[0]); close(ptoc[1]);
		close(ctop[0]); close(ctop[1]);
		errno = save_errno;
		return false;
	}

	/* connect pipes to stdin and stdout */
	close(1);	/* close stdout */
	if (dup(ctop[1]) != 1) {	/* connect pipe input to stdout */
		close(save_stdin); close(save_stdout);
		close(ptoc[0]); close(ptoc[1]);
		close(ctop[0]); close(ctop[1]);
		fatal(_("moving pipe to stdout in child failed (dup: %s)"), strerror(errno));
	}
	close(0);	/* close stdin */
	if (dup(ptoc[0]) != 0) {	/* connect pipe output to stdin */
		close(save_stdin); close(save_stdout);
		close(ptoc[0]); close(ptoc[1]);
		close(ctop[0]); close(ctop[1]);
		fatal(_("moving pipe to stdin in child failed (dup: %s)"), strerror(errno));
	}

	/* none of these handles must be inherited by the child process */
	(void) close(ptoc[0]);	/* close pipe output, child will use stdin instead */
	(void) close(ctop[1]);	/* close pipe input, child will use stdout instead */

	os_close_on_exec(ptoc[1], str, "pipe", "from"); /* pipe input: output of the parent process */
	os_close_on_exec(ctop[0], str, "pipe", "from"); /* pipe output: input of the parent process */
	os_close_on_exec(save_stdin, str, "pipe", "from"); /* saved stdin of the parent process */
	os_close_on_exec(save_stdout, str, "pipe", "from"); /* saved stdout of the parent process */

	/* stderr does NOT get dup'ed onto child's stdout */
	pid = spawnl(P_NOWAIT, getenv("ComSpec"), "cmd.exe", "/c",
		     qcmd = quote_cmd(str), NULL);
	efree(qcmd);

	/* restore stdin and stdout */
	close(1);
	if (dup(save_stdout) != 1) {
		close(save_stdin); close(save_stdout);
		close(ptoc[1]); close(ctop[0]);
		fatal(_("restoring stdout in parent process failed"));
	}
	close(save_stdout);

	close(0);
	if (dup(save_stdin) != 0) {
		close(save_stdin);
		close(ptoc[1]);	close(ctop[0]);
		fatal(_("restoring stdin in parent process failed"));
	}
	close(save_stdin);

	if (pid < 0) { /* spawnl() failed */
		save_errno = errno;
		close(ptoc[1]);
		close(ctop[0]);

		errno = save_errno;
		return false;
	}

#else /* NOT __MINGW32__ */
	if ((pid = fork()) < 0) {
		save_errno = errno;
		close(ptoc[0]); close(ptoc[1]);
		close(ctop[0]); close(ctop[1]);
		errno = save_errno;
		return false;
	}

	if (pid == 0) {	/* child */
		if (close(1) == -1)
			fatal(_("close of stdout in child failed: %s"),
				strerror(errno));
		if (dup(ctop[1]) != 1)
			fatal(_("moving pipe to stdout in child failed (dup: %s)"), strerror(errno));
		if (close(0) == -1)
			fatal(_("close of stdin in child failed: %s"),
				strerror(errno));
		if (dup(ptoc[0]) != 0)
			fatal(_("moving pipe to stdin in child failed (dup: %s)"), strerror(errno));
		if (   close(ptoc[0]) == -1 || close(ptoc[1]) == -1
		    || close(ctop[0]) == -1 || close(ctop[1]) == -1)
			fatal(_("close of pipe failed: %s"), strerror(errno));
		/* stderr does NOT get dup'ed onto child's stdout */
		set_sigpipe_to_default();
		execl("/bin/sh", "sh", "-c", str, NULL);
		_exit(errno == ENOENT ? 127 : 126);
	}
#endif /* NOT __MINGW32__ */

	/* parent */
	if ((BINMODE & BINMODE_INPUT) != 0)
		os_setbinmode(ctop[0], O_BINARY);
	if ((BINMODE & BINMODE_OUTPUT) != 0)
		os_setbinmode(ptoc[1], O_BINARY);
	rp->pid = pid;
	rp->iop = iop_alloc(ctop[0], str, 0);
	find_input_parser(rp->iop);
	iop_finish(rp->iop);
	if (! rp->iop->valid) {
		if (! do_traditional && rp->iop->errcode != 0)
			update_ERRNO_int(rp->iop->errcode);
		iop_close(rp->iop);
		rp->iop = NULL;
		(void) close(ctop[1]);
		(void) close(ptoc[0]);
		(void) close(ptoc[1]);
		(void) kill(pid, SIGKILL);

		return false;
	}
	rp->output.fp = fdopen(ptoc[1], binmode("w"));
	rp->output.mode = "w";
	rp->output.name = str;
	if (rp->output.fp == NULL) {
		iop_close(rp->iop);
		rp->iop = NULL;
		(void) close(ctop[0]);
		(void) close(ctop[1]);
		(void) close(ptoc[0]);
		(void) close(ptoc[1]);
		(void) kill(pid, SIGKILL);

		return false;
	}
	else
		find_output_wrapper(& rp->output);

#if !defined(__MINGW32__)
	os_close_on_exec(ctop[0], str, "pipe", "from");
	os_close_on_exec(ptoc[1], str, "pipe", "from");

	(void) close(ptoc[0]);
	(void) close(ctop[1]);
#endif

	return true;
    }

#else	/*PIPES_SIMULATED*/

	fatal(_("`|&' not supported"));
	/*NOTREACHED*/
	return false;

#endif
}

#ifndef PIPES_SIMULATED		/* real pipes */

/*
 * wait_any --- if the argument pid is 0, wait for all child processes that
 * have exited.  We loop to make sure to reap all children that have exited to
 * minimize the risk of running out of process slots.  Since we don't process
 * SIGCHLD, we do not immediately reap exited children.  So when we get here,
 * we want to reap any that have piled up.
 *
 * Note: on platforms that do not support waitpid with WNOHANG, when called with
 * a zero argument, this function will hang until all children have exited.
 *
 * AJS, 2013-07-07: I do not see why we need to ignore signals during this
 * function.  This function just waits and updates the pid and status fields.
 * I don't see why that should interfere with any signal handlers.  But I am
 * reluctant to remove this protection.  So I changed to use sigprocmask to
 * block signals instead to avoid interfering with installed signal handlers.
 */

int
wait_any(int interesting)	/* pid of interest, if any */
{
	int pid;
	int status = 0;
	struct redirect *redp;
#ifdef HAVE_SIGPROCMASK
	sigset_t set, oldset;

	/* I have no idea why we are blocking signals during this function... */
	sigemptyset(& set);
	sigaddset(& set, SIGINT);
	sigaddset(& set, SIGHUP);
	sigaddset(& set, SIGQUIT);
	sigprocmask(SIG_BLOCK, & set, & oldset);
#else
	void (*hstat)(int), (*istat)(int), (*qstat)(int);

	istat = signal(SIGINT, SIG_IGN);
#endif
#ifdef __MINGW32__
	if (interesting < 0) {
		status = -1;
		pid = -1;
	}
	else
		pid = _cwait(& status, interesting, 0);
	if (pid == interesting && pid > 0) {
		for (redp = red_head; redp != NULL; redp = redp->next)
			if (interesting == redp->pid) {
				redp->pid = -1;
				redp->status = sanitize_exit_status(status);
				break;
			}
	}
#else /* ! __MINGW32__ */
#ifndef HAVE_SIGPROCMASK
	hstat = signal(SIGHUP, SIG_IGN);
	qstat = signal(SIGQUIT, SIG_IGN);
#endif
	for (;;) {
# if defined(HAVE_WAITPID) && defined(WNOHANG)
		/*
		 * N.B. If the caller wants status for a specific child process
		 * (i.e. interesting is non-zero), then we must hang until we
		 * get exit status for that child.
		 */
		if ((pid = waitpid(-1, & status, (interesting ? 0 : WNOHANG))) == 0)
			/* No children have exited */
			break;
# elif defined(HAVE_SYS_WAIT_H)	/* POSIX compatible sys/wait.h */
		pid = wait(& status);
# else
		pid = wait((union wait *) & status);
# endif
		if (interesting && pid == interesting) {
			break;
		} else if (pid != -1) {
			for (redp = red_head; redp != NULL; redp = redp->next)
				if (pid == redp->pid) {
					redp->pid = -1;
					redp->status = sanitize_exit_status(status);
					break;
				}
		}
		if (pid == -1 && errno == ECHILD)
			break;
	}
#ifndef HAVE_SIGPROCMASK
	signal(SIGHUP, hstat);
	signal(SIGQUIT, qstat);
#endif
#endif /* ! __MINGW32__ */
#ifndef HAVE_SIGPROCMASK
	signal(SIGINT, istat);
#else
	sigprocmask(SIG_SETMASK, & oldset, NULL);
#endif
	return status;
}

/* gawk_popen --- open an IOBUF on a child process */

static IOBUF *
gawk_popen(const char *cmd, struct redirect *rp)
{
	int p[2];
	int pid;
#if defined(__MINGW32__)
	int save_stdout;
	char *qcmd = NULL;
#endif

	/*
	 * We used to wait for any children to synchronize input and output,
	 * but this could cause gawk to hang when it is started in a pipeline
	 * and thus has a child process feeding it input (shell dependent).
	 *
	 * (void) wait_any(0);	// wait for outstanding processes
	 */

	if (pipe(p) < 0)
		fatal(_("cannot open pipe `%s': %s"), cmd, strerror(errno));

#if defined(__MINGW32__)
	rp->iop = NULL;
	save_stdout = dup(1); /* save stdout */
	if (save_stdout == -1) {
		close(p[0]);
		close(p[1]);
		return NULL;	/* failed */
	}

	close(1); /* close stdout */
	if (dup(p[1]) != 1) {
		close(p[0]);
		close(p[1]);
		fatal(_("moving pipe to stdout in child failed (dup: %s)"),
				strerror(errno));
	}

	/* none of these handles must be inherited by the child process */
	close(p[1]); /* close pipe input */

	os_close_on_exec(p[0], cmd, "pipe", "from"); /* pipe output: input of the parent process */
	os_close_on_exec(save_stdout, cmd, "pipe", "from"); /* saved stdout of the parent process */

	pid = spawnl(P_NOWAIT, getenv("ComSpec"), "cmd.exe", "/c",
		     qcmd = quote_cmd(cmd), NULL);
	efree(qcmd);

	/* restore stdout */
	close(1);
	if (dup(save_stdout) != 1) {
		close(p[0]);
		fatal(_("restoring stdout in parent process failed"));
	}
	close(save_stdout);

#else /* NOT __MINGW32__ */
	if ((pid = fork()) == 0) {
		if (close(1) == -1)
			fatal(_("close of stdout in child failed: %s"),
				strerror(errno));
		if (dup(p[1]) != 1)
			fatal(_("moving pipe to stdout in child failed (dup: %s)"), strerror(errno));
		if (close(p[0]) == -1 || close(p[1]) == -1)
			fatal(_("close of pipe failed: %s"), strerror(errno));
		set_sigpipe_to_default();
		execl("/bin/sh", "sh", "-c", cmd, NULL);
		_exit(errno == ENOENT ? 127 : 126);
	}
#endif /* NOT __MINGW32__ */

	if (pid == -1) {
		close(p[0]); close(p[1]);
		fatal(_("cannot create child process for `%s' (fork: %s)"), cmd, strerror(errno));
	}
	rp->pid = pid;
#if !defined(__MINGW32__)
	if (close(p[1]) == -1) {
		close(p[0]);
		fatal(_("close of pipe failed: %s"), strerror(errno));
	}
	os_close_on_exec(p[0], cmd, "pipe", "from");
#endif
	if ((BINMODE & BINMODE_INPUT) != 0)
		os_setbinmode(p[0], O_BINARY);
	rp->iop = iop_alloc(p[0], cmd, 0);
	find_input_parser(rp->iop);
	iop_finish(rp->iop);
	if (! rp->iop->valid) {
		if (! do_traditional && rp->iop->errcode != 0)
			update_ERRNO_int(rp->iop->errcode);
		iop_close(rp->iop);
		rp->iop = NULL;
	}

	return rp->iop;
}

/* gawk_pclose --- close an open child pipe */

static int
gawk_pclose(struct redirect *rp)
{
	if (rp->iop != NULL)
		(void) iop_close(rp->iop);
	rp->iop = NULL;

	/* process previously found, return stored status */
	if (rp->pid == -1)
		return rp->status;
	rp->status = sanitize_exit_status(wait_any(rp->pid));
	rp->pid = -1;
	return rp->status;
}

#else	/* PIPES_SIMULATED */

/*
 * use temporary file rather than pipe
 * except if popen() provides real pipes too
 */

/* gawk_popen --- open an IOBUF on a child process */

static IOBUF *
gawk_popen(const char *cmd, struct redirect *rp)
{
	FILE *current;

	os_restore_mode(fileno(stdin));

	set_sigpipe_to_default();
	current = popen(cmd, binmode("r"));
	ignore_sigpipe();

	if ((BINMODE & BINMODE_INPUT) != 0)
		os_setbinmode(fileno(stdin), O_BINARY);

	if (current == NULL)
		return NULL;
	os_close_on_exec(fileno(current), cmd, "pipe", "from");
	rp->iop = iop_alloc(fileno(current), cmd, 0);
	find_input_parser(rp->iop);
	iop_finish(rp->iop);
	if (! rp->iop->valid) {
		if (! do_traditional && rp->iop->errcode != 0)
			update_ERRNO_int(rp->iop->errcode);
		(void) pclose(current);
		rp->iop->public.fd = INVALID_HANDLE;
		iop_close(rp->iop);
		rp->iop = NULL;
		current = NULL;
	}
	rp->ifp = current;
	return rp->iop;
}

/* gawk_pclose --- close an open child pipe */

static int
gawk_pclose(struct redirect *rp)
{
	int rval, aval, fd = rp->iop->public.fd;

	if (rp->iop != NULL) {
		rp->iop->public.fd = dup(fd);	  /* kludge to allow close() + pclose() */
		rval = iop_close(rp->iop);
	}
	rp->iop = NULL;
	aval = pclose(rp->ifp);
	rp->ifp = NULL;
	return (rval < 0 ? rval : aval);
}

#endif	/* PIPES_SIMULATED */

/* do_getline_redir --- read in a line, into var and with redirection */

NODE *
do_getline_redir(int into_variable, enum redirval redirtype)
{
	struct redirect *rp = NULL;
	IOBUF *iop;
	size_t cnt;
	int retval = EOF;
	char *s = NULL;
	int errcode;
	NODE *redir_exp = NULL;
	NODE **lhs = NULL;
	int redir_error = 0;
	const awk_fieldwidth_info_t *field_width = NULL;

	if (into_variable)
		lhs = POP_ADDRESS();

	assert(redirtype != redirect_none);
	redir_exp = TOP();
	rp = redirect(redir_exp, redirtype, & redir_error, false);
	DEREF(redir_exp);
	decr_sp();
	if (rp == NULL) {
		if (redir_error) { /* failed redirect */
			if (! do_traditional)
				update_ERRNO_int(redir_error);
		}
		return make_number((AWKNUM) -1.0);
	} else if ((rp->flag & RED_TWOWAY) != 0 && rp->iop == NULL) {
		if (is_non_fatal_redirect(redir_exp->stptr, redir_exp->stlen)) {
			update_ERRNO_int(EBADF);
			return make_number((AWKNUM) -1.0);
		}
		(void) close_rp(rp, CLOSE_ALL);
		fatal(_("getline: attempt to read from closed read end of two-way pipe"));
	}
	iop = rp->iop;
	if (iop == NULL)		/* end of input */
		return make_number((AWKNUM) 0.0);

	errcode = 0;
	retval = get_a_record(& s, & cnt, iop, & errcode, (lhs ? NULL : & field_width));
	if (errcode != 0) {
		if (! do_traditional && (errcode != -1))
			update_ERRNO_int(errcode);
		return make_number((AWKNUM) retval);
	}

	if (retval == EOF) {
		/*
		 * Don't do iop_close() here if we are
		 * reading from a pipe; otherwise
		 * gawk_pclose will not be called.
		 */
		if ((rp->flag & (RED_PIPE|RED_TWOWAY)) == 0) {
			(void) iop_close(iop);
			rp->iop = NULL;
		}
		rp->flag |= RED_EOF;	/* sticky EOF */
		return make_number((AWKNUM) 0.0);
	}

	if (lhs == NULL)	/* no optional var. */
		set_record(s, cnt, field_width);
	else {			/* assignment to variable */
		unref(*lhs);
		// s could be NULL if cnt == 0, avoid passing a null
		// pointer to make_string().
		*lhs = make_string(s != NULL ? s : "", cnt);
		(*lhs)->flags |= USER_INPUT;
	}

	return make_number((AWKNUM) 1.0);
}

/* do_getline --- read in a line, into var and without redirection */

NODE *
do_getline(int into_variable, IOBUF *iop)
{
	size_t cnt;
	int retval = EOF;
	char *s = NULL;
	int errcode;
	const awk_fieldwidth_info_t *field_width = NULL;

	if (iop == NULL) {	/* end of input */
		if (into_variable)
			(void) POP_ADDRESS();
		return make_number((AWKNUM) 0.0);
	}

	errcode = 0;
	retval = get_a_record(& s, & cnt, iop, & errcode, (into_variable ? NULL : & field_width));
	if (errcode != 0) {
		if (! do_traditional && (errcode != -1))
			update_ERRNO_int(errcode);
		if (into_variable)
			(void) POP_ADDRESS();
		return make_number((AWKNUM) retval);
	}

	if (retval == EOF)
		return NULL;	/* try next file */
	INCREMENT_REC(NR);
	INCREMENT_REC(FNR);

	if (! into_variable)	/* no optional var. */
		set_record(s, cnt, field_width);
	else {			/* assignment to variable */
		NODE **lhs;
		lhs = POP_ADDRESS();
		unref(*lhs);
		// s could be NULL if cnt == 0, avoid passing a null
		// pointer to make_string().
		*lhs = make_string(s != NULL ? s : "", cnt);
		(*lhs)->flags |= USER_INPUT;
	}
	return make_number((AWKNUM) 1.0);
}

typedef struct {
	const char *envname;
	const char **dfltp;	/* pointer to address of default path */
	const char **awkpath;	/* array containing library search paths */
	int max_pathlen;	/* length of the longest item in awkpath */
} path_info;

static path_info pi_awkpath = {
	/* envname */	"AWKPATH",
	/* dfltp */	& defpath,
};

static path_info pi_awklibpath = {
	/* envname */	"AWKLIBPATH",
	/* dfltp */	& deflibpath,
};

/* init_awkpath --- split path(=$AWKPATH) into components */

static void
init_awkpath(path_info *pi)
{
	const char *path;
	const char *start, *end;
	char *p;
	int len, i;
	int max_path;		/* (# of allocated paths)-1 */

	pi->max_pathlen = 0;
	if ((path = getenv(pi->envname)) == NULL || *path == '\0')
		path = pi->dfltp[0];

	/* count number of separators */
	for (max_path = 0, p = (char *) path; *p; p++)
		if (*p == envsep)
			max_path++;

	// +3 --> 2 for null entries at front and end of path, 1 for NULL end of list
	ezalloc(pi->awkpath, const char **, (max_path + 3) * sizeof(char *));

	start = path;
	i = 0;

	if (*path == envsep) {	/* null entry at front of path */
		pi->awkpath[i++] = ".";
		pi->max_pathlen = 1;
	}

	while (*start) {
		if (*start == envsep) {
			if (start[1] == envsep) {
				pi->awkpath[i++] = ".";
				if (pi->max_pathlen == 0)
					pi->max_pathlen = 1;
				start++;
			} else if (start[1] == '\0') {
				pi->awkpath[i++] = ".";
				if (pi->max_pathlen == 0)
					pi->max_pathlen = 1;
				break;
			} else
				start++;
		} else {
			for (end = start; *end && *end != envsep; end++)
				continue;

			len = end - start;
			if (len > 0) {
				emalloc(p, char *, len + 2);
				memcpy(p, start, len);

				/* add directory punctuation if necessary */
				if (! isdirpunct(end[-1]))
					p[len++] = '/';
				p[len] = '\0';
				pi->awkpath[i++] = p;
				if (len > pi->max_pathlen)
					pi->max_pathlen = len;

				start = end;
			} else
				start++;
		}
	}

	pi->awkpath[i] = NULL;
}

/* do_find_source --- search $AWKPATH for file, return NULL if not found */

static char *
do_find_source(const char *src, struct stat *stb, int *errcode, path_info *pi)
{
	char *path;
	int i;

	assert(errcode != NULL);

	/* some kind of path name, no search */
	if (ispath(src)) {
		emalloc(path, char *, strlen(src) + 1);
		strcpy(path, src);
		if (stat(path, stb) == 0)
			return path;
		*errcode = errno;
		efree(path);
		return NULL;
	}

	if (pi->awkpath == NULL)
		init_awkpath(pi);

	emalloc(path, char *, pi->max_pathlen + strlen(src) + 1);
	for (i = 0; pi->awkpath[i] != NULL; i++) {
		if (strcmp(pi->awkpath[i], "./") == 0 || strcmp(pi->awkpath[i], ".") == 0)
			*path = '\0';
		else
			strcpy(path, pi->awkpath[i]);
		strcat(path, src);
		if (stat(path, stb) == 0)
			return path;
	}

	/* not found, give up */
	*errcode = errno;
	efree(path);
	return NULL;
}

/* find_source --- find source file with default file extension handling */

char *
find_source(const char *src, struct stat *stb, int *errcode, int is_extlib)
{
	char *path;
	path_info *pi = (is_extlib ? & pi_awklibpath : & pi_awkpath);

	*errcode = 0;
	if (src == NULL || *src == '\0')
		return NULL;
	path = do_find_source(src, stb, errcode, pi);

	if (path == NULL && is_extlib) {
		char *file_ext;
		int save_errno;
		size_t src_len;
		size_t suffix_len;

#define EXTLIB_SUFFIX	"." SHLIBEXT
		src_len = strlen(src);
		suffix_len = strlen(EXTLIB_SUFFIX);

		/* check if already has the SUFFIX */
		if (src_len >= suffix_len && strcmp(& src[src_len - suffix_len], EXTLIB_SUFFIX) == 0)
			return NULL;

		/* append EXTLIB_SUFFIX and try again */
		save_errno = errno;
		emalloc(file_ext, char *, src_len + suffix_len + 1);
		sprintf(file_ext, "%s%s", src, EXTLIB_SUFFIX);
		path = do_find_source(file_ext, stb, errcode, pi);
		efree(file_ext);
		if (path == NULL)
			errno = save_errno;
		return path;
#undef EXTLIB_SUFFIX
	}

/*
 * Try searching with .awk appended if the platform headers have not specified
 * another suffix.
 */
#ifndef DEFAULT_FILETYPE
#define DEFAULT_FILETYPE ".awk"
#endif

#ifdef DEFAULT_FILETYPE
	if (path == NULL) {
		char *file_awk;
		int save_errno = errno;
#ifdef VMS
		int vms_save = vaxc$errno;
#endif

		/* append ".awk" and try again */
		emalloc(file_awk, char *, strlen(src) + sizeof(DEFAULT_FILETYPE) + 1);
		sprintf(file_awk, "%s%s", src, DEFAULT_FILETYPE);
		path = do_find_source(file_awk, stb, errcode, pi);
		efree(file_awk);
		if (path == NULL) {
			errno = save_errno;
#ifdef VMS
			vaxc$errno = vms_save;
#endif
		}
	}
#endif	/*DEFAULT_FILETYPE*/

	return path;
}


/* srcopen --- open source file */

int
srcopen(SRCFILE *s)
{
	int fd = INVALID_HANDLE;

	if (s->stype == SRC_STDIN)
		fd = fileno(stdin);
	else if (s->stype == SRC_FILE || s->stype == SRC_INC)
		fd = devopen(s->fullpath, "r");

	/* set binary mode so that debugger byte offset calculations will be right */
	if (fd != INVALID_HANDLE)
		os_setbinmode(fd, O_BINARY);

	return fd;
}

/* input parsers, mainly for use by extension functions */

static awk_input_parser_t *ip_head, *ip_tail;

/*
 * register_input_parser --- add an input parser to the list, FIFO.
 * 	The main reason to use FIFO is to provide the diagnostic
 * 	with the correct information: input parser 2 conflicts
 * 	with input parser 1.  Otherwise LIFO would have been easier.
 */

void
register_input_parser(awk_input_parser_t *input_parser)
{
	if (input_parser == NULL)
		fatal(_("register_input_parser: received NULL pointer"));

	input_parser->next = NULL;	/* force it */
	if (ip_head == NULL) {
		ip_head = ip_tail = input_parser;
	} else {
		ip_tail->next = input_parser;
		ip_tail = ip_tail->next;
	}
}

/* find_input_parser --- search the list of input parsers */

static void
find_input_parser(IOBUF *iop)
{
	awk_input_parser_t *ip, *ip2;

	/* if already associated with an input parser, bail out early */
	if (iop->public.get_record != NULL || iop->public.read_func != read)
		return;

	ip = ip2 = NULL;
	for (ip2 = ip_head; ip2 != NULL; ip2 = ip2->next) {
		if (ip2->can_take_file(& iop->public)) {
			if (ip == NULL)
				ip = ip2;	/* found first one */
			else
				fatal(_("input parser `%s' conflicts with previously installed input parser `%s'"),
						ip2->name, ip->name);
		}
	}

	if (ip != NULL) {
		if (! ip->take_control_of(& iop->public))
			warning(_("input parser `%s' failed to open `%s'"),
					ip->name, iop->public.name);
		else
			iop->valid = true;
	}
}

/* output wrappers --- for use by extensions */

static awk_output_wrapper_t *op_head, *op_tail;

/*
 * register_output_wrapper --- add an output wrapper to the list.
 * 	Same stuff here as for input parsers.
 */

void
register_output_wrapper(awk_output_wrapper_t *wrapper)
{
	if (wrapper == NULL)
		fatal(_("register_output_wrapper: received NULL pointer"));

	wrapper->next = NULL;	/* force it */
	if (op_head == NULL) {
		op_head = op_tail = wrapper;
	} else {
		op_tail->next = wrapper;
		op_tail = op_tail->next;
	}
}

/* find_output_wrapper --- search the list of output wrappers */

static bool
find_output_wrapper(awk_output_buf_t *outbuf)
{
	awk_output_wrapper_t *op, *op2;

	/* if already associated with an output wrapper, bail out early */
	if (outbuf->redirected)
		return false;

	op = op2 = NULL;
	for (op2 = op_head; op2 != NULL; op2 = op2->next) {
		if (op2->can_take_file(outbuf)) {
			if (op == NULL)
				op = op2;	/* found first one */
			else
				fatal(_("output wrapper `%s' conflicts with previously installed output wrapper `%s'"),
						op2->name, op->name);
		}
	}

	if (op != NULL) {
		if (! op->take_control_of(outbuf)) {
			warning(_("output wrapper `%s' failed to open `%s'"),
					op->name, outbuf->name);
			return false;
		}
		return true;
	}

	return false;
}


/* two way processors --- for use by extensions */

static awk_two_way_processor_t *tw_head, *tw_tail;

/* register_two_way_processor --- register a two-way I/O processor, for extensions */

void
register_two_way_processor(awk_two_way_processor_t *processor)
{
	if (processor == NULL)
		fatal(_("register_output_processor: received NULL pointer"));

	processor->next = NULL;	/* force it */
	if (tw_head == NULL) {
		tw_head = tw_tail = processor;
	} else {
		tw_tail->next = processor;
		tw_tail = tw_tail->next;
	}
}

/* find_two_way_processor --- search the list of two way processors */

static bool
find_two_way_processor(const char *name, struct redirect *rp)
{
	awk_two_way_processor_t *tw, *tw2;

	/* if already associated with i/o, bail out early */
	if (   (rp->iop != NULL && rp->iop->public.fd != INVALID_HANDLE)
	    || rp->output.fp != NULL)
		return false;

	tw = tw2 = NULL;
	for (tw2 = tw_head; tw2 != NULL; tw2 = tw2->next) {
		if (tw2->can_take_two_way(name)) {
			if (tw == NULL)
				tw = tw2;	/* found first one */
			else
				fatal(_("two-way processor `%s' conflicts with previously installed two-way processor `%s'"),
						tw2->name, tw->name);
		}
	}

	if (tw != NULL) {
		if (rp->iop == NULL)
			rp->iop = iop_alloc(INVALID_HANDLE, name, 0);
		if (! tw->take_control_of(name, & rp->iop->public, & rp->output)) {
			warning(_("two way processor `%s' failed to open `%s'"),
					tw->name, name);
			return false;
		}
		iop_finish(rp->iop);
		return true;
	}

	return false;
}

/*
 * IOBUF management is somewhat complicated.  In particular,
 * it is possible and OK for an IOBUF to be allocated with
 * a file descriptor that is either valid or not usable with
 * read(2), in case an input parser will come along later and
 * make it readable.  Alternatively, an input parser can simply
 * come along and take over reading on a valid readable descriptor.
 *
 * The first stage is simply to allocate the IOBUF.  This is done
 * during nextfile() for command line files and by redirect()
 * and other routines for getline, input pipes, and the input
 * side of a two-way pipe.
 *
 * The second stage is to check for input parsers.  This is done
 * for command line files in after_beginfile() and for the others
 * as part of the full flow.  At this point, either:
 * 	- The fd is valid on a readable file
 * 	- The input parser has taken over a valid fd and made
 * 	  it usable (e.g., directories)
 * 	- Or the input parser has simply hijacked the reading
 * 	  (such as the gawkextlib XML extension)
 * If none of those are true, the fd should be closed, reset
 * to INVALID_HANDLE, and iop->errcode set to indicate the error
 * (EISDIR for directories, EIO for anything else).
 * iop->valid should be set to false in this case.
 *
 * Otherwise, after the second stage, iop->errcode should be
 * zero, iop->valid should be true, and iop->public.fd should
 * not be INVALID_HANDLE.
 *
 * The third stage is to set up the rest of the IOBUF for
 * use by get_a_record(). In this case, iop->valid must
 * be true already, and iop->public.fd cannot be INVALID_HANDLE.
 *
 * Checking for input parsers for command line files is delayed
 * to after_beginfile() so that the BEGINFILE rule has an
 * opportunity to look at FILENAME and ERRNO and attempt to
 * recover with a custom input parser. The XML extension, in
 * particular, relies strongly upon this ability.
 */

/* iop_alloc --- allocate an IOBUF structure for an open fd */

static IOBUF *
iop_alloc(int fd, const char *name, int errno_val)
{
	IOBUF *iop;

	ezalloc(iop, IOBUF *, sizeof(IOBUF));

	iop->public.fd = fd;
	iop->public.name = name;
	iop->public.read_func = ( ssize_t(*)(int, void *, size_t) ) read;
	iop->valid = false;
	iop->errcode = errno_val;

	if (fd != INVALID_HANDLE)
		fstat(fd, & iop->public.sbuf);
	else {
#ifdef HAVE_LSTAT
		int (*statf)(const char *, struct stat *) = lstat;
#else
		int (*statf)(const char *, struct stat *) = stat;
#endif
		/*
		 * Try to fill in the stat struct. If it fails, zero
		 * it out.
		 */
		if (statf(name, & iop->public.sbuf) < 0)
			memset(& iop->public.sbuf, 0, sizeof(struct stat));
	}

	return iop;
}

/* iop_finish --- finish setting up an IOBUF */

static IOBUF *
iop_finish(IOBUF *iop)
{
	bool isdir = false;

	if (iop->public.fd != INVALID_HANDLE) {
		if (os_isreadable(& iop->public, & isdir))
			iop->valid = true;
		else {
			if (isdir)
				iop->errcode = EISDIR;
			else {
				iop->errcode = EIO;
				/*
				 * Extensions can supply values that are not
				 * INVALID_HANDLE but that are also not real
				 * file descriptors. So check the fd before
				 * trying to close it, which avoids errors
				 * on some operating systems.
				 *
				 * The fcntl call works for Windows, too.
				 */
#if defined(F_GETFL)
				if (fcntl(iop->public.fd, F_GETFL) >= 0)
#endif
					(void) close(iop->public.fd);
				iop->public.fd = INVALID_HANDLE;
			}
			/*
			 * Don't close directories: after_beginfile(),
			 * special cases them.
			 */
		}
	}

	if (! iop->valid || iop->public.fd == INVALID_HANDLE)
		return iop;

	if (os_isatty(iop->public.fd))
		iop->flag |= IOP_IS_TTY;

	iop->readsize = iop->size = optimal_bufsize(iop->public.fd, & iop->public.sbuf);
	if (do_lint && S_ISREG(iop->public.sbuf.st_mode) && iop->public.sbuf.st_size == 0)
		lintwarn(_("data file `%s' is empty"), iop->public.name);
	iop->errcode = errno = 0;
	iop->count = iop->scanoff = 0;
	emalloc(iop->buf, char *, iop->size += 1);
	iop->off = iop->buf;
	iop->dataend = NULL;
	iop->end = iop->buf + iop->size;
	iop->flag |= IOP_AT_START;

	return iop;
}

#define set_RT_to_null() \
	(void)(! do_traditional && (unref(RT_node->var_value), \
			   RT_node->var_value = dupnode(Nnull_string)))

#define set_RT(str, len) \
	(void)(! do_traditional && (unref(RT_node->var_value), \
			   RT_node->var_value = make_string(str, len)))

/*
 * grow_iop_buffer:
 *
 * grow must increase size of buffer, set end, make sure off and dataend
 * point at the right spot.
 */

static void
grow_iop_buffer(IOBUF *iop)
{
	size_t valid = iop->dataend - iop->off;
	size_t off = iop->off - iop->buf;
	size_t newsize;

	/*
	 * Lop off original extra byte, double the size,
	 * add it back.
	 */
	newsize = ((iop->size - 1) * 2) + 1;

	/* Check for overflow */
	if (newsize <= iop->size)
		fatal(_("could not allocate more input memory"));

	/* Make sure there's room for a disk block */
	if (newsize - valid < iop->readsize)
		newsize += iop->readsize + 1;

	/* Check for overflow, again */
	if (newsize <= iop->size)
		fatal(_("could not allocate more input memory"));

	iop->size = newsize;
	erealloc(iop->buf, char *, iop->size);
	iop->off = iop->buf + off;
	iop->dataend = iop->off + valid;
	iop->end = iop->buf + iop->size;
}

/* rs1scan --- scan for a single character record terminator */

static RECVALUE
rs1scan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)
{
	char *bp;
	char rs;
	size_t mbclen = 0;
	mbstate_t mbs;

	memset(recm, '\0', sizeof(struct recmatch));
	rs = RS->stptr[0];
	*(iop->dataend) = rs;   /* set sentinel */
	recm->start = iop->off; /* beginning of record */

	bp = iop->off;
	if (*state == INDATA)   /* skip over data we've already seen */
		bp += iop->scanoff;

	/*
	 * From: Bruno Haible <bruno@clisp.org>
	 * To: Aharon Robbins <arnold@skeeve.com>, gnits@gnits.org
	 * Subject: Re: multibyte locales: any way to find if a character isn't multibyte?
	 * Date: Mon, 23 Jun 2003 12:20:16 +0200
	 * Cc: isamu@yamato.ibm.com
	 *
	 * Hi,
	 *
	 * > Is there any way to make the following query to the current locale?
	 * >
	 * > 	Given an 8-bit value, can this value ever appear as part of
	 * > 	a multibyte character?
	 *
	 * There is no simple answer here. The easiest solution I see is to
	 * get the current locale's codeset (via locale_charset() which is a
	 * wrapper around nl_langinfo(CODESET)), and then perform a case-by-case
	 * treatment of the known multibyte encodings, from GB2312 to EUC-JISX0213;
	 * for the unibyte encodings, a single btowc() call will tell you.
	 *
	 * > This is particularly critical for me for ASCII newline ('\n').  If I
	 * > can be guaranteed that it never shows up as part of a multibyte character,
	 * > I can speed up gawk considerably in mulitbyte locales.
	 *
	 * This is much simpler to answer!
	 * In all ASCII based multibyte encodings used for locales today (this
	 * excludes EBCDIC based doublebyte encodings from IBM, and also excludes
	 * ISO-2022-JP which is used for email exchange but not as a locale encoding)
	 * ALL bytes in the range 0x00..0x2F occur only as a single character, not
	 * as part of a multibyte character.
	 *
	 * So it's safe to assume, but deserves a comment in the source.
	 *
	 * Bruno
	 ***************************************************************
	 * From: Bruno Haible <bruno@clisp.org>
	 * To: Aharon Robbins <arnold@skeeve.com>
	 * Subject: Re: multibyte locales: any way to find if a character isn't multibyte?
	 * Date: Mon, 23 Jun 2003 14:27:49 +0200
	 *
	 * On Monday 23 June 2003 14:11, you wrote:
	 *
	 * >       if (rs != '\n' && MB_CUR_MAX > 1) {
	 *
	 * If you assume ASCII, you can even write
	 *
	 *         if (rs >= 0x30 && MB_CUR_MAX > 1) {
	 *
	 * (this catches also the space character) but if portability to EBCDIC
	 * systems is desired, your code is fine as is.
	 *
	 * Bruno
	 */
	/* Thus, the check for \n here; big speedup ! */
	if (rs != '\n' && gawk_mb_cur_max > 1) {
		int len = iop->dataend - bp;
		bool found = false;

		memset(& mbs, 0, sizeof(mbstate_t));
		do {
			if (*bp == rs)
				found = true;
			if (is_valid_character(*bp))
				mbclen = 1;
			else
				mbclen = mbrlen(bp, len, & mbs);
			if (   mbclen == 1
			    || mbclen == (size_t) -1
			    || mbclen == (size_t) -2
			    || mbclen == 0) {
				/* We treat it as a single-byte character.  */
				mbclen = 1;
			}
			len -= mbclen;
			bp += mbclen;
		} while (len > 0 && ! found);

		/* Check that newline found isn't the sentinel. */
		if (found && (bp - mbclen) < iop->dataend) {
			/*
			 * Set len to what we have so far, in case this is
			 * all there is.
			 */
			recm->len = bp - recm->start - mbclen;
			recm->rt_start = bp - mbclen;
			recm->rt_len = mbclen;
			*state = NOSTATE;
			return REC_OK;
		} else {
			/* also set len */
			recm->len = bp - recm->start;
			*state = INDATA;
			iop->scanoff = bp - iop->off;
			return NOTERM;
		}
	}

	while (*bp != rs)
		bp++;

	/* set len to what we have so far, in case this is all there is */
	recm->len = bp - recm->start;

	if (bp < iop->dataend) {        /* found it in the buffer */
		recm->rt_start = bp;
		recm->rt_len = 1;
		*state = NOSTATE;
		return REC_OK;
	} else {
		*state = INDATA;
		iop->scanoff = bp - iop->off;
		return NOTERM;
	}
}

/* rsrescan --- search for a regex match in the buffer */

static RECVALUE
rsrescan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)
{
	char *bp;
	size_t restart = 0, reend = 0;
	Regexp *RSre = RS_regexp;
	int regex_flags = RE_NEED_START;

	memset(recm, '\0', sizeof(struct recmatch));
	recm->start = iop->off;

	bp = iop->off;
	if (*state == INDATA)
		bp += iop->scanoff;

	if ((iop->flag & IOP_AT_START) == 0)
		regex_flags |= RE_NO_BOL;
again:
	/* case 1, no match */
	if (research(RSre, bp, 0, iop->dataend - bp, regex_flags) == -1) {
		/* set len, in case this all there is. */
		recm->len = iop->dataend - iop->off;
		return NOTERM;
	}

	/* ok, we matched within the buffer, set start and end */
	restart = RESTART(RSre, iop->off);
	reend = REEND(RSre, iop->off);

	/* case 2, null regex match, grow buffer, try again */
	if (restart == reend) {
		*state = INDATA;
		iop->scanoff = reend + 1;
		/*
		 * If still room in buffer, skip over null match
		 * and restart search. Otherwise, return.
		 */
		if (bp + iop->scanoff <= iop->dataend) {
			bp += iop->scanoff;
			goto again;
		}
		recm->len = (bp - iop->off) + restart;
		return NOTERM;
	}

	/*
	 * At this point, we have a non-empty match.
	 *
	 * First, fill in rest of data. The rest of the cases return
	 * a record and terminator.
	 */
	recm->len = restart;
	recm->rt_start = bp + restart;
	recm->rt_len = reend - restart;
	*state = NOSTATE;

	/*
	 * 3. Match exactly at end:
	 *      if re is a simple string match
	 *              found a simple string match at end, return REC_OK
	 *      else
	 *              grow buffer, add more data, try again
	 *              if possibly a variable length match (in which case more
	 *                  match could be in next input buffer)
	 *                      grow buffer, add more data, try again
	 *              else # simpler re
	 *                      return REC_OK
	 *              fi
	 *      fi
	 */
	if (iop->off + reend >= iop->dataend) {
		if (reisstring(RS->stptr, RS->stlen, RSre, iop->off))
			return REC_OK;
		else if (! RSre->maybe_long)
 			return REC_OK;
		else
			return TERMATEND;
	}

	/*
	 * 4. Match within xxx bytes of end & maybe islong re:
	 *      return TERMNEAREND
	 */

        /*
         * case 4, match succeeded, but there may be more in
         * the next input buffer.
         *
         * Consider an RS of   xyz(abc)?   where the
         * exact end of the buffer is   xyza  and the
         * next two, unread, characters are bc.
         *
         * This matches the "xyz" and ends up putting the
         * "abc" into the front of the next record. Ooops.
         *
         * The re->maybe_long member is true if the
         * regex contains one of: + * ? | { }.  This is a very
         * simple heuristic, but in combination with the
         * "end of match within a few bytes of end of buffer"
         * check, should keep things reasonable.
         */

	/* succession of tests is easier to trace in GDB. */
	if (RSre->maybe_long) {
		char *matchend = iop->off + reend;

		if (iop->dataend - matchend < RS->stlen)
			return TERMNEAREND;
	}

	return REC_OK;
}

/* rsnullscan --- handle RS = "" */

static RECVALUE
rsnullscan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)
{
	char *bp;

	if (*state == NOSTATE || *state == INLEADER)
		memset(recm, '\0', sizeof(struct recmatch));

	recm->start = iop->off;

	bp = iop->off;
	if (*state != NOSTATE)
		bp += iop->scanoff;

	/* set sentinel */
	*(iop->dataend) = '\n';

	if (*state == INTERM)
		goto find_longest_terminator;
	else if (*state == INDATA)
		goto scan_data;
	/* else
		fall into things from beginning,
		either NOSTATE or INLEADER */

/* skip_leading: */
	/* leading newlines are ignored */
	while (*bp == '\n' && bp < iop->dataend)
		bp++;

	if (bp >= iop->dataend) {       /* LOTS of leading newlines, sheesh. */
		*state = INLEADER;
		iop->scanoff = bp - iop->off;
		return NOTERM;
	}

	iop->off = recm->start = bp;    /* real start of record */
scan_data:
	while (*bp++ != '\n')
		continue;

	if (bp >= iop->dataend) {       /* no full terminator */
		iop->scanoff = recm->len = bp - iop->off - 1;
		if (bp == iop->dataend) {	/* half a terminator */
			recm->rt_start = bp - 1;
			recm->rt_len = 1;
		}
		*state = INDATA;
		return NOTERM;
	}

	/* found one newline before end of buffer, check next char */
	if (*bp != '\n')
		goto scan_data;

	/* we've now seen at least two newlines */
	*state = INTERM;
	recm->len = bp - iop->off - 1;
	recm->rt_start = bp - 1;

find_longest_terminator:
	/* find as many newlines as we can, to set RT */
	while (*bp == '\n' && bp < iop->dataend)
		bp++;

	recm->rt_len = bp - recm->rt_start;
	iop->scanoff = bp - iop->off;

	if (bp >= iop->dataend)
		return TERMATEND;

	return REC_OK;
}

/* csvscan --- handle --csv mode */

static RECVALUE
csvscan(IOBUF *iop, struct recmatch *recm, SCANSTATE *state)
{
	char *bp;
	char rs = '\n';
	static bool in_quote = false;

	memset(recm, '\0', sizeof(struct recmatch));
	*(iop->dataend) = rs;   /* set sentinel */
	recm->start = iop->off; /* beginning of record */

	if (*state == NOSTATE)  /* reset in_quote at the beginning of the record */
		in_quote = false;

	bp = iop->off;
	if (*state == INDATA)   /* skip over data we've already seen */
		bp += iop->scanoff;

	/* look for a newline outside quotes */
	do {
		while (*bp != rs && bp < iop->dataend) { 
			if (*bp == '\"')
				in_quote = ! in_quote;
			bp++;
		}
		if (bp > iop->off && bp[-1] == '\r') {
			// convert CR-LF to LF by shifting the record
			memmove(bp - 1, bp, iop->dataend - bp);
			iop->dataend--;
			*(iop->dataend) = rs;	/* set sentinel */
			bp--;
		}
	} while (in_quote && bp < iop->dataend && bp++);

	/* set len to what we have so far, in case this is all there is */
	recm->len = bp - recm->start;

	if (bp < iop->dataend) {        /* found it in the buffer */
		recm->rt_start = bp;
		recm->rt_len = 1;
		*state = NOSTATE;
		return REC_OK;
	} else {
		*state = INDATA;
		iop->scanoff = bp - iop->off;
		return NOTERM;
	}
}

/* retryable --- return true if PROCINFO[<filename>, "RETRY"] exists */

static inline int
retryable(IOBUF *iop)
{
	return PROCINFO_node && in_PROCINFO(iop->public.name, "RETRY", NULL);
}

/* errno_io_retry --- Does the I/O error indicate that the operation should be retried later? */

static inline int
errno_io_retry(void)
{
	switch (errno) {
#ifdef EAGAIN
	case EAGAIN:
#endif
#ifdef EWOULDBLOCK
#if !defined(EAGAIN) || (EWOULDBLOCK != EAGAIN)
	case EWOULDBLOCK:
#endif
#endif
#ifdef EINTR
	case EINTR:
#endif
#ifdef ETIMEDOUT
	case ETIMEDOUT:
#endif
		return 1;
	default:
		return 0;
	}
}

/*
 * get_a_record --- read a record from IOP into out,
 * its length into len, and set RT.
 * return 0 on success, EOF when out of data, and -2 if I/O would block.
 * Note that errcode is never NULL, and the caller initializes *errcode to 0.
 */

static int
get_a_record(char **out,        /* pointer to pointer to data */
        size_t *len,            /* pointer to record length */
        IOBUF *iop,             /* input IOP */
        int *errcode,           /* pointer to error variable */
        const awk_fieldwidth_info_t **field_width)
				/* pointer to pointer to field_width info */
{
	struct recmatch recm;
	SCANSTATE state;
	RECVALUE ret;
	NODE *rtval = NULL;
	static RECVALUE (*lastmatchrec)(IOBUF *iop, struct recmatch *recm, SCANSTATE *state) = NULL;

	if (at_eof(iop) && no_data_left(iop))
		return EOF;

	if (read_can_timeout)
		read_timeout = get_read_timeout(iop);

	if (iop->public.get_record != NULL) {
		char *rt_start;
		size_t rt_len;
		int rc = iop->public.get_record(out, &iop->public, errcode,
						&rt_start, &rt_len,
						field_width);
		if (rc == EOF)
			iop->flag |= IOP_AT_EOF;
		else {
			assert(rc >= 0);
			*len = rc;
			rc = 0;
			if (rt_len != 0)
				set_RT(rt_start, rt_len);
			else
				set_RT_to_null();
		}
		return rc;
	}

        /* fill initial buffer */
	if (has_no_data(iop) || no_data_left(iop)) {
		iop->count = iop->public.read_func(iop->public.fd, iop->buf, iop->readsize);
		if (iop->count == 0) {
			iop->flag |= IOP_AT_EOF;
			return EOF;
		} else if (iop->count == -1) {
			*errcode = errno;
			if (errno_io_retry() && retryable(iop))
				return -2;
			iop->flag |= IOP_AT_EOF;
			return EOF;
		} else {
			iop->dataend = iop->buf + iop->count;
			iop->off = iop->buf;
		}
	}

	/* loop through file to find a record */
	state = NOSTATE;
	for (;;) {
		size_t dataend_off;
		size_t room_left;
		size_t amt_to_read;

		ret = (*matchrec)(iop, & recm, & state);
		iop->flag &= ~IOP_AT_START;
		/* found the record, we're done, break the loop */
		if (ret == REC_OK)
			break;

		/*
		 * Likely found the record; if there's no more data
		 * to be had (like from a tiny regular file), break the
		 * loop. Otherwise, see if we can read more.
		 */
		if (ret == TERMNEAREND && buffer_has_all_data(iop))
			break;

		/* need to add more data to buffer */
		/* shift data down in buffer */
		dataend_off = iop->dataend - iop->off;
		memmove(iop->buf, iop->off, dataend_off);
		iop->off = iop->buf;
		iop->dataend = iop->buf + dataend_off;

		/* adjust recm contents */
		recm.start = iop->off;
		if (recm.rt_start != NULL)
			recm.rt_start = iop->off + recm.len;

		/* read more data, break if EOF */
#ifndef MIN
#define MIN(x, y) (x < y ? x : y)
#endif
		/* subtract one in read count to leave room for sentinel */
		room_left = iop->end - iop->dataend - 1;
		amt_to_read = MIN(iop->readsize, room_left);

		if (amt_to_read < iop->readsize) {
			grow_iop_buffer(iop);
			/* adjust recm contents */
			recm.start = iop->off;
			if (recm.rt_start != NULL)
				recm.rt_start = iop->off + recm.len;

			/* recalculate amt_to_read */
			room_left = iop->end - iop->dataend - 1;
			amt_to_read = MIN(iop->readsize, room_left);
		}
		while (amt_to_read + iop->readsize < room_left)
			amt_to_read += iop->readsize;

#ifdef SSIZE_MAX
		/*
		 * POSIX limits read to SSIZE_MAX. There are (bizarre)
		 * systems where this amount is small.
		 */
		amt_to_read = MIN(amt_to_read, SSIZE_MAX);
#endif

		iop->count = iop->public.read_func(iop->public.fd, iop->dataend, amt_to_read);
		if (iop->count == -1) {
			*errcode = errno;
			if (errno_io_retry() && retryable(iop))
				return -2;
			iop->flag |= IOP_AT_EOF;
			break;
		} else if (iop->count == 0) {
			/*
			 * Hit EOF before being certain that we've matched
			 * the end of the record. If ret is TERMNEAREND,
			 * we need to pull out what we've got in the buffer.
			 * Eventually we'll come back here and see the EOF,
			 * end the record and set RT to "".
			 */
			if (ret != TERMNEAREND)
				iop->flag |= IOP_AT_EOF;
			break;
		} else
			iop->dataend += iop->count;
	}

	/* set record, RT, return right value */

	/*
	 * rtval is not a static pointer to avoid dangling pointer problems
	 * in case awk code assigns to RT.  A remote possibility, to be sure,
	 * but Bitter Experience teaches us not to make ``that'll never
	 * happen'' kinds of assumptions.
	 */
	rtval = RT_node->var_value;

	if (recm.rt_len == 0) {
		set_RT_to_null();
		lastmatchrec = NULL;
	} else {
		assert(recm.rt_start != NULL);
		/*
		 * Optimization. For rs1 case, don't set RT if
		 * character is same as last time.  This knocks a
		 * chunk of time off something simple like
		 *
		 *      gawk '{ print }' /some/big/file
		 *
		 * Similarly, for rsnull case, if length of new RT is
		 * shorter than current RT, just bump length down in RT.
		 *
		 * Make sure that matchrec didn't change since the last
		 * check.  (Ugh, details, details, details.)
		 */
		if (lastmatchrec == NULL || lastmatchrec != matchrec) {
			lastmatchrec = matchrec;
			set_RT(recm.rt_start, recm.rt_len);
		} else if (matchrec == rs1scan) {
			if (rtval->stlen != 1 || rtval->stptr[0] != recm.rt_start[0])
				set_RT(recm.rt_start, recm.rt_len);
			/* else
				leave it alone */
		} else if (matchrec == rsnullscan) {
			if (rtval->stlen >= recm.rt_len) {
				rtval->stlen = recm.rt_len;
				free_wstr(rtval);
			} else
				set_RT(recm.rt_start, recm.rt_len);
		} else
			set_RT(recm.rt_start, recm.rt_len);
	}

	if (recm.len == 0) {
		*out = NULL;
		*len = 0;
	} else {
		assert(recm.start != NULL);
		*out = recm.start;
		*len = recm.len;
	}

	iop->off += recm.len + recm.rt_len;

	if (recm.len == 0 && recm.rt_len == 0 && at_eof(iop))
		return EOF;
	else
		return 0;
}

/* set_RS --- update things as appropriate when RS is set */

void
set_RS()
{
	/*
	 * Setting RS does nothing if CSV mode, warn in that case,
	 * but don't warn on first call which happens at initialization.
	 */
	static bool first_time = true;
	static bool warned = false;

	static NODE *save_rs = NULL;

	/*
	 * Don't use cmp_nodes(), which pays attention to IGNORECASE.
	 */
	if (save_rs
		&& RS_node->var_value->stlen == save_rs->stlen
		&& memcmp(RS_node->var_value->stptr, save_rs->stptr, save_rs->stlen) == 0) {
		/*
		 * It could be that just IGNORECASE changed.  If so,
		 * update the regex and then do the same for FS.
		 * set_IGNORECASE() relies on this routine to call
		 * set_FS().
		 */
		RS_regexp = RS_re[IGNORECASE];
		goto set_FS;
	}
	unref(save_rs);
	save_rs = dupnode(RS_node->var_value);
	RS_is_null = false;
	RS = force_string(RS_node->var_value);
	/*
	 * used to be if (RS_regexp != NULL) { refree(..); refree(..); ...; }.
	 * Please do not remerge the if condition; hinders memory deallocation
	 * in case of fatal error in make_regexp.
	 */
	refree(RS_re[0]);	/* NULL argument is ok */
	refree(RS_re[1]);
	RS_re[0] = RS_re[1] = RS_regexp = NULL;

	if (! first_time && do_csv) {
		if (! warned) {
			warned = true;
			warning(_("assignment to RS has no effect when using --csv"));
		}
		return;
	}

	if (RS->stlen == 0) {
		RS_is_null = true;
		if (first_time || ! do_csv)
			matchrec = rsnullscan;
	} else if ((RS->stlen > 1 || (RS->flags & REGEX) != 0) && ! do_traditional) {
		static bool warned = false;

		RS_re[0] = make_regexp(RS->stptr, RS->stlen, false, true, true);
		RS_re[1] = make_regexp(RS->stptr, RS->stlen, true, true, true);
		RS_regexp = RS_re[IGNORECASE];

		if (first_time || ! do_csv)
			matchrec = rsrescan;

		if (do_lint_extensions && ! warned) {
			lintwarn(_("multicharacter value of `RS' is a gawk extension"));
			warned = true;
		}
	} else {
		if (first_time || ! do_csv)
			matchrec = rs1scan;
	}
set_FS:
	if (current_field_sep() == Using_FS)
		set_FS();

	if (first_time)
		first_time = false;
}


/* pty_vs_pipe --- return true if should use pty instead of pipes for `|&' */

/*
 * This works by checking if PROCINFO["command", "pty"] exists and is true.
 */

static bool
pty_vs_pipe(const char *command)
{
#ifdef HAVE_TERMIOS_H
	NODE *val;

	/*
	 * N.B. No need to check for NULL PROCINFO_node, since the
	 * in_PROCINFO function now checks that for us.
	 */
	val = in_PROCINFO(command, "pty", NULL);
	if (val)
		return boolval(val);
#endif /* HAVE_TERMIOS_H */
	return false;
}

/* iopflags2str --- make IOP flags printable */

const char *
iopflags2str(int flag)
{
	static const struct flagtab values[] = {
		{ IOP_IS_TTY, "IOP_IS_TTY" },
		{ IOP_AT_EOF,  "IOP_AT_EOF" },
		{ IOP_CLOSED, "IOP_CLOSED" },
		{ IOP_AT_START,  "IOP_AT_START" },
		{ 0, NULL }
	};

	return genflags2str(flag, values);
}

/* free_rp --- release the memory used by rp */

static void
free_rp(struct redirect *rp)
{
	efree(rp->value);
	efree(rp);
}

/* inetfile --- return true for a /inet special file, set other values */

static bool
inetfile(const char *str, size_t len, struct inet_socket_info *isi)
{
#ifndef HAVE_SOCKETS
	return false;
#else
	const char *cp = str;
	const char *cpend = str + len;
	struct inet_socket_info buf;

	/* syntax: /inet/protocol/localport/hostname/remoteport */
	if (len < 5 || memcmp(cp, "/inet", 5) != 0)
		/* quick exit */
		return false;
	if (! isi)
		isi = & buf;
	cp += 5;
	if (cpend - cp < 2)
		return false;
	switch (*cp) {
	case '/':
		isi->family = AF_UNSPEC;
		break;
	case '4':
		if (*++cp != '/')
			return false;
		isi->family = AF_INET;
		break;
	case '6':
		if (*++cp != '/')
			return false;
		isi->family = AF_INET6;
		break;
	default:
		return false;
	}
	cp++;	/* skip past '/' */

	/* which protocol? */
	if (cpend - cp < 5)
		return false;
	if (memcmp(cp, "tcp/", 4) == 0)
		isi->protocol = SOCK_STREAM;
	else if (memcmp(cp, "udp/", 4) == 0)
		isi->protocol = SOCK_DGRAM;
	else
		return false;
	cp += 4;

	/* which localport? */
	isi->localport.offset = cp-str;
	while (*cp != '/') {
		if (++cp >= cpend)
			return false;
	}
	/*
	 * Require a port, let them explicitly put 0 if
	 * they don't care.
	 */
	if ((isi->localport.len = (cp-str)-isi->localport.offset) == 0)
		return false;

	/* which hostname? */
	if (cpend - cp < 2)
		return false;
	cp++;
	isi->remotehost.offset = cp-str;
	while (*cp != '/') {
		if (++cp >= cpend)
			return false;
	}
	if ((isi->remotehost.len = (cp-str)-isi->remotehost.offset) == 0)
		return false;

	/* which remoteport? */
	if (cpend - cp < 2)
		return false;
	cp++;
	/*
	 * The remote port ends the special file name.
	 *
	 * Here too, require a port, let them explicitly put 0 if
	 * they don't care.
	 */
	isi->remoteport.offset = cp-str;
	while (*cp != '/' && cp < cpend)
		cp++;
	if (cp != cpend || ((isi->remoteport.len = (cp-str)-isi->remoteport.offset) == 0))
		return false;

#ifndef HAVE_GETADDRINFO
	/* final check for IPv6: */
	if (isi->family == AF_INET6)
		fatal(_("IPv6 communication is not supported"));
#endif
	return true;
#endif /* HAVE_SOCKETS */
}

/*
 * in_PROCINFO --- return value for a PROCINFO element with
 *	SUBSEP seperated indices.
 */

static NODE *
in_PROCINFO(const char *pidx1, const char *pidx2, NODE **full_idx)
{
	char *str;
	size_t str_len;
	NODE *r, *sub = NULL;
	NODE *subsep = SUBSEP_node->var_value;

	if (PROCINFO_node == NULL || (pidx1 == NULL && pidx2 == NULL))
		return NULL;

	/* full_idx is in+out parameter */

	if (full_idx)
		sub = *full_idx;

	if (pidx1 != NULL && pidx2 == NULL)
		str_len = strlen(pidx1);
	else if (pidx1 == NULL && pidx2 != NULL)
		str_len = strlen(pidx2);
	else
		str_len = strlen(pidx1) + subsep->stlen	+ strlen(pidx2);

	if (sub == NULL) {
		emalloc(str, char *, str_len + 1);
		sub = make_str_node(str, str_len, ALREADY_MALLOCED);
		if (full_idx)
			*full_idx = sub;
	} else if (str_len != sub->stlen) {
		/* *full_idx != NULL */

		assert(sub->valref == 1);
		erealloc(sub->stptr, char *, str_len + 1);
		sub->stlen = str_len;
	}

	if (pidx1 != NULL && pidx2 == NULL)
		strcpy(sub->stptr, pidx1);
	else if (pidx1 == NULL && pidx2 != NULL)
		strcpy(sub->stptr, pidx2);
	else
		sprintf(sub->stptr, "%s%.*s%s", pidx1, (int)subsep->stlen,
				subsep->stptr, pidx2);

	r = in_array(PROCINFO_node, sub);
	if (! full_idx)
		unref(sub);
	return r;
}


/* get_read_timeout --- get timeout in milliseconds for reading */

static long
get_read_timeout(IOBUF *iop)
{
	long tmout = read_default_timeout;	/* initialized from env. variable in init_io() */

	if (PROCINFO_node != NULL) {
		const char *name = iop->public.name;
		NODE *val = NULL;
		static NODE *full_idx = NULL;
		static const char *last_name = NULL;

		/*
		 * Do not re-construct the full index when last redirection
		 * string is the same as the current; "efficiency_hack++".
		 */
		if (full_idx == NULL || strcmp(name, last_name) != 0) {
			val = in_PROCINFO(name, "READ_TIMEOUT", & full_idx);
			if (last_name != NULL)
				efree((void *) last_name);
			last_name = estrdup(name, strlen(name));
		} else	/* use cached full index */
			val = in_array(PROCINFO_node, full_idx);

		if (val != NULL) {
			(void) force_number(val);
			tmout = get_number_si(val);
		}
	}

	/* overwrite read routine only if an extension has not done so */
	if ((iop->public.read_func == ( ssize_t(*)(int, void *, size_t) ) read) && tmout > 0)
		iop->public.read_func = read_with_timeout;

	return tmout;
}

/*
 * read_with_timeout --- read with a timeout, return failure
 *	if no data is available within the timeout period.
 */

static ssize_t
read_with_timeout(int fd, void *buf, size_t size)
{
#if ! defined(VMS)
	fd_set readfds;
	struct timeval tv;
#ifdef __MINGW32__
	/*
	 * Only sockets can be read with a timeout.  Also, the FD_*
	 * macros work on SOCKET type, not on int file descriptors.
	 */
	SOCKET s = valid_socket(fd);

	if (!s)
		return read(fd, buf, size);
#else
	int s = fd;
#endif

	tv.tv_sec = read_timeout / 1000;
	tv.tv_usec = 1000 * (read_timeout - 1000 * tv.tv_sec);

	FD_ZERO(& readfds);
	FD_SET(s, & readfds);

	errno = 0;
	/*
	 * Note: the 1st arg of 'select' is ignored on MS-Windows, so
	 * it's not a mistake to pass fd+1 there, although we use
	 * sockets, not file descriptors.
	 */
	if (select(fd + 1, & readfds, NULL, NULL, & tv) < 0)
		return -1;

	if (FD_ISSET(s, & readfds))
		return read(fd, buf, size);
	/* else
		timed out */

	/* Set a meaningful errno */
#ifdef ETIMEDOUT
	errno = ETIMEDOUT;
#else
	errno = EAGAIN;
#endif
	return -1;
#else  /* VMS */
	return read(fd, buf, size);
#endif	/* VMS */
}

/*
 * Dummy pass through functions for default output.
 */

/* gawk_fwrite --- like fwrite */

size_t
gawk_fwrite(const void *buf, size_t size, size_t count, FILE *fp, void *opaque)
{
	(void) opaque;

	return fwrite(buf, size, count, fp);
}

/* gawk_fflush --- like fflush */

static int
gawk_fflush(FILE *fp, void *opaque)
{
	(void) opaque;

	return fflush(fp);
}

/* gawk_ferror --- like ferror */

static int
gawk_ferror(FILE *fp, void *opaque)
{
	(void) opaque;

	return ferror(fp);
}

/* gawk_fclose --- like fclose */

static int
gawk_fclose(FILE *fp, void *opaque)
{
	int result;
#ifdef __MINGW32__
	SOCKET s = valid_socket (fileno(fp));
#endif
	(void) opaque;

	result =  fclose(fp);
#ifdef __MINGW32__
	if (s && closesocket(s) == SOCKET_ERROR)
		result = -1;
#endif
	return result;
}

/* init_output_wrapper --- initialize the output wrapper */

static void
init_output_wrapper(awk_output_buf_t *outbuf)
{
	outbuf->name = NULL;
	outbuf->mode = NULL;
	outbuf->fp = NULL;
	outbuf->opaque = NULL;
	outbuf->redirected = awk_false;
	outbuf->gawk_fwrite = gawk_fwrite;
	outbuf->gawk_fflush = gawk_fflush;
	outbuf->gawk_ferror = gawk_ferror;
	outbuf->gawk_fclose = gawk_fclose;
}

/* avoid_flush --- return true if should not flush a pipe every time */

static bool
avoid_flush(const char *name)
{
	static const char bufferpipe[] = "BUFFERPIPE";

	return in_PROCINFO(bufferpipe, NULL, NULL) != NULL
		|| in_PROCINFO(name, bufferpipe, NULL) != NULL;
}

/*
 * See the thread starting at
 * https://lists.gnu.org/archive/html/bug-gawk/2023-12/msg00011.html.
 *
 * We do our version of popen for write pipes in order
 * to be able to reset SIGPIPE. Bleah.
 */

typedef struct write_pipe {
	FILE *fp;
	pid_t pid;
} write_pipe;

static write_pipe *open_pipes = NULL;

/* gawk_popen_write --- open a pipe for writing, set up a FILE * return value. */

static FILE *
gawk_popen_write(const char *cmd)
{
#if defined(VMS) || defined(__MINGW32__)
	return popen(cmd, binmode("w"));
#else
	pid_t childpid;
	int pipefds[2];

	if (pipe(pipefds) < 0)
		return NULL;

	if (open_pipes == NULL) {
		int count = getdtablesize();

		emalloc(open_pipes, write_pipe *, sizeof(write_pipe) * count);
		memset(open_pipes, 0, sizeof(write_pipe) * count);
	}

	childpid = fork();
	if (childpid == 0) {
		// in the child
		(void) close(pipefds[1]);	// close write end in the child
		(void) close(0);
		if (dup(pipefds[0]) != 0)
			fatal(_("gawk_popen_write: failed to move pipe fd to standard input"));
		(void) close(pipefds[0]);
		set_sigpipe_to_default();
		execl("/bin/sh", "sh", "-c", cmd, NULL);
		_exit(errno == ENOENT ? 127 : 126);
	} else if (childpid < 0) {
		(void) close(pipefds[0]);
		(void) close(pipefds[1]);
		return NULL;
	}

	(void) close(pipefds[0]);	// don't need the read end in the parent
	FILE *fp = fdopen(pipefds[1], binmode("w"));
	if (fp == NULL) {
		(void) close(pipefds[1]);
		return NULL;
	}

	int index = pipefds[1];	// use the write file desciptor.
	open_pipes[index].pid = childpid;
	open_pipes[index].fp = fp;

	return fp;
#endif
}

/* gawk_popen_write_close --- close a FILE * that we created */

static int
gawk_popen_write_close(FILE *fp)
{
#if defined(VMS) || defined(__MINGW32__)
	return pclose(fp);
#else
	int status, index;

	if (open_pipes == NULL || fp == NULL) {
		errno = EINVAL;
		return -1;
	}

	index = fileno(fp);
	if (open_pipes[index].fp == fp) {
		(void) fflush(fp);
		(void) fclose(fp);
		status = wait_any(open_pipes[index].pid);

		open_pipes[index].fp = NULL;
		open_pipes[index].pid = 0;

		return status;
	}

	errno = EBADF;
	return -1;
#endif
}
/*
 * main.c -- Code generator and main program for gawk.
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

/* FIX THIS BEFORE EVERY RELEASE: */
#define UPDATE_YEAR	2025

#include "awk.h"
#include "getopt.h"

#ifdef HAVE_MCHECK_H
#include <mcheck.h>
#endif

#define DEFAULT_PROFILE		"awkprof.out"	/* where to put profile */
#define DEFAULT_VARFILE		"awkvars.out"	/* where to put vars */
#define DEFAULT_PREC		53
#define DEFAULT_ROUNDMODE	"N"		/* round to nearest */

static const char *varfile = DEFAULT_VARFILE;
const char *command_file = NULL;	/* debugger commands */

static void usage(int exitval, FILE *fp) ATTRIBUTE_NORETURN;
static void copyleft(void) ATTRIBUTE_NORETURN;
static void cmdline_fs(char *str);
static void init_args(int argc0, int argc, const char *argv0, char **argv);
static void init_vars(void);
static NODE *load_environ(void);
static NODE *load_procinfo(void);
static void catchsig(int sig);
static void version(void) ATTRIBUTE_NORETURN;
static void init_fds(void);
static void init_groupset(void);
static void save_argv(int, char **);
static const char *platform_name();
static void check_pma_security(const char *pma_file);

/* These nodes store all the special variables AWK uses */
NODE *ARGC_node, *ARGIND_node, *ARGV_node, *BINMODE_node, *CONVFMT_node;
static NODE *ENVIRON_node;
NODE *ERRNO_node, *FIELDWIDTHS_node, *FILENAME_node;
NODE *FNR_node, *FPAT_node, *FS_node, *IGNORECASE_node, *LINT_node;
NODE *NF_node, *NR_node, *OFMT_node, *OFS_node, *ORS_node, *PROCINFO_node;
NODE *RLENGTH_node, *RSTART_node, *RS_node, *RT_node, *SUBSEP_node;
NODE *PREC_node, *ROUNDMODE_node;
NODE *TEXTDOMAIN_node;

long NF;
long NR;
long FNR;
int BINMODE;
bool IGNORECASE;
char *OFS;
char *ORS;
char *OFMT;
char *TEXTDOMAIN;

/*
 * CONVFMT is a convenience pointer for the current number to string format.
 * We must supply an initial value to avoid recursion problems of
 *	set_CONVFMT -> fmt_index -> force_string: gets NULL CONVFMT
 * Fun, fun, fun, fun.
 */
const char *CONVFMT = "%.6g";

NODE *Nnull_string;		/* The global null string */

#if defined(HAVE_LOCALE_H)
struct lconv loc;		/* current locale */
static void init_locale(struct lconv *l);
#endif /* defined(HAVE_LOCALE_H) */

/* The name the program was invoked under, for error messages */
const char *myname;

/* A block of AWK code to be run */
INSTRUCTION *code_block = NULL;

char **d_argv;			/* saved argv for debugger restarting */
/*
 * List of rules and functions with first and last instruction (source_line)
 * information; used for profiling and debugging.
 */
INSTRUCTION *rule_list;

int exit_val = EXIT_SUCCESS;		/* exit value */

#if defined(YYDEBUG) || defined(GAWKDEBUG)
extern int yydebug;
#endif

SRCFILE *srcfiles; /* source files */

/*
 * structure to remember variable pre-assignments
 */
struct pre_assign {
	enum assign_type { PRE_ASSIGN = 1, PRE_ASSIGN_FS } type;
	char *val;
};

static struct pre_assign *preassigns = NULL;	/* requested via -v or -F */
static long numassigns = -1;			/* how many of them */

static bool disallow_var_assigns = false;	/* true for --exec */

static void add_preassign(enum assign_type type, char *val);

static void parse_args(int argc, char **argv);
static void set_locale_stuff(void);
static bool stopped_early = false;

bool using_persistent_malloc = false;
enum do_flag_values do_flags = DO_FLAG_NONE;
bool do_itrace = false;			/* provide simple instruction trace */
bool do_optimize = true;		/* apply default optimizations */
static int do_binary = false;		/* hands off my data! */
static int do_version = false;		/* print version info */
static const char *locale = "";		/* default value to setlocale */
static const char *locale_dir = LOCALEDIR;	/* default locale dir */
#ifdef USE_PERSISTENT_MALLOC
const char *get_pma_version(void);
#endif
static bool enable_pma(char **argv);

int use_lc_numeric = false;	/* obey locale for decimal point */

int gawk_mb_cur_max;		/* MB_CUR_MAX value, see comment in main() */

FILE *output_fp;		/* default gawk output, can be redirected in the debugger */
bool output_is_tty = false;	/* control flushing of output */

/* default format for strftime(), available via PROCINFO */
const char def_strftime_format[] = "%a %b %e %H:%M:%S %Z %Y";

extern const char *version_string;

#if defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0
GETGROUPS_T *groupset;		/* current group set */
int ngroups;			/* size of said set */
#endif

void (*lintfunc)(const char *mesg, ...) = r_warning;

/* Sorted by long option name! */
static const struct option optab[] = {
	{ "assign",		required_argument,	NULL,	'v' },
	{ "bignum",		no_argument,		NULL,	'M' },
	{ "characters-as-bytes", no_argument,		& do_binary,	 'b' },
	{ "copyright",		no_argument,		NULL,	'C' },
	{ "csv",		no_argument,		NULL,	'k' },
	{ "debug",		optional_argument,	NULL,	'D' },
	{ "dump-variables",	optional_argument,	NULL,	'd' },
	{ "exec",		required_argument,	NULL,	'E' },
	{ "field-separator",	required_argument,	NULL,	'F' },
	{ "file",		required_argument,	NULL,	'f' },
	{ "gen-pot",		no_argument,		NULL,	'g' },
	{ "help",		no_argument,		NULL,	'h' },
	{ "include",		required_argument,	NULL,	'i' },
	{ "lint",		optional_argument,	NULL,	'L' },
	{ "lint-old",		no_argument,		NULL,	't' },
	{ "load",		required_argument,	NULL,	'l' },
#if defined(LOCALEDEBUG)
	{ "locale",		required_argument,	NULL,	'Z' },
#endif
	{ "non-decimal-data",	no_argument,		NULL,	'n' },
	{ "no-optimize",	no_argument,		NULL,	's' },
	{ "optimize",		no_argument,		NULL,	'O' },
#if defined(YYDEBUG) || defined(GAWKDEBUG)
	{ "parsedebug",		no_argument,		NULL,	'Y' },
#endif
	{ "persist",		optional_argument,	NULL,	'T' },
	{ "posix",		no_argument,		NULL,	'P' },
	{ "pretty-print",	optional_argument,	NULL,	'o' },
	{ "profile",		optional_argument,	NULL,	'p' },
	{ "re-interval",	no_argument,		NULL,	'r' },
	{ "sandbox",		no_argument,		NULL, 	'S' },
	{ "source",		required_argument,	NULL,	'e' },
	{ "trace",		no_argument,		NULL,	'I' },
	{ "traditional",	no_argument,		NULL,	'c' },
	{ "use-lc-numeric",	no_argument,		& use_lc_numeric, 1 },
	{ "version",		no_argument,		& do_version, 'V' },
	{ NULL, 0, NULL, '\0' }
};

/* main --- process args, parse program, run it, clean up */

int
main(int argc, char **argv)
{
	int i;
	bool have_srcfile = false;
	SRCFILE *s;
	char *cp;
#if defined(LOCALEDEBUG)
	const char *initial_locale;
#endif

	myname = gawk_name(argv[0]);

	using_persistent_malloc = enable_pma(argv);
#ifdef HAVE_MPFR
	mp_set_memory_functions(mpfr_mem_alloc, mpfr_mem_realloc, mpfr_mem_free);
#endif

	/* do these checks early */
	if (getenv("TIDYMEM") != NULL)
		do_flags |= DO_TIDY_MEM;

#ifdef HAVE_MCHECK_H
#ifdef HAVE_MTRACE
	if (! using_persistent_malloc && do_tidy_mem)
		mtrace();
#endif /* HAVE_MTRACE */
#endif /* HAVE_MCHECK_H */

	os_arg_fixup(&argc, &argv); /* emulate redirection, expand wildcards */

	if (argc < 2)
		usage(EXIT_FAILURE, stderr);

	if ((cp = getenv("GAWK_LOCALE_DIR")) != NULL)
		locale_dir = cp;

#if defined(LOCALEDEBUG)
	initial_locale = locale;
#endif
	set_locale_stuff();

	(void) signal(SIGSEGV, catchsig);
	(void) signal(SIGFPE, catchsig);
#ifdef SIGBUS
	(void) signal(SIGBUS, catchsig);
#endif

	/*
	 * Ignore SIGPIPE so that writes to pipes that fail don't
	 * kill the process but instead return -1 and set errno.
	 * That lets us print a fatal message instead of dieing suddenly.
	 *
	 * Note that this requires ignoring EPIPE when writing and
	 * flushing stdout/stderr in other parts of the program. E.g.,
	 *
	 * 	gawk 'BEGIN { print "hi" }' | exit
	 *
	 * should not give us "broken pipe" messages --- mainly because
	 * it did not do so in the past and people would complain.
	 */
	ignore_sigpipe();

	/* initialize the null string */
	Nnull_string = make_string("", 0);

	/* Robustness: check that file descriptors 0, 1, 2 are open */
	init_fds();

	/* init array handling. */
	array_init();

	/* init the symbol tables */
	init_symbol_table();

	output_fp = stdout;

	/* initialize global (main) execution context */
	push_context(new_context());

	parse_args(argc, argv);

#if defined(LOCALEDEBUG)
	if (locale != initial_locale)
		set_locale_stuff();
#endif

	/*
	 * In glibc, MB_CUR_MAX is actually a function.  This value is
	 * tested *a lot* in many speed-critical places in gawk. Caching
	 * this value once makes a speed difference.
	 */
	gawk_mb_cur_max = MB_CUR_MAX;

	/* init the cache for checking bytes if they're characters */
	init_btowc_cache();

	/* set up the single byte case table */
	if (gawk_mb_cur_max == 1)
		load_casetable();

	/* check for POSIXLY_CORRECT environment variable */
	if (! do_posix && getenv("POSIXLY_CORRECT") != NULL) {
		do_flags |= DO_POSIX;
		if (do_lint)
			lintwarn(
	_("environment variable `POSIXLY_CORRECT' set: turning on `--posix'"));
	}

	// Checks for conflicting command-line arguments.
	if (do_posix) {
		use_lc_numeric = true;
		if (do_traditional)	/* both on command line */
			warning(_("`--posix' overrides `--traditional'"));
		else
			do_flags |= DO_TRADITIONAL;
			/*
			 * POSIX compliance also implies
			 * no GNU extensions either.
			 */
	}

	if (do_traditional && do_non_decimal_data) {
		do_flags &= ~DO_NON_DEC_DATA;
		warning(_("`--posix'/`--traditional' overrides `--non-decimal-data'"));
	}

	if (do_binary) {
		if (do_posix)
			warning(_("`--posix' overrides `--characters-as-bytes'"));
		else {
			gawk_mb_cur_max = 1;	/* hands off my data! */
#if defined(LC_ALL)
			setlocale(LC_ALL, "C");
#endif
		}
	}

	if (do_csv && do_posix)
		fatal(_("`--posix' and `--csv' conflict"));

	if (do_lint) {
		if (os_is_setuid())
			lintwarn(_("running %s setuid root may be a security problem"), myname);
		if (do_intervals)
			lintwarn(_("The -r/--re-interval options no longer have any effect"));
	}

	if (do_debug)	/* Need to register the debugger pre-exec hook before any other */
		init_debug();

#ifdef HAVE_MPFR
	/* Set up MPFR defaults, and register pre-exec hook to process arithmetic opcodes */
	if (do_mpfr)
		init_mpfr(DEFAULT_PREC, DEFAULT_ROUNDMODE);
#endif

	/* load group set */
	init_groupset();

#ifdef HAVE_MPFR
	if (do_mpfr) {
		mpz_init(Nnull_string->mpg_i);
		Nnull_string->flags = (MALLOC|STRCUR|STRING|MPZN|NUMCUR|NUMBER);
	} else
#endif
	{
		Nnull_string->numbr = 0.0;
		Nnull_string->flags = (MALLOC|STRCUR|STRING|NUMCUR|NUMBER);
	}

	/*
	 * Tell the regex routines how they should work.
	 * Do this before initializing variables, since
	 * they could want to do a regexp compile.
	 */
	resetup();

	/* Set up the special variables */
	init_vars();

	/* set up CSV */
	init_csv_records();
	init_csv_fields();

	/* Set up the field variables */
	init_fields();

	/* Now process the pre-assignments */
	int dash_v_errs = 0;	// bad stuff for -v
	for (i = 0; i <= numassigns; i++) {
		if (preassigns[i].type == PRE_ASSIGN)
			dash_v_errs += (arg_assign(preassigns[i].val, true) == false);
		else	/* PRE_ASSIGN_FS */
			cmdline_fs(preassigns[i].val);
		efree(preassigns[i].val);
	}

	if (preassigns != NULL)
		efree(preassigns);

	if ((BINMODE & BINMODE_INPUT) != 0)
		if (os_setbinmode(fileno(stdin), O_BINARY) == -1)
			fatal(_("cannot set binary mode on stdin: %s"), strerror(errno));
	if ((BINMODE & BINMODE_OUTPUT) != 0) {
		if (os_setbinmode(fileno(stdout), O_BINARY) == -1)
			fatal(_("cannot set binary mode on stdout: %s"), strerror(errno));
		if (os_setbinmode(fileno(stderr), O_BINARY) == -1)
			fatal(_("cannot set binary mode on stderr: %s"), strerror(errno));
	}

#ifdef GAWKDEBUG
	setbuf(stdout, (char *) NULL);	/* make debugging easier */
#endif
	if (os_isatty(fileno(stdout)))
		output_is_tty = true;

	/* arrange to save free lists if using PMA */
	atexit(pma_save_free_lists);

	/* initialize API before loading extension libraries */
	init_ext_api();

	/* load extension libs */
	for (s = srcfiles->next; s != srcfiles; s = s->next) {
		if (s->stype == SRC_EXTLIB)
			load_ext(s->fullpath);
		else if (s->stype != SRC_INC)
			have_srcfile = true;
	}

	/* do version check after extensions are loaded to get extension info */
	if (do_version)
		version();

	/* No -f or --source options, use next arg */
	if (! have_srcfile) {
		if (optind > argc - 1 || stopped_early) /* no args left or no program */
			usage(EXIT_FAILURE, stderr);
		(void) add_srcfile(SRC_CMDLINE, argv[optind], srcfiles, NULL, NULL);
		optind++;
	}

	/* Select the interpreter routine */
	init_interpret();

	init_args(optind, argc,
			do_posix ? argv[0] : myname,
			argv);

#if defined(LC_NUMERIC)
	/*
	 * FRAGILE!  CAREFUL!
	 * Pre-initing the variables with arg_assign() can change the
	 * locale.  Force it to C before parsing the program.
	 */
	setlocale(LC_NUMERIC, "C");
#endif
	/* Read in the program */
	if (parse_program(& code_block, false) != 0 || dash_v_errs > 0)
		exit(EXIT_FAILURE);

	if (do_intl)
		exit(EXIT_SUCCESS);

	set_current_namespace(awk_namespace);

	install_builtins();

	if (do_lint)
		shadow_funcs();

	if (do_lint && code_block->nexti->opcode == Op_atexit)
		lintwarn(_("no program text at all!"));

	load_symbols();

	if (do_profile)
		init_profiling_signals();

#if defined(LC_NUMERIC)
	/*
	 * See comment above about using locale's decimal point.
	 *
	 * 10/2005:
	 * Bitter experience teaches us that most people the world over
	 * use period as the decimal point, not whatever their locale
	 * uses.  Thus, only use the locale's decimal point if being
	 * posixly anal-retentive.
	 *
	 * 7/2007:
	 * Be a little bit kinder. Allow the --use-lc-numeric option
	 * to also use the local decimal point. This avoids the draconian
	 * strictness of POSIX mode if someone just wants to parse their
	 * data using the local decimal point.
	 */
	if (use_lc_numeric)
		setlocale(LC_NUMERIC, locale);
#endif

	init_io();
	output_fp = stdout;

	if (do_debug)
		debug_prog(code_block);
	else if (do_pretty_print && ! do_profile)
		;	/* run pretty printer only. */
	else
		interpret(code_block);

	if (do_pretty_print) {
		set_current_namespace(awk_namespace);
		dump_prog(code_block);
		dump_funcs();
		close_prof_file();
	}

	if (do_dump_vars)
		dump_vars(varfile);

#ifdef HAVE_MPFR
	if (do_mpfr)
		cleanup_mpfr();
#endif

	if (do_tidy_mem)
		release_all_vars();

	final_exit(exit_val);
	return exit_val;	/* to suppress warnings */
}

/* add_preassign --- add one element to preassigns */

static void
add_preassign(enum assign_type type, char *val)
{
	static long alloc_assigns;		/* for how many are allocated */

#define INIT_SRC 4

	++numassigns;

	if (preassigns == NULL) {
		emalloc(preassigns, struct pre_assign *, INIT_SRC * sizeof(struct pre_assign));
		alloc_assigns = INIT_SRC;
	} else if (numassigns >= alloc_assigns) {
		alloc_assigns *= 2;
		erealloc(preassigns, struct pre_assign *, alloc_assigns * sizeof(struct pre_assign));
	}
	preassigns[numassigns].type = type;
	preassigns[numassigns].val = estrdup(val, strlen(val));

#undef INIT_SRC
}

/* usage --- print usage information and exit */

static void
usage(int exitval, FILE *fp)
{
	static const char gnu_url[] = "https://ftp.gnu.org/gnu/gawk";
	static const char beta_url[] = "https://www.skeeve.com/gawk";
	const char *url;
	int major_version, minor_version, patchlevel;

	major_version = minor_version = patchlevel = 0;
	sscanf(PACKAGE_VERSION, "%d.%d.%d", & major_version, & minor_version, & patchlevel);

	/* Not factoring out common stuff makes it easier to translate. */
	fprintf(fp, _("Usage: %s [POSIX or GNU style options] -f progfile [--] file ...\n"),
		myname);
	fprintf(fp, _("Usage: %s [POSIX or GNU style options] [--] %cprogram%c file ...\n"),
			myname, quote, quote);

	/* GNU long options info. This is too many options. */

	fputs(_("POSIX options:\t\tGNU long options: (standard)\n"), fp);
	fputs(_("\t-f progfile\t\t--file=progfile\n"), fp);
	fputs(_("\t-F fs\t\t\t--field-separator=fs\n"), fp);
	fputs(_("\t-v var=val\t\t--assign=var=val\n"), fp);
	fputs(_("Short options:\t\tGNU long options: (extensions)\n"), fp);
	fputs(_("\t-b\t\t\t--characters-as-bytes\n"), fp);
	fputs(_("\t-c\t\t\t--traditional\n"), fp);
	fputs(_("\t-C\t\t\t--copyright\n"), fp);
	fputs(_("\t-d[file]\t\t--dump-variables[=file]\n"), fp);
	fputs(_("\t-D[file]\t\t--debug[=file]\n"), fp);
	fputs(_("\t-e 'program-text'\t--source='program-text'\n"), fp);
	fputs(_("\t-E file\t\t\t--exec=file\n"), fp);
	fputs(_("\t-g\t\t\t--gen-pot\n"), fp);
	fputs(_("\t-h\t\t\t--help\n"), fp);
	fputs(_("\t-i includefile\t\t--include=includefile\n"), fp);
	fputs(_("\t-I\t\t\t--trace\n"), fp);
	fputs(_("\t-k\t\t\t--csv\n"), fp);
	fputs(_("\t-l library\t\t--load=library\n"), fp);
	/*
	 * TRANSLATORS: the "fatal", "invalid" and "no-ext" here are literal
	 * values, they should not be translated. Thanks.
	 */
	fputs(_("\t-L[fatal|invalid|no-ext]\t--lint[=fatal|invalid|no-ext]\n"), fp);
	fputs(_("\t-M\t\t\t--bignum\n"), fp);
	fputs(_("\t-N\t\t\t--use-lc-numeric\n"), fp);
	fputs(_("\t-n\t\t\t--non-decimal-data\n"), fp);
	fputs(_("\t-o[file]\t\t--pretty-print[=file]\n"), fp);
	fputs(_("\t-O\t\t\t--optimize\n"), fp);
	fputs(_("\t-p[file]\t\t--profile[=file]\n"), fp);
	fputs(_("\t-P\t\t\t--posix\n"), fp);
	fputs(_("\t-r\t\t\t--re-interval\n"), fp);
	fputs(_("\t-s\t\t\t--no-optimize\n"), fp);
	fputs(_("\t-S\t\t\t--sandbox\n"), fp);
	fputs(_("\t-t\t\t\t--lint-old\n"), fp);
	fputs(_("\t-V\t\t\t--version\n"), fp);
#ifdef GAWKDEBUG
	fputs(_("\t-Y\t\t\t--parsedebug\n"), fp);
#endif
#ifdef GAWKDEBUG
	fputs(_("\t-Z locale-name\t\t--locale=locale-name\n"), fp);
#endif

	/* This is one string to make things easier on translators. */
	/* TRANSLATORS: --help output (end)
	   no-wrap */
	fputs(_("\nTo report bugs, use the `gawkbug' program.\n\
For full instructions, see the node `Bugs' in `gawk.info'\n\
which is section `Reporting Problems and Bugs' in the\n\
printed version.  This same information may be found at\n\
https://www.gnu.org/software/gawk/manual/html_node/Bugs.html.\n\
PLEASE do NOT try to report bugs by posting in comp.lang.awk,\n\
or by using a web forum such as Stack Overflow.\n\n"), fp);

	// 5.2.60 is beta release on master, will become 5.3.0.
	// 5.2.2a is beta release on stable, will become 5.2.3.
	if (patchlevel >= 60 || isalpha((int) PACKAGE_VERSION[strlen(PACKAGE_VERSION)-1]))
		url = beta_url;
	else
		url = gnu_url;

	/* ditto */
	fprintf(fp, _("Source code for gawk may be obtained from\n%s/gawk-%s.tar.gz\n\n"),
		url, PACKAGE_VERSION);

	/* ditto */
	fputs(_("gawk is a pattern scanning and processing language.\n\
By default it reads standard input and writes standard output.\n\n"), fp);

	/* ditto */
	fprintf(fp, _("Examples:\n\t%s '{ sum += $1 }; END { print sum }' file\n\
\t%s -F: '{ print $1 }' /etc/passwd\n"), myname, myname);

	fflush(fp);

	if (ferror(fp)) {
		os_maybe_set_errno();

		/* don't warn about stdout/stderr if EPIPE, but do error exit */
		if (errno == EPIPE)
			die_via_sigpipe();

		if (fp == stdout)
			warning(_("error writing standard output: %s"), strerror(errno));
		else if (fp == stderr)
			warning(_("error writing standard error: %s"), strerror(errno));

		// some other problem than SIGPIPE
		exit(EXIT_FAILURE);
	}

	exit(exitval);
}

/* copyleft --- print out the short GNU copyright information */

static void
copyleft()
{
	static const char blurb_part1[] =
	  N_("Copyright (C) 1989, 1991-%d Free Software Foundation.\n\
\n\
This program is free software; you can redistribute it and/or modify\n\
it under the terms of the GNU General Public License as published by\n\
the Free Software Foundation; either version 3 of the License, or\n\
(at your option) any later version.\n\
\n");
	static const char blurb_part2[] =
	  N_("This program is distributed in the hope that it will be useful,\n\
but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
GNU General Public License for more details.\n\
\n");
	static const char blurb_part3[] =
	  N_("You should have received a copy of the GNU General Public License\n\
along with this program. If not, see http://www.gnu.org/licenses/.\n");

	/* multiple blurbs are needed for some brain dead compilers. */
	printf(_(blurb_part1), UPDATE_YEAR);	/* Last update year */
	fputs(_(blurb_part2), stdout);
	fputs(_(blurb_part3), stdout);
	fflush(stdout);

	if (ferror(stdout)) {
		os_maybe_set_errno();

		/* don't warn about stdout if EPIPE, but do error exit */
		if (errno != EPIPE)
			warning(_("error writing standard output: %s"), strerror(errno));
		exit(EXIT_FAILURE);
	}

	exit(EXIT_SUCCESS);
}

/* cmdline_fs --- set FS from the command line */

static void
cmdline_fs(char *str)
{
	NODE **tmp;

	tmp = &FS_node->var_value;
	unref(*tmp);
	/*
	 * Only if in full compatibility mode check for the stupid special
	 * case so -F\t works as documented in awk book even though the shell
	 * hands us -Ft.  Bleah!
	 *
	 * Thankfully, POSIX didn't propagate this "feature".
	 */
	if (str[0] == 't' && str[1] == '\0') {
		if (do_lint)
			lintwarn(_("-Ft does not set FS to tab in POSIX awk"));
		if (do_traditional && ! do_posix)
			str[0] = '\t';
	}

	*tmp = make_str_node(str, strlen(str), SCAN); /* do process escapes */
	set_FS();
}

/* init_args --- set up ARGV from stuff on the command line */

static void
init_args(int argc0, int argc, const char *argv0, char **argv)
{
	int i, j;
	NODE *sub, *val;
	NODE *shadow_node = NULL;

	ARGV_node = install_symbol(estrdup("ARGV", 4), Node_var_array);
	sub = make_number(0.0);
	val = make_string(argv0, strlen(argv0));
	val->flags |= USER_INPUT;
	assoc_set(ARGV_node, sub, val);

	if (do_sandbox) {
		shadow_node = make_array();
		sub = make_string(argv0, strlen(argv0));
		val = make_number(0.0);
		assoc_set(shadow_node, sub, val);
	}


	for (i = argc0, j = 1; i < argc; i++, j++) {
		sub = make_number((AWKNUM) j);
		val = make_string(argv[i], strlen(argv[i]));
		val->flags |= USER_INPUT;
		assoc_set(ARGV_node, sub, val);

		if (do_sandbox) {
			sub = make_string(argv[i], strlen(argv[i]));
			val = make_number(0.0);
			assoc_set(shadow_node, sub, val);
		}
	}

	ARGC_node = install_symbol(estrdup("ARGC", 4), Node_var);
	ARGC_node->var_value = make_number((AWKNUM) j);

	if (do_sandbox)
		init_argv_array(ARGV_node, shadow_node);
}


/*
 * Set all the special variables to their initial values.
 * Note that some of the variables that have set_FOO routines should
 * *N*O*T* have those routines called upon initialization, and thus
 * they have NULL entries in that field. This is notably true of FS
 * and IGNORECASE.
 */

struct varinit {
	NODE **spec;
	const char *name;
	const char *strval;
	AWKNUM numval;
	Func_ptr update;
	Func_ptr assign;
	bool do_assign;
	int flags;
#define NO_INSTALL	0x01
#define NON_STANDARD	0x02
#define NOT_OFF_LIMITS	0x04	/* may be accessed by extension function */
};

static const struct varinit varinit[] = {
{NULL,		"ARGC",		NULL,	0,  NULL, NULL,	false, NO_INSTALL },
{&ARGIND_node,	"ARGIND",	NULL,	0,  NULL, NULL,	false, NON_STANDARD },
{NULL,		"ARGV",		NULL,	0,  NULL, NULL,	false, NO_INSTALL },
{&BINMODE_node,	"BINMODE",	NULL,	0,  NULL, set_BINMODE,	false, NON_STANDARD },
{&CONVFMT_node,	"CONVFMT",	"%.6g",	0,  NULL, set_CONVFMT,true, 	0 },
{NULL,		"ENVIRON",	NULL,	0,  NULL, NULL,	false, NO_INSTALL },
{&ERRNO_node,	"ERRNO",	"",	0,  NULL, NULL,	false, NON_STANDARD },
{&FIELDWIDTHS_node, "FIELDWIDTHS", "",	0,  NULL, set_FIELDWIDTHS,	false, NON_STANDARD },
{&FILENAME_node, "FILENAME",	"",	0,  NULL, NULL,	false, 0 },
{&FNR_node,	"FNR",		NULL,	0,  update_FNR, set_FNR,	true, 0 },
{&FS_node,	"FS",		" ",	0,  NULL, set_FS,	false, 0 },
{&FPAT_node,	"FPAT",		"[^[:space:]]+", 0,  NULL, set_FPAT,	false, NON_STANDARD },
{&IGNORECASE_node, "IGNORECASE", NULL,	0,  NULL, set_IGNORECASE,	false, NON_STANDARD },
{&LINT_node,	"LINT",		NULL,	0,  NULL, set_LINT,	false, NON_STANDARD },
{&PREC_node,	"PREC",		NULL,	DEFAULT_PREC,	NULL,	set_PREC,	false,	NON_STANDARD},
{&NF_node,	"NF",		NULL,	-1, update_NF, set_NF,	false, 0 },
{&NR_node,	"NR",		NULL,	0,  update_NR, set_NR,	true, 0 },
{&OFMT_node,	"OFMT",		"%.6g",	0,  NULL, set_OFMT,	true, 0 },
{&OFS_node,	"OFS",		" ",	0,  NULL, set_OFS,	true, 0 },
{&ORS_node,	"ORS",		"\n",	0,  NULL, set_ORS,	true, 0 },
{NULL,		"PROCINFO",	NULL,	0,  NULL, NULL,	false, NO_INSTALL | NON_STANDARD | NOT_OFF_LIMITS },
{&RLENGTH_node, "RLENGTH",	NULL,	0,  NULL, NULL,	false, 0 },
{&ROUNDMODE_node, "ROUNDMODE",	DEFAULT_ROUNDMODE,	0,  NULL, set_ROUNDMODE,	false, NON_STANDARD },
{&RS_node,	"RS",		"\n",	0,  NULL, set_RS,	true, 0 },
{&RSTART_node,	"RSTART",	NULL,	0,  NULL, NULL,	false, 0 },
{&RT_node,	"RT",		"",	0,  NULL, NULL,	false, NON_STANDARD },
{&SUBSEP_node,	"SUBSEP",	"\034",	0,  NULL, set_SUBSEP,	true, 0 },
{&TEXTDOMAIN_node,	"TEXTDOMAIN",	"messages",	0,  NULL, set_TEXTDOMAIN,	true, NON_STANDARD },
{0,		NULL,		NULL,	0,  NULL, NULL,	false, 0 },
};

/* init_vars --- actually initialize everything in the symbol table */

static void
init_vars()
{
	const struct varinit *vp;
	NODE *n;

	for (vp = varinit; vp->name != NULL; vp++) {
		if ((vp->flags & NO_INSTALL) != 0)
			continue;
		n = *(vp->spec) = install_symbol(estrdup(vp->name, strlen(vp->name)), Node_var);
		if (vp->strval != NULL)
			n->var_value = make_string(vp->strval, strlen(vp->strval));
		else
			n->var_value = make_number(vp->numval);
		n->var_assign = (Func_ptr) vp->assign;
		n->var_update = (Func_ptr) vp->update;
		if (vp->do_assign)
			(*(vp->assign))();
	}

	/* Load PROCINFO and ENVIRON */
	if (! do_traditional)
		load_procinfo();
	load_environ();
}

/* path_environ --- put path variable into environment if not already there */

static void
path_environ(const char *pname, const char *dflt)
{
	const char *val;
	NODE **aptr;
	NODE *tmp;

	tmp = make_string(pname, strlen(pname));
	/*
	 * On VMS, environ[] only holds a subset of what getenv() can
	 * find, so look AWKPATH up before resorting to default path.
	 */
	val = getenv(pname);
	if (val == NULL || *val == '\0')
		val = dflt;
	aptr = assoc_lookup(ENVIRON_node, tmp);
	/*
	 * If original value was the empty string, set it to
	 * the default value.
	 */
	if ((*aptr)->stlen == 0) {
		unref(*aptr);
		*aptr = make_string(val, strlen(val));
	}

	unref(tmp);
}

/* load_environ --- populate the ENVIRON array */

static NODE *
load_environ()
{
#if ! (defined(VMS) && defined(__DECC))
	extern char **environ;
#endif
	char *var, *val;
	int i;
	NODE *sub, *newval;
	static bool been_here = false;

	if (been_here)
		return ENVIRON_node;

	been_here = true;

	ENVIRON_node = install_symbol(estrdup("ENVIRON", 7), Node_var_array);

	// Force string functions; if the first element in environ[]
	// looks like "0=foo" we end up with the cint_funcs and that's
	// not what we want, we just get core dumps.
	ENVIRON_node->array_funcs = & str_array_func;

	for (i = 0; environ[i] != NULL; i++) {
		static char nullstr[] = "";

		var = environ[i];
		val = strchr(var, '=');
		if (val != NULL)
			*val++ = '\0';
		else
			val = nullstr;
		sub = make_string(var, strlen(var));
		newval = make_string(val, strlen(val));
		newval->flags |= USER_INPUT;
		assoc_set(ENVIRON_node, sub, newval);

		/* restore '=' so that system() gets a valid environment */
		if (val != nullstr)
			*--val = '=';
	}
	/*
	 * Put AWKPATH and AWKLIBPATH into ENVIRON if not already there.
	 * This allows querying it from within awk programs.
	 *
	 * October 2014:
	 * If their values are "", override with the default values;
	 * since 2.10 AWKPATH used default value if environment's
	 * value was "".
	 */
	path_environ("AWKPATH", defpath);
	path_environ("AWKLIBPATH", deflibpath);

	/* set up array functions */
	init_env_array(ENVIRON_node);

	return ENVIRON_node;
}

/* load_procinfo_argv --- populate PROCINFO["argv"] */

static void
load_procinfo_argv()
{
	NODE *sub;
	NODE *val;
	NODE *argv_array;
	int i;

	// build the sub-array first
	getnode(argv_array);
 	memset(argv_array, '\0', sizeof(NODE));  /* valgrind wants this */
	null_array(argv_array);
	argv_array->parent_array = PROCINFO_node;
	argv_array->vname = estrdup("argv", 4);
	for (i = 0; d_argv[i] != NULL; i++) {
		sub = make_number(i);
		val = make_string(d_argv[i], strlen(d_argv[i]));
		assoc_set(argv_array, sub, val);
	}

	// hook it into PROCINFO
	sub = make_string("argv", 4);
	assoc_set(PROCINFO_node, sub, argv_array);
}

/* load_procinfo --- populate the PROCINFO array */

static NODE *
load_procinfo()
{
#if defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0
	int i;
#endif
#if (defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0) || defined(HAVE_MPFR)
	char name[100];
#endif
	AWKNUM value;
	static bool been_here = false;

	if (been_here)
		return PROCINFO_node;

	been_here = true;

	PROCINFO_node = install_symbol(estrdup("PROCINFO", 8), Node_var_array);

	update_PROCINFO_str("version", VERSION);
	update_PROCINFO_str("strftime", def_strftime_format);
	update_PROCINFO_str("platform", platform_name());

#ifdef HAVE_MPFR
	sprintf(name, "GNU MPFR %s", mpfr_get_version());
	update_PROCINFO_str("mpfr_version", name);
	sprintf(name, "GNU MP %s", gmp_version);
	update_PROCINFO_str("gmp_version", name);
	update_PROCINFO_num("prec_max", MPFR_PREC_MAX);
	update_PROCINFO_num("prec_min", MPFR_PREC_MIN);
#endif

#ifdef DYNAMIC
	update_PROCINFO_num("api_major", GAWK_API_MAJOR_VERSION);
	update_PROCINFO_num("api_minor", GAWK_API_MINOR_VERSION);
#endif

#ifdef GETPGRP_VOID
#define getpgrp_arg() /* nothing */
#else
#define getpgrp_arg() getpid()
#endif

	value = getpgrp(getpgrp_arg());
	update_PROCINFO_num("pgrpid", value);

	/*
	 * Could put a lot of this into a table, but then there's
	 * portability problems declaring all the functions. So just
	 * do it the slow and stupid way. Sigh.
	 */

	value = getpid();
	update_PROCINFO_num("pid", value);

	value = getppid();
	update_PROCINFO_num("ppid", value);

	value = getuid();
	update_PROCINFO_num("uid", value);

	value = geteuid();
	update_PROCINFO_num("euid", value);

	value = getgid();
	update_PROCINFO_num("gid", value);

	value = getegid();
	update_PROCINFO_num("egid", value);

	update_PROCINFO_str("FS", current_field_sep_str());

#if defined (HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0
	for (i = 0; i < ngroups; i++) {
		sprintf(name, "group%d", i + 1);
		value = groupset[i];
		update_PROCINFO_num(name, value);
	}
	if (groupset) {
		efree(groupset);
		groupset = NULL;
	}
#endif

#ifdef USE_PERSISTENT_MALLOC
	update_PROCINFO_str("pma", get_pma_version());
#endif /* USE_PERSISTENT_MALLOC */

	if (do_csv)
		update_PROCINFO_num("CSV", 1);

	load_procinfo_argv();
	return PROCINFO_node;
}

/* is_std_var --- return true if a variable is a standard variable */

int
is_std_var(const char *var)
{
	const struct varinit *vp;

	for (vp = varinit; vp->name != NULL; vp++) {
		if (strcmp(vp->name, var) == 0) {
			if ((do_traditional || do_posix) && (vp->flags & NON_STANDARD) != 0)
				return false;

			return true;
		}
	}

	return false;
}

/*
 * is_off_limits_var --- return true if a variable is off limits
 * 			to extension functions
 */

int
is_off_limits_var(const char *var)
{
	const struct varinit *vp;

	for (vp = varinit; vp->name != NULL; vp++) {
		if (strcmp(vp->name, var) == 0)
			return ((vp->flags & NOT_OFF_LIMITS) == 0);
	}

	return false;
}

/* get_spec_varname --- return the name of a special variable
	with the given assign or update routine.
*/

const char *
get_spec_varname(Func_ptr fptr)
{
	const struct varinit *vp;

	if (! fptr)
		return NULL;
	for (vp = varinit; vp->name != NULL; vp++) {
		if (vp->assign == fptr || vp->update == fptr)
			return vp->name;
	}
	return NULL;
}


/* arg_assign --- process a command-line assignment */

int
arg_assign(char *arg, bool initing)
{
	char *cp, *cp2;
	bool badvar;
	NODE *var;
	NODE *it;
	NODE **lhs;
	long save_FNR;

	if (! initing && disallow_var_assigns)
		return false;	/* --exec */

	cp = strchr(arg, '=');

	if (cp == NULL) {
		if (! initing)
			return false;	/* This is file name, not assignment. */

		fprintf(stderr,
			_("%s: `%s' argument to `-v' not in `var=value' form\n\n"),
			myname, arg);
		usage(EXIT_FAILURE, stderr);
	}

	*cp++ = '\0';

	/* avoid false source indications in a fatal message */
	source = NULL;
	sourceline = 0;
	save_FNR = FNR;
	FNR = 0;

	/* first check that the variable name has valid syntax */
	badvar = false;
	if (! is_letter((unsigned char) arg[0]))
		badvar = true;
	else
		for (cp2 = arg+1; *cp2; cp2++)
			if (! is_identchar((unsigned char) *cp2) && *cp2 != ':') {
				badvar = true;
				break;
			}

	if (badvar) {
		if (initing)
			fatal(_("`%s' is not a legal variable name"), arg);

		if (do_lint)
			lintwarn(_("`%s' is not a variable name, looking for file `%s=%s'"),
				arg, arg, cp);

		goto done;
	}

	// Assigning a string or typed regex

	if (! validate_qualified_name(arg)) {
		badvar = true;
		goto done;
	}

	if (check_special(arg) >= 0)
		fatal(_("cannot use gawk builtin `%s' as variable name"), arg);

	if (! initing) {
		var = lookup(arg);
		if (var != NULL && var->type == Node_func)
			fatal(_("cannot use function `%s' as variable name"), arg);
	}

	cp2 = cp + strlen(cp) - 1;	// end char
	if (! do_traditional
	    && strlen(cp) >= 3		// '@/' doesn't do it.
	    && cp[0] == '@' && cp[1] == '/' && *cp2 == '/') {
		// typed regex
		size_t len = strlen(cp) - 3;

		ezalloc(cp2, char *, len + 1);
		memcpy(cp2, cp + 2, len);

		it = make_typed_regex(cp2, len);
		// fall through to variable setup
	} else {
		// string assignment

		// POSIX disallows any newlines inside strings
		// The scanner handles that for program files.
		// We have to check here for strings passed to -v.
		if (do_posix && strchr(cp, '\n') != NULL)
			fatal(_("POSIX does not allow physical newlines in string values"));

		/*
		 * BWK awk expands escapes inside assignments.
		 * This makes sense, so we do it too.
		 * In addition, remove \-<newline> as in scanning.
		 */
		it = make_str_node(cp, strlen(cp), SCAN);
		it->flags |= USER_INPUT;
#ifdef LC_NUMERIC
		/*
		 * See comment above about locale decimal point.
		 */
		if (do_posix)
			setlocale(LC_NUMERIC, "C");
#endif /* LC_NUMERIC */
		(void) force_number(it);
#ifdef LC_NUMERIC
		if (do_posix)
			setlocale(LC_NUMERIC, locale);
#endif /* LC_NUMERIC */
	}

	/*
	 * since we are restoring the original text of ARGV later,
	 * need to copy the variable name part if we don't want
	 * name like v=abc instead of just v in var->vname
	 */

	cp2 = estrdup(arg, cp - arg);	/* var name */

	var = variable(0, cp2, Node_var);
	if (var == NULL)	/* error */
		final_exit(EXIT_FATAL);

	if (var->type == Node_var && var->var_update)
		var->var_update();
	lhs = get_lhs(var, false);
	unref(*lhs);
	*lhs = it;
	/* check for set_FOO() routine */
	if (var->type == Node_var && var->var_assign)
		var->var_assign();

done:
	if (! initing)
		*--cp = '=';	/* restore original text of ARGV */
	FNR = save_FNR;
	return ! badvar;
}

/* catchsig --- catch signals */

static void
catchsig(int sig)
{
	if (sig == SIGFPE) {
		fatal(_("floating point exception"));
	} else if (sig == SIGSEGV
#ifdef SIGBUS
	        || sig == SIGBUS
#endif
	) {
		if (errcount > 0)	// assume a syntax error corrupted our data structures
			exit(EXIT_FATAL);

		set_loc(__FILE__, __LINE__);
		msg(_("fatal error: internal error"));
		/* fatal won't abort() if not compiled for debugging */
		// GLIBC 2.27 doesn't necessarily flush on abort. Sigh.
		fflush(NULL);
		abort();
	} else
		cant_happen("unexpected signal, number %d (%s)", sig, strsignal(sig));
	/* NOTREACHED */
}

#ifdef USE_PERSISTENT_MALLOC
/* get_pma_version --- get a usable version string out of PMA */

const char *
get_pma_version(void)
{
	static char buf[200];
	const char *open, *close;
	char *out;
	const char *in;

	/*
	 * The default version string looks like this:
	 * 2022.08Aug.03.1659520468 (Avon 7)
	 * Yucko. Just pull out the bits between the parens.
	 */

	open = strchr(pma_version, '(');
	if (open == NULL)
		return pma_version;	// sigh.

	open++;
	close = strchr(open, ')');
	if (close == NULL)
		return pma_version;	// sigh, again.

	// copy over the short name
	for (out = buf, in = open; in < close;)
		*out++ = *in++;

	*out++ = '\0';

	return buf;
}
#endif

/* version --- print version message */

static void
version()
{
	printf("%s", version_string);
#ifdef DYNAMIC
	printf(", API %d.%d", GAWK_API_MAJOR_VERSION, GAWK_API_MINOR_VERSION);
#endif
#ifdef USE_PERSISTENT_MALLOC
	printf(", PMA %s", get_pma_version());
#endif
#ifdef HAVE_MPFR
	printf(", (GNU MPFR %s, GNU MP %s)", mpfr_get_version(), gmp_version);
#endif
	printf("\n");
	print_ext_versions();

	/*
	 * Per GNU coding standards, print copyright info,
	 * then exit successfully, do nothing else.
	 */
	copyleft();
	exit(EXIT_SUCCESS);
}

/* init_fds --- check for 0, 1, 2, open on /dev/null if possible */

static void
init_fds()
{
	struct stat sbuf;
	int fd;
	int newfd;
	char const *const opposite_mode[] = {"w", "r", "r"};

	/* maybe no stderr, don't bother with error mesg */
	for (fd = 0; fd <= 2; fd++) {
		if (fstat(fd, &sbuf) < 0) {
#if MAKE_A_HEROIC_EFFORT
			if (do_lint)
				lintwarn(_("no pre-opened fd %d"), fd);
#endif
			newfd = devopen("/dev/null", opposite_mode[fd]);
			/* turn off some compiler warnings "set but not used" */
			newfd += 0;
#ifdef MAKE_A_HEROIC_EFFORT
			if (do_lint && newfd < 0)
				lintwarn(_("could not pre-open /dev/null for fd %d"), fd);
#endif
		}
	}
}

/* init_groupset --- initialize groupset */

static void
init_groupset()
{
#if defined(HAVE_GETGROUPS) && defined(NGROUPS_MAX) && NGROUPS_MAX > 0
#ifdef GETGROUPS_NOT_STANDARD
	/* For systems that aren't standards conformant, use old way. */
	ngroups = NGROUPS_MAX;
#else
	/*
	 * If called with 0 for both args, return value is
	 * total number of groups.
	 */
	ngroups = getgroups(0, NULL);
#endif
	/* If an error or no groups, just give up and get on with life. */
	if (ngroups <= 0)
		return;

	/* fill in groups */
	emalloc(groupset, GETGROUPS_T *, ngroups * sizeof(GETGROUPS_T));

	ngroups = getgroups(ngroups, groupset);
	/* same thing here, give up but keep going */
	if (ngroups == -1) {
		efree(groupset);
		ngroups = 0;
		groupset = NULL;
	}
#endif
}

/* estrdup --- duplicate a string */

char *
estrdup(const char *str, size_t len)
{
	char *s;
	emalloc(s, char *, len + 1);
	memcpy(s, str, len);
	s[len] = '\0';
	return s;
}

#if defined(HAVE_LOCALE_H)

/* init_locale --- initialize locale info. */

/*
 * On some operating systems, the pointers in the struct returned
 * by localeconv() can become dangling pointers after a call to
 * setlocale().  So we do a deep copy.
 *
 * Thanks to KIMURA Koichi <kimura.koichi@canon.co.jp>.
 */

static void
init_locale(struct lconv *l)
{
	struct lconv *t;

	t = localeconv();
	*l = *t;
	l->thousands_sep = estrdup(t->thousands_sep, strlen(t->thousands_sep));
	l->decimal_point = estrdup(t->decimal_point, strlen(t->decimal_point));
	l->grouping = estrdup(t->grouping, strlen(t->grouping));
	l->int_curr_symbol = estrdup(t->int_curr_symbol, strlen(t->int_curr_symbol));
	l->currency_symbol = estrdup(t->currency_symbol, strlen(t->currency_symbol));
	l->mon_decimal_point = estrdup(t->mon_decimal_point, strlen(t->mon_decimal_point));
	l->mon_thousands_sep = estrdup(t->mon_thousands_sep, strlen(t->mon_thousands_sep));
	l->mon_grouping = estrdup(t->mon_grouping, strlen(t->mon_grouping));
	l->positive_sign = estrdup(t->positive_sign, strlen(t->positive_sign));
	l->negative_sign = estrdup(t->negative_sign, strlen(t->negative_sign));
}
#endif /* LOCALE_H */

/* save_argv --- save argv array */

static void
save_argv(int argc, char **argv)
{
	int i;

	emalloc(d_argv, char **, (argc + 1) * sizeof(char *));
	for (i = 0; i < argc; i++)
		d_argv[i] = estrdup(argv[i], strlen(argv[i]));
	d_argv[argc] = NULL;
}

/*
 * update_global_values --- make sure the symbol table has correct values.
 * Called from the grammar before dumping values.
 *
 * Also called when accessing through SYMTAB, and from api_sym_lookup().
 */

void
update_global_values()
{
	const struct varinit *vp;

	for (vp = varinit; vp->name; vp++) {
		if (vp->update != NULL)
			vp->update();
	}
}

/* getenv_long --- read a long value (>= 0) from an environment var. */

long
getenv_long(const char *name)
{
	const char *val;
	long newval;
	if ((val = getenv(name)) != NULL && isdigit((unsigned char) *val)) {
		for (newval = 0; *val && isdigit((unsigned char) *val); val++)
			newval = (newval * 10) + *val - '0';
		return newval;
	}
	return -1;
}

/* parse_args --- do the getopt_long thing */

static void
parse_args(int argc, char **argv)
{
	/*
	 * The + on the front tells GNU getopt not to rearrange argv.
	 */
	const char *optlist = "+F:f:v:W;bcCd::D::e:E:ghi:kIl:L::nNo::Op::MPrSstVYZ:";
	int old_optind;
	int c;
	char *scan;
	char *src;

	/* we do error messages ourselves on invalid options */
	opterr = false;

	/* copy argv before getopt gets to it; used to restart the debugger */
	save_argv(argc, argv);

	/* option processing. ready, set, go! */
	for (optopt = 0, old_optind = 1;
	     (c = getopt_long(argc, argv, optlist, optab, NULL)) != EOF;
	     optopt = 0, old_optind = optind) {
		if (do_posix)
			opterr = true;

		switch (c) {
		case 'F':
			add_preassign(PRE_ASSIGN_FS, optarg);
			break;

		case 'E':
			disallow_var_assigns = true;
			/* fall through */
		case 'f':
			/*
			 * Allow multiple -f options.
			 * This makes function libraries real easy.
			 * Most of the magic is in the scanner.
			 *
			 * The following is to allow for whitespace at the end
			 * of a #! /bin/gawk line in an executable file
			 */
			scan = optarg;
			if (argv[optind-1] != optarg)
				while (isspace((unsigned char) *scan))
					scan++;
			src = (*scan == '\0' ? argv[optind++] : optarg);
			(void) add_srcfile((src && src[0] == '-' && src[1] == '\0') ?
					SRC_STDIN : SRC_FILE,
					src, srcfiles, NULL, NULL);

			break;

		case 'v':
			add_preassign(PRE_ASSIGN, optarg);
			break;

		case 'b':
			do_binary = true;
			break;

		case 'c':
			do_flags |= DO_TRADITIONAL;
			break;

		case 'C':
			copyleft();
			break;

		case 'd':
			do_flags |= DO_DUMP_VARS;
			if (optarg != NULL && optarg[0] != '\0')
				varfile = optarg;
			break;

		case 'D':
			do_flags |= DO_DEBUG;
			if (optarg != NULL && optarg[0] != '\0')
				command_file = optarg;
			break;

		case 'e':
			if (optarg[0] == '\0')
				warning(_("empty argument to `-e/--source' ignored"));
			else
				(void) add_srcfile(SRC_CMDLINE, optarg, srcfiles, NULL, NULL);
			break;

		case 'g':
			do_flags |= DO_INTL;
			break;

		case 'h':
			/* write usage to stdout, per GNU coding stds */
			usage(EXIT_SUCCESS, stdout);
			break;

		case 'i':
			(void) add_srcfile(SRC_INC, optarg, srcfiles, NULL, NULL);
			break;

		case 'I':
			do_itrace = true;
			break;

		case 'k':	// k is for "comma". it's a stretch, I know
			do_flags |= DO_CSV;
			break;

		case 'l':
			(void) add_srcfile(SRC_EXTLIB, optarg, srcfiles, NULL, NULL);
			break;

#ifndef NO_LINT
		case 'L':
			do_flags |= (DO_LINT_ALL|DO_LINT_EXTENSIONS);
			if (optarg != NULL) {
				if (strcmp(optarg, "fatal") == 0)
					lintfunc = r_fatal;
				else if (strcmp(optarg, "invalid") == 0) {
					do_flags &= ~DO_LINT_ALL;
					do_flags |= DO_LINT_INVALID;
				}
				else if (strcmp(optarg, "no-ext") == 0) {
					do_flags &= ~DO_LINT_EXTENSIONS;
				}
			}
			break;

		case 't':
			do_flags |= DO_LINT_OLD;
			break;
#else
		case 'L':
		case 't':
			break;
#endif

		case 'n':
			do_flags |= DO_NON_DEC_DATA;
			break;

		case 'N':
			use_lc_numeric = true;
			break;

		case 'O':
			do_optimize = true;
			break;

		case 'p':
			if (do_pretty_print && ! do_profile)
				warning(_("`--profile' overrides `--pretty-print'"));
			do_flags |= DO_PROFILE;
			/* fall through */
		case 'o':
			if (c == 'o' && do_profile)
				warning(_("`--profile' overrides `--pretty-print'"));
			do_flags |= DO_PRETTY_PRINT;
			if (optarg != NULL)
				set_prof_file(optarg);
			else
				set_prof_file(DEFAULT_PROFILE);
			break;

		case 'M':
#ifdef HAVE_MPFR
			do_flags |= DO_MPFR;
#else
			warning(_("-M ignored: MPFR/GMP support not compiled in"));
#endif
			break;

		case 'P':
			do_flags |= DO_POSIX;
			break;

		case 'r':
			// This no longer has any effect. It remains for the
			// lint check in main().
			do_flags |= DO_INTERVALS;
 			break;

		case 's':
			do_optimize = false;
			break;

		case 'S':
			do_flags |= DO_SANDBOX;
			break;

		case 'T':	// --persist[=file]
#ifdef USE_PERSISTENT_MALLOC
			if (optarg == NULL)
				optarg = "/some/file";
			fatal(_("Use `GAWK_PERSIST_FILE=%s gawk ...' instead of --persist."), optarg);
#else
			warning(_("Persistent memory is not supported."));
#endif /* USE_PERSISTENT_MALLOC */
			break;

		case 'V':
			do_version = true;
			break;

		case 'W':       /* gawk specific options - now in getopt_long */
			fprintf(stderr, _("%s: option `-W %s' unrecognized, ignored\n"),
				argv[0], optarg);
			break;

		case 0:
			/*
			 * getopt_long found an option that sets a variable
			 * instead of returning a letter. Do nothing, just
			 * cycle around for the next one.
			 */
			break;

		case 'Y':
		case 'Z':
#if defined(YYDEBUG) || defined(GAWKDEBUG)
			if (c == 'Y') {
				yydebug = 2;
				break;
			}
#endif
#if defined(LOCALEDEBUG)
			if (c == 'Z') {
				locale = optarg;
				break;
			}
#endif
			/* if not debugging, fall through */
		case '?':
		default:
			/*
			 * If not posix, an unrecognized option stops argument
			 * processing so that it can go into ARGV for the awk
			 * program to see. This makes use of ``#! /bin/gawk -f''
			 * easier.
			 *
			 * However, it's never simple. If optopt is set,
			 * an option that requires an argument didn't get the
			 * argument. We care because if opterr is 0, then
			 * getopt_long won't print the error message for us.
			 */
			if (! do_posix
			    && (optopt == '\0' || strchr(optlist, optopt) == NULL)) {
				/*
				 * can't just do optind--. In case of an
				 * option with >= 2 letters, getopt_long
				 * won't have incremented optind.
				 */
				optind = old_optind;
				stopped_early = true;
				goto out;
			} else if (optopt != '\0') {
				/* Use POSIX required message format */
				fprintf(stderr,
					_("%s: option requires an argument -- %c\n"),
					myname, optopt);
				usage(EXIT_FAILURE, stderr);
			}
			/* else
				let getopt print error message for us */
			break;
		}
		if (c == 'E')	/* --exec ends option processing */
			break;
	}
out:
	do_optimize = (do_optimize && ! do_pretty_print);

	pma_mpfr_check();

	return;
}

/* set_locale_stuff --- setup the locale stuff */

static void
set_locale_stuff(void)
{
#if defined(LC_CTYPE)
	setlocale(LC_CTYPE, locale);
#endif
#if defined(LC_COLLATE)
	setlocale(LC_COLLATE, locale);
#endif
#if defined(LC_MESSAGES)
	setlocale(LC_MESSAGES, locale);
#endif
#if defined(LC_NUMERIC) && defined(HAVE_LOCALE_H)
	/*
	 * Force the issue here.  According to POSIX 2001, decimal
	 * point is used for parsing source code and for command-line
	 * assignments and the locale value for processing input,
	 * number to string conversion, and printing output.
	 *
	 * 10/2005 --- see below also; we now only use the locale's
	 * decimal point if do_posix in effect.
	 *
	 * 9/2007:
	 * This is a mess. We need to get the locale's numeric info for
	 * the thousands separator for the %'d flag.
	 */
	setlocale(LC_NUMERIC, locale);
	init_locale(& loc);
	setlocale(LC_NUMERIC, "C");
#endif
#if defined(LC_TIME)
	setlocale(LC_TIME, locale);
#endif

	/* These must be done after calling setlocale */
	(void) bindtextdomain(PACKAGE, locale_dir);
	(void) textdomain(PACKAGE);
}

/* platform_name --- return the platform name */

static const char *
platform_name()
{
	// Cygwin and Mac OS X count as POSIX
#if defined(__VMS)
	return "vms";
#elif defined(__MINGW32__)
	return "mingw";
#elif defined(USE_EBCDIC)
	return "os390";
#else
	return "posix";
#endif
}

/* set_current_namespace --- set current_namespace and handle memory management */

void
set_current_namespace(const char *new_namespace)
{
	if (current_namespace != awk_namespace)
		efree((void *) current_namespace);

	current_namespace = new_namespace;
}

/* check_pma_security --- make some minimal security checks */

static void
check_pma_security(const char *pma_file)
{
#ifdef USE_PERSISTENT_MALLOC
	struct stat sbuf;
	int euid = geteuid();

	// don't use 'fatal' routine, it seems to need to allocate memory
	// and we haven't initialized PMA yet.

	if (pma_file == NULL)
		return;
	else if (stat(pma_file, & sbuf) < 0) {
		fprintf(stderr, _("%s: fatal: cannot stat %s: %s\n"),
				myname, pma_file, strerror(errno));
		exit(EXIT_FATAL);
	} else if (euid == 0) {
		fprintf(stderr, _("%s: fatal: using persistent memory is not allowed when running as root.\n"), myname);
		exit(EXIT_FATAL);
	} else if (sbuf.st_uid != euid) {
		fprintf(stderr, _("%s: warning: %s is not owned by euid %d.\n"),
				myname, pma_file, euid);
	}
#endif /* USE_PERSISTENT_MALLOC */
}

/* enable_pma --- do the PMA flow, handle ASLR on Linux */

static bool
enable_pma(char **argv)
{
	const char *persist_file = getenv("GAWK_PERSIST_FILE");	/* backing file for PMA */

#ifndef USE_PERSISTENT_MALLOC
	if (persist_file != NULL) {
		warning(_("persistent memory is not supported"));
		return false;
	}
	return true;	// silence compiler warnings
#else
	os_disable_aslr(persist_file, argv);

	check_pma_security(persist_file);
	int pma_result = pma_init(1, persist_file);
	if (pma_result != 0) {
		// don't use 'fatal' routine, memory can't be allocated
		fprintf(stderr, _("%s: fatal: persistent memory allocator failed to initialize: return value %d, pma.c line: %d.\n"),
				myname, pma_result, pma_errno);
		exit(EXIT_FATAL);
	}


	return (persist_file != NULL);
#endif
}
/*
 * mpfr.c - routines for arbitrary-precision number support in gawk.
 */

/*
 * Copyright (C) 2012, 2013, 2015, 2017, 2018, 2019, 2021, 2022, 2024, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

#ifdef HAVE_MPFR

int MPFR_round_mode = 'N';	// default value

#if !defined(MPFR_VERSION_MAJOR) || MPFR_VERSION_MAJOR < 3
typedef mp_exp_t mpfr_exp_t;
#endif

extern NODE **fmt_list;          /* declared in eval.c */

mpz_t mpzval;	/* GMP integer type, used as temporary in few places */
mpz_t MNR;
mpz_t MFNR;
bool do_ieee_fmt;	/* IEEE-754 floating-point emulation */
mpfr_rnd_t ROUND_MODE;

static mpfr_prec_t default_prec;

static mpfr_rnd_t get_rnd_mode(const char rmode);
static NODE *mpg_force_number(NODE *n);
static NODE *mpg_make_number(double);
static NODE *mpg_format_val(const char *format, int index, NODE *s);
static int mpg_interpret(INSTRUCTION **cp);

static mpfr_exp_t min_exp = MPFR_EMIN_DEFAULT;
static mpfr_exp_t max_exp = MPFR_EMAX_DEFAULT;

/* temporary MPFR floats used to hold converted GMP integer operands */
static mpfr_t _mpf_t1;
static mpfr_t _mpf_t2;

/*
 * PRECISION_MIN is the precision used to initialize _mpf_t1 and _mpf_t2.
 * 64 bits should be enough for exact conversion of most integers to floats.
 */

#define PRECISION_MIN	64

/* mf = { _mpf_t1, _mpf_t2 } */
static inline mpfr_ptr mpg_tofloat(mpfr_ptr mf, mpz_ptr mz);
/* T = {t1, t2} */
#define MP_FLOAT(T) is_mpg_integer(T) ? mpg_tofloat(_mpf_##T, (T)->mpg_i) : (T)->mpg_numbr


/* init_mpfr --- set up MPFR related variables */

void
init_mpfr(mpfr_prec_t prec, const char *rmode)
{
	mpfr_set_default_prec(default_prec = prec);
	ROUND_MODE = get_rnd_mode(rmode[0]);
	mpfr_set_default_rounding_mode(ROUND_MODE);
	make_number = mpg_make_number;
	str2number = mpg_force_number;
	format_val = mpg_format_val;
	cmp_numbers = mpg_cmp;

	mpz_init(MNR);
	mpz_init(MFNR);
	do_ieee_fmt = false;

	mpfr_init2(_mpf_t1, PRECISION_MIN);
	mpfr_init2(_mpf_t2, PRECISION_MIN);
	mpz_init(mpzval);

	register_exec_hook(mpg_interpret, 0);
}

/* cleanup_mpfr --- clean stuff up, mainly for valgrind */

void
cleanup_mpfr(void)
{
	mpfr_clear(_mpf_t1);
	mpfr_clear(_mpf_t2);
}

/* mpg_node --- allocate a node to store MPFR float or GMP integer */

NODE *
mpg_node(unsigned int flags)
{
	NODE *r = make_number_node(flags);

	if (flags == MPFN)
		/* Initialize, set precision to the default precision, and value to NaN */
		mpfr_init(r->mpg_numbr);
	else
		/* Initialize and set value to 0 */
		mpz_init(r->mpg_i);
	return r;
}

/*
 * mpg_make_number --- make a arbitrary-precision number node
 *	and initialize with a C double
 */

static NODE *
mpg_make_number(double x)
{
	NODE *r;
	double ival;

	if ((ival = double_to_int(x)) != x) {
		int tval;
		r = mpg_float();
		tval = mpfr_set_d(r->mpg_numbr, x, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	} else {
		r = mpg_integer();
		mpz_set_d(r->mpg_i, ival);
	}
	return r;
}

/* mpg_strtoui --- assign arbitrary-precision integral value from a string */

int
mpg_strtoui(mpz_ptr zi, char *str, size_t len, char **end, int base)
{
	char *s = str;
	char *start;
	int ret = -1;

	/*
	 * mpz_set_str does not like leading 0x or 0X for hex (or 0 for octal)
	 * with a non-zero base argument.
	*/
	if (base == 16 && len >= 2 && *s == '0' && (s[1] == 'x' || s[1] == 'X')) {
		s += 2; len -= 2;
	} else if (base == 8 && len >= 1 && *s == '0') {
		s++; len--;
	}
	start = s;

	while (len > 0) {
		switch (*s) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
			break;
		case '8':
		case '9':
			if (base == 8)
				base = 10;
			break;
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			if (base == 16)
				break;
		default:
			goto done;
		}
		s++; len--;
	}
done:
	if (s > start) {
		char save = *s;
		*s = '\0';
		ret = mpz_set_str(zi, start, base);
		*s = save;
	}
	if (end != NULL)
		*end = s;
	return ret;
}


/* mpg_maybe_float --- test if a string may contain arbitrary-precision float */

static int
mpg_maybe_float(const char *str, int use_locale)
{
	int dec_point = '.';
	const char *s = str;

#if defined(HAVE_LOCALE_H)
	/*
	 * loc.decimal_point may not have been initialized yet,
	 * so double check it before using it.
	 */
	if (use_locale && loc.decimal_point != NULL && loc.decimal_point[0] != '\0')
		dec_point = loc.decimal_point[0];	/* XXX --- assumes one char */
#endif

	if (strlen(s) >= 3
		&& (   (   (s[0] == 'i' || s[0] == 'I')
			&& (s[1] == 'n' || s[1] == 'N')
			&& (s[2] == 'f' || s[2] == 'F'))
		    || (   (s[0] == 'n' || s[0] == 'N')
			&& (s[1] == 'a' || s[1] == 'A')
			&& (s[2] == 'n' || s[2] == 'N'))))
		return true;

	for (; *s != '\0'; s++) {
		if (*s == dec_point || *s == 'e' || *s == 'E')
			return true;
	}

	return false;
}


/* mpg_zero --- initialize with arbitrary-precision integer(GMP) and set value to zero */

void
mpg_zero(NODE *n)
{
	if (is_mpg_float(n)) {
		mpfr_clear(n->mpg_numbr);
		n->flags &= ~MPFN;
	}
	if (! is_mpg_integer(n)) {
		mpz_init(n->mpg_i);	/* this also sets its value to 0 */
		n->flags |= MPZN;
	} else
		mpz_set_si(n->mpg_i, 0);
}


/* force_mpnum --- force a value to be a GMP integer or MPFR float */

static int
force_mpnum(NODE *n, int do_nondec, int use_locale)
{
	char *cp, *cpend, *ptr, *cp1;
	char save;
	int tval, base = 10;

	if (n->stlen == 0 || (n->flags & REGEX) != 0) {
		mpg_zero(n);
		return false;
	}

	cp = n->stptr;
	cpend = n->stptr + n->stlen;
	while (cp < cpend && isspace((unsigned char) *cp))
		cp++;
	if (cp == cpend) {	/* only spaces */
		mpg_zero(n);
		return false;
	}

	save = *cpend;
	*cpend = '\0';

	if (*cp == '+' || *cp == '-')
		cp1 = cp + 1;
	else
		cp1 = cp;

	/*
	 * Maybe "+" or "-" was the field.  mpg_strtoui
	 * won't check for that and set errno, so we have
	 * to check manually.
	 */
	if (*cp1 == '\0') {
		*cpend = save;
		mpg_zero(n);
		return false;
	}

	if (do_nondec)
		base = get_numbase(cp1, cpend - cp1, use_locale);

	if (base != 10 || ! mpg_maybe_float(cp1, use_locale)) {
		mpg_zero(n);
		errno = 0;
		mpg_strtoui(n->mpg_i, cp1, cpend - cp1, & ptr, base);
		if (*cp == '-')
			mpz_neg(n->mpg_i, n->mpg_i);
		goto done;
	}

	if (is_mpg_integer(n)) {
		mpz_clear(n->mpg_i);
		n->flags &= ~MPZN;
	}

	if (! is_mpg_float(n)) {
		mpfr_init(n->mpg_numbr);
		n->flags |= MPFN;
	}

	errno = 0;
	tval = mpfr_strtofr(n->mpg_numbr, cp, & ptr, base, ROUND_MODE);
	if (mpfr_nan_p(n->mpg_numbr) && *cp == '-')
		tval = mpfr_setsign(n->mpg_numbr, n->mpg_numbr, 1, ROUND_MODE);
	IEEE_FMT(n->mpg_numbr, tval);
done:
	/* trailing space is OK for NUMBER */
	while (ptr < cpend && isspace((unsigned char) *ptr))
		ptr++;
	*cpend = save;
	if (errno == 0 && ptr == cpend)
		return true;
	errno = 0;
	return false;
}

/* mpg_force_number --- force a value to be a multiple-precision number */

static NODE *
mpg_force_number(NODE *n)
{
	char *cp, *cpend;

	if (n->type == Node_elem_new) {
		elem_new_reset(n);
		n->type = Node_val;

		return n;
	}

	if ((n->flags & NUMCUR) != 0)
		return n;
	n->flags |= NUMCUR;

	/* Trim leading white space, bailing out if there's nothing else */
	for (cp = n->stptr, cpend = cp + n->stlen;
	     cp < cpend && isspace((unsigned char) *cp); cp++)
		continue;

	if (cp == cpend)
		goto badnum;

	/* At this point, we know the string is not entirely white space */
	/* Trim trailing white space */
	while (isspace((unsigned char) cpend[-1]))
		cpend--;

	/*
	 * 2/2007:
	 * POSIX, by way of severe language lawyering, seems to
	 * allow things like "inf" and "nan" to mean something.
	 * So if do_posix, the user gets what he deserves.
	 * This also allows hexadecimal floating point. Ugh.
	 */
	if (! do_posix) {
		if (is_alpha((unsigned char) *cp))
			goto badnum;
		else if (is_ieee_magic_val(cp)) {
			if (cpend != cp + 4)
				goto badnum;
			/* else
				fall through */
		}
		/* else
			fall through */
	}
	/* else POSIX, so
		fall through */

	if (force_mpnum(n, (do_non_decimal_data && ! do_traditional), true)) {
		if ((n->flags & USER_INPUT) != 0) {
			/* leave USER_INPUT set to indicate a strnum */
			n->flags &= ~STRING;
			n->flags |= NUMBER;
		}
	} else
		n->flags &= ~USER_INPUT;
	return n;
badnum:
	mpg_zero(n);
	n->flags &= ~USER_INPUT;
	return n;
}

/* mpg_format_val --- format a numeric value based on format */

static NODE *
mpg_format_val(const char *format, int index, NODE *s)
{
	NODE *dummy[2], *r;
	unsigned int oflags;

	if (out_of_range(s)) {
		const char *result = format_nan_inf(s, 'g');
		return make_string(result, strlen(result));
	}

	/* create dummy node for a sole use of format_args */
	dummy[1] = s;
	oflags = s->flags;

	if (is_mpg_integer(s) || mpfr_integer_p(s->mpg_numbr)) {
		/* integral value, use %d */
		r = format_args("%d", 2, dummy, 2);
		s->stfmt = STFMT_UNUSED;
	} else {
		r = format_args(format, fmt_list[index]->stlen, dummy, 2);
		assert(r != NULL);
		s->stfmt = index;
	}
	s->flags = oflags;
	s->stlen = r->stlen;
	if ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
		efree(s->stptr);
	s->stptr = r->stptr;
	s->flags |= STRCUR;
	s->strndmode = MPFR_round_mode;
	freenode(r);	/* Do not unref(r)! We want to keep s->stptr == r->stpr.  */
	free_wstr(s);
	return s;
}

/* mpg_cmp --- compare two numbers */

int
mpg_cmp(const NODE *t1, const NODE *t2)
{
	/*
	 * For the purposes of sorting, NaN is considered greater than
	 * any other value, and all NaN values are considered equivalent and equal.
	 */

	if (is_mpg_float(t1)) {
		if (is_mpg_float(t2)) {
			if (mpfr_nan_p(t1->mpg_numbr))
				return ! mpfr_nan_p(t2->mpg_numbr);
			if (mpfr_nan_p(t2->mpg_numbr))
				return -1;
			return mpfr_cmp(t1->mpg_numbr, t2->mpg_numbr);
		}
		if (mpfr_nan_p(t1->mpg_numbr))
			return 1;
		return mpfr_cmp_z(t1->mpg_numbr, t2->mpg_i);
	} else if (is_mpg_float(t2)) {
		int ret;
		if (mpfr_nan_p(t2->mpg_numbr))
			return -1;
		ret = mpfr_cmp_z(t2->mpg_numbr, t1->mpg_i);
		return ret > 0 ? -1 : (ret < 0);
	} else if (is_mpg_integer(t1)) {
		return mpz_cmp(t1->mpg_i, t2->mpg_i);
	}

	/* t1 and t2 are AWKNUMs */
	return cmp_awknums(t1, t2);
}

/* mpg_cmp_as_numbers --- compare two numbers, similar to doubles */

bool
mpg_cmp_as_numbers(const NODE *t1, const NODE *t2, scalar_cmp_t comparison_type)
{
	/*
	 * This routine provides numeric comparisons that should work
	 * the same as in C.  It should NOT be used for sorting.
	 */

	bool t1_nan = mpfr_nan_p(t1->mpg_numbr);
	bool t2_nan = mpfr_nan_p(t2->mpg_numbr);
	bool ret = false;

	// MPFR is different than native doubles...
	if (t1_nan || t2_nan)
		return comparison_type == SCALAR_NEQ;

	int di = mpg_cmp(t1, t2);

	switch (comparison_type) {
	case SCALAR_EQ:
		ret = (di == 0);
		break;
	case SCALAR_NEQ:
		ret = (di != 0);
		break;
	case SCALAR_LT:
		ret = (di < 0);
		break;
	case SCALAR_LE:
		ret = (di <= 0);
		break;
	case SCALAR_GT:
		ret = (di > 0);
		break;
	case SCALAR_GE:
		ret = (di >= 0);
		break;
	default:
		cant_happen("invalid comparison type %d", (int) comparison_type);
		break;
	}

	return ret;
}


/*
 * mpg_update_var --- update NR or FNR.
 *	NR_node->var_value(mpz_t) = MNR(mpz_t) * LONG_MAX + NR(long)
 */

NODE *
mpg_update_var(NODE *n)
{
	NODE *val = n->var_value;
	long nr = 0;
	mpz_ptr nq = 0;

	if (n == NR_node) {
		nr = NR;
		nq = MNR;
	} else if (n == FNR_node) {
		nr = FNR;
		nq = MFNR;
	} else
		cant_happen("invalid node for mpg_update_var%s", "");

	if (mpz_sgn(nq) == 0) {
		/* Efficiency hack similar to that for AWKNUM */
		if (is_mpg_float(val) || mpz_get_si(val->mpg_i) != nr) {
			unref(n->var_value);
			val = n->var_value = mpg_integer();
			mpz_set_si(val->mpg_i, nr);
		}
	} else {
		unref(n->var_value);
		val = n->var_value = mpg_integer();
		mpz_set_si(val->mpg_i, nr);
		mpz_addmul_ui(val->mpg_i, nq, LONG_MAX);	/* val->mpg_i += nq * LONG_MAX */
	}
	return val;
}

/* mpg_set_var --- set NR or FNR */

long
mpg_set_var(NODE *n)
{
	long nr = 0;
	mpz_ptr nq = 0, r;
	NODE *val = n->var_value;

	if (n == NR_node)
		nq = MNR;
	else if (n == FNR_node)
		nq = MFNR;
	else
		cant_happen("invalid node for mpg_set_var%s", "");

	if (is_mpg_integer(val))
		r = val->mpg_i;
	else {
		/* convert float to integer */
		mpfr_get_z(mpzval, val->mpg_numbr, MPFR_RNDZ);
		r = mpzval;
	}
	nr = mpz_fdiv_q_ui(nq, r, LONG_MAX);	/* nq (MNR or MFNR) is quotient */
	return nr;	/* remainder (NR or FNR) */
}

/* set_PREC --- update MPFR PRECISION related variables when PREC assigned to */

void
set_PREC()
{
	long prec = 0;
	NODE *val;
	static const struct ieee_fmt {
		const char *name;
		mpfr_prec_t precision;
		mpfr_exp_t emax;
		mpfr_exp_t emin;
	} ieee_fmts[] = {
		{ "half",	11,	16,	-23	},	/* binary16 */
		{ "single",	24,	128,	-148	},	/* binary32 */
		{ "double",	53,	1024,	-1073	},	/* binary64 */
		{ "quad",	113,	16384,	-16493	},	/* binary128 */
		{ "oct",	237,	262144,	-262377	},	/* binary256, not in the IEEE 754-2008 standard */

		/*
 		 * For any bitwidth = 32 * k ( k >= 4),
 		 * precision = 13 + bitwidth - int(4 * log2(bitwidth))
		 * emax = 1 << bitwidth - precision - 1
		 * emin = 4 - emax - precision
 		 */
	};

	if (! do_mpfr)
		return;

	val = fixtype(PREC_node->var_value);

	if ((val->flags & STRING) != 0) {
		int i, j;

		/* emulate IEEE-754 binary format */

		for (i = 0, j = sizeof(ieee_fmts)/sizeof(ieee_fmts[0]); i < j; i++) {
			if (strcasecmp(ieee_fmts[i].name, val->stptr) == 0)
				break;
		}

		if (i < j) {
			prec = ieee_fmts[i].precision;

			/*
			 * We *DO NOT* change the MPFR exponent range using
			 * mpfr_set_{emin, emax} here. See format_ieee() for details.
			 */
			max_exp = ieee_fmts[i].emax;
			min_exp = ieee_fmts[i].emin;

			do_ieee_fmt = true;
		}
	}

	if (prec <= 0) {
		force_number(val);
		prec = get_number_si(val);
		if (prec < MPFR_PREC_MIN || prec > MPFR_PREC_MAX) {
			force_string(val);
			warning(_("PREC value `%.*s' is invalid"), (int) val->stlen, val->stptr);
			prec = 0;
		} else
			do_ieee_fmt = false;
	}

	if (prec > 0)
		mpfr_set_default_prec(default_prec = prec);
}


/* get_rnd_mode --- convert string to MPFR rounding mode */

static mpfr_rnd_t
get_rnd_mode(const char rmode)
{
	switch (rmode) {
	case 'N':
	case 'n':
		return MPFR_RNDN;	/* round to nearest (IEEE-754 roundTiesToEven) */
	case 'Z':
	case 'z':
		return MPFR_RNDZ;	/* round toward zero (IEEE-754 roundTowardZero) */
	case 'U':
	case 'u':
		return MPFR_RNDU;	/* round toward plus infinity (IEEE-754 roundTowardPositive) */
	case 'D':
	case 'd':
		return MPFR_RNDD;	/* round toward minus infinity (IEEE-754 roundTowardNegative) */
#if defined(MPFR_VERSION_MAJOR) && MPFR_VERSION_MAJOR > 2
	case 'A':
	case 'a':
		return MPFR_RNDA;	/* round away from zero */
#endif
	default:
		break;
	}
	return (mpfr_rnd_t) -1;
}

/*
 * set_ROUNDMODE --- update MPFR rounding mode related variables
 *	when ROUNDMODE assigned to
 */

void
set_ROUNDMODE()
{
	if (do_mpfr) {
		mpfr_rnd_t rndm = (mpfr_rnd_t) -1;
		NODE *n;
		n = force_string(ROUNDMODE_node->var_value);
		if (n->stlen == 1)
			rndm = get_rnd_mode(n->stptr[0]);
		if (rndm != -1) {
			mpfr_set_default_rounding_mode(rndm);
			ROUND_MODE = rndm;
			MPFR_round_mode = n->stptr[0];
		} else
			warning(_("ROUNDMODE value `%.*s' is invalid"), (int) n->stlen, n->stptr);
	}
}


/* format_ieee --- make sure a number follows IEEE-754 floating-point standard */

int
format_ieee(mpfr_ptr x, int tval)
{
	/*
	 * The MPFR doc says that it's our responsibility to make sure all numbers
	 * including those previously created are in range after we've changed the
	 * exponent range. Most MPFR operations and functions require
	 * the input arguments to have exponents within the current exponent range.
	 * Any argument outside the range results in a MPFR assertion failure
	 * like this:
	 *
	 *   $ gawk -M 'BEGIN { x=1.0e-10000; print x+0; PREC="double"; print x+0}'
	 *   1e-10000
	 *   init2.c:52: MPFR assertion failed ....
	 *
	 * A "naive" approach would be to keep track of the ternary state and
	 * the rounding mode for each number, and make sure it is in the current
	 * exponent range (using mpfr_check_range) before using it in an
	 * operation or function. Instead, we adopt the following strategy.
	 *
	 * When gawk starts, the exponent range is the MPFR default
	 * [MPFR_EMIN_DEFAULT, MPFR_EMAX_DEFAULT]. Any number that gawk
	 * creates must have exponent in this range (excluding infinities, NaNs and zeros).
	 * Each MPFR operation or function is performed with this default exponent
	 * range.
	 *
	 * When emulating IEEE-754 format, the exponents are *temporarily* changed,
	 * mpfr_check_range is called to make sure the number is in the new range,
	 * and mpfr_subnormalize is used to round following the rules of subnormal
	 * arithmetic. The exponent range is then *restored* to the original value
	 * [MPFR_EMIN_DEFAULT, MPFR_EMAX_DEFAULT].
	 */

	(void) mpfr_set_emin(min_exp);
	(void) mpfr_set_emax(max_exp);
	tval = mpfr_check_range(x, tval, ROUND_MODE);
	tval = mpfr_subnormalize(x, tval, ROUND_MODE);
	(void) mpfr_set_emin(MPFR_EMIN_DEFAULT);
	(void) mpfr_set_emax(MPFR_EMAX_DEFAULT);
	return tval;
}


/* do_mpfr_atan2 --- do the atan2 function */

NODE *
do_mpfr_atan2(int nargs)
{
	NODE *t1, *t2, *res;
	mpfr_ptr p1, p2;
	int tval;

	check_exact_args(nargs, "atan2", 2);

	t2 = POP_SCALAR();
	t1 = POP_SCALAR();

	if (do_lint) {
		if ((fixtype(t1)->flags & NUMBER) == 0)
			lintwarn(_("atan2: received non-numeric first argument"));
		if ((fixtype(t2)->flags & NUMBER) == 0)
			lintwarn(_("atan2: received non-numeric second argument"));
	}
	force_number(t1);
	force_number(t2);

	p1 = MP_FLOAT(t1);
	p2 = MP_FLOAT(t2);
	res = mpg_float();
	/* See MPFR documentation for handling of special values like +inf as an argument */
	tval = mpfr_atan2(res->mpg_numbr, p1, p2, ROUND_MODE);
	IEEE_FMT(res->mpg_numbr, tval);

	DEREF(t1);
	DEREF(t2);
	return res;
}

/* do_mpfr_func --- run an MPFR function - not inline, for debugging */

static inline NODE *
do_mpfr_func(const char *name,
		int (*mpfr_func)(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t),
		int nargs, bool warn_negative)
{
	NODE *t1, *res;
	mpfr_ptr p1;
	int tval;
	mpfr_prec_t argprec;

	check_exact_args(nargs, name, 1);

	t1 = POP_SCALAR();
	if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument"), name);

	force_number(t1);
	p1 = MP_FLOAT(t1);
	if (warn_negative && mpfr_sgn(p1) < 0) {
		force_string(t1);
		warning(_("%s: received negative argument %.*s"), name, (int) t1->stlen, t1->stptr);
	}
	res = mpg_float();
	if ((argprec = mpfr_get_prec(p1)) > default_prec)
		mpfr_set_prec(res->mpg_numbr, argprec);	/* needed at least for sqrt() */
	tval = mpfr_func(res->mpg_numbr, p1, ROUND_MODE);
	IEEE_FMT(res->mpg_numbr, tval);
	DEREF(t1);
	return res;
}

#define SPEC_MATH(X, WN)				\
NODE *result;					\
result = do_mpfr_func(#X, mpfr_##X, nargs, WN);	\
return result

/* do_mpfr_sin --- do the sin function */

NODE *
do_mpfr_sin(int nargs)
{
	SPEC_MATH(sin, false);
}

/* do_mpfr_cos --- do the cos function */

NODE *
do_mpfr_cos(int nargs)
{
	SPEC_MATH(cos, false);
}

/* do_mpfr_exp --- exponential function */

NODE *
do_mpfr_exp(int nargs)
{
	SPEC_MATH(exp, false);
}

/* do_mpfr_log --- the log function */

NODE *
do_mpfr_log(int nargs)
{
	SPEC_MATH(log, true);
}

/* do_mpfr_sqrt --- do the sqrt function */

NODE *
do_mpfr_sqrt(int nargs)
{
	SPEC_MATH(sqrt, true);
}

/* do_mpfr_int --- convert double to int for awk */

NODE *
do_mpfr_int(int nargs)
{
	NODE *tmp, *r;

	check_exact_args(nargs, "int", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("int: received non-numeric argument"));
	force_number(tmp);

	if (is_mpg_integer(tmp)) {
		r = mpg_integer();
		mpz_set(r->mpg_i, tmp->mpg_i);
	} else {
		if (! mpfr_number_p(tmp->mpg_numbr)) {
			/* [+-]inf or NaN */
			return tmp;
		}

		r = mpg_integer();
		mpfr_get_z(r->mpg_i, tmp->mpg_numbr, MPFR_RNDZ);
	}

	DEREF(tmp);
	return r;
}

/* do_mpfr_compl --- perform a ~ operation */

NODE *
do_mpfr_compl(int nargs)
{
	NODE *tmp, *r;
	mpz_ptr zptr;

	check_exact_args(nargs, "compl", 1);

	tmp = POP_SCALAR();
	if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
		lintwarn(_("compl: received non-numeric argument"));

	force_number(tmp);
	if (is_mpg_float(tmp)) {
		mpfr_ptr p = tmp->mpg_numbr;

		if (! mpfr_number_p(p)) {
			/* [+-]inf or NaN */
			return tmp;
		}
		if (mpfr_sgn(p) < 0)
			fatal("%s",
			mpg_fmt(_("compl(%Rg): negative value is not allowed"), p)
					);
		if (do_lint) {
			if (! mpfr_integer_p(p))
				lintwarn("%s",
			mpg_fmt(_("comp(%Rg): fractional value will be truncated"), p)
					);
		}

		mpfr_get_z(mpzval, p, MPFR_RNDZ);	/* float to integer conversion */
		zptr = mpzval;
	} else {
		/* (tmp->flags & MPZN) != 0 */
		zptr = tmp->mpg_i;
		if (mpz_sgn(zptr) < 0)
				fatal("%s",
			mpg_fmt(_("compl(%Zd): negative values are not allowed"), zptr)
					);
	}

	r = mpg_integer();
	mpz_com(r->mpg_i, zptr);
	DEREF(tmp);
	return r;
}

/* get_intval --- get the (converted) integral operand of a binary function. */

static mpz_ptr
get_intval(NODE *t1, int argnum, const char *op)
{
	mpz_ptr pz;

	if (do_lint && (fixtype(t1)->flags & NUMBER) == 0)
		lintwarn(_("%s: received non-numeric argument #%d"), op, argnum);

	(void) force_number(t1);

	if (is_mpg_float(t1)) {
		mpfr_ptr left = t1->mpg_numbr;
		if (! mpfr_number_p(left)) {
			/* inf or NaN */
			if (do_lint)
                       		lintwarn("%s",
		mpg_fmt(_("%s: argument #%d has invalid value %Rg, using 0"),
                                	op, argnum, left)
				);

			emalloc(pz, mpz_ptr, sizeof (mpz_t));
			mpz_init(pz);
			return pz;	/* should be freed */
		}

		if (mpfr_sgn(left) < 0)
			fatal("%s",
		mpg_fmt(_("%s: argument #%d negative value %Rg is not allowed"),
					op, argnum, left)
				);

		if (do_lint) {
			if (! mpfr_integer_p(left))
				lintwarn("%s",
		mpg_fmt(_("%s: argument #%d fractional value %Rg will be truncated"),
					op, argnum, left)
				);
		}

		emalloc(pz, mpz_ptr, sizeof (mpz_t));
		mpz_init(pz);
		mpfr_get_z(pz, left, MPFR_RNDZ);	/* float to integer conversion */
		return pz;	/* should be freed */
	}
	/* (t1->flags & MPZN) != 0 */
	pz = t1->mpg_i;
	if (mpz_sgn(pz) < 0)
		fatal("%s",
	mpg_fmt(_("%s: argument #%d negative value %Zd is not allowed"),
					op, argnum, pz)
				);

	return pz;	/* must not be freed */
}


/* free_intval --- free the converted integer value returned by get_intval() */

static inline void
free_intval(NODE *t, mpz_ptr pz)
{
	if ((t->flags & MPZN) == 0) {
		mpz_clear(pz);
		efree(pz);
	}
}


/* do_mpfr_lshift --- perform a << operation */

NODE *
do_mpfr_lshift(int nargs)
{
	NODE *t1, *t2, *res;
	unsigned long shift;
	mpz_ptr pz1, pz2;

	check_exact_args(nargs, "lshift", 2);

	t2 = POP_SCALAR();
	t1 = POP_SCALAR();

	pz1 = get_intval(t1, 1, "lshift");
	pz2 = get_intval(t2, 2, "lshift");

	/*
	 * mpz_get_ui: If op is too big to fit an unsigned long then just
	 * the least significant bits that do fit are returned.
	 * The sign of op is ignored, only the absolute value is used.
	 */

	shift = mpz_get_ui(pz2);	/* GMP integer => unsigned long conversion */
	res = mpg_integer();
	mpz_mul_2exp(res->mpg_i, pz1, shift);		/* res = pz1 * 2^shift */

	free_intval(t1, pz1);
	free_intval(t2, pz2);
	DEREF(t2);
	DEREF(t1);
	return res;
}

/* do_mpfr_rshift --- perform a >> operation */

NODE *
do_mpfr_rshift(int nargs)
{
	NODE *t1, *t2, *res;
	unsigned long shift;
	mpz_ptr pz1, pz2;

	check_exact_args(nargs, "rshift", 2);

	t2 = POP_SCALAR();
	t1 = POP_SCALAR();

	pz1 = get_intval(t1, 1, "rshift");
	pz2 = get_intval(t2, 2, "rshift");

	/* N.B: See do_mpfp_lshift. */
	shift = mpz_get_ui(pz2);	/* GMP integer => unsigned long conversion */
	res = mpg_integer();
	mpz_fdiv_q_2exp(res->mpg_i, pz1, shift);	/* res = pz1 / 2^shift, round towards -inf */

	free_intval(t1, pz1);
	free_intval(t2, pz2);
	DEREF(t2);
	DEREF(t1);
	return res;
}


/* do_mpfr_and --- perform an & operation */

NODE *
do_mpfr_and(int nargs)
{
	NODE *t1, *t2, *res;
	mpz_ptr pz1, pz2;
	int i;

	if (nargs < 2)
		fatal(_("and: called with less than two arguments"));

	t2 = POP_SCALAR();
	pz2 = get_intval(t2, nargs, "and");

	res = mpg_integer();
	for (i = 1; i < nargs; i++) {
		t1 = POP_SCALAR();
		pz1 = get_intval(t1, nargs - i, "and");
		mpz_and(res->mpg_i, pz1, pz2);
		free_intval(t1, pz1);
		DEREF(t1);
		if (i == 1) {
			free_intval(t2, pz2);
			DEREF(t2);
		}
		pz2 = res->mpg_i;
	}
	return res;
}


/* do_mpfr_or --- perform an | operation */

NODE *
do_mpfr_or(int nargs)
{
	NODE *t1, *t2, *res;
	mpz_ptr pz1, pz2;
	int i;

	if (nargs < 2)
		fatal(_("or: called with less than two arguments"));

	t2 = POP_SCALAR();
	pz2 = get_intval(t2, nargs, "or");

	res = mpg_integer();
	for (i = 1; i < nargs; i++) {
		t1 = POP_SCALAR();
		pz1 = get_intval(t1, nargs - i, "or");
		mpz_ior(res->mpg_i, pz1, pz2);
		free_intval(t1, pz1);
		DEREF(t1);
		if (i == 1) {
			free_intval(t2, pz2);
			DEREF(t2);
		}
		pz2 = res->mpg_i;
	}
	return res;
}

/* do_mpfr_xor --- perform an ^ operation */

NODE *
do_mpfr_xor(int nargs)
{
	NODE *t1, *t2, *res;
	mpz_ptr pz1, pz2;
	int i;

	if (nargs < 2)
		fatal(_("xor: called with less than two arguments"));

	t2 = POP_SCALAR();
	pz2 = get_intval(t2, nargs, "xor");

	res = mpg_integer();
	for (i = 1; i < nargs; i++) {
		t1 = POP_SCALAR();
		pz1 = get_intval(t1, nargs - i, "xor");
		mpz_xor(res->mpg_i, pz1, pz2);
		free_intval(t1, pz1);
		DEREF(t1);
		if (i == 1) {
			free_intval(t2, pz2);
			DEREF(t2);
		}
		pz2 = res->mpg_i;
	}
	return res;
}

/* do_mpfr_strtonum --- the strtonum function */

NODE *
do_mpfr_strtonum(int nargs)
{
	NODE *tmp, *r;

	check_exact_args(nargs, "strtonum", 1);

	tmp = fixtype(POP_SCALAR());
	if ((tmp->flags & NUMBER) == 0) {
		r = mpg_integer();	/* will be changed to MPFR float if necessary in force_mpnum() */
		r->stptr = tmp->stptr;
		r->stlen = tmp->stlen;
		force_mpnum(r, true, use_lc_numeric);
		r->stptr = NULL;
		r->stlen = 0;
		r->wstptr = NULL;
		r->wstlen = 0;
	} else if (is_mpg_float(tmp)) {
		int tval;
		r = mpg_float();
		tval = mpfr_set(r->mpg_numbr, tmp->mpg_numbr, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	} else {
		r = mpg_integer();
		mpz_set(r->mpg_i, tmp->mpg_i);
	}

	DEREF(tmp);
	return r;
}


static bool firstrand = true;
static gmp_randstate_t state;
static mpz_t seed;	/* current seed */

/* do_mpfr_rand --- do the rand function */

NODE *
do_mpfr_rand(int nargs ATTRIBUTE_UNUSED)
{
	NODE *res;
	int tval;

	check_exact_args(nargs, "rand", 0);

	if (firstrand) {
#if 0
		/* Choose the default algorithm */
		gmp_randinit_default(state);
#endif
		/*
		 * Choose a specific (Mersenne Twister) algorithm in case the default
		 * changes in the future.
		 */

		gmp_randinit_mt(state);

		mpz_init(seed);
		mpz_set_ui(seed, 1);
		/* seed state */
		gmp_randseed(state, seed);
		firstrand = false;
	}
	res = mpg_float();
	tval = mpfr_urandomb(res->mpg_numbr, state);
	IEEE_FMT(res->mpg_numbr, tval);
	return res;
}


/* do_mpfr_srand --- seed the random number generator */

NODE *
do_mpfr_srand(int nargs)
{
	NODE *res;

	if (firstrand) {
#if 0
		/* Choose the default algorithm */
		gmp_randinit_default(state);
#endif
		/*
		 * Choose a specific algorithm (Mersenne Twister) in case default
		 * changes in the future.
		 */

		gmp_randinit_mt(state);

		mpz_init(seed);
		mpz_set_ui(seed, 1);
		/* No need to seed state, will change it below */
		firstrand = false;
	}

	check_args_min_max(nargs, "srand", 0, 1);

	res = mpg_integer();
	mpz_set(res->mpg_i, seed);	/* previous seed */

	if (nargs == 0)
		mpz_set_ui(seed, (unsigned long) time((time_t *) 0));
	else {
		NODE *tmp;
		tmp = POP_SCALAR();
		if (do_lint && (fixtype(tmp)->flags & NUMBER) == 0)
			lintwarn(_("srand: received non-numeric argument"));
		force_number(tmp);
		if (is_mpg_float(tmp))
			mpfr_get_z(seed, tmp->mpg_numbr, MPFR_RNDZ);
		else /* MP integer */
			mpz_set(seed, tmp->mpg_i);
		DEREF(tmp);
	}

	gmp_randseed(state, seed);
	return res;
}

#ifdef SUPPLY_INTDIV
/* do_mpfr_intdiv --- do integer division, return quotient and remainder in dest array */

/*
 * We define the semantics as:
 * 	numerator = int(numerator)
 *	denominator = int(denonmator)
 *	quotient = int(numerator / denomator)
 *	remainder = int(numerator % denomator)
 */

NODE *
do_mpfr_intdiv(int nargs)
{
	NODE *numerator, *denominator, *result;
	NODE *num, *denom;
	NODE *quotient, *remainder;
	NODE *sub, **lhs;

	check_exact_args(nargs, "intdiv", 3);

	result = POP_PARAM();
	if (result->type != Node_var_array)
		fatal(_("intdiv: third argument is not an array"));
	assoc_clear(result);

	denominator = POP_SCALAR();
	numerator = POP_SCALAR();

	if (do_lint) {
		if ((fixtype(numerator)->flags & NUMBER) == 0)
			lintwarn(_("intdiv: received non-numeric first argument"));
		if ((fixtype(denominator)->flags & NUMBER) == 0)
			lintwarn(_("intdiv: received non-numeric second argument"));
	}

	(void) force_number(numerator);
	(void) force_number(denominator);

	/* convert numerator and denominator to integer */
	if (is_mpg_integer(numerator)) {
		num = mpg_integer();
		mpz_set(num->mpg_i, numerator->mpg_i);
	} else {
		if (! mpfr_number_p(numerator->mpg_numbr)) {
			/* [+-]inf or NaN */
			unref(numerator);
			unref(denominator);
			return make_number((AWKNUM) -1);
		}

		num = mpg_integer();
		mpfr_get_z(num->mpg_i, numerator->mpg_numbr, MPFR_RNDZ);
	}

	if (is_mpg_integer(denominator)) {
		denom = mpg_integer();
		mpz_set(denom->mpg_i, denominator->mpg_i);
	} else {
		if (! mpfr_number_p(denominator->mpg_numbr)) {
			/* [+-]inf or NaN */
			unref(numerator);
			unref(denominator);
			unref(num);
			return make_number((AWKNUM) -1);
		}

		denom = mpg_integer();
		mpfr_get_z(denom->mpg_i, denominator->mpg_numbr, MPFR_RNDZ);
	}

	if (mpz_sgn(denom->mpg_i) == 0)
		fatal(_("intdiv: division by zero attempted"));

	quotient = mpg_integer();
	remainder = mpg_integer();

	/* do the division */
	mpz_tdiv_qr(quotient->mpg_i, remainder->mpg_i, num->mpg_i, denom->mpg_i);
	unref(num);
	unref(denom);
	unref(numerator);
	unref(denominator);

	sub = make_string("quotient", 8);
	assoc_set(result, sub, quotient);

	sub = make_string("remainder", 9);
	assoc_set(result, sub, remainder);

	return make_number((AWKNUM) 0.0);
}
#endif /* SUPPLY_INTDIV */

/*
 * mpg_tofloat --- convert an arbitrary-precision integer operand to
 *	a float without loss of precision. It is assumed that the
 *	MPFR variable has already been initialized.
 */

static inline mpfr_ptr
mpg_tofloat(mpfr_ptr mf, mpz_ptr mz)
{
	size_t prec;

	/*
	 * When implicitely converting a GMP integer operand to a MPFR float, use
	 * a precision sufficiently large to hold the converted value exactly.
	 *
 	 *	$ ./gawk -M 'BEGIN { print 13 % 2 }'
 	 *	1
 	 * If the user-specified precision is used to convert the integer 13 to a
	 * float, one will get:
 	 *	$ ./gawk -M 'BEGIN { PREC=2; print 13 % 2.0 }'
 	 *	0
 	 */

	prec = mpz_sizeinbase(mz, 2);	/* most significant 1 bit position starting at 1 */
	if (prec > PRECISION_MIN) {
		prec -= (size_t) mpz_scan1(mz, 0);	/* least significant 1 bit index starting at 0 */
		if (prec > MPFR_PREC_MAX)
			prec = MPFR_PREC_MAX;
		else if (prec < PRECISION_MIN)
			prec = PRECISION_MIN;
	}
	else
		prec = PRECISION_MIN;
	/*
	 * Always set the precision to avoid hysteresis, since do_mpfr_func
	 * may copy our precision.
	 */
	if (prec != mpfr_get_prec(mf))
		mpfr_set_prec(mf, prec);

	mpfr_set_z(mf, mz, ROUND_MODE);
	return mf;
}


/* mpg_add --- add arbitrary-precision numbers */

static NODE *
mpg_add(NODE *t1, NODE *t2)
{
	NODE *r;
	int tval;

	if (is_mpg_integer(t1) && is_mpg_integer(t2)) {
		r = mpg_integer();
		mpz_add(r->mpg_i, t1->mpg_i, t2->mpg_i);
	} else {
		r = mpg_float();
		if (is_mpg_integer(t2))
			tval = mpfr_add_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);
		else if (is_mpg_integer(t1))
			tval = mpfr_add_z(r->mpg_numbr, t2->mpg_numbr, t1->mpg_i, ROUND_MODE);
		else
			tval = mpfr_add(r->mpg_numbr, t1->mpg_numbr, t2->mpg_numbr, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	}
	return r;
}

/* mpg_sub --- subtract arbitrary-precision numbers */

static NODE *
mpg_sub(NODE *t1, NODE *t2)
{
	NODE *r;
	int tval;

	if (is_mpg_integer(t1) && is_mpg_integer(t2)) {
		r = mpg_integer();
		mpz_sub(r->mpg_i, t1->mpg_i, t2->mpg_i);
	} else {
		r = mpg_float();
		if (is_mpg_integer(t2))
			tval = mpfr_sub_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);
		else if (is_mpg_integer(t1)) {
#if (!defined(MPFR_VERSION) || (MPFR_VERSION < MPFR_VERSION_NUM(3,1,0)))
			NODE *tmp = t1;
			t1 = t2;
			t2 = tmp;
			tval = mpfr_sub_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);
			tval = mpfr_neg(r->mpg_numbr, r->mpg_numbr, ROUND_MODE);
			t2 = t1;
			t1 = tmp;
#else
			tval = mpfr_z_sub(r->mpg_numbr, t1->mpg_i, t2->mpg_numbr, ROUND_MODE);
#endif
		} else
			tval = mpfr_sub(r->mpg_numbr, t1->mpg_numbr, t2->mpg_numbr, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	}
	return r;
}

/* mpg_mul --- multiply arbitrary-precision numbers */

static NODE *
mpg_mul(NODE *t1, NODE *t2)
{
	NODE *r;
	int tval;

	if (is_mpg_integer(t1) && is_mpg_integer(t2)) {
		r = mpg_integer();
		mpz_mul(r->mpg_i, t1->mpg_i, t2->mpg_i);
	} else {
		r = mpg_float();
		if (is_mpg_integer(t2))
			tval = mpfr_mul_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);
		else if (is_mpg_integer(t1))
			tval = mpfr_mul_z(r->mpg_numbr, t2->mpg_numbr, t1->mpg_i, ROUND_MODE);
		else
			tval = mpfr_mul(r->mpg_numbr, t1->mpg_numbr, t2->mpg_numbr, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	}
	return r;
}


/* mpg_pow --- exponentiation involving arbitrary-precision numbers */

static NODE *
mpg_pow(NODE *t1, NODE *t2)
{
	NODE *r;
	int tval;

	if (is_mpg_integer(t1) && is_mpg_integer(t2)) {
		if (mpz_sgn(t2->mpg_i) >= 0 && mpz_fits_ulong_p(t2->mpg_i)) {
			r = mpg_integer();
			mpz_pow_ui(r->mpg_i, t1->mpg_i, mpz_get_ui(t2->mpg_i));
		} else {
			mpfr_ptr p1, p2;
			p1 = MP_FLOAT(t1);
			p2 = MP_FLOAT(t2);
			r = mpg_float();
			tval = mpfr_pow(r->mpg_numbr, p1, p2, ROUND_MODE);
			IEEE_FMT(r->mpg_numbr, tval);
		}
	} else {
		r = mpg_float();
		if (is_mpg_integer(t2))
			tval = mpfr_pow_z(r->mpg_numbr, t1->mpg_numbr, t2->mpg_i, ROUND_MODE);
		else {
			mpfr_ptr p1;
			p1 = MP_FLOAT(t1);
			tval = mpfr_pow(r->mpg_numbr, p1, t2->mpg_numbr, ROUND_MODE);
		}
		IEEE_FMT(r->mpg_numbr, tval);
	}
	return r;
}

/* mpg_div --- arbitrary-precision division */

static NODE *
mpg_div(NODE *t1, NODE *t2)
{
	NODE *r;
	int tval;

	if (is_mpg_integer(t1) && is_mpg_integer(t2)
			&& (mpz_sgn(t2->mpg_i) != 0)	/* not dividing by 0 */
			&& mpz_divisible_p(t1->mpg_i, t2->mpg_i)
	) {
		r = mpg_integer();
		mpz_divexact(r->mpg_i, t1->mpg_i, t2->mpg_i);
	} else {
		mpfr_ptr p1, p2;
		p1 = MP_FLOAT(t1);
		p2 = MP_FLOAT(t2);
		if (mpfr_zero_p(p2))
			fatal(_("division by zero attempted"));
		r = mpg_float();
		tval = mpfr_div(r->mpg_numbr, p1, p2, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	}
	return r;
}

/* mpg_mod --- modulus operation with arbitrary-precision numbers */

static NODE *
mpg_mod(NODE *t1, NODE *t2)
{
	NODE *r;
	int tval;

	if (is_mpg_integer(t1) && is_mpg_integer(t2)) {
		/*
		 * 8/2014: Originally, this was just
		 *
		 * r = mpg_integer();
		 * mpz_mod(r->mpg_i, t1->mpg_i, t2->mpg_i);
		 *
		 * But that gave very strange results with negative numerator:
		 *
		 *	$ ./gawk -M 'BEGIN { print -15 % 7 }'
		 *	6
		 *
		 * So instead we use mpz_tdiv_qr() to get the correct result
		 * and just throw away the quotient. We could not find any
		 * reason why mpz_mod() wasn't working correctly.
		 */
		NODE *dummy_quotient;

		if (mpz_sgn(t2->mpg_i) == 0)
			fatal(_("division by zero attempted"));
		r = mpg_integer();
		dummy_quotient = mpg_integer();
		mpz_tdiv_qr(dummy_quotient->mpg_i, r->mpg_i, t1->mpg_i, t2->mpg_i);
		unref(dummy_quotient);
	} else {
		mpfr_ptr p1, p2;
		p1 = MP_FLOAT(t1);
		p2 = MP_FLOAT(t2);
		if (mpfr_zero_p(p2))
			fatal(_("division by zero attempted in `%%'"));
		r = mpg_float();
		tval = mpfr_fmod(r->mpg_numbr, p1, p2, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	}
	return r;
}

/*
 * mpg_interpret --- pre-exec hook in the interpreter. Handles
 *	arithmetic operations with MPFR/GMP numbers.
 */

static int
mpg_interpret(INSTRUCTION **cp)
{
	INSTRUCTION *pc = *cp;	/* current instruction */
	OPCODE op;	/* current opcode */
	NODE *r = NULL;
	NODE *t1, *t2;
	NODE **lhs;
	int tval;	/* the ternary value returned by a MPFR function */

	op = pc->opcode;
	if (do_itrace) {
		switch (op) {
		case Op_plus_i:
		case Op_plus:
		case Op_minus_i:
		case Op_minus:
		case Op_times_i:
		case Op_times:
		case Op_exp_i:
		case Op_exp:
		case Op_quotient_i:
		case Op_quotient:
		case Op_mod_i:
		case Op_mod:
		case Op_preincrement:
		case Op_predecrement:
		case Op_postincrement:
		case Op_postdecrement:
		case Op_unary_minus:
		case Op_unary_plus:
		case Op_assign_plus:
		case Op_assign_minus:
		case Op_assign_times:
		case Op_assign_quotient:
		case Op_assign_mod:
		case Op_assign_exp:
			fprintf(stderr, "++ %s: mpg_interpret\n", opcode2str(op));
			fflush(stderr);
			break;
		default:
			return true;	/* unhandled */
		}
	}

	switch (op) {
	case Op_plus_i:
		t2 = force_number(pc->memory);
		goto plus;
	case Op_plus:
		t2 = POP_NUMBER();
plus:
		t1 = TOP_NUMBER();
		r = mpg_add(t1, t2);
		DEREF(t1);
		if (op == Op_plus)
			DEREF(t2);
		REPLACE(r);
		break;

	case Op_minus_i:
		t2 = force_number(pc->memory);
		goto minus;
	case Op_minus:
		t2 = POP_NUMBER();
minus:
		t1 = TOP_NUMBER();
		r = mpg_sub(t1, t2);
		DEREF(t1);
		if (op == Op_minus)
			DEREF(t2);
		REPLACE(r);
		break;

	case Op_times_i:
		t2 = force_number(pc->memory);
		goto times;
	case Op_times:
		t2 = POP_NUMBER();
times:
		t1 = TOP_NUMBER();
		r = mpg_mul(t1, t2);
		DEREF(t1);
		if (op == Op_times)
			DEREF(t2);
		REPLACE(r);
		break;

	case Op_exp_i:
		t2 = force_number(pc->memory);
		goto exp;
	case Op_exp:
		t2 = POP_NUMBER();
exp:
		t1 = TOP_NUMBER();
		r = mpg_pow(t1, t2);
		DEREF(t1);
		if (op == Op_exp)
			DEREF(t2);
		REPLACE(r);
		break;

	case Op_quotient_i:
		t2 = force_number(pc->memory);
		goto quotient;
	case Op_quotient:
		t2 = POP_NUMBER();
quotient:
		t1 = TOP_NUMBER();
		r = mpg_div(t1, t2);
		DEREF(t1);
		if (op == Op_quotient)
			DEREF(t2);
		REPLACE(r);
		break;

	case Op_mod_i:
		t2 = force_number(pc->memory);
		goto mod;
	case Op_mod:
		t2 = POP_NUMBER();
mod:
		t1 = TOP_NUMBER();
		r = mpg_mod(t1, t2);
		DEREF(t1);
		if (op == Op_mod)
			DEREF(t2);
		REPLACE(r);
		break;

	case Op_preincrement:
	case Op_predecrement:
		lhs = TOP_ADDRESS();
		t1 = *lhs;
		force_number(t1);

		if (is_mpg_integer(t1)) {
			if (t1->valref == 1 && t1->flags == (MALLOC|MPZN|NUMCUR|NUMBER))
			/* Efficiency hack. Big speed-up (> 30%) in a tight loop */
				r = t1;
			else
				r = *lhs = mpg_integer();
			if (op == Op_preincrement)
				mpz_add_ui(r->mpg_i, t1->mpg_i, 1);
			else
				mpz_sub_ui(r->mpg_i, t1->mpg_i, 1);
		} else {

			/*
			 * An optimization like the one above is not going to work
			 * for a floating-point number. With it,
			 *   gawk -M 'BEGIN { PREC=53; i=2^53+0.0; PREC=113; ++i; print i}'
		 	 * will output 2^53 instead of 2^53+1.
		 	 */

			r = *lhs = mpg_float();
			tval = mpfr_add_si(r->mpg_numbr, t1->mpg_numbr,
					op == Op_preincrement ? 1 : -1,
					ROUND_MODE);
			IEEE_FMT(r->mpg_numbr, tval);
		}
		if (r != t1)
			unref(t1);
		UPREF(r);
		REPLACE(r);
		break;

	case Op_postincrement:
	case Op_postdecrement:
		lhs = TOP_ADDRESS();
		t1 = *lhs;
		force_number(t1);

		if (is_mpg_integer(t1)) {
			r = mpg_integer();
			mpz_set(r->mpg_i, t1->mpg_i);
			if (t1->valref == 1 && t1->flags == (MALLOC|MPZN|NUMCUR|NUMBER))
			/* Efficiency hack. Big speed-up (> 30%) in a tight loop */
				t2 = t1;
			else
				t2 = *lhs = mpg_integer();
			if (op == Op_postincrement)
				mpz_add_ui(t2->mpg_i, t1->mpg_i, 1);
			else
				mpz_sub_ui(t2->mpg_i, t1->mpg_i, 1);
		} else {
			r = mpg_float();
			tval = mpfr_set(r->mpg_numbr, t1->mpg_numbr, ROUND_MODE);
			IEEE_FMT(r->mpg_numbr, tval);
			t2 = *lhs = mpg_float();
			tval = mpfr_add_si(t2->mpg_numbr, t1->mpg_numbr,
					op == Op_postincrement ? 1 : -1,
					ROUND_MODE);
			IEEE_FMT(t2->mpg_numbr, tval);
		}
		if (t2 != t1)
			unref(t1);
		REPLACE(r);
		break;

	case Op_unary_minus:
		t1 = TOP_NUMBER();
		if (is_mpg_float(t1)) {
			r = mpg_float();
			tval = mpfr_neg(r->mpg_numbr, t1->mpg_numbr, ROUND_MODE);
			IEEE_FMT(r->mpg_numbr, tval);
		} else {
			if (! is_zero(t1)) {
				r = mpg_integer();
				mpz_neg(r->mpg_i, t1->mpg_i);
			} else {
				// have to convert to MPFR for -0.0. sigh
				r = mpg_float();
				tval = mpfr_set_d(r->mpg_numbr, 0.0, ROUND_MODE);
				IEEE_FMT(r->mpg_numbr, tval);
				tval = mpfr_neg(r->mpg_numbr, r->mpg_numbr, ROUND_MODE);
				IEEE_FMT(r->mpg_numbr, tval);
			}
		}
		DEREF(t1);
		REPLACE(r);
		break;

	case Op_unary_plus:
		t1 = TOP_NUMBER();
		if (is_mpg_float(t1)) {
			r = mpg_float();
			tval = mpfr_set(r->mpg_numbr, t1->mpg_numbr, ROUND_MODE);
			IEEE_FMT(r->mpg_numbr, tval);
		} else {
			r = mpg_integer();
			mpz_set(r->mpg_i, t1->mpg_i);
		}
		DEREF(t1);
		REPLACE(r);
		break;

	case Op_assign_plus:
	case Op_assign_minus:
	case Op_assign_times:
	case Op_assign_quotient:
	case Op_assign_mod:
	case Op_assign_exp:
		lhs = POP_ADDRESS();
		t1 = *lhs;
		force_number(t1);
		t2 = TOP_NUMBER();

		switch (op) {
		case Op_assign_plus:
			r = mpg_add(t1, t2);
			break;
		case Op_assign_minus:
			r = mpg_sub(t1, t2);
			break;
		case Op_assign_times:
			r = mpg_mul(t1, t2);
			break;
		case Op_assign_quotient:
			r = mpg_div(t1, t2);
			break;
		case Op_assign_mod:
			r = mpg_mod(t1, t2);
			break;
		case Op_assign_exp:
			r = mpg_pow(t1, t2);
			break;
		default:
			cant_happen("unexpected opcode %s", opcode2str(op));
		}

		DEREF(t2);
		unref(*lhs);
		*lhs = r;
		UPREF(r);
		REPLACE(r);
		break;

	default:
		return true;	/* unhandled */
	}

	*cp = pc->nexti;	/* next instruction to execute */
	return false;
}


/* mpg_fmt --- output formatted string with special MPFR/GMP conversion specifiers */

const char *
mpg_fmt(const char *mesg, ...)
{
	static char *tmp = NULL;
	int ret;
	va_list args;

	if (tmp != NULL) {
		mpfr_free_str(tmp);
		tmp = NULL;
	}
	va_start(args, mesg);
	ret = mpfr_vasprintf(& tmp, mesg, args);
	va_end(args);
	if (ret >= 0 && tmp != NULL)
		return tmp;
	return mesg;
}

/* mpfr_unset --- clear out the MPFR values */

void
mpfr_unset(NODE *n)
{
	if (is_mpg_float(n))
		mpfr_clear(n->mpg_numbr);
	else if (is_mpg_integer(n))
		mpz_clear(n->mpg_i);
}

/*
 * Custom memory allocation functions for GMP / MPFR. We need these so that the
 * persistent memory feature will also work with the -M option.
 *
 * These just call malloc/realloc/free; if we are using PMA then those are
 * redefined as macros to point at the pma functions, so all should "just work."
 */

/* mpfr_mem_alloc --- allocate memory */

void *
mpfr_mem_alloc(size_t alloc_size)
{
	return malloc(alloc_size);
}

/* mpfr_mem_realloc --- reallocate memory */

void *
mpfr_mem_realloc(void *ptr, size_t old_size, size_t new_size)
{
	return realloc(ptr, new_size);
}

/* mpfr_mem_free --- free memory */

void
mpfr_mem_free(void *ptr, size_t size)
{
	free(ptr);
}

#else

void
set_PREC()
{
	/* dummy function */
}

void
set_ROUNDMODE()
{
	/* dummy function */
}

void
mpfr_unset(NODE *n)
{
	/* dummy function */
}
#endif
/*
 * msg.c - routines for error messages.
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2001, 2003, 2010-2013, 2017-2019,
 * 2021, 2022, 2023,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

extern FILE *output_fp;
int sourceline = 0;
char *source = NULL;
static const char *srcfile = NULL;
static int srcline;

jmp_buf fatal_tag;
int fatal_tag_valid = 0;

/* err --- print an error message with source line and file and record */

/* VARARGS2 */
void
err(bool isfatal, const char *s, const char *emsg, va_list argp)
{
	char *file;
	const char *me;

	static bool first = true;
	static bool add_src_info = false;
	static long lineno_val = 0;	// Easter Egg

	if (first) {
		first = false;
		add_src_info = (getenv("GAWK_MSG_SRC") != NULL);
		if (! do_traditional) {
			NODE *n = lookup("LINENO");

			if (n != NULL && n->type == Node_var)
				lineno_val = get_number_d(n->var_value);
		}
	}

	(void) fflush(output_fp);
	me = myname;
	(void) fprintf(stderr, "%s: ", me);

	if (srcfile != NULL && add_src_info) {
		fprintf(stderr, "%s:%d:", srcfile, srcline);
		srcfile = NULL;
	}

	if (sourceline > 0) {
		if (source != NULL)
			(void) fprintf(stderr, "%s:", source);
		else
			(void) fprintf(stderr, _("cmd. line:"));

		(void) fprintf(stderr, "%ld: ", sourceline + lineno_val);
	}

#ifdef HAVE_MPFR
	if (FNR_node && FNR_node->var_value && is_mpg_number(FNR_node->var_value)) {
		NODE *val;
		val = mpg_update_var(FNR_node);
		assert((val->flags & MPZN) != 0);
		if (mpz_sgn(val->mpg_i) > 0) {
			int len = FILENAME_node->var_value->stlen;
			file = FILENAME_node->var_value->stptr;
			(void) putc('(', stderr);
			if (file)
				(void) fprintf(stderr, "FILENAME=%.*s ", len, file);
			(void) mpfr_fprintf(stderr, "FNR=%Zd) ", val->mpg_i);
		}
	} else
#endif
	if (FNR > 0) {
		int len = FILENAME_node->var_value->stlen;
		file = FILENAME_node->var_value->stptr;
		(void) putc('(', stderr);
		if (file)
			(void) fprintf(stderr, "FILENAME=%.*s ", len, file);
		(void) fprintf(stderr, "FNR=%ld) ", FNR);
	}

	(void) fprintf(stderr, "%s", s);
	vfprintf(stderr, emsg, argp);
	(void) fprintf(stderr, "\n");
	(void) fflush(stderr);

	if (isfatal)
		gawk_exit(EXIT_FATAL);

}

/* msg --- take a varargs error message and print it */

void
msg(const char *mesg, ...)
{
	va_list args;
	va_start(args, mesg);
	err(false, "", mesg, args);
	va_end(args);
}

/* r_warning --- print a warning message */

void
r_warning(const char *mesg, ...)
{
	va_list args;
	va_start(args, mesg);
	err(false, _("warning: "), mesg, args);
	va_end(args);
}

void
error(const char *mesg, ...)
{
	va_list args;
	va_start(args, mesg);
	err(false, _("error: "), mesg, args);
	va_end(args);
}

/* set_loc --- set location where a fatal error happened */

void
set_loc(const char *file, int line)
{
	srcfile = file;
	srcline = line;

	/* This stupid line keeps some compilers happy: */
	file = srcfile; line = srcline;
}

/* r_fatal --- print a fatal error message */

void
r_fatal(const char *mesg, ...)
{
	va_list args;
	va_start(args, mesg);
	err(true, _("fatal: "), mesg, args);
	va_end(args);
}

/* gawk_exit --- longjmp out if necessary */

void
gawk_exit(int status)
{
	if (fatal_tag_valid) {
		exit_val = status;
		longjmp(fatal_tag, 1);
	}

	final_exit(status);
}

/* final_exit --- run extension exit handlers and exit */

void
final_exit(int status)
{
	/* run any extension exit handlers */
	run_ext_exit_handlers(status);

	/* we could close_io() here */
	close_extensions();

	exit(status);
}
/*
 * node.c -- routines for node management
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2001, 2003-2015, 2017-2019, 2021-2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

static NODE *r_make_number(double x);
static AWKNUM get_ieee_magic_val(char *val);
extern NODE **fmt_list;          /* declared in eval.c */

NODE *(*make_number)(double) = r_make_number;
NODE *(*str2number)(NODE *) = r_force_number;
NODE *(*format_val)(const char *, int, NODE *) = r_format_val;
int (*cmp_numbers)(const NODE *, const NODE *) = cmp_awknums;

/* is_hex --- return true if a string looks like a hex value */

static bool
is_hex(const char *str, const char *cpend)
{
	/* on entry, we know the string length is >= 1 */
	if (*str == '-' || *str == '+')
		str++;

	if (str + 1 < cpend && str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
		return true;

	return false;
}

/* force_number --- force a value to be numeric */

NODE *
r_force_number(NODE *n)
{
	char *cp;
	char *cpend;
	char save;
	char *ptr;

	if (n->type == Node_elem_new) {
		elem_new_reset(n);
		n->type = Node_val;

		return n;
	}

	if ((n->flags & NUMCUR) != 0)
		return n;

	/*
	 * We should always set NUMCUR. If USER_INPUT is set and it's a
	 * numeric string, we clear STRING and enable NUMBER, but if it's not
	 * numeric, we disable USER_INPUT.
	 */

	/* All the conditionals are an attempt to avoid the expensive strtod */

	n->flags |= NUMCUR;
	n->numbr = 0.0;

	/* Trim leading white space, bailing out if there's nothing else */
	for (cp = n->stptr, cpend = cp + n->stlen;
	     cp < cpend && isspace((unsigned char) *cp); cp++)
		continue;

	if (cp == cpend)
		goto badnum;

	/* At this point, we know the string is not entirely white space */
	/* Trim trailing white space */
	while (isspace((unsigned char) cpend[-1]))
		cpend--;

	/*
	 * 2/2007:
	 * POSIX, by way of severe language lawyering, seems to
	 * allow things like "inf" and "nan" to mean something.
	 * So if do_posix, the user gets what he deserves.
	 * This also allows hexadecimal floating point. Ugh.
	 */
	if (! do_posix) {
		if (is_alpha((unsigned char) *cp))
			goto badnum;
		else if (is_ieee_magic_val(cp)) {
			if (cpend == cp + 4) {
				n->numbr = get_ieee_magic_val(cp);
				goto goodnum;
			} else
				goto badnum;
		}
		/* else
			fall through */
	}
	/* else POSIX, so
		fall through */

	if (   (! do_posix		/* not POSIXLY paranoid and */
	        && (is_alpha((unsigned char) *cp)	/* letter, or */
					/* CANNOT do non-decimal and saw 0x */
		    || (! do_non_decimal_data && is_hex(cp, cpend))))) {
		goto badnum;
	}

	if (cpend - cp == 1) {		/* only one character */
		if (isdigit((unsigned char) *cp)) {	/* it's a digit! */
			n->numbr = (AWKNUM)(*cp - '0');
			if (n->stlen == 1)		/* no white space */
				n->flags |= NUMINT;
			goto goodnum;
		}
		goto badnum;
	}

	errno = 0;
	if (do_non_decimal_data		/* main.c assures false if do_posix */
		&& ! do_traditional && get_numbase(cp, cpend - cp, true) != 10) {
		/* nondec2awknum() saves and restores the byte after the string itself */
		n->numbr = nondec2awknum(cp, cpend - cp, &ptr);
	} else {
		save = *cpend;
		*cpend = '\0';
		n->numbr = (AWKNUM) strtod((const char *) cp, &ptr);
		*cpend = save;
	}

	if (errno == 0 || errno == ERANGE) {
		errno = 0;	/* reset in case of ERANGE */
		if (ptr == cpend)
			goto goodnum;
		/* else keep the leading numeric value without updating flags */
		/* fall through to badnum */
	} else {
		errno = 0;
		/*
		 * N.B. For subnormal values, strtod may return the
		 * floating-point representation while setting errno to ERANGE.
		 * We force the numeric value to 0 in such cases.
		 */
		n->numbr = 0;
		/*
		 * Or should we accept it as a NUMBER even though strtod
		 * threw an error?
		 */
		/* fall through to badnum */
	}
badnum:
	n->flags &= ~USER_INPUT;
	return n;

goodnum:
	if (isnan(n->numbr) && *cp == '-' && signbit(n->numbr) == 0)
		n->numbr = -(n->numbr);

	if ((n->flags & USER_INPUT) != 0) {
		/* leave USER_INPUT enabled to indicate that this is a strnum */
		n->flags &= ~STRING;
		n->flags |= NUMBER;
	}
	return n;
}


/*
 * The following lookup table is used as an optimization in force_string;
 * (more complicated) variations on this theme didn't seem to pay off, but
 * systematic testing might be in order at some point.
 */
static const char *values[] = {
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
};
#define	NVAL	(sizeof(values)/sizeof(values[0]))

/* r_format_val --- format a numeric value based on format */

NODE *
r_format_val(const char *format, int index, NODE *s)
{
	char buf[BUFSIZ];
	char *sp = buf;
	double val;

	/*
	 * 2/2007: Simplify our lives here. Instead of worrying about
	 * whether or not the value will fit into a long just so we
	 * can use sprintf("%ld", val) on it, always format it ourselves.
	 * The only thing to worry about is that integral values always
	 * format as integers. %.0f does that very well.
	 *
	 * 6/2008: Would that things were so simple. Always using %.0f
	 * imposes a notable performance penalty for applications that
	 * do a lot of conversion of integers to strings. So, we reinstate
	 * the old code, but use %.0f for integral values that are outside
	 * the range of a long.  This seems a reasonable compromise.
	 *
	 * 12/2009: Use <= and >= in the comparisons with LONG_xxx instead of
	 * < and > so that things work correctly on systems with 64 bit integers.
	 */

	if (out_of_range(s)) {
		const char *result = format_nan_inf(s, 'g');
		return make_string(result, strlen(result));
	} else if ((val = double_to_int(s->numbr)) != s->numbr
			|| val <= LONG_MIN || val >= LONG_MAX
	) {
		/* not an integral value, or out of integer range */
		/*
		 * Once upon a time, we just blindly did this:
		 *	sprintf(sp, format, s->numbr);
		 *	s->stlen = strlen(sp);
		 *	s->stfmt = index;
		 * but that's no good if, e.g., OFMT is %s. So we punt,
		 * and just always format the value ourselves.
		 */

		NODE *dummy[2], *r;
		unsigned int oflags;

		/* create dummy node for a sole use of format_args */
		dummy[1] = s;
		oflags = s->flags;

		if (val == s->numbr) {
			/* integral value, but outside range of %ld, use %.0f */
			r = format_args("%.0f", 4, dummy, 2);
			s->stfmt = STFMT_UNUSED;
		} else {
			r = format_args(format, fmt_list[index]->stlen, dummy, 2);
			assert(r != NULL);
			s->stfmt = index;
		}
		s->flags = oflags;
		s->stlen = r->stlen;
		if ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
			efree(s->stptr);
		s->stptr = r->stptr;
#ifdef HAVE_MPFR
		s->strndmode = MPFR_round_mode;
#endif
		freenode(r);	/* Do not unref(r)! We want to keep s->stptr == r->stpr.  */

		goto no_malloc;
	} else {
		/*
		 * integral value; force conversion to long only once.
		 */
		long num = (long) val;

		if (num < NVAL && num >= 0) {
			sp = (char *) values[num];
			s->stlen = 1;
		} else {
			(void) sprintf(sp, "%ld", num);
			s->stlen = strlen(sp);
		}
		s->stfmt = STFMT_UNUSED;
		if ((s->flags & INTIND) != 0) {
			s->flags &= ~(INTIND|NUMBER);
			s->flags |= STRING;
		}
#ifdef HAVE_MPFR
		s->strndmode = MPFR_round_mode;
#endif
	}
	if ((s->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
		efree(s->stptr);
	emalloc(s->stptr, char *, s->stlen + 1);
	memcpy(s->stptr, sp, s->stlen + 1);
no_malloc:
	s->flags |= STRCUR;
	free_wstr(s);
	return s;
}

/* r_dupnode --- duplicate a node */

NODE *
r_dupnode(NODE *n)
{
	NODE *r;

	assert(n->type == Node_val);

#ifdef GAWKDEBUG
	/* Do the same as in awk.h:dupnode().  */
	if ((n->flags & MALLOC) != 0) {
		n->valref++;
		return n;
	}
#endif
	getnode(r);
	*r = *n;

#ifdef HAVE_MPFR
	if ((n->flags & MPZN) != 0) {
		mpz_init(r->mpg_i);
		mpz_set(r->mpg_i, n->mpg_i);
	} else if ((n->flags & MPFN) != 0) {
		mpfr_init(r->mpg_numbr);
		int tval = mpfr_set(r->mpg_numbr, n->mpg_numbr, ROUND_MODE);
		IEEE_FMT(r->mpg_numbr, tval);
	}
#endif

	r->flags |= MALLOC;
	r->valref = 1;
	/*
	 * DON'T call free_wstr(r) here!
	 * r->wstptr still points at n->wstptr's value, and we
	 * don't want to free it!
	 */
	r->wstptr = NULL;
	r->wstlen = 0;

	if ((n->flags & STRCUR) != 0) {
		emalloc(r->stptr, char *, n->stlen + 1);
		memcpy(r->stptr, n->stptr, n->stlen);
		r->stptr[n->stlen] = '\0';
		r->stlen = n->stlen;
		if ((n->flags & WSTRCUR) != 0) {
			r->wstlen = n->wstlen;
			emalloc(r->wstptr, wchar_t *, sizeof(wchar_t) * (n->wstlen + 1));
			memcpy(r->wstptr, n->wstptr, n->wstlen * sizeof(wchar_t));
			r->wstptr[n->wstlen] = L'\0';
			r->flags |= WSTRCUR;
		}
	}

	return r;
}

/* r_make_number --- allocate a node with defined number */

static NODE *
r_make_number(double x)
{
	NODE *r = make_number_node(0);
	r->numbr = x;
	return r;
}

/* cmp_awknums --- compare two AWKNUMs */

int
cmp_awknums(const NODE *t1, const NODE *t2)
{
	/*
	 * This routine is used to sort numeric array indices or values.
	 * For the purposes of sorting, NaN is considered greater than
	 * any other value, and all NaN values are considered equivalent and equal.
	 * This isn't in compliance with IEEE standard, but compliance w.r.t. NaN
	 * comparison at the awk level is a different issue, and needs to be dealt
	 * with in the interpreter for each opcode seperately.
	 */

	if (isnan(t1->numbr))
		return ! isnan(t2->numbr);
	if (isnan(t2->numbr))
		return -1;
	/* don't subtract, in case one or both are infinite */
	if (t1->numbr == t2->numbr)
		return 0;
	if (t1->numbr < t2->numbr)
		return -1;
	return 1;
}

/* make_str_node --- make a string node */

NODE *
make_str_node(const char *s, size_t len, int flags)
{
	NODE *r;
	getnode(r);
	memset(r, '\0', sizeof(NODE));
	r->type = Node_val;
	r->numbr = 0;
	r->flags = (MALLOC|STRING|STRCUR);
	r->valref = 1;
	r->stfmt = STFMT_UNUSED;
#ifdef HAVE_MPFR
	r->strndmode = MPFR_round_mode;
#endif
	r->wstptr = NULL;
	r->wstlen = 0;

	if ((flags & ALREADY_MALLOCED) != 0)
		r->stptr = (char *) s;
	else {
		emalloc(r->stptr, char *, len + 1);
		memcpy(r->stptr, s, len);
	}
	r->stptr[len] = '\0';

	if ((flags & SCAN) != 0) {	/* scan for escape sequences */
		const char *pf;
		char *ptm;
		int c;
		const char *end;
		mbstate_t cur_state;

		memset(& cur_state, 0, sizeof(cur_state));

		end = &(r->stptr[len]);
		for (pf = ptm = r->stptr; pf < end;) {
			/*
			 * Keep multibyte characters together. This avoids
			 * problems if a subsequent byte of a multibyte
			 * character happens to be a backslash.
			 */
			if (gawk_mb_cur_max > 1) {
				size_t mblen = mbrlen(pf, end-pf, &cur_state);

				/*
				 * Incomplete (-2), invalid (-1), and
				 * null (0) characters are excluded here.
				 * They are read as a sequence of bytes.
				 */
				if (mblen > 1 && mblen < (size_t) -2) {
					size_t i;

					for (i = 0; i < mblen; i++)
						*ptm++ = *pf++;
					continue;
				}
			}

			c = *pf++;
			if (c == '\\') {
				const char *result;
				size_t nbytes;
				enum escape_results ret;

				ret = parse_escape(& pf, & result, & nbytes);
				switch (ret) {
				case ESCAPE_OK:
					assert(nbytes > 0);
					while (nbytes--)
						*ptm++ = *result++;
					break;
				case ESCAPE_CONV_ERR:
					*ptm++ = '?';
					break;
				case ESCAPE_TERM_BACKSLASH:
					if (do_lint)
						lintwarn(_("backslash at end of string"));
					*ptm++ = '\\';
					break;
				case ESCAPE_LINE_CONTINUATION:
					if (do_lint)
						lintwarn(_("backslash string continuation is not portable"));
					continue;
				default:
					cant_happen("received bad result %d from parse_escape(), nbytes = %zu",
							(int) ret, nbytes);
					break;
				}
			} else
				*ptm++ = c;
		}
		len = ptm - r->stptr;
		erealloc(r->stptr, char *, len + 1);
		r->stptr[len] = '\0';
	}
	r->stlen = len;

	return r;
}

/* make_typed_regex --- make a typed regex node */

NODE *
make_typed_regex(const char *re, size_t len)
{
	NODE *n, *exp, *n2;

	exp = make_str_node(re, len, ALREADY_MALLOCED);
	n = make_regnode(Node_regex, exp);
	if (n == NULL)
		fatal(_("could not make typed regex"));

	n2 = make_string(re, len);
	n2->typed_re = n;
#if HAVE_MPFR
	if (do_mpfr)
		mpg_zero(n2);
	else
#endif
	n2->numbr = 0;
	n2->flags |= NUMCUR|STRCUR|REGEX;
	n2->flags &= ~(STRING|NUMBER);

	return n2;
}


/* unref --- remove reference to a particular node */

void
r_unref(NODE *tmp)
{
#ifdef GAWKDEBUG
	/* Do the same as in awk.h:unref().  */
	assert(tmp == NULL || tmp->valref > 0);
	if (tmp == NULL || --tmp->valref > 0)
		return;
#endif

	if ((tmp->flags & (MALLOC|STRCUR)) == (MALLOC|STRCUR))
		efree(tmp->stptr);

	if ((tmp->flags & REGEX) != 0) {
		refree(tmp->typed_re->re_reg[0]);
		if (tmp->typed_re->re_reg[1] != NULL)
			refree(tmp->typed_re->re_reg[1]);
		unref(tmp->typed_re->re_exp);
		freenode(tmp->typed_re);
	}

	mpfr_unset(tmp);

	if (tmp->type == Node_elem_new && tmp->elemnew_vname != NULL)
		efree(tmp->elemnew_vname);
	else if ((tmp->type == Node_var || tmp->type == Node_var_new)
			&& tmp->vname != NULL)
		efree(tmp->vname);

	free_wstr(tmp);
	freenode(tmp);
}


/*
 * parse_escape:
 *
 * Parse a C escape sequence.  string_ptr points to a variable containing
 * a pointer to the string to parse.  result points to a pointer which will
 * be set to the address of the internal buffer holding the bytes of the
 * translated escape sequence.
 *
 * Return values:
 *	ESCAPE_OK,		// nbytes == 1 to MB_CUR_MAX: the length of the translated escape sequence
 *	ESCAPE_CONV_ERR,	// wcrtomb conversion error
 *	ESCAPE_TERM_BACKSLASH,	// terminal backslash (to be preserved in cmdline strings)
 *	ESCAPE_LINE_CONTINUATION	// line continuation  (backslash-newline pair)
 *
 * POSIX doesn't allow \x or \u.
 */

enum escape_results
parse_escape(const char **string_ptr, const char **result, size_t *nbytes)
{
	static char buf[MB_LEN_MAX];
	enum escape_results retval = ESCAPE_OK;
	int c = *(*string_ptr)++;
	int i;
	int count;
	int j;
	const char *start;

	*nbytes = 1;
	if (do_lint_old) {
		switch (c) {
		case 'a':
		case 'b':
		case 'f':
		case 'r':
			lintwarn(_("old awk does not support the `\\%c' escape sequence"), c);
			break;
		}
	}

	switch (c) {
	case 'a':
		buf[0] = '\a';
		break;
	case 'b':
		buf[0] = '\b';
		break;
	case 'f':
		buf[0] = '\f';
		break;
	case 'n':
		buf[0] = '\n';
		break;
	case 'r':
		buf[0] = '\r';
		break;
	case 't':
		buf[0] = '\t';
		break;
	case 'v':
		buf[0] = '\v';
		break;
	case '\n':
		retval = ESCAPE_LINE_CONTINUATION;
		break;
	case 0:
		(*string_ptr)--;
		retval = ESCAPE_TERM_BACKSLASH;
		break;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
		i = c - '0';
		count = 0;
		while (++count < 3) {
			if ((c = *(*string_ptr)++) >= '0' && c <= '7') {
				i *= 8;
				i += c - '0';
			} else {
				(*string_ptr)--;
				break;
			}
		}
		buf[0] = i;
		break;
	case 'x':
		if (do_lint) {
			static bool warned = false;

			if (! warned) {
				warned = true;
				lintwarn(_("POSIX does not allow `\\x' escapes"));
			}
		}
		if (do_posix) {
			buf[0] = 'x';
			break;
		}
		if (! isxdigit((unsigned char) (*string_ptr)[0])) {
			warning(_("no hex digits in `\\x' escape sequence"));
			buf[0] = 'x';
			break;
		}
		start = *string_ptr;
		for (i = j = 0; j < 2; j++) {
			/* do outside test to avoid multiple side effects */
			c = (unsigned char) *(*string_ptr)++;
			if (isxdigit(c)) {
				i *= 16;
				if (isdigit(c))
					i += c - '0';
				else if (isupper(c))
					i += c - 'A' + 10;
				else
					i += c - 'a' + 10;
			} else {
				(*string_ptr)--;
				break;
			}
		}
		if (do_lint && j == 2 && isxdigit((unsigned char)*(*string_ptr)))
			lintwarn(_("hex escape \\x%.*s of %d characters probably not interpreted the way you expect"), 3, start, 3);
		buf[0] = i;
		break;
	case 'u':
	{
		size_t n;
#ifndef __MINGW32__
		mbstate_t mbs;
#endif

		if (do_lint) {
			static bool warned = false;

			if (! warned) {
				warned = true;
				lintwarn(_("POSIX does not allow `\\u' escapes"));
			}
		}
		if (do_posix) {
			buf[0] = 'u';
			break;
		}
		if (! isxdigit((unsigned char) (*string_ptr)[0])) {
			warning(_("no hex digits in `\\u' escape sequence"));
			buf[0] = 'u';
			break;
		}
		start = *string_ptr;
		for (i = j = 0; j < 8; j++) {
			/* do outside test to avoid multiple side effects */
			c = (unsigned char) *(*string_ptr)++;
			if (isxdigit(c)) {
				i *= 16;
				if (isdigit(c))
					i += c - '0';
				else if (isupper(c))
					i += c - 'A' + 10;
				else
					i += c - 'a' + 10;
			} else {
				(*string_ptr)--;
				break;
			}
		}
#ifdef __MINGW32__
		n = w32_wc_to_lc (i, buf);
#elif defined (__CYGWIN__)
		memset(& mbs, 0, sizeof(mbs));
		n = wcitomb(buf, i, & mbs);
#else
		memset(& mbs, 0, sizeof(mbs));
		n = wcrtomb(buf, i, & mbs);
#endif	/* !__MINGW32__ */
		if (n == (size_t) -1) {
			warning(_("invalid `\\u' escape sequence"));
			retval = ESCAPE_CONV_ERR;
			*nbytes = 0;
		} else {
			*nbytes = n;
		}
		break;
	}
	case '\\':
	case '"':
		buf[0] = c;
		break;
	default:
	{
		static bool warned[256];
		unsigned char uc = (unsigned char) c;

		/* N.B.: use unsigned char here to avoid Latin-1 problems */

		if (! warned[uc]) {
			warned[uc] = true;

			warning(_("escape sequence `\\%c' treated as plain `%c'"), uc, uc);
		}
	}
		buf[0] = c;
		break;
	}

	*result = buf;
	return retval;
}

/* get_numbase --- return the base to use for the number in 's' */

int
get_numbase(const char *s, size_t len, bool use_locale)
{
	int dec_point = '.';
	const char *str = s;

#if defined(HAVE_LOCALE_H)
	/*
	 * loc.decimal_point may not have been initialized yet,
	 * so double check it before using it.
	 */
	if (use_locale && loc.decimal_point != NULL && loc.decimal_point[0] != '\0')
		dec_point = loc.decimal_point[0];	/* XXX --- assumes one char */
#endif

	if (len < 2 || str[0] != '0')
		return 10;

	/* leading 0x or 0X */
	if (str[1] == 'x' || str[1] == 'X')
		return 16;

	/*
	 * Numbers with '.', 'e', or 'E' are decimal.
	 * Have to check so that things like 00.34 are handled right.
	 *
	 * These beasts can have trailing whitespace. Deal with that too.
	 */
	for (; len > 0; len--, str++) {
		if (*str == 'e' || *str == 'E' || *str == dec_point)
			return 10;
		else if (! isdigit((unsigned char) *str))
			break;
	}

	if (! isdigit((unsigned char) s[1])
			|| s[1] == '8' || s[1] == '9'
	)
		return 10;
	return 8;
}

/* str2wstr --- convert a multibyte string to a wide string */

NODE *
str2wstr(NODE *n, size_t **ptr)
{
	size_t i, count, src_count;
	char *sp;
	mbstate_t mbs;
	wchar_t wc, *wsp;
	static bool warned = false;

	assert((n->flags & (STRING|STRCUR)) != 0);

	/*
	 * For use by do_match, create and fill in an array.
	 * For each byte `i' in n->stptr (the original string),
	 * a[i] is equal to `j', where `j' is the corresponding wchar_t
	 * in the converted wide string.
	 *
	 * This is needed even for Nnull_string or Null_field.
	 *
	 * Create the array.
	 */
	if (ptr != NULL) {
		ezalloc(*ptr, size_t *, sizeof(size_t) * (n->stlen + 1));
	}

	/*
	 * Don't convert global null string or global null field
	 * variables to a wide string. They are both zero-length anyway.
	 * This also avoids future double-free errors while releasing
	 * shallow copies, eg. *tmp = *Null_field; free_wstr(tmp);
	 */
	if (n == Nnull_string || n == Null_field)
		return n;

	if ((n->flags & WSTRCUR) != 0) {
		if (ptr == NULL)
			return n;
		/* otherwise
			fall through and recompute to fill in the array */
		free_wstr(n);
	}

	/*
	 * After consideration and consultation, this
	 * code trades space for time. We allocate
	 * an array of wchar_t that is n->stlen long.
	 * This is needed in the worst case anyway, where
	 * each input byte maps to one wchar_t.  The
	 * advantage is that we only have to convert the string
	 * once, instead of twice, once to find out how many
	 * wide characters, and then again to actually fill in
	 * the info.  If there's a lot left over, we can
	 * realloc the wide string down in size.
	 */

	emalloc(n->wstptr, wchar_t *, sizeof(wchar_t) * (n->stlen + 1));
	wsp = n->wstptr;

	sp = n->stptr;
	src_count = n->stlen;
	memset(& mbs, 0, sizeof(mbs));
	for (i = 0; src_count > 0; i++) {
		/*
		 * 9/2010: Check the current byte; if it's a valid character,
		 * then it doesn't start a multibyte sequence. This brings a
		 * big speed up. Thanks to Ulrich Drepper for the tip.
		 * 11/2010: Thanks to Paolo Bonzini for some even faster code.
		 */
		if (is_valid_character(*sp)) {
			count = 1;
			wc = btowc_cache(*sp);
		} else
			count = mbrtowc(& wc, sp, src_count, & mbs);
		switch (count) {
		case (size_t) -2:
		case (size_t) -1:
			/*
			 * mbrtowc(3) says the state of mbs becomes undefined
			 * after a bad character, so reset it.
			 */
			memset(& mbs, 0, sizeof(mbs));

			/* Warn the user something's wrong */
			if (! warned) {
				warned = true;
				warning(_("Invalid multibyte data detected. There may be a mismatch between your data and your locale"));
			}

			/*
			 * 8/2015: If we're using UTF, then instead of just
			 * skipping the character, plug in the Unicode
			 * replacement character. In most cases this gives
			 * us "better" results, in that character counts
			 * and string lengths tend to make more sense.
			 *
			 * Otherwise, just skip the bad byte and keep going,
			 * so that we get a more-or-less full string, instead of
			 * stopping early. This is particularly important
			 * for match() where we need to build the indices.
			 */
			if (using_utf8()) {
				count = 1;
				wc = 0xFFFD;	/* unicode replacement character */
				goto set_wc;
			} else {
				/* skip it and keep going */
				sp++;
				src_count--;
			}
			break;

		case 0:
			count = 1;
			/* fall through */
		default:
		set_wc:
			*wsp++ = wc;
			src_count -= count;
			while (count--)  {
				if (ptr != NULL)
					(*ptr)[sp - n->stptr] = i;
				sp++;
			}
			break;
		}
	}

	/* Needed for zero-length matches at the end of a string */
	assert(sp - n->stptr == n->stlen);
	if (ptr != NULL)
		(*ptr)[sp - n->stptr] = i;

	*wsp = L'\0';
	n->wstlen = wsp - n->wstptr;
	n->flags |= WSTRCUR;
#define ARBITRARY_AMOUNT_TO_GIVE_BACK 100
	if (n->stlen - n->wstlen > ARBITRARY_AMOUNT_TO_GIVE_BACK)
		erealloc(n->wstptr, wchar_t *, sizeof(wchar_t) * (n->wstlen + 1));

	return n;
}

/* wstr2str --- convert a wide string back into multibyte one */

NODE *
wstr2str(NODE *n)
{
	size_t result;
	size_t length;
	wchar_t *wp;
	mbstate_t mbs;
	char *newval, *cp;

	assert(n->valref == 1);
	assert((n->flags & WSTRCUR) != 0);

	/*
	 * Convert the wide chars in t1->wstptr back into m.b. chars.
	 * This is pretty grotty, but it's the most straightforward
	 * way to do things.
	 */
	memset(& mbs, 0, sizeof(mbs));

	length = n->wstlen;
	emalloc(newval, char *, (length * gawk_mb_cur_max) + 1);

	wp = n->wstptr;
	for (cp = newval; length > 0; length--) {
		result = wcrtomb(cp, *wp, & mbs);
		if (result == (size_t) -1)	/* what to do? break seems best */
			break;
		cp += result;
		wp++;
	}
	*cp = '\0';

	/* N.B. caller just created n with make_string, so this free is safe */
	efree(n->stptr);
	n->stptr = newval;
	n->stlen = cp - newval;

	return n;
}

/* free_wstr --- release the wide string part of a node */

void
r_free_wstr(NODE *n)
{
	assert(n->type == Node_val);

	if ((n->flags & WSTRCUR) != 0) {
		assert(n->wstptr != NULL);
		efree(n->wstptr);
	}
	n->wstptr = NULL;
	n->wstlen = 0;
	n->flags &= ~WSTRCUR;
}

static void __attribute__ ((unused))
dump_wstr(FILE *fp, const wchar_t *str, size_t len)
{
	if (str == NULL || len == 0)
		return;

	for (; len--; str++)
		putwc(*str, fp);
}

/* wstrstr --- walk haystack, looking for needle, wide char version */

const wchar_t *
wstrstr(const wchar_t *haystack, size_t hs_len,
	const wchar_t *needle, size_t needle_len)
{
	size_t i;

	if (haystack == NULL || needle == NULL || needle_len > hs_len)
		return NULL;

	for (i = 0; i < hs_len; i++) {
		if (haystack[i] == needle[0]
		    && i+needle_len-1 < hs_len
		    && haystack[i+needle_len-1] == needle[needle_len-1]) {
			/* first & last chars match, check string */
			if (memcmp(haystack+i, needle, sizeof(wchar_t) * needle_len) == 0) {
				return haystack + i;
			}
		}
	}

	return NULL;
}

/* wcasestrstr --- walk haystack, nocase look for needle, wide char version */

const wchar_t *
wcasestrstr(const wchar_t *haystack, size_t hs_len,
	const wchar_t *needle, size_t needle_len)
{
	size_t i, j;

	if (haystack == NULL || needle == NULL || needle_len > hs_len)
		return NULL;

	for (i = 0; i < hs_len; i++) {
		if (towlower(haystack[i]) == towlower(needle[0])
		    && i+needle_len-1 < hs_len
		    && towlower(haystack[i+needle_len-1]) == towlower(needle[needle_len-1])) {
			/* first & last chars match, check string */
			const wchar_t *start;

			start = haystack+i;
			for (j = 0; j < needle_len; j++, start++) {
				wchar_t h, n;

				h = towlower(*start);
				n = towlower(needle[j]);
				if (h != n)
					goto out;
			}
			return haystack + i;
		}
out:	;
	}

	return NULL;
}

/* is_ieee_magic_val --- return true for +inf, -inf, +nan, -nan */

bool
is_ieee_magic_val(const char *val)
{
	/*
	 * Avoid strncasecmp: it mishandles ASCII bytes in some locales.
	 * Assume the length is 4, as the caller checks this.
	 */
	return (   (val[0] == '+' || val[0] == '-')
		&& (   (   (val[1] == 'i' || val[1] == 'I')
			&& (val[2] == 'n' || val[2] == 'N')
			&& (val[3] == 'f' || val[3] == 'F'))
		    || (   (val[1] == 'n' || val[1] == 'N')
			&& (val[2] == 'a' || val[2] == 'A')
			&& (val[3] == 'n' || val[3] == 'N'))));
}

/* get_ieee_magic_val --- return magic value for string */

static AWKNUM
get_ieee_magic_val(char *val)
{
	static bool first = true;
	static AWKNUM inf;
	static AWKNUM nan;
	char save;

	char *ptr;
	save = val[4];
	val[4] = '\0';
	AWKNUM v = strtod(val, &ptr);
	val[4] = save;

	if (val == ptr) { /* Older strtod implementations don't support inf or nan. */
		if (first) {
			first = false;
			nan = sqrt(-1.0);
			inf = -log(0.0);
		}

		v = ((val[1] == 'i' || val[1] == 'I') ? inf : nan);
		if (val[0] == '-')
			v = -v;
	}

	return v;
}

wint_t btowc_cache[256];

/* init_btowc_cache --- initialize the cache */

void init_btowc_cache()
{
	int i;

	for (i = 0; i <= 255; i++) {
		btowc_cache[i] = btowc(i);
	}
}

#define BLOCKCHUNK 100

struct block_header nextfree[BLOCK_MAX] = {
	{ NULL, sizeof(NODE), "node" },
	{ NULL, sizeof(BUCKET), "bucket" },
};

#ifdef MEMDEBUG

void *
r_getblock(int id)
{
	void *res;
	emalloc(res, void *, nextfree[id].size);
	nextfree[id].active++;
	if (nextfree[id].highwater < nextfree[id].active)
		nextfree[id].highwater = nextfree[id].active;
	return res;
}

void
r_freeblock(void *p, int id)
{
	nextfree[id].active--;
	free(p);
}

#else

/* more_blocks --- get more blocks of memory and add to the free list;
	size of a block must be >= sizeof(struct block_item)
 */

void *
more_blocks(int id)
{
	struct block_item *freep, *np, *next;
	char *p, *endp;
	size_t size;

	size = nextfree[id].size;

	assert(size >= sizeof(struct block_item));
	emalloc(freep, struct block_item *, BLOCKCHUNK * size);
	p = (char *) freep;
	endp = p + BLOCKCHUNK * size;

	for (np = freep; ; np = next) {
		next = (struct block_item *) (p += size);
		if (p >= endp) {
			np->freep = NULL;
			break;
		}
		np->freep = next;
	}
	nextfree[id].freep = freep->freep;
	nextfree[id].highwater += BLOCKCHUNK;
	return freep;
}

#endif

/* make_bool_node --- make a boolean-valued node */

extern NODE *
make_bool_node(bool value)
{
	NODE *val;
	const char *sval;
	AWKNUM nval;

	sval = (value ? "1" : "0");
	nval = (value ? 1.0 : 0.0);

	val = make_number(nval);
	val->stptr = estrdup(sval, strlen(sval));
	val->stlen = strlen(sval);
	val->flags |= NUMCUR|STRCUR|BOOLVAL;
	val->stfmt = STFMT_UNUSED;

	return val;
}
/*
 * profile.c - gawk bytecode pretty-printer with counts
 */

/*
 * Copyright (C) 1999-2023, 2025, the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

static void pprint(INSTRUCTION *startp, INSTRUCTION *endp, int flags);
static INSTRUCTION *end_line(INSTRUCTION *ip);
static void pp_parenthesize(NODE *n);
static void parenthesize(int type, NODE *left, NODE *right);
static char *pp_list(int nargs, const char *paren, const char *delim);
static char *pp_group3(const char *s1, const char *s2, const char *s3);
static char *pp_concat(int nargs);
static char *pp_string_or_typed_regex(const char *in_str, size_t len, int delim, bool typed_regex);
static char *pp_typed_regex(const char *in_str, size_t len, int delim);
static bool is_binary(int type);
static bool is_scalar(int type);
static int prec_level(int type);
static void pp_push(int type, char *s, int flag, INSTRUCTION *comment);
static NODE *pp_pop(void);
static void print_comment(INSTRUCTION *pc, long in);
const char *redir2str(int redirtype);
static void pp_namespace(const char *name, INSTRUCTION *comment);
static void pp_namespace_list(INSTRUCTION *list);
static char *adjust_namespace(char *name, bool *malloced);

#define pp_str	vname
#define pp_len	sub.nodep.reserved
#define pp_next	rnode
#define pp_comment	sub.nodep.x.cmnt

#define DONT_FREE 1
#define CAN_FREE  2

static void dump_and_exit(int signum) ATTRIBUTE_NORETURN;
static void just_dump(int signum);

/* pretty printing related functions and variables */

static NODE *pp_stack = NULL;
static NODE *func_params;	/* function parameters */
static FILE *prof_fp;	/* where to send the profile */

static long indent_level = 0;

static const char tabs[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";
static const size_t tabs_len = sizeof(tabs) - 1;

static bool at_start = true;

#define check_indent_level() \
	if (indent_level + 1 > tabs_len) \
		/* We're allowed to be snarky, occasionally. */ \
		fatal(_("Program indentation level too deep. Consider refactoring your code"));


#define SPACEOVER	0

#define NO_PPRINT_FLAGS	0
#define IN_FOR_HEADER	1
#define IN_ELSE_IF	2

/* set_prof_file --- set the output file for profiling or pretty-printing */

void
set_prof_file(const char *file)
{
	int fd;

	assert(file != NULL);
	fd = devopen_simple(file, "w", true);
	if (fd == INVALID_HANDLE)
		prof_fp = NULL;
	else if (fd == fileno(stdout))
		prof_fp = stdout;
	else if (fd == fileno(stderr))
		prof_fp = stderr;
	else
		prof_fp = fdopen(fd, "w");

	if (prof_fp == NULL) {
		/* don't leak file descriptors */
		int e = errno;

		if (   fd != INVALID_HANDLE
		    && fd != fileno(stdout)
		    && fd != fileno(stderr))
			(void) close(fd);

		errno = e;
		warning(_("could not open `%s' for writing: %s"),
				file, strerror(errno));
		warning(_("sending profile to standard error"));
		prof_fp = stderr;
	}
}

/* close_prof_file --- close the output file for profiling or pretty-printing */

void
close_prof_file(void)
{
	if (prof_fp != NULL
	    && fileno(prof_fp) != fileno(stdout)
	    && fileno(prof_fp) != fileno(stderr))
		(void) fclose(prof_fp);
}

/* init_profiling_signals --- set up signal handling for gawk --profile */

void
init_profiling_signals()
{
#ifdef SIGHUP
	signal(SIGHUP, dump_and_exit);
#endif
#ifdef SIGUSR1
	signal(SIGUSR1, just_dump);
#endif
}

/* indent --- print out enough tabs */

static void
indent(exec_count_t count)
{
	int i;

	if (do_profile) {
		if (count == 0)
			fprintf(prof_fp, "\t");
		else
			fprintf(prof_fp, EXEC_COUNT_PROFILE_FMT "  ", count);
	}

	assert(indent_level >= 0);
	for (i = 0; i < indent_level; i++)
		fprintf(prof_fp, "\t");
}

/* indent_in --- increase the level, with error checking */

static void
indent_in(void)
{
	assert(indent_level >= 0);
	indent_level++;
}

/* indent_out --- decrease the level, with error checking */

static void
indent_out(void)
{
	indent_level--;
	assert(indent_level >= 0);
}

/* pp_push --- push a pretty printed string onto the stack */

static void
pp_push(int type, char *s, int flag, INSTRUCTION *comment)
{
	NODE *n;
	getnode(n);
	memset(n, '\0', sizeof(NODE));
	n->pp_str = s;
	n->pp_len = strlen(s);
	n->flags = flag;
	n->type = (NODETYPE) type;
	n->pp_next = pp_stack;
	n->pp_comment = comment;
	pp_stack = n;
}

/* pp_pop --- pop a pretty printed string off the stack */

static NODE *
pp_pop()
{
	NODE *n;
	n = pp_stack;
	pp_stack = n->pp_next;
	return n;
}

/* pp_top --- look at what's on the top of the stack */

#define pp_top()	pp_stack

/* pp_free --- release a pretty printed node */

static void
pp_free(NODE *n)
{
	if ((n->flags & CAN_FREE) != 0)
		efree(n->pp_str);
	freenode(n);
}

/* pprint --- pretty print a program segment */

static void
pprint(INSTRUCTION *startp, INSTRUCTION *endp, int flags)
{
	INSTRUCTION *pc;
	NODE *t1;
	char *str;
	NODE *t2;
	INSTRUCTION *ip1;
	INSTRUCTION *ip2;
	NODE *m;
	char *tmp;
	int rule;
	static int rule_count[MAXRULE];
	static bool skip_comment = false;

	for (pc = startp; pc != endp; pc = pc->nexti) {
		if (pc->source_line > 0)
			sourceline = pc->source_line;

		/* skip leading EOL comment as it has already been printed  */
		if (pc->opcode == Op_comment
		    && pc->memory->comment_type == EOL_COMMENT
		    && skip_comment) {
			skip_comment = false;
			continue;
		}
		skip_comment = false;

		switch (pc->opcode) {
		case Op_rule:
			/*
			 * Rules are four instructions long.
			 * See append_rule in awkgram.y.
			 * The first has the Rule Op Code, nexti etc.
			 * The second, (pc + 1) has firsti and lasti:
			 * 	the first/last ACTION instructions for this rule.
			 * The third has first_line and last_line:
			 * 	the first and last source line numbers.
			 * The fourth holds the namespace name if there is one.
			 *	(there should be one if we're in this file)
			 * This can actually be a list in reverse order if
			 * there were several @namespace directives one
			 * after the other.
			 */
			source = pc->source_file;
			rule = pc->in_rule;

			pp_namespace_list(pc[3].nexti);

			if (rule != Rule) {
				/* Allow for pre-non-rule-block comment  */
				if (pc->nexti != (pc+1)->firsti
				    && pc->nexti->opcode == Op_comment
				    && pc->nexti->memory->comment_type == BLOCK_COMMENT)
					print_comment(pc->nexti, -1);
				ip1 = (pc + 1)->firsti;
				ip2 = (pc + 1)->lasti;

				if (do_profile) {
					if (! rule_count[rule]++)
						fprintf(prof_fp, _("\t# %s rule(s)\n\n"), ruletab[rule]);
					indent(0);
				} else if (! at_start)
					putc('\n', prof_fp);
				else
					at_start = false;

				fprintf(prof_fp, "%s {", ruletab[rule]);
				end_line(pc);
				skip_comment = true;
			} else {
				if (do_profile && ! rule_count[rule]++)
					fprintf(prof_fp, _("\t# Rule(s)\n\n"));
				ip1 = pc->nexti;
				if (! at_start)
					putc('\n', prof_fp);
				else
					at_start = false;
				indent(ip1->exec_count);
				if (ip1 != (pc + 1)->firsti) {		/* non-empty pattern */
					pprint(ip1->nexti, (pc + 1)->firsti, NO_PPRINT_FLAGS);
					/* Allow for case where the "pattern" is just a comment  */
					if (ip1->nexti->nexti->nexti != (pc +1)->firsti
					    || ip1->nexti->opcode != Op_comment) {
						t1 = pp_pop();
						fprintf(prof_fp, "%s {", t1->pp_str);
						pp_free(t1);
					} else
						fprintf(prof_fp, "{");
					ip1 = (pc + 1)->firsti;
					ip2 = (pc + 1)->lasti;

					if (do_profile && ip1->exec_count > 0)
						fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);

					end_line(ip1);
					skip_comment = true;
				} else {
					fprintf(prof_fp, "{\n");
					ip1 = (pc + 1)->firsti;
					ip2 = (pc + 1)->lasti;
				}
				ip1 = ip1->nexti;
			}
			indent_in();
			pprint(ip1, ip2, NO_PPRINT_FLAGS);
			indent_out();
			if (do_profile)
				indent(0);
			fprintf(prof_fp, "}\n");
			pc = (pc + 1)->lasti;
			break;

		case Op_atexit:
			break;

		case Op_stop:
			memset(rule_count, 0, MAXRULE * sizeof(int));
			break;

		case Op_push_i:
			m = pc->memory;
			if (m == Nnull_string)	/* optional return or exit value; don't print 0 or "" */
				pp_push(pc->opcode, m->stptr, DONT_FREE, pc->comment);
			else if ((m->flags & NUMBER) != 0)
				pp_push(pc->opcode, pp_number(m), CAN_FREE, pc->comment);
			else {
				str = pp_string(m->stptr, m->stlen, '"');
				if ((m->flags & INTLSTR) != 0) {
					char *tmp = str;
					str = pp_group3("_", tmp, "");
					efree(tmp);
				}
				pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			}
			break;

		case Op_store_var:
			if (pc->initval != NULL)
				pp_push(Op_push_i, pp_node(pc->initval), CAN_FREE, pc->comment);
			/* fall through */
		case Op_store_sub:
		case Op_assign_concat:
		case Op_push_lhs:
		case Op_push_param:
		case Op_push_array:
		case Op_push:
		case Op_push_arg:
		case Op_push_arg_untyped:
			m = pc->memory;
			switch (m->type) {
			case Node_param_list:
				pp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE, pc->comment);
				break;

			case Node_var:
			case Node_var_new:
			case Node_var_array:
				if (m->vname != NULL) {
					bool malloced = false;
					char *name = adjust_namespace(m->vname, & malloced);

					pp_push(pc->opcode, name, malloced ? CAN_FREE : DONT_FREE, pc->comment);
				} else
					fatal(_("internal error: %s with null vname"),
							nodetype2str(m->type));
				break;

			default:
				cant_happen("got unexpected type %s", nodetype2str(m->type));
			}

			switch (pc->opcode) {
			case Op_store_var:
				t2 = pp_pop(); /* l.h.s. */
				t1 = pp_pop(); /* r.h.s. */
				fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(pc->opcode), t1->pp_str);
				goto cleanup;

			case Op_store_sub:
				t1 = pp_pop();	/* array */
				tmp = pp_list(pc->expr_count, op2str(Op_subscript), ", "); /*subscript*/
				t2 = pp_pop(); /* r.h.s. */
				fprintf(prof_fp, "%s%s%s%s", t1->pp_str, tmp,
									op2str(pc->opcode), t2->pp_str);
				efree(tmp);
				goto cleanup;

			case Op_assign_concat:
				t2 = pp_pop(); /* l.h.s. */
				t1 = pp_pop();
				tmp = pp_group3(t2->pp_str, op2str(Op_concat), t1->pp_str);
				fprintf(prof_fp, "%s%s%s", t2->pp_str, op2str(Op_assign), tmp);
				efree(tmp);
cleanup:
				pp_free(t2);
				pp_free(t1);
				if ((flags & IN_FOR_HEADER) == 0)
					pc = end_line(pc);
				break;

			default:
				break;
			}
			break;

		case Op_sub_array:
		case Op_subscript_lhs:
		case Op_subscript:
			tmp = pp_list(pc->sub_count, op2str(pc->opcode), ", ");
			t1 = pp_pop();
			str = pp_group3(t1->pp_str, tmp, "");
			efree(tmp);
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_and:
		case Op_or:
			pprint(pc->nexti, pc->target_jmp, flags);
			t2 = pp_pop();
			t1 = pp_pop();
			parenthesize(pc->opcode, t1, t2);
			if (pc->comment == NULL)
				str = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);
			else {
				check_indent_level();

				size_t len = strlen(t1->pp_str)
						+ strlen(op2str(pc->opcode)) + strlen(t2->pp_str)	// foo && bar
						+ indent_level + 1				// indent
						+ pc->comment->memory->stlen + 3;		// tab comment

				emalloc(str, char *, len);
				sprintf(str, "%s%s%s%.*s %s", t1->pp_str, op2str(pc->opcode),
						pc->comment->memory->stptr,
						(int) (indent_level + 1), tabs, t2->pp_str);
			}
			pp_free(t1);
			pp_free(t2);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			pc = pc->target_jmp;
			break;

		case Op_plus_i:
		case Op_minus_i:
		case Op_times_i:
		case Op_exp_i:
		case Op_quotient_i:
		case Op_mod_i:
			m = pc->memory;
			t1 = pp_pop();
			if (prec_level(pc->opcode) > prec_level(t1->type)
					&& is_binary(t1->type))  /* (a - b) * 1 */
				pp_parenthesize(t1);
			if ((m->flags & NUMBER) != 0)
				tmp = pp_number(m);
			else
				tmp = pp_string(m->stptr, m->stlen, '"');
			str = pp_group3(t1->pp_str, op2str(pc->opcode), tmp);
			efree(tmp);
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_parens:
			t1 = pp_pop();
			str = pp_group3("(", t1->pp_str, ")");
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_plus:
		case Op_minus:
		case Op_times:
		case Op_exp:
		case Op_quotient:
		case Op_mod:
		case Op_equal:
		case Op_notequal:
		case Op_less:
		case Op_greater:
		case Op_leq:
		case Op_geq:
			t2 = pp_pop();
			t1 = pp_pop();
			parenthesize(pc->opcode, t1, t2);
			str = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);
			pp_free(t1);
			pp_free(t2);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_preincrement:
		case Op_predecrement:
		case Op_postincrement:
		case Op_postdecrement:
			t1 = pp_pop();
			if (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)
				str = pp_group3(op2str(pc->opcode), t1->pp_str, "");
			else
				str = pp_group3(t1->pp_str, op2str(pc->opcode), "");
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_field_spec:
		case Op_field_spec_lhs:
		case Op_unary_minus:
		case Op_unary_plus:
		case Op_not:
			t1 = pp_pop();
			if (is_binary(t1->type)
			    || (((OPCODE) t1->type) == pc->opcode
				    && (pc->opcode == Op_unary_minus
					    || pc->opcode == Op_unary_plus)))
				pp_parenthesize(t1);

			/* optypes table (eval.c) includes space after ! */
			str = pp_group3(op2str(pc->opcode), t1->pp_str, "");
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_assign:
		case Op_assign_plus:
		case Op_assign_minus:
		case Op_assign_times:
		case Op_assign_quotient:
		case Op_assign_mod:
		case Op_assign_exp:
			t2 = pp_pop(); /* l.h.s. */
			t1 = pp_pop();
			str = pp_group3(t2->pp_str, op2str(pc->opcode), t1->pp_str);
			pp_free(t2);
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_store_field:
		case Op_store_field_exp:
		{
			char *assignment, *final;

			t1 = pp_pop(); /* field num */
			if (is_binary(t1->type))
				pp_parenthesize(t1);
			t2 = pp_pop(); /* r.h.s. */
			assignment = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);
			final = pp_group3("$", assignment, "");
			efree(assignment);
			pp_free(t2);
			pp_free(t1);
			if (pc->opcode == Op_store_field_exp)
				pp_push(pc->opcode, final, CAN_FREE, NULL);
			else {
				fprintf(prof_fp, "%s", final);
				efree(final);
				if ((flags & IN_FOR_HEADER) == 0)
					pc = end_line(pc);
			}
		}
			break;

		case Op_concat:
			str = pp_concat(pc->expr_count);
			pp_push(Op_concat, str, CAN_FREE, pc->comment);
			break;

		case Op_K_delete:
		{
			char *array;
			t1 = pp_pop();
			array = t1->pp_str;
			if (pc->expr_count > 0) {
				char *sub;
				sub = pp_list(pc->expr_count, NULL, pc->expr_count > 1 ? "][" : ", ");
				fprintf(prof_fp, "%s %s[%s]", op2str(Op_K_delete), array, sub);
				efree(sub);
			} else
				fprintf(prof_fp, "%s %s", op2str(Op_K_delete), array);
			if ((flags & IN_FOR_HEADER) == 0)
				pc = end_line(pc);
			pp_free(t1);
		}
			break;

		case Op_K_delete_loop:
			/* Efficency hack not in effect because of exec_count instruction */
			cant_happen("unexpected opcode %s", opcode2str(pc->opcode));
			break;

		case Op_in_array:
		{
			char *array, *sub;
			t1 = pp_pop();
			array = t1->pp_str;
			if (pc->expr_count > 1) {
				sub = pp_list(pc->expr_count, "()", ", ");
				str = pp_group3(sub, op2str(Op_in_array), array);
				efree(sub);
			} else {
				t2 = pp_pop();
				if (prec_level(t2->type) < prec_level(Op_in_array)) {
					pp_parenthesize(t2);
				}
				sub = t2->pp_str;
				str = pp_group3(sub, op2str(Op_in_array), array);
				pp_free(t2);
			}
			pp_free(t1);
			pp_push(Op_in_array, str, CAN_FREE, pc->comment);
		}
			break;

		case Op_var_update:
		case Op_var_assign:
		case Op_field_assign:
		case Op_subscript_assign:
		case Op_arrayfor_init:
		case Op_arrayfor_incr:
		case Op_arrayfor_final:
		case Op_newfile:
		case Op_get_record:
		case Op_lint:
		case Op_lint_plus:
		case Op_jmp:
		case Op_jmp_false:
		case Op_jmp_true:
		case Op_no_op:
		case Op_and_final:
		case Op_or_final:
		case Op_cond_pair:
		case Op_after_beginfile:
		case Op_after_endfile:
			break;

		case Op_sub_builtin:
		{
			const char *fname = "sub";
			if ((pc->sub_flags & GSUB) != 0)
				fname = "gsub";
			else if ((pc->sub_flags & GENSUB) != 0)
				fname = "gensub";
			tmp = pp_list(pc->expr_count, "()", ", ");
			str = pp_group3(fname, tmp, "");
			efree(tmp);
			pp_push(Op_sub_builtin, str, CAN_FREE, pc->comment);
		}
			break;

		case Op_builtin:
		case Op_ext_builtin:
		{
			const char *fname;
			if (pc->opcode == Op_builtin) {
				bool prepend_awk = (current_namespace != awk_namespace && strcmp(current_namespace, awk_namespace) != 0);
				fname = getfname(pc->builtin, prepend_awk);
			} else
				fname = (pc + 1)->func_name;
			if (fname != NULL) {
				if (pc->expr_count > 0) {
					tmp = pp_list(pc->expr_count, "()", ", ");
					str = pp_group3(fname, tmp, "");
					efree(tmp);
				} else
					str = pp_group3(fname, "()", "");
				pp_push(Op_builtin, str, CAN_FREE, pc->comment);
			} else
				fatal(_("internal error: builtin with null fname"));
		}
			break;

		case Op_K_print:
		case Op_K_printf:
		case Op_K_print_rec:
			if (pc->opcode == Op_K_print_rec)
				// instead of `print $0', just `print'
				tmp = estrdup("", 0);
			else if (pc->redir_type != 0) {
				// Avoid turning printf("hello\n") into printf(("hello\n"))
				NODE *n = pp_top();

				if (pc->expr_count == 1
				    && n->pp_str[0] == '('
				    && n->pp_str[n->pp_len - 1] == ')') {
					n = pp_pop();

					tmp = estrdup(n->pp_str, strlen(n->pp_str));
					pp_free(n);
				} else
					tmp = pp_list(pc->expr_count, "()", ", ");
			} else {
				tmp = pp_list(pc->expr_count, "  ", ", ");
				tmp[strlen(tmp) - 1] = '\0';	/* remove trailing space */
			}

			if (pc->redir_type != 0) {
				t1 = pp_pop();
				if (is_binary(t1->type))
					pp_parenthesize(t1);
				fprintf(prof_fp, "%s%s%s%s", op2str(pc->opcode),
							tmp, redir2str(pc->redir_type), t1->pp_str);
				pp_free(t1);
			} else
				fprintf(prof_fp, "%s%s", op2str(pc->opcode), tmp);
			efree(tmp);
			if ((flags & IN_FOR_HEADER) == 0)
				pc = end_line(pc);
			break;

		case Op_push_re:
			if (pc->memory->type != Node_regex && (pc->memory->flags & REGEX) == 0)
				break;
			/* fall through */
		case Op_match_rec:
		{
			if (pc->memory->type == Node_regex) {
				NODE *re = pc->memory->re_exp;
				str = pp_string(re->stptr, re->stlen, '/');
			} else {
				assert((pc->memory->flags & REGEX) != 0);
				str = pp_typed_regex(pc->memory->stptr, pc->memory->stlen, '/');
			}
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
		}
			break;

		case Op_nomatch:
		case Op_match:
		{
			char *restr, *txt;
			t1 = pp_pop();
			if (is_binary(t1->type))
				pp_parenthesize(t1);
			txt = t1->pp_str;
			m = pc->memory;
			if (m->type == Node_dynregex) {
				restr = txt;
				t2 = pp_pop();
				if (is_binary(t2->type))
					pp_parenthesize(t2);
				txt = t2->pp_str;
				str = pp_group3(txt, op2str(pc->opcode), restr);
				pp_free(t2);
			} else if (m->type == Node_val && (m->flags & REGEX) != 0) {
				restr = pp_typed_regex(m->stptr, m->stlen, '/');
				str = pp_group3(txt, op2str(pc->opcode), restr);
				efree(restr);
			} else {
				NODE *re = m->re_exp;
				restr = pp_string(re->stptr, re->stlen, '/');
				str = pp_group3(txt, op2str(pc->opcode), restr);
				efree(restr);
			}
			pp_free(t1);
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
		}
			break;

		case Op_K_getline:
		case Op_K_getline_redir:
			if (pc->into_var) {
				t1 = pp_pop();
				tmp = pp_group3(op2str(Op_K_getline), " ", t1->pp_str);
				pp_free(t1);
			} else
				tmp = pp_group3(op2str(Op_K_getline), "", "");

			if (pc->redir_type != 0) {
				int before = (pc->redir_type == redirect_pipein
							|| pc->redir_type == redirect_twoway);

				t2 = pp_pop();
				if (is_binary(t2->type))
					pp_parenthesize(t2);
				if (before)
					str = pp_group3(t2->pp_str, redir2str(pc->redir_type), tmp);
				else
					str = pp_group3(tmp, redir2str(pc->redir_type), t2->pp_str);
				efree(tmp);
				pp_free(t2);
			} else
				str = tmp;
			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			break;

		case Op_indirect_func_call:
		case Op_func_call:
		{
			const char *pre;
 			int pcount;
			bool malloced = false;
			char *fname = adjust_namespace(pc->func_name, & malloced);

			if (pc->opcode == Op_indirect_func_call)
				pre = "@";
			else
				pre = "";
			pcount = (pc + 1)->expr_count;
			if (pcount > 0) {
				tmp = pp_list(pcount, "()", ", ");
				str = pp_group3(pre, fname, tmp);
				efree(tmp);
			} else
				str = pp_group3(pre, fname, "()");
			if (pc->opcode == Op_indirect_func_call) {
				t1 = pp_pop();	/* indirect var */
				pp_free(t1);
			}

			pp_push(pc->opcode, str, CAN_FREE, pc->comment);
			if (malloced)
				efree((void *) fname);
		}
			break;

		case Op_K_continue:
		case Op_K_break:
		case Op_K_nextfile:
		case Op_K_next:
			fprintf(prof_fp, "%s", op2str(pc->opcode));
			pc = end_line(pc);
			break;

		case Op_K_return:
		case Op_K_exit:
			t1 = pp_pop();
			if (is_binary(t1->type))
				pp_parenthesize(t1);
			if (pc->source_line > 0) {	/* don't print implicit 'return' at end of function */
				// avoid final trailing space to keep whiny users happy
				if (t1->pp_str[0] != '\0')
					fprintf(prof_fp, "%s %s", op2str(pc->opcode), t1->pp_str);
				else
					fprintf(prof_fp, "%s", op2str(pc->opcode));
				pc = end_line(pc);
			}
			pp_free(t1);
			break;

		case Op_pop:
			t1 = pp_pop();
			fprintf(prof_fp, "%s", t1->pp_str);
			if ((flags & IN_FOR_HEADER) == 0)
				pc = end_line(pc);
			pp_free(t1);
			break;

		case Op_line_range:
			ip1 = pc + 1;
			pprint(pc->nexti, ip1->condpair_left, NO_PPRINT_FLAGS);
			pprint(ip1->condpair_left->nexti, ip1->condpair_right, NO_PPRINT_FLAGS);
			t2 = pp_pop();
			t1 = pp_pop();
			str = pp_group3(t1->pp_str, ", ", t2->pp_str);
			pp_free(t1);
			pp_free(t2);
			pp_push(Op_line_range, str, CAN_FREE, pc->comment);
			pc = ip1->condpair_right;
			break;

		case Op_K_while:
			ip1 = pc + 1;
			indent(ip1->while_body->exec_count);
			fprintf(prof_fp, "%s (", op2str(pc->opcode));
			pprint(pc->nexti, ip1->while_body, NO_PPRINT_FLAGS);
			t1 = pp_pop();
			fprintf(prof_fp, "%s) {", t1->pp_str);
			pp_free(t1);
			ip1->while_body = end_line(ip1->while_body);
			indent_in();
			pprint(ip1->while_body->nexti, pc->target_break, NO_PPRINT_FLAGS);
			indent_out();
			indent(SPACEOVER);
			fprintf(prof_fp, "}");
			pc = end_line(pc->target_break);
			break;

		case Op_K_do:
			ip1 = pc + 1;
			indent(pc->nexti->exec_count);
			fprintf(prof_fp, "%s {", op2str(pc->opcode));
			end_line(pc->nexti);
			skip_comment = true;
			indent_in();
			pprint(pc->nexti->nexti, ip1->doloop_cond, NO_PPRINT_FLAGS);
			indent_out();
			pprint(ip1->doloop_cond, pc->target_break, NO_PPRINT_FLAGS);
			indent(SPACEOVER);
			t1 = pp_pop();
			fprintf(prof_fp, "} %s (%s)", op2str(Op_K_while), t1->pp_str);
			if (pc->comment)
				fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);
			else {
				end_line(pc->target_break);
				skip_comment = true;
			}
			pp_free(t1);
			pc = pc->target_break;
			break;

		case Op_K_for:
		{
			INSTRUCTION *comment1 = NULL, *comment2 = NULL;

			if (pc->comment != NULL) {
				comment1 = pc->comment;
				pc->comment = NULL;
				if (comment1 != NULL && comment1->comment != NULL) {
					comment2 = comment1->comment;
					comment1->comment = NULL;
				}
				if (comment2 == NULL && comment1->memory->comment_type == FOR_COMMENT) {
					comment2 = comment1;
					comment2->memory->comment_type = EOL_COMMENT;
					comment1 = NULL;
				}
			}

			ip1 = pc + 1;
			indent(ip1->forloop_body->exec_count);
			fprintf(prof_fp, "%s (", op2str(pc->opcode));

			/* If empty for looop header, print it a little more nicely. */
			if (   pc->nexti->opcode == Op_no_op
			    && ip1->forloop_cond == pc->nexti
			    && pc->target_continue->opcode == Op_jmp
			    && comment1 == NULL && comment2 == NULL) {
				fprintf(prof_fp, ";;");
			} else {
				pprint(pc->nexti, ip1->forloop_cond, IN_FOR_HEADER);
				fprintf(prof_fp, "; ");

				if (comment1 != NULL) {
					print_comment(comment1, 0);
					indent(ip1->forloop_body->exec_count);
					indent(1);
				}

				if (ip1->forloop_cond->opcode == Op_no_op &&
						ip1->forloop_cond->nexti == ip1->forloop_body)
					fprintf(prof_fp, "; ");
				else {
					pprint(ip1->forloop_cond, ip1->forloop_body, IN_FOR_HEADER);
					t1 = pp_pop();
					fprintf(prof_fp, "%s; ", t1->pp_str);
					pp_free(t1);
				}

				if (comment2 != NULL) {
					print_comment(comment2, 0);
					indent(ip1->forloop_body->exec_count);
					indent(1);
				}

				pprint(pc->target_continue, pc->target_break, IN_FOR_HEADER);
			}
			fprintf(prof_fp, ") {");
			end_line(ip1->forloop_body);
			skip_comment = true;
			indent_in();
			pprint(ip1->forloop_body->nexti, pc->target_continue, NO_PPRINT_FLAGS);
			indent_out();
			indent(SPACEOVER);
			fprintf(prof_fp, "}");
			end_line(pc->target_break);
			skip_comment = true;
			pc = pc->target_break;
		}
			break;

		case Op_K_arrayfor:
		{
			char *array;
			const char *item;

			ip1 = pc + 1;
			t1 = pp_pop();
			array = t1->pp_str;
			m = ip1->forloop_cond->array_var;
			if (m->type == Node_param_list)
				item = func_params[m->param_cnt].param;
			else
				item = m->vname;
			indent(ip1->forloop_body->exec_count);
			fprintf(prof_fp, "%s (%s%s%s) {", op2str(Op_K_arrayfor),
						item, op2str(Op_in_array), array);
			end_line(ip1->forloop_body);
			skip_comment = true;
			indent_in();
			pp_free(t1);
			pprint(ip1->forloop_body->nexti, pc->target_break, NO_PPRINT_FLAGS);
			indent_out();
			indent(SPACEOVER);
			fprintf(prof_fp, "}");
			end_line(pc->target_break);
			skip_comment = true;
			pc = pc->target_break;
		}
			break;

		case Op_K_switch:
			ip1 = pc + 1;
			fprintf(prof_fp, "%s (", op2str(pc->opcode));
			pprint(pc->nexti, ip1->switch_start, NO_PPRINT_FLAGS);
			t1 = pp_pop();
			fprintf(prof_fp, "%s) {", t1->pp_str);
			if (pc->comment)
				print_comment(pc->comment, 0);
			else
				fprintf(prof_fp, "\n");
			pp_free(t1);
			pprint(ip1->switch_start, ip1->switch_end, NO_PPRINT_FLAGS);
			indent(SPACEOVER);
			fprintf(prof_fp, "}\n");
			if (ip1->switch_end->comment)
				print_comment(ip1->switch_end->comment, 0);
			pc = pc->target_break;
			break;

		case Op_K_case:
		case Op_K_default:
			indent(pc->stmt_start->exec_count);
			if (pc->opcode == Op_K_case) {
				t1 = pp_pop();
				fprintf(prof_fp, "%s %s:", op2str(pc->opcode), t1->pp_str);
				pp_free(t1);
			} else
				fprintf(prof_fp, "%s:", op2str(pc->opcode));

			indent_in();
			if (pc->comment != NULL) {
				if (pc->comment->memory->comment_type == EOL_COMMENT) {
					fprintf(prof_fp, "\t%s", pc->comment->memory->stptr);
					if (pc->comment->comment != NULL)
						print_comment(pc->comment->comment, indent_level);
				} else {
					fprintf(prof_fp, "\n");
					print_comment(pc->comment, indent_level);
				}
			} else
				fprintf(prof_fp, "\n");
			pprint(pc->stmt_start->nexti, pc->stmt_end->nexti, NO_PPRINT_FLAGS);
			indent_out();
			break;

		case Op_K_if:
			fprintf(prof_fp, "%s (", op2str(pc->opcode));
			pprint(pc->nexti, pc->branch_if, NO_PPRINT_FLAGS);
			t1 = pp_pop();
			fprintf(prof_fp, "%s) {", t1->pp_str);
			pp_free(t1);

			ip1 = pc->branch_if;
			if (ip1->exec_count > 0)
				fprintf(prof_fp, " # " EXEC_COUNT_FMT, ip1->exec_count);
			ip1 = end_line(ip1);
			indent_in();
			if (pc->comment != NULL)
				print_comment(pc->comment, indent_level);
			pprint(ip1->nexti, pc->branch_else, NO_PPRINT_FLAGS);
			indent_out();
			pc = pc->branch_else;
			if (pc->nexti->opcode == Op_no_op) {	/* no following else */
				indent(SPACEOVER);
				fprintf(prof_fp, "}");
				if (pc->nexti->nexti->opcode != Op_comment
				    || pc->nexti->nexti->memory->comment_type == BLOCK_COMMENT)
					fprintf(prof_fp, "\n");
				/* else
				 	It will be printed at the top. */
			}
			/*
			 * See next case; turn off the flag so that the
			 * following else is correctly indented.
			 */
			flags &= ~IN_ELSE_IF;
			break;

		case Op_K_else:
			/*
			 * If possible, chain else-if's together on the
			 * same line.
			 *
			 * See awkgram.y:mk_condition to understand
			 * what is being checked here.
			 *
			 * Op_exec_count follows Op_K_else, check the
			 * opcode of the following instruction.
			 * Additionally, check that the subsequent if
			 * terminates where this else does; in that case
			 * it's ok to compact the if to follow the else.
			 */

			fprintf(prof_fp, "} %s ", op2str(pc->opcode));
			if (pc->nexti->nexti->opcode == Op_K_if
			    && pc->branch_end == pc->nexti->nexti->branch_else->lasti) {
				pprint(pc->nexti, pc->branch_end, IN_ELSE_IF);
			} else {
				fprintf(prof_fp, "{");
				end_line(pc);
				skip_comment = true;
				indent_in();
				if (pc->comment != NULL)
					print_comment(pc->comment, indent_level);
				pprint(pc->nexti, pc->branch_end, NO_PPRINT_FLAGS);
				indent_out();
				indent(SPACEOVER);
				fprintf(prof_fp, "}");
				end_line(pc->branch_end);
				skip_comment = true;
			}
			/*
			 * Don't do end_line() here, we get multiple blank lines after
			 * the final else in a chain of else-ifs since they all point
			 * to the same branch_end.
			 */
			pc = pc->branch_end;
			break;

		case Op_cond_exp:
		{
			NODE *f, *t, *cond;
			size_t len;
			INSTRUCTION *qm_comment = NULL, *colon_comment = NULL;

			qm_comment = pc->comment;

			pprint(pc->nexti, pc->branch_if, NO_PPRINT_FLAGS);
			ip1 = pc->branch_if;
			pprint(ip1->nexti, pc->branch_else, NO_PPRINT_FLAGS);
			ip1 = pc->branch_else->nexti;

			pc = ip1->nexti;
			colon_comment = pc->comment;
			assert(pc->opcode == Op_cond_exp);
			pprint(pc->nexti, pc->branch_end, NO_PPRINT_FLAGS);

			f = pp_pop();
			t = pp_pop();
			cond = pp_pop();

			/*
			 * This stuff handles comments that come after a ?, :, or both.
			 * Allowing newlines after ? and : is a gawk extension.
			 * Theoretically this is fragile, since ?: expressions can be nested.
			 * In practice, it's not, since if there was a comment following ? or :
			 * in the original code, then it wasn't nested.
			 */

			len = f->pp_len + t->pp_len + cond->pp_len + 12;
			if (qm_comment == NULL && colon_comment == NULL) {
				// easy case
				emalloc(str, char *, len);
				sprintf(str, "%s ? %s : %s", cond->pp_str, t->pp_str, f->pp_str);
			} else if (qm_comment != NULL && colon_comment != NULL) {
				check_indent_level();
				len += qm_comment->memory->stlen +		// comments
					colon_comment->memory->stlen +
					2 * (indent_level + 1) + 3 +		// indentation
					t->pp_len + 6;
				emalloc(str, char *, len);
				sprintf(str,
					"%s ? %s"	// cond ? comment
					"%.*s   %s"	// indent true-part
					" : %s"		// : comment
					"%.*s   %s",	// indent false-part
					cond->pp_str,	// condition
					qm_comment->memory->stptr,	// comment
					(int) (indent_level + 1), tabs,		// indent
					t->pp_str,			// true part
					colon_comment->memory->stptr,	// comment
					(int) (indent_level + 1), tabs,		// indent
					f->pp_str			// false part
					);
			} else if (qm_comment != NULL) {
				check_indent_level();
				len += qm_comment->memory->stlen +	// comment
					1 * (indent_level + 1) + 3 +	// indentation
					t->pp_len + 3;
				emalloc(str, char *, len);
				sprintf(str,
					"%s ? %s"	// cond ? comment
					"%.*s   %s"	// indent true-part
					" : %s",	// : false-part
					cond->pp_str,	// condition
					qm_comment->memory->stptr,	// comment
					(int) (indent_level + 1), tabs,		// indent
					t->pp_str,			// true part
					f->pp_str			// false part
					);
			} else {
				check_indent_level();
				len += colon_comment->memory->stlen +		// comment
					1 * (indent_level + 1) + 3 +		// indentation
					t->pp_len + 3;
				emalloc(str, char *, len);
				sprintf(str,
					"%s ? %s"	// cond ? true-part
					" : %s"		// : comment
					"%.*s   %s",	// indent false-part
					cond->pp_str,			// condition
					t->pp_str,			// true part
					colon_comment->memory->stptr,	// comment
					(int) (indent_level + 1), tabs,		// indent
					f->pp_str			// false part
					);
			}

			pp_free(cond);
			pp_free(t);
			pp_free(f);
			pp_push(Op_cond_exp, str, CAN_FREE, pc->comment);
			pc = pc->branch_end;
		}
			break;

		case Op_exec_count:
			if (flags == NO_PPRINT_FLAGS)
				indent(pc->exec_count);
			break;

		case Op_comment:
			print_comment(pc, 0);
			break;

		case Op_list:
			break;

		default:
			cant_happen("unexpected opcode %s", opcode2str(pc->opcode));
		}

		if (pc == endp)
			break;
	}
}

/* end_line --- end pretty print line with new line or on-line comment  */

INSTRUCTION *
end_line(INSTRUCTION *ip)
{
	INSTRUCTION *ret = ip;

	if (ip->nexti->opcode == Op_comment
	    && ip->nexti->memory->comment_type == EOL_COMMENT) {
		fprintf(prof_fp, "\t");
		print_comment(ip->nexti, -1);
		ret = ip->nexti;
	}
	else
		fprintf(prof_fp, "\n");

	return ret;
}

/* pp_string_fp --- pretty print a string to the fp */

/*
 * This routine concentrates string pretty printing in one place,
 * so that it can be called from multiple places within gawk.
 */

void
pp_string_fp(Func_print print_func, FILE *fp, const char *in_str,
		size_t len, int delim, bool breaklines)
{
	char *s = pp_string(in_str, len, delim);
	int count;
	size_t slen;
	const char *str = (const char *) s;
#define BREAKPOINT	70 /* arbitrary */

	slen = strlen(str);
	for (count = 0; slen > 0; slen--, str++) {
		print_func(fp, "%c", *str);
		if (++count >= BREAKPOINT && breaklines) {
			print_func(fp, "%c\n%c", delim, delim);
			count = 0;
		}
	}
	efree(s);
}


/* just_dump --- dump the profile and function stack and keep going */

static void
just_dump(int signum)
{
	extern INSTRUCTION *code_block;

	dump_prog(code_block);
	dump_funcs();
	dump_fcall_stack(prof_fp);
	fflush(prof_fp);
	signal(signum, just_dump);	/* for OLD Unix systems ... */
}

/* dump_and_exit --- dump the profile, the function stack, and exit */

static void
dump_and_exit(int signum)
{
	just_dump(signum);
	final_exit(EXIT_FAILURE);
}

/* print_lib_list --- print a list of all libraries loaded */

static void
print_lib_list(FILE *prof_fp)
{
	SRCFILE *s;
	static bool printed_header = false;
	const char *indent = "";
	bool found = false;

	if (do_profile)
		indent = "\t";

	for (s = srcfiles->next; s != srcfiles; s = s->next) {
		if (s->stype == SRC_EXTLIB) {
			if (do_profile && ! printed_header) {
				printed_header = true;
				fprintf(prof_fp, _("%s# Loaded extensions (-l and/or @load)\n\n"), indent);
			}
			found = true;
			fprintf(prof_fp, "%s@load \"%s\"", indent, s->src);
			if (s->comment != NULL) {
				fprintf(prof_fp, "\t");
				print_comment(s->comment, indent_level + 1);
			} else
				fprintf(prof_fp, "\n");
		}
	}
	if (found)	/* we found some */
		at_start = false;
}

/* print_include_list --- print a list of all files included */

static void
print_include_list(FILE *prof_fp)
{
	SRCFILE *s;
	static bool printed_header = false;
	bool found = false;

	if (do_profile)
		return;

	for (s = srcfiles->next; s != srcfiles; s = s->next) {
		if (s->stype == SRC_INC) {
			if (! printed_header) {
				printed_header = true;
				fprintf(prof_fp, _("\n# Included files (-i and/or @include)\n\n"));
			}
			found = true;
			fprintf(prof_fp, "# @include \"%s\"", s->src);
			if (s->comment != NULL) {
				fprintf(prof_fp, "\t");
				print_comment(s->comment, indent_level + 1);
			} else
				fprintf(prof_fp, "\n");
		}
	}
	if (found)	/* we found some */
		at_start = false;
}

/* print_comment --- print comment text with proper indentation */

static void
print_comment(INSTRUCTION* pc, long in)
{
	char *text;
	size_t count;
	bool after_newline = false;

	if (pc->memory->comment_type == BLOCK_COMMENT) {
		if (! at_start && indent_level == 0)
			putc('\n', prof_fp);
		else
			at_start = false;
	}

	count = pc->memory->stlen;
	text = pc->memory->stptr;

	if (in >= 0)
		indent(in);    /* is this correct? Where should comments go?  */
	for (; count > 0; count--, text++) {
		if (after_newline) {
			indent(in);
			after_newline = false;
		}
		putc(*text, prof_fp);
		after_newline = (*text == '\n');
	}

	if (pc->comment) {
		// chaining should only be two deep
		assert(pc->comment->comment == NULL);
		// if first was EOL comment, next must be block comment,
		// it needs to be indented.
		if (pc->memory->comment_type == EOL_COMMENT)
			in++;
		print_comment(pc->comment, in);
	}
}

/* dump_prog --- dump the program */

/*
 * XXX: I am not sure it is right to have the strings in the dump
 * be translated, but I'll leave it alone for now.
 */

void
dump_prog(INSTRUCTION *code)
{
	time_t now;

	(void) time(& now);
	/* \n on purpose, with \n in ctime() output */
	if (do_profile)
		fprintf(prof_fp, _("\t# gawk profile, created %s\n"), ctime(& now));
	print_lib_list(prof_fp);
	pprint(code, NULL, NO_PPRINT_FLAGS);
	print_include_list(prof_fp);
}

/* prec_level --- return the precedence of an operator, for paren tests */

static int
prec_level(int type)
{
	switch (type) {
	case Op_push_lhs:
	case Op_push_param:
	case Op_push_array:
	case Op_push:
	case Op_push_i:
	case Op_push_re:
	case Op_match_rec:
	case Op_subscript:
	case Op_subscript_lhs:
	case Op_func_call:
	case Op_K_delete_loop:
	case Op_builtin:
		return 16;

	case Op_field_spec:
	case Op_field_spec_lhs:
		return 15;

	case Op_preincrement:
	case Op_predecrement:
	case Op_postincrement:
	case Op_postdecrement:
		return 14;

	case Op_exp:
	case Op_exp_i:
		return 13;

	case Op_unary_minus:
	case Op_unary_plus:
	case Op_not:
		return 12;

	case Op_times:
	case Op_times_i:
	case Op_quotient:
	case Op_quotient_i:
	case Op_mod:
	case Op_mod_i:
		return 11;

	case Op_plus:
	case Op_plus_i:
	case Op_minus:
	case Op_minus_i:
		return 10;

	case Op_concat:
	case Op_assign_concat:
		return 9;

	case Op_equal:
	case Op_notequal:
	case Op_greater:
	case Op_less:
	case Op_leq:
	case Op_geq:
		return 8;

	case Op_match:
	case Op_nomatch:
		return 7;

	case Op_K_getline:
	case Op_K_getline_redir:
		return 6;

	case Op_in_array:
		return 5;

	case Op_and:
		return 4;

	case Op_or:
		return 3;

	case Op_cond_exp:
		return 2;

	case Op_assign:
	case Op_assign_times:
	case Op_assign_quotient:
	case Op_assign_mod:
	case Op_assign_plus:
	case Op_assign_minus:
	case Op_assign_exp:
		return 1;

	default:
		return 0;
	}
}

/* is_scalar --- return true if scalar, false otherwise */

static bool
is_scalar(int type)
{
	switch (type) {
	case Op_push_lhs:
	case Op_push_param:
	case Op_push_array:
	case Op_push:
	case Op_push_i:
	case Op_push_re:
	case Op_subscript:
	case Op_subscript_lhs:
	case Op_func_call:
	case Op_builtin:
	case Op_field_spec:
	case Op_field_spec_lhs:
	case Op_preincrement:
	case Op_predecrement:
	case Op_postincrement:
	case Op_postdecrement:
	case Op_unary_minus:
	case Op_unary_plus:
	case Op_not:
		return true;

	default:
		return false;
	}
}

/* is_binary --- return true if type represents a binary operator */

static bool
is_binary(int type)
{
	switch (type) {
	case Op_geq:
	case Op_leq:
	case Op_greater:
	case Op_less:
	case Op_notequal:
	case Op_equal:
	case Op_exp:
	case Op_times:
	case Op_quotient:
	case Op_mod:
	case Op_plus:
	case Op_minus:
	case Op_exp_i:
	case Op_times_i:
	case Op_quotient_i:
	case Op_mod_i:
	case Op_plus_i:
	case Op_minus_i:
	case Op_concat:
	case Op_assign_concat:
	case Op_match:
	case Op_nomatch:
	case Op_assign:
	case Op_assign_times:
	case Op_assign_quotient:
	case Op_assign_mod:
	case Op_assign_plus:
	case Op_assign_minus:
	case Op_assign_exp:
	case Op_cond_exp:
	case Op_and:
	case Op_or:
	case Op_in_array:
	case Op_K_getline_redir:	/* sometimes */
	case Op_K_getline:
		return true;

	default:
		return false;
	}
}

/* pp_parenthesize --- parenthesize an expression in stack */

static void
pp_parenthesize(NODE *sp)
{
	char *p = sp->pp_str;
	size_t len = sp->pp_len;

	if (p[0] == '(')	// already parenthesized
		return;

	emalloc(p, char *, len + 3);
	*p = '(';
	memcpy(p + 1, sp->pp_str, len);
	p[len + 1] = ')';
	p[len + 2] = '\0';
	if ((sp->flags & CAN_FREE) != 0)
		efree(sp->pp_str);
	sp->pp_str = p;
	sp->pp_len += 2;
	sp->flags |= CAN_FREE;
}

/* parenthesize --- parenthesize two nodes relative to parent node type */

static void
parenthesize(int type, NODE *left, NODE *right)
{
	int rprec = prec_level(right->type);
	int lprec = prec_level(left->type);
	int prec = prec_level(type);

	if (lprec < prec)
		pp_parenthesize(left);
	if (rprec < prec)
		pp_parenthesize(right);
}

/* pp_string --- pretty format a string or regular regex constant */

char *
pp_string(const char *in_str, size_t len, int delim)
{
	return pp_string_or_typed_regex(in_str, len, delim, false);
}

/* pp_typed_regex --- pretty format a hard regex constant */

static char *
pp_typed_regex(const char *in_str, size_t len, int delim)
{
	return pp_string_or_typed_regex(in_str, len, delim, true);
}

/* pp_string_or_typed_regex --- pretty format a string, regex, or typed regex constant */

char *
pp_string_or_typed_regex(const char *in_str, size_t len, int delim, bool typed_regex)
{
	static char str_escapes[] = "\a\b\f\n\r\t\v\\";
	static char str_printables[] = "abfnrtv\\";
	static char re_escapes[] = "\a\b\f\n\r\t\v";
	static char re_printables[] = "abfnrtv";
	char *escapes;
	char *printables;
	char *cp;
	int i;
	const unsigned char *str = (const unsigned char *) in_str;
	size_t ofre, osiz;
	char *obuf, *obufout;

	assert(delim == '"' || delim == '/');

	if (delim == '/') {
		escapes = re_escapes;
		printables = re_printables;
	} else {
		escapes = str_escapes;
		printables = str_printables;
	}

/* make space for something l big in the buffer */
#define chksize(l)  if ((l) > ofre) { \
		long olen = obufout - obuf; \
		erealloc(obuf, char *, osiz * 2); \
		obufout = obuf + olen; \
		ofre += osiz; \
		osiz *= 2; \
	} ofre -= (l)

	/* initial size; 3 for delim + terminating null, 1 for @ */
	osiz = len + 3 + 1 + (typed_regex == true);
	emalloc(obuf, char *, osiz);
	obufout = obuf;
	ofre = osiz - 1;

	if (typed_regex)
		*obufout++ = '@';

	*obufout++ = delim;
	for (; len > 0; len--, str++) {
		chksize(2);		/* make space for 2 chars */
		if (delim != '/' && *str == delim) {
			*obufout++ = '\\';
			*obufout++ = delim;
		} else if (*str == '\0') {
			*obufout++ = '\\';
			*obufout++ = '0';
			chksize(2);	/* need 2 more chars for this case */
			*obufout++ = '0';
			*obufout++ = '0';
		} else if ((cp = strchr(escapes, *str)) != NULL) {
			i = cp - escapes;
			*obufout++ = '\\';
			*obufout++ = printables[i];
		/* NB: Deliberate use of lower-case versions. */
		} else if (isascii(*str) && isprint(*str)) {
			*obufout++ = *str;
			ofre += 1;	/* used 1 less than expected */
		} else {
			size_t len;

			chksize(8);		/* total available space is 10 */

			sprintf(obufout, "\\%03o", *str & 0xff);
			len = strlen(obufout);
			ofre += (10 - len);	 /* adjust free space count */
			obufout += len;
		}
	}
	chksize(2);
	*obufout++ = delim;
	*obufout = '\0';
	return obuf;
#undef chksize
}

/* pp_number --- pretty format a number */

char *
pp_number(NODE *n)
{
	char *str;

	assert((n->flags & NUMCONSTSTR) != 0);
	emalloc(str, char *, n->stlen + 1);
	strcpy(str, n->stptr);
	return str;
}

/* pp_node --- pretty format a node */

char *
pp_node(NODE *n)
{
	if ((n->flags & NUMBER) != 0)
		return pp_number(n);
	return pp_string(n->stptr, n->stlen, '"');
}

/* pp_list --- pretty print a list, with surrounding characters and separator */

static NODE **pp_args = NULL;
static int npp_args;

static char *
pp_list(int nargs, const char *paren, const char *delim)
{
	NODE *r;
 	char *str, *s;
	size_t len;
	size_t delimlen;
	int i;
	INSTRUCTION *comment = NULL;

	if (pp_args == NULL) {
		npp_args = nargs;
		emalloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *));
	} else if (nargs > npp_args) {
		npp_args = nargs;
		erealloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *));
	}

	delimlen = strlen(delim);
	if (nargs == 0)
		len = 2;
	else {
		len = -delimlen;
		for (i = 1; i <= nargs; i++) {
			r = pp_args[i] = pp_pop();
			len += r->pp_len + delimlen;
			if (r->pp_comment != NULL) {
				comment = (INSTRUCTION *) r->pp_comment;
				len += comment->memory->stlen + indent_level + 1;	// comment\n indent
			}
		}
		if (paren != NULL) {
			assert(strlen(paren) == 2);
			len += 2;
		}
	}
	comment = NULL;

	emalloc(str, char *, len + 1);
	s = str;
	if (paren != NULL)
		*s++ = paren[0];

	for (i = nargs; i > 0; i--) {
		// argument
		r = pp_args[i];
		memcpy(s, r->pp_str, r->pp_len);
		s += r->pp_len;

		// delimiter
		if (i > 1 && delimlen > 0) {
			memcpy(s, delim, delimlen);
			s += delimlen;
		}

		// comment if any
		if (r->pp_comment != NULL) {
			check_indent_level();
			comment = (INSTRUCTION *) r->pp_comment;
			memcpy(s, comment->memory->stptr, comment->memory->stlen);
			s += comment->memory->stlen;
			memcpy(s, tabs, indent_level + 1);
			s += indent_level + 1;
		}
		pp_free(r);
	}

	if (paren != NULL)
		*s++ = paren[1];
	*s = '\0';
	return str;
}

/* is_unary_minus --- return true if string starts with unary minus */

static bool
is_unary_minus(const char *str)
{
	return str[0] == '-' && str[1] != '-';
}

/* pp_concat --- handle concatenation and correct parenthesizing of expressions */

static char *
pp_concat(int nargs)
{
	NODE *r;
 	char *str, *s;
	size_t len;
	static const size_t delimlen = 1;	/* " " */
	int i;
	int pl_l, pl_r;

	if (pp_args == NULL) {
		npp_args = nargs;
		emalloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *));
	} else if (nargs > npp_args) {
		npp_args = nargs;
		erealloc(pp_args, NODE **, (nargs + 2) * sizeof(NODE *));
	}

	/*
	 * items are on the stack in reverse order that they
	 * will be printed so pop them off backwards.
	 */

	len = -delimlen;
	for (i = nargs; i >= 1; i--) {
		r = pp_args[i] = pp_pop();
		len += r->pp_len + delimlen + 2;
	}

	emalloc(str, char *, len + 1);
	s = str;

	/* now copy in */
	for (i = 1; i < nargs; i++) {
		r = pp_args[i];

		if (r->pp_str[0] != '(') {
			pl_l = prec_level(pp_args[i]->type);
			pl_r = prec_level(pp_args[i+1]->type);

			if (i >= 2 && is_unary_minus(r->pp_str)) {
				*s++ = '(';
				memcpy(s, r->pp_str, r->pp_len);
				s += r->pp_len;
				*s++ = ')';
			} else if (is_scalar(pp_args[i]->type) && is_scalar(pp_args[i+1]->type)) {
				memcpy(s, r->pp_str, r->pp_len);
				s += r->pp_len;
			} else if (pl_l <= pl_r || is_scalar(pp_args[i+1]->type)) {
				*s++ = '(';
				memcpy(s, r->pp_str, r->pp_len);
				s += r->pp_len;
				*s++ = ')';
			} else {
				memcpy(s, r->pp_str, r->pp_len);
				s += r->pp_len;
			}
		} else {
			memcpy(s, r->pp_str, r->pp_len);
			s += r->pp_len;
		}

		if (i < nargs) {
			*s++ = ' ';
		}
	}

	pl_l = prec_level(pp_args[nargs-1]->type);
	pl_r = prec_level(pp_args[nargs]->type);
	r = pp_args[nargs];
	if (r->pp_str[0] == '(') {
		memcpy(s, r->pp_str, r->pp_len);
		s += r->pp_len;
	} else if (is_unary_minus(r->pp_str) || ((pl_l >= pl_r && ! is_scalar(pp_args[nargs]->type)))) {
		*s++ = '(';
		memcpy(s, r->pp_str, r->pp_len);
		s += r->pp_len;
		*s++ = ')';
	} else {
		memcpy(s, r->pp_str, r->pp_len);
		s += r->pp_len;
	}

	for (i = nargs; i >= 1; i--) {
		pp_free(pp_args[i]);
	}

	*s = '\0';
	return str;
}

/* pp_group3 --- string together up to 3 strings */

static char *
pp_group3(const char *s1, const char *s2, const char *s3)
{
	size_t len1, len2, len3, l;
	char *str, *s;

	len1 = strlen(s1);
	len2 = strlen(s2);
	len3 = strlen(s3);
	l = len1 + len2 + len3 + 1;
	emalloc(str, char *, l);
	s = str;
	if (len1 > 0) {
		memcpy(s, s1, len1);
		s += len1;
	}
	if (len2 > 0) {
		memcpy(s, s2, len2);
		s += len2;
	}
	if (len3 > 0) {
		memcpy(s, s3, len3);
		s += len3;
	}
	*s = '\0';
	return str;
}

/* pp_func --- pretty print a function */

int
pp_func(INSTRUCTION *pc, void *data ATTRIBUTE_UNUSED)
{
	int j;
	static bool first = true;
	NODE *func;
	int pcount;
	INSTRUCTION *fp;

	if (first) {
		first = false;
		if (do_profile)
			fprintf(prof_fp, _("\n\t# Functions, listed alphabetically\n"));
	}

	pp_namespace_list(pc[3].nexti);

	fp = pc->nexti->nexti;
	func = pc->func_body;
	fprintf(prof_fp, "\n");

	/* print any function comment */
	if (pc->comment != NULL)
		print_comment(pc->comment, -1);	/* -1 ==> don't indent */

	indent(pc->nexti->exec_count);

	bool malloced = false;
	char *name = adjust_namespace(func->vname, & malloced);
	fprintf(prof_fp, "%s %s(", op2str(Op_K_function), name);
	if (malloced)
		free(name);
	pcount = func->param_cnt;
	func_params = func->fparms;
	for (j = 0; j < pcount; j++) {
		fprintf(prof_fp, "%s", func_params[j].param);
		if (j < pcount - 1)
			fprintf(prof_fp, ", ");
	}
	if (fp->opcode == Op_comment
		&& fp->memory->comment_type == EOL_COMMENT) {
		fprintf(prof_fp, ")");
		fp = end_line(fp);
	} else
		fprintf(prof_fp, ")\n");
	if (do_profile)
		indent(0);
	fprintf(prof_fp, "{\n");
	indent_in();
	pprint(fp, NULL, NO_PPRINT_FLAGS);	/* function body */
	indent_out();
	if (do_profile)
		indent(0);
	fprintf(prof_fp, "}\n");
	at_start = false;
	return 0;
}

/* redir2str --- convert a redirection type into a printable value */

const char *
redir2str(int redirtype)
{
	static const char *const redirtab[] = {
		"",
		" > ",	/* redirect_output */
		" >> ",	/* redirect_append */
		" | ",	/* redirect_pipe */
		" | ",	/* redirect_pipein */
		" < ",	/* redirect_input */
		" |& ",	/* redirect_twoway */
	};

	if (redirtype < 0 || redirtype > redirect_twoway)
		fatal(_("redir2str: unknown redirection type %d"), redirtype);
	return redirtab[redirtype];
}

/* pp_namespace --- print @namespace directive */

static void
pp_namespace(const char *name, INSTRUCTION *comment)
{
	// Don't print the initial `@namespace "awk"' unless
	// @namespace was used at some point in the program
	if (! namespace_changed)
		return;

	if (strcmp(current_namespace, name) == 0)
		return;

	// don't need to free current_namespace, it comes from
	// info saved in Op_namespace instructions.
	current_namespace = name;

	if (! at_start)
		fprintf(prof_fp, "\n");

	if (do_profile)
		indent(SPACEOVER);

	fprintf(prof_fp, "@namespace \"%s\"", name);

	if (comment != NULL) {
		putc('\t', prof_fp);
		print_comment(comment, 0);
		// no newline here, print_comment puts one out
	} else
		fprintf(prof_fp, "\n");

	at_start = false;
}

/* pp_namespace_list --- print the list, back to front, using recursion */

static void
pp_namespace_list(INSTRUCTION *list)
{
	if (list == NULL)
		return;

	pp_namespace_list(list->nexti);
	pp_namespace(list->ns_name, list->comment);
}

/* adjust_namespace --- remove leading namespace or add leading awk:: */

static char *
adjust_namespace(char *name, bool *malloced)
{
	*malloced = false;

	// unadorned name from symbol table, add awk:: if not in awk:: n.s.
	if (strchr(name, ':') == NULL &&
	    current_namespace != awk_namespace &&	// can be equal if namespace never changed
	    strcmp(current_namespace, awk_namespace) != 0 &&
	    ! is_all_upper(name)) {
		char *buf;
		size_t len = 5 + strlen(name) + 1;

		emalloc(buf, char *, len);
		sprintf(buf, "awk::%s", name);
		*malloced = true;

		return buf;
	}

	// qualifed name, remove <ns>:: if in that n.s.
	size_t len = strlen(current_namespace);

	if (strncmp(current_namespace, name, len) == 0 &&
	    name[len] == ':' && name[len+1] == ':') {
		char *ret = name + len + 2;

		return ret;
	}

	return name;
}
/*
 * re.c - compile regular expressions.
 */

/*
 * Copyright (C) 1991-2019, 2021-2025
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

#include "localeinfo.h"

static reg_syntax_t syn;
static void check_bracket_exp(char *s, size_t len);
const char *regexflags2str(int flags);

static struct localeinfo localeinfo;

/* make_regexp --- generate compiled regular expressions */

Regexp *
make_regexp(const char *s, size_t len, bool ignorecase, bool dfa, bool canfatal)
{
	static char metas[] = ".*+(){}[]|?^$\\";
	Regexp *rp;
	const char *rerr;
	const char *src = s;
	static char *buf = NULL;
	static size_t buflen;
	const char *end = s + len;
	char *dest;
	int c;
	static bool first = true;
	static bool no_dfa = false;
	int i;
	static struct dfa* dfaregs[2] = { NULL, NULL };
	static bool nul_warned = false;

	assert(s[len] == '\0');

	if (do_lint && ! nul_warned && memchr(s, '\0', len) != NULL) {
		nul_warned = true;
		lintwarn(_("behavior of matching a regexp containing NUL characters is not defined by POSIX"));
	}

	mbstate_t mbs;

	memset(&mbs, 0, sizeof(mbstate_t)); /* Initialize.  */

	if (first) {
		/* for debugging and testing */
		no_dfa = (getenv("GAWK_NO_DFA") != NULL);
		/* don't set first to false here, we do it below */
	}

	/* always check */
	check_bracket_exp((char *) s, len);

	/* Handle escaped characters first. */

	/*
	 * Build a copy of the string (in buf) with the
	 * escaped characters translated, and generate the regex
	 * from that.
	 */
	if (buf == NULL) {
		emalloc(buf, char *, len + 1);
		buflen = len;
	} else if (len > buflen) {
		erealloc(buf, char *, len + 1);
		buflen = len;
	}
	dest = buf;

	while (src < end) {
		/*
		 * Keep multibyte characters together. This avoids
		 * problems if a subsequent byte of a multibyte
		 * character happens to be a backslash.
		 */
		if (gawk_mb_cur_max > 1) {
			size_t mblen = mbrlen(src, end - src, &mbs);

			/*
			 * Incomplete (-2), invalid (-1), and
			 * null (0) characters are excluded here.
			 * They are read as a sequence of bytes.
			 */
			if (mblen > 1 && mblen < (size_t) -2) {
				size_t i;

				for (i = 0; i < mblen; i++)
					*dest++ = *src++;
				continue;
			}
		}

		/*
		 * From here *src is a single byte character.
		 */
		if (*src != '\\') {
			*dest++ = *src++;
			continue;
		}

		/* Escape sequence */
		c = *++src;
		switch (c) {
		case '\0':	/* \\ before \0, either dynamic data or real end of string */
			if (src >= s + len)
				*dest++ = '\\';	// at end of string, will fatal below
			else
				fatal(_("invalid NUL byte in dynamic regexp"));
			break;
		case 'a':
		case 'b':
		case 'f':
		case 'n':
		case 'r':
		case 't':
		case 'v':
		case 'x':
		case 'u':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		{
			const char *result;
			size_t nbytes;
			enum escape_results ret;

			ret = parse_escape(& src, & result, & nbytes);
			switch (ret) {
			case ESCAPE_OK:
				/*
				 * Unix awk treats octal (and hex?) chars
				 * literally in re's, so escape regexp
				 * metacharacters.
				 */
				if (nbytes == 1
				    && do_traditional
				    && ! do_posix
				    && (isdigit(c) || c == 'x' || c == 'u')
				    && strchr(metas, *result) != NULL)
					*dest++ = '\\';

				if (nbytes == 1
				    && do_lint
				    && ! nul_warned
				    && *result == '\0') {
					nul_warned = true;
					lintwarn(_("behavior of matching a regexp containing NUL characters is not defined by POSIX"));
				}

				/* nbytes is now > 0 */
				while (nbytes--)
					*dest++ = *result++;
				break;
			case ESCAPE_CONV_ERR:
				/*
				 * Invalid code points produce '?' (0x3F).
				 * These are quoted so that they're taken
				 * literally. Unlike \u3F, a metachar.
				 */
				*dest++ = '\\';
				*dest++ = '?';
				break;
			default:
				/*
				 * The outer switch handles terminal
				 * backslashes and line continuations.
				 * parse_escape should never see them
				 * and therefore it should never return
				 * ESCAPE_TERM_BACKSLASH nor
				 * ESCAPE_LINE_CONTINUATION.
				 *
				 * This also catches unknown values.
				 */
				cant_happen("received bad result %d from parse_escape(), nbytes = %zu",
						(int) ret, nbytes);
			}
			break;
		}
		case '8':
		case '9':	/* a\9b not valid */
			*dest++ = c;
			src++;
		{
			static bool warned[2];

			if (! warned[c - '8']) {
				warning(_("regexp escape sequence `\\%c' treated as plain `%c'"), c, c);
				warned[c - '8'] = true;
			}
		}
			break;
		case 'y':	/* normally \b */
			/* gnu regex op */
			if (! do_traditional) {
				*dest++ = '\\';
				*dest++ = 'b';
				src++;
				break;
			}
			/* else, fall through */
		default:
		  {
			static const char *ok_to_escape = NULL;

			/*
			 * The posix and traditional flags do not change
			 * once the awk program is running. Therefore,
			 * neither does ok_to_escape.
			 */
			if (ok_to_escape == NULL) {
				if (do_posix || do_traditional)
					ok_to_escape = "{}()|*+?.^$\\[]/-";
				else
					ok_to_escape = "<>`'BywWsS{}()|*+?.^$\\[]/-";
			}

			if (strchr(ok_to_escape, c) == NULL) {
				static bool warned[256];

				if (! warned[c & 0xFF]) {
					warning(_("regexp escape sequence `\\%c' is not a known regexp operator"), c);
					warned[c & 0xFF] = true;
				}
			}
			*dest++ = '\\';
			*dest++ = (char) c;
			src++;
			break;
		  }
		} /* switch */
	} /* while */

	*dest = '\0';
	len = dest - buf;

	ezalloc(rp, Regexp *, sizeof(*rp));
	rp->pat.allocated = 0;	/* regex will allocate the buffer */
	emalloc(rp->pat.fastmap, char *, 256);

	/*
	 * Lo these many years ago, had I known what a P.I.T.A. IGNORECASE
	 * was going to turn out to be, I wouldn't have bothered with it.
	 *
	 * In the case where we have a multibyte character set, we have no
	 * choice but to use RE_ICASE, since the casetable is for single-byte
	 * character sets only.
	 *
	 * On the other hand, if we do have a single-byte character set,
	 * using the casetable should give  a performance improvement, since
	 * it's computed only once, not each time a regex is compiled.  We
	 * also think it's probably better for portability.  See the
	 * discussion by the definition of casetable[] in eval.c.
	 */

	ignorecase = !! ignorecase;	/* force to 1 or 0 */
	if (ignorecase) {
		if (gawk_mb_cur_max > 1) {
			syn |= RE_ICASE;
			rp->pat.translate = NULL;
		} else {
			syn &= ~RE_ICASE;
			rp->pat.translate = (RE_TRANSLATE_TYPE) casetable;
		}
	} else {
		rp->pat.translate = NULL;
		syn &= ~RE_ICASE;
	}

	/* initialize dfas to hold syntax */
	if (first) {
		first = false;
		dfaregs[0] = dfaalloc();
		dfaregs[1] = dfaalloc();
		dfasyntax(dfaregs[0], & localeinfo, syn, DFA_ANCHOR);
		dfasyntax(dfaregs[1], & localeinfo, syn | RE_ICASE, DFA_ANCHOR);
	}

	re_set_syntax(syn);

	if ((rerr = re_compile_pattern(buf, len, &(rp->pat))) != NULL) {
		refree(rp);
		if (! canfatal) {
			/* rerr already gettextized inside regex routines */
			error("%s: /%s/", rerr, s);
 			return NULL;
		}
		fatal("invalid regexp: %s: /%s/", rerr, s);
	}

	/* gack. this must be done *after* re_compile_pattern */
	rp->pat.newline_anchor = false; /* don't get \n in middle of string */
	if (dfa && ! no_dfa) {
		rp->dfareg = dfaalloc();
		dfacopysyntax(rp->dfareg, dfaregs[ignorecase]);
		dfacomp(buf, len, rp->dfareg, true);
	} else
		rp->dfareg = NULL;

	/* Additional flags that help with RS as regexp. */
	for (i = 0; i < len; i++) {
		if (strchr(metas, buf[i]) != NULL) {
			rp->has_meta = true;
			break;
		}
	}

	for (i = len - 1; i >= 0; i--) {
		if (strchr("\\*+|?{}", buf[i]) != NULL) {
			rp->maybe_long = true;
			break;
		}
	}

	return rp;
}

/* research --- do a regexp search. use dfa if possible */

int
research(Regexp *rp, char *str, int start,
	 size_t len, int flags)
{
	const char *ret = str;
	bool try_backref = false;
	int need_start;
	int no_bol;
	int res;

	need_start = ((flags & RE_NEED_START) != 0);
	no_bol = ((flags & RE_NO_BOL) != 0);

	if (no_bol)
		rp->pat.not_bol = 1;

	/*
	 * Always do dfa search if can; if it fails, then even if
	 * need_start is true, we won't bother with the regex search.
	 *
	 * The dfa matcher doesn't have a no_bol flag, so don't bother
	 * trying it in that case.
	 *
	 * 7/2008: Skip the dfa matcher if need_start. The dfa matcher
	 * has bugs in certain multibyte cases and it's too difficult
	 * to try to special case things.
	 * 7/2017: Apparently there are some cases where DFA gets
	 * stuck, even in the C locale, so we use dfa only if not need_start.
	 *
	 * Should that issue ever get resolved, note this comment:
	 *
	 * 7/2016: The dfa matcher can't handle a case where searching
	 * starts in the middle of a string, so don't bother trying it
	 * in that case.
	 *	if (rp->dfa && ! no_bol && start == 0) ...
	 */
	if (rp->dfareg != NULL && ! no_bol && ! need_start) {
		struct dfa *superset = dfasuperset(rp->dfareg);
		if (superset)
			ret = dfaexec(superset, str+start, str+start+len,
							true, NULL, NULL);

		if (ret && (! need_start
				|| (! superset && dfaisfast(rp->dfareg))))
			ret = dfaexec(rp->dfareg, str+start, str+start+len,
						true, NULL, &try_backref);
	}

	if (ret) {
		if (   rp->dfareg == NULL
			|| start != 0
			|| no_bol
			|| need_start
			|| try_backref) {
			/*
			 * Passing NULL as last arg speeds up search for cases
			 * where we don't need the start/end info.
			 */
			res = re_search(&(rp->pat), str, start+len,
				start, len, need_start ? &(rp->regs) : NULL);
		} else
			res = 1;
	} else
		res = -1;

	rp->pat.not_bol = 0;
	return res;
}

/* refree --- free up the dynamic memory used by a compiled regexp */

void
refree(Regexp *rp)
{
	if (rp == NULL)
		return;
	rp->pat.translate = NULL;
	regfree(& rp->pat);
	if (rp->regs.start)
		free(rp->regs.start);
	if (rp->regs.end)
		free(rp->regs.end);
	if (rp->dfareg != NULL) {
		dfafree(rp->dfareg);
		free(rp->dfareg);
	}
	efree(rp);
}

/* dfaerror --- print an error message for the dfa routines */

void
dfaerror(const char *s)
{
	fatal("%s", s);
	exit(EXIT_FATAL);
}

/* re_cache_get --- populate regexp cache if empty */

static inline Regexp *
re_cache_get(NODE *t)
{
	if (t->re_reg[IGNORECASE] == NULL)
		t->re_reg[IGNORECASE] = make_regexp(t->re_exp->stptr, t->re_exp->stlen, IGNORECASE, t->re_cnt, true);
	return t->re_reg[IGNORECASE];
}

/* re_update --- recompile a dynamic regexp */

Regexp *
re_update(NODE *t)
{
	NODE *t1;

	if (t->type == Node_val && (t->flags & REGEX) != 0)
		return re_cache_get(t->typed_re);

	if ((t->re_flags & CONSTANT) != 0) {
		/* it's a constant, so just return it as is */
		assert(t->type == Node_regex);
		return re_cache_get(t);
	}
	t1 = t->re_exp;
	if (t->re_text != NULL) {
		/* if contents haven't changed, just return it */
		if (cmp_nodes(t->re_text, t1, true) == 0)
			return re_cache_get(t);
		/* things changed, fall through to recompile */
		unref(t->re_text);
	}
	/* get fresh copy of the text of the regexp */
	t->re_text = dupnode(t1);

	/* text changed */

	/* free old */
	if (t->re_reg[0] != NULL) {
		refree(t->re_reg[0]);
		t->re_reg[0] = NULL;
	}
	if (t->re_reg[1] != NULL) {
		refree(t->re_reg[1]);
		t->re_reg[1] = NULL;
	}
	if (t->re_cnt > 0 && ++t->re_cnt > 10)
		/*
		 * The regex appears to update frequently, so disable DFA
		 * matching (which trades off expensive upfront compilation
		 * overhead for faster subsequent matching).
		 */
		t->re_cnt = 0;
	if (t->re_text == NULL) {
		/* reset regexp text if needed */
		t1 = t->re_exp;
		unref(t->re_text);
		t->re_text = dupnode(t1);
	}
	return re_cache_get(t);
}

/* resetup --- choose what kind of regexps we match */

void
resetup()
{
	// init localeinfo for dfa
	init_localeinfo(& localeinfo);

	/*
	 * Syntax bits: _that_ is yet another mind trip.  Recreational drugs
	 * are helpful for recovering from the experience.
	 *
	 *	Aharon Robbins <arnold@skeeve.com>
	 *	Sun, 21 Oct 2007 23:55:33 +0200
	 */
	if (do_posix)
		syn = RE_SYNTAX_POSIX_AWK;	/* strict POSIX re's */
	else if (do_traditional)
		syn = RE_SYNTAX_AWK;		/* traditional Unix awk re's */
	else
		syn = RE_SYNTAX_GNU_AWK;	/* POSIX re's + GNU ops */

	/*
	 * Interval expressions are now on by default, as POSIX is
	 * wide-spread enough that people want it.
	 *
	 * 2/2022: BWK awk has supported interval expressions since
	 * March 2019, with an important fix added in Januay 2020.
	 * So we add that support even for --traditional. It's easier to
	 * do it here than to try to get the GLIBC / GNULIB folks to change
	 * the definition of RE_SYNTAX_AWK, which likely would cause
	 * binary compatibility issues.
	 */
	if (do_traditional)
		syn |= RE_INTERVALS | RE_INVALID_INTERVAL_ORD | RE_NO_BK_BRACES;

	(void) re_set_syntax(syn);
}

/* using_utf8 --- are we using utf8 */

bool
using_utf8(void)
{
	return localeinfo.using_utf8;
}

/* reisstring --- return true if the RE match is a simple string match */

int
reisstring(const char *text, size_t len, Regexp *re, const char *buf)
{
	int res;
	const char *matched;

	/* simple checking for meta characters in re */
	if (re->has_meta)
		return false;	/* give up early, can't be string match */

	/* make accessable to gdb */
	matched = &buf[RESTART(re, buf)];

	res = (memcmp(text, matched, len) == 0);

	return res;
}

/* reflags2str --- make a regex flags value readable */

const char *
reflags2str(int flagval)
{
	static const struct flagtab values[] = {
		{ RE_BACKSLASH_ESCAPE_IN_LISTS, "RE_BACKSLASH_ESCAPE_IN_LISTS" },
		{ RE_BK_PLUS_QM, "RE_BK_PLUS_QM" },
		{ RE_CHAR_CLASSES, "RE_CHAR_CLASSES" },
		{ RE_CONTEXT_INDEP_ANCHORS, "RE_CONTEXT_INDEP_ANCHORS" },
		{ RE_CONTEXT_INDEP_OPS, "RE_CONTEXT_INDEP_OPS" },
		{ RE_CONTEXT_INVALID_OPS, "RE_CONTEXT_INVALID_OPS" },
		{ RE_DOT_NEWLINE, "RE_DOT_NEWLINE" },
		{ RE_DOT_NOT_NULL, "RE_DOT_NOT_NULL" },
		{ RE_HAT_LISTS_NOT_NEWLINE, "RE_HAT_LISTS_NOT_NEWLINE" },
		{ RE_INTERVALS, "RE_INTERVALS" },
		{ RE_LIMITED_OPS, "RE_LIMITED_OPS" },
		{ RE_NEWLINE_ALT, "RE_NEWLINE_ALT" },
		{ RE_NO_BK_BRACES, "RE_NO_BK_BRACES" },
		{ RE_NO_BK_PARENS, "RE_NO_BK_PARENS" },
		{ RE_NO_BK_REFS, "RE_NO_BK_REFS" },
		{ RE_NO_BK_VBAR, "RE_NO_BK_VBAR" },
		{ RE_NO_EMPTY_RANGES, "RE_NO_EMPTY_RANGES" },
		{ RE_UNMATCHED_RIGHT_PAREN_ORD, "RE_UNMATCHED_RIGHT_PAREN_ORD" },
		{ RE_NO_POSIX_BACKTRACKING, "RE_NO_POSIX_BACKTRACKING" },
		{ RE_NO_GNU_OPS, "RE_NO_GNU_OPS" },
		{ RE_DEBUG, "RE_DEBUG" },	// not actually used in the code anymore, :-(
		{ RE_INVALID_INTERVAL_ORD, "RE_INVALID_INTERVAL_ORD" },
		{ RE_ICASE, "RE_ICASE" },
		{ RE_CARET_ANCHORS_HERE, "RE_CARET_ANCHORS_HERE" },
		{ RE_CONTEXT_INVALID_DUP, "RE_CONTEXT_INVALID_DUP" },
		{ RE_NO_SUB, "RE_NO_SUB" },
		{ 0,	NULL },
	};

	if (flagval == RE_SYNTAX_EMACS) /* == 0 */
		return "RE_SYNTAX_EMACS";

	return genflags2str(flagval, values);
}

/*
 * dfawarn() is called by the dfa routines whenever a regex is compiled
 * must supply a dfawarn.
 */

void
dfawarn(const char *dfa_warning)
{
	/*
	 * This routine does nothing, since gawk does its own
	 * (better) check for bad [[:foo:]] syntax.
	 */
}

/* check_bracket_exp --- look for /[:space:]/ that should be /[[:space:]]/ */

static void
check_bracket_exp(char *s, size_t length)
{
	static struct reclass {
		const char *name;
		size_t len;
		bool warned;
	} classes[] = {
		/*
		 * Ordered by what we hope is frequency,
		 * since it's linear searched.
		 */
		{ "[:alpha:]", 9, false },
		{ "[:digit:]", 9, false },
		{ "[:alnum:]", 9, false },
		{ "[:upper:]", 9, false },
		{ "[:lower:]", 9, false },
		{ "[:space:]", 9, false },
		{ "[:xdigit:]", 10, false },
		{ "[:punct:]", 9, false },
		{ "[:print:]", 9, false },
		{ "[:graph:]", 9, false },
		{ "[:cntrl:]", 9, false },
		{ "[:blank:]", 9, false },
		{ NULL, 0 }
	};
	int i;
	bool found = false;
	char save;
	char *sp, *sp2, *end;
	int len;
	int count = 0;

	if (length == 0)
		return;

	end = s + length;
	save = s[length];
	s[length] = '\0';
	sp = s;

again:
	sp = sp2 = (char *) memchr(sp, '[', (end - sp));
	if (sp == NULL)
		goto done;

	sp++;
	count = 1;
	/*
	 * Skip over the following:
	 * [^]...]
	 * [\]...]
	 * []...]
	 */
	if (*sp == '^')
		sp++;
	if (*sp == '\\')
		sp += 2;
	else if (*sp == ']')
		sp++;

	for (; sp < end && *sp != '\0'; sp++) {
		if (*sp == '[')
			count++;
		else if (*sp == ']')
			count--;

		if (count == 0) {
			sp++;	/* skip past ']' */
			break;
		}
	}

	if (count > 0) {	/* bad regex, give up */
		goto done;
	}

	/* sp2 has start */

	for (i = 0; classes[i].name != NULL; i++) {
		if (classes[i].warned)
			continue;
		len = classes[i].len;
		if (   len == (sp - sp2)
		    && memcmp(sp2, classes[i].name, len) == 0) {
			found = true;
			break;
		}
	}

	if (found && ! classes[i].warned) {
		warning(_("regexp component `%.*s' should probably be `[%.*s]'"),
				len, sp2, len, sp2);
		classes[i].warned = true;
	}

	if (sp < end) {
		found = false;
		goto again;
	}
done:
	s[length] = save;
}
/*
 * symbol.c - routines for symbol table management and code allocation
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2015, 2017-2020, 2022, 2023, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

extern SRCFILE *srcfiles;
extern INSTRUCTION *rule_list;

#define HASHSIZE	1021

static NODE *symbol_list;
static void (*install_func)(NODE *) = NULL;
static NODE *make_symbol(const char *name, NODETYPE type);
static NODE *install(const char *name, NODE *parm, NODETYPE type);
static void free_bcpool(INSTRUCTION_POOL *pl);
static NODE *get_name_from_awk_ns(const char *name);

static AWK_CONTEXT *curr_ctxt = NULL;
static int ctxt_level;

static NODE *global_table, *param_table;
NODE *symbol_table, *func_table;

/* Use a flag to avoid a strcmp() call inside install() */
static bool installing_specials = false;

// Using persistent memory, manage the root pointer
// which holds this struct:
struct root_pointers {
	NODE *global_table;
	NODE *func_table;
	NODE *symbol_table;
	struct block_header nextfree[BLOCK_MAX];
	int mpfr;
	bool first;
} *root_pointers = NULL;

/* init_the_tables --- deal with the tables for in memory use */

static void
init_the_tables(void)
{
	getnode(global_table);
	memset(global_table, '\0', sizeof(NODE));
	null_array(global_table);

	getnode(param_table);
	memset(param_table, '\0', sizeof(NODE));
	null_array(param_table);

	installing_specials = true;
	func_table = install_symbol(estrdup("FUNCTAB", 7), Node_var_array);
	symbol_table = install_symbol(estrdup("SYMTAB", 6), Node_var_array);
	installing_specials = false;
}

/* init_symbol_table --- make sure the symbol tables are initialized */

void
init_symbol_table()
{
	if (! using_persistent_malloc) {
		// normal case, initialize regularly, return
		init_the_tables();
		return;
	}

	root_pointers = (struct root_pointers *) pma_get_root();

	if (root_pointers == NULL) {
		// very first time!

		// set up the tables
		init_the_tables();

		// save the pointers for the next time.
		emalloc(root_pointers, struct root_pointers *, sizeof(struct root_pointers));
		memset(root_pointers, 0, sizeof(struct root_pointers));
		root_pointers->global_table = global_table;
		root_pointers->func_table = func_table;
		root_pointers->symbol_table = symbol_table;
		root_pointers->first = true;
		root_pointers->mpfr = 0;
		pma_set_root(root_pointers);
	} else {
		// this is the next time, get the saved pointers and put them back in place
		global_table = root_pointers->global_table;
		func_table = root_pointers->func_table;
		symbol_table = root_pointers->symbol_table;
		memcpy(nextfree, root_pointers->nextfree, sizeof(nextfree));

		// still need to set this one up as usual
		getnode(param_table);
		memset(param_table, '\0', sizeof(NODE));
		null_array(param_table);
	}
}

/* pma_mpfr_check --- check that -M is same between invocations */

void
pma_mpfr_check(void)
{
	if (! using_persistent_malloc)
		return;

	if (root_pointers->first) {
		root_pointers->first = false;
		root_pointers->mpfr = do_mpfr;
		return;
	}

	if (root_pointers->mpfr != do_mpfr)
		fatal(_("current setting of -M/--bignum does not match saved setting in PMA backing file"));
}

/* pma_save_free_lists --- save the free lists in the root pointer */

void
pma_save_free_lists(void)
{
	if (! using_persistent_malloc)
		return;

	assert(! root_pointers->first);

	memcpy(root_pointers->nextfree, nextfree, sizeof(nextfree));
}

/*
 * install_symbol:
 * Install a global name in the symbol table, even if it is already there.
 * Caller must check against redefinition if that is desired.
 */

NODE *
install_symbol(const char *name, NODETYPE type)
{
	return install(name, NULL, type);
}


/*
 * lookup --- find the most recent global or param node for name
 *	installed by install_symbol
 */

NODE *
lookup(const char *name)
{
	NODE *n;
	NODE *tmp;
	NODE *tables[5];	/* manual init below, for z/OS */
	int i;

	/* ``It's turtles, all the way down.'' */
	tables[0] = param_table;	/* parameters shadow everything */
	tables[1] = global_table;	/* SYMTAB and FUNCTAB found first, can't be redefined */
	tables[2] = func_table;		/* then functions */
	tables[3] = symbol_table;	/* then globals */
	tables[4] = NULL;

	tmp = get_name_from_awk_ns(name);

	n = NULL;
	for (i = 0; tables[i] != NULL; i++) {
		if (assoc_empty(tables[i]))
			continue;

		if ((do_posix || do_traditional) && tables[i] == global_table)
			continue;

		n = in_array(tables[i], tmp);
		if (n != NULL)
			break;
	}

	unref(tmp);
	if (n == NULL || n->type == Node_val)	/* non-variable in SYMTAB */
		return NULL;
	return n;	/* new place */
}

/* make_params --- allocate function parameters for the symbol table */

NODE *
make_params(char **pnames, int pcount)
{
	NODE *p, *parms;
	int i;

	if (pcount <= 0 || pnames == NULL)
		return NULL;

	ezalloc(parms, NODE *, pcount * sizeof(NODE));

	for (i = 0, p = parms; i < pcount; i++, p++) {
		p->type = Node_param_list;
		p->param = pnames[i];	/* shadows pname and vname */
		p->param_cnt = i;
	}

	return parms;
}

/* install_params --- install function parameters into the symbol table */

void
install_params(NODE *func)
{
	int i, pcount;
	NODE *parms;

	if (func == NULL)
		return;

	assert(func->type == Node_func);

	if (   (pcount = func->param_cnt) <= 0
	    || (parms = func->fparms) == NULL)
		return;

	for (i = 0; i < pcount; i++)
		(void) install(parms[i].param, parms + i, Node_param_list);
}


/*
 * remove_params --- remove function parameters out of the symbol table.
 */

void
remove_params(NODE *func)
{
	NODE *parms, *p;
	int i, pcount;

	if (func == NULL)
		return;

	assert(func->type == Node_func);

	if (   (pcount = func->param_cnt) <= 0
	    || (parms = func->fparms) == NULL)
		return;

	for (i = pcount - 1; i >= 0; i--) {
		NODE *tmp;
		NODE *tmp2;

		p = parms + i;
		assert(p->type == Node_param_list);
		tmp = make_string(p->vname, strlen(p->vname));
		tmp2 = in_array(param_table, tmp);
		if (tmp2 != NULL && tmp2->dup_ent != NULL)
			tmp2->dup_ent = tmp2->dup_ent->dup_ent;
		else
			(void) assoc_remove(param_table, tmp);

		unref(tmp);
	}

	assoc_clear(param_table);	/* shazzam! */
}


/* remove_symbol --- remove a symbol from the symbol table */

NODE *
remove_symbol(NODE *r)
{
	NODE *n = in_array(symbol_table, r);

	if (n == NULL)
		return n;

	n = dupnode(n);

	(void) assoc_remove(symbol_table, r);

	return n;
}


/*
 * destroy_symbol --- remove a symbol from symbol table
 *	and free all associated memory.
 */

void
destroy_symbol(NODE *r)
{
	r = remove_symbol(r);
	if (r == NULL)
		return;

	switch (r->type) {
	case Node_func:
		if (r->param_cnt > 0) {
			NODE *n;
			int i;
			int pcount = r->param_cnt;

			/* function parameters of type Node_param_list */
			for (i = 0; i < pcount; i++) {
				n = r->fparms + i;
				efree(n->param);
			}
			efree(r->fparms);
		}
		break;

	case Node_ext_func:
		bcfree(r->code_ptr);
		break;

	case Node_var_array:
		assoc_clear(r);
		break;

	case Node_var:
		unref(r->var_value);
		break;

	default:
		/* Node_param_list -- YYABORT */
		break;	/* use break so that storage is freed */
	}

	efree(r->vname);
	freenode(r);
}


/* make_symbol --- allocates a global symbol for the symbol table. */

static NODE *
make_symbol(const char *name, NODETYPE type)
{
	NODE *r;

	getnode(r);
	memset(r, '\0', sizeof(NODE));
	if (type == Node_var_array)
		null_array(r);
	else if (type == Node_var)
		r->var_value = dupnode(Nnull_string);
	r->vname = (char *) name;
	r->type = type;
	r->valref = 1;

	return r;
}

/* install --- install a global name or function parameter in the symbol table */

static NODE *
install(const char *name, NODE *parm, NODETYPE type)
{
	NODE *r;
	NODE *table;
	NODE *n_name;
	NODE *prev;

	n_name = get_name_from_awk_ns(name);

	table = symbol_table;

	if (type == Node_param_list) {
		table = param_table;
	} else if (   type == Node_func
		   || type == Node_ext_func
		   || type == Node_builtin_func) {
		table = func_table;
	} else if (installing_specials) {
		table = global_table;
	}

	if (parm != NULL)
		r = parm;
	else {
		/* global symbol */
		r = make_symbol(name, type);
	}

	if (type == Node_param_list) {
		prev = in_array(table, n_name);
		if (prev == NULL)
			goto simple;
		r->dup_ent = prev->dup_ent;
		prev->dup_ent = r;
		unref(n_name);
	} else {
simple:
		/* the simple case */
		assoc_set(table, n_name, r);
	}

	if (install_func)
		(*install_func)(r);

	return r;
}

/* comp_symbol --- compare two (variable or function) names */

static int
comp_symbol(const void *v1, const void *v2)
{
	const NODE *const *npp1, *const *npp2;
	const NODE *n1, *n2;

	npp1 = (const NODE *const *) v1;
	npp2 = (const NODE *const *) v2;
	n1 = *npp1;
	n2 = *npp2;

	// names in awk namespace come out first
	bool n1_is_in_ns = (strchr(n1->vname, ':') != NULL);
	bool n2_is_in_ns = (strchr(n2->vname, ':') != NULL);

	if (n1_is_in_ns && n2_is_in_ns)
		return strcmp(n1->vname, n2->vname);
	else if (n1_is_in_ns && ! n2_is_in_ns)
		return 1;
	else if (! n1_is_in_ns && n2_is_in_ns)
		return -1;
	else
		return strcmp(n1->vname, n2->vname);
}


typedef enum { FUNCTION = 1, VARIABLE } SYMBOL_TYPE;

/* get_symbols --- return a list of optionally sorted symbols */

static NODE **
get_symbols(SYMBOL_TYPE what, bool sort)
{
	int i;
	NODE **table;
	NODE **list;
	NODE *r;
	long count = 0;
	long max;
	NODE *the_table;

	/*
	 * assoc_list() returns an array with two elements per awk array
	 * element. Elements i and i+1 in the C array represent the key
	 * and value of element j in the awk array. Thus the loops use += 2
	 * to go through the awk array.
	 */

	if (what == FUNCTION) {
		the_table = func_table;
		max = the_table->table_size * 2;

		list = assoc_list(the_table, "@unsorted", ASORTI);
		emalloc(table, NODE **, (the_table->table_size + 1) * sizeof(NODE *));

		for (i = count = 0; i < max; i += 2) {
			r = list[i+1];
			if (r->type == Node_ext_func || r->type == Node_builtin_func)
				continue;
			assert(r->type == Node_func);
			table[count++] = r;
		}
	} else {	/* what == VARIABLE */
		update_global_values();

		the_table = symbol_table;
		max = the_table->table_size * 2;

		list = assoc_list(the_table, "@unsorted", ASORTI);
		/* add three: one for FUNCTAB, one for SYMTAB, and one for a final NULL */
		emalloc(table, NODE **, (the_table->table_size + 1 + 1 + 1) * sizeof(NODE *));

		for (i = count = 0; i < max; i += 2) {
			r = list[i+1];
			if (r->type == Node_val)	/* non-variable in SYMTAB */
				continue;
			table[count++] = r;
		}

		table[count++] = func_table;
		table[count++] = symbol_table;
	}

	efree(list);

	if (sort && count > 1)
		qsort(table, count, sizeof(NODE *), comp_symbol);	/* Shazzam! */
	table[count] = NULL; /* null terminate the list */
	return table;
}


/* variable_list --- list of global variables */

NODE **
variable_list()
{
	return get_symbols(VARIABLE, true);
}

/* function_list --- list of functions */

NODE **
function_list(bool sort)
{
	return get_symbols(FUNCTION, sort);
}

/* print_vars --- print names and values of global variables */

void
print_vars(NODE **table, int (*print_func)(FILE *, const char *, ...), FILE *fp)
{
	int i;
	NODE *r;

	assert(table != NULL);

	for (i = 0; (r = table[i]) != NULL; i++) {
		if (r->type == Node_func || r->type == Node_ext_func)
			continue;
		print_func(fp, "%s: ", r->vname);
		if (r->type == Node_var_array)
			print_func(fp, "array, %ld elements\n", assoc_length(r));
		else if (r->type == Node_var_new)
			print_func(fp, "untyped variable\n");
		else if (r->type == Node_var)
			valinfo(r->var_value, print_func, fp);
		else
			cant_happen("unexpected node type: %s", nodetype2str(r->type));
	}
}


/* foreach_func --- execute given function for each awk function in table. */

int
foreach_func(NODE **table, int (*pfunc)(INSTRUCTION *, void *), void *data)
{
	int i;
	NODE *r;
	int ret = 0;

	assert(table != NULL);

	for (i = 0; (r = table[i]) != NULL; i++) {
		if ((ret = pfunc(r->code_ptr, data)) != 0)
			break;
	}
	return ret;
}

/* release_all_vars --- free all variable memory */

void
release_all_vars()
{
	assoc_clear(symbol_table);
	assoc_clear(func_table);
	assoc_clear(global_table);
}


/* append_symbol --- append symbol to the list of symbols
 *	installed in the symbol table.
 */

void
append_symbol(NODE *r)
{
	NODE *p;

	getnode(p);
	memset(p, '\0', sizeof(NODE));
	p->lnode = r;
	p->rnode = symbol_list->rnode;
	symbol_list->rnode = p;
}

/* release_symbols --- free symbol list and optionally remove symbol from symbol table */

void
release_symbols(NODE *symlist, int keep_globals)
{
	NODE *p, *next;

	for (p = symlist->rnode; p != NULL; p = next) {
		if (! keep_globals) {
			/*
			 * destroys globals, function, and params
			 * if still in symbol table
			 */
			destroy_symbol(p->lnode);
		}
		next = p->rnode;
		freenode(p);
	}
	symlist->rnode = NULL;
}

/* load_symbols --- fill in symbols' information */

void
load_symbols()
{
	NODE *r;
	NODE *tmp;
	NODE *sym_array;
	NODE **aptr;
	long i, j, max;
	NODE *user, *extension, *untyped, *scalar, *array, *built_in;
	NODE **list;
	NODE *tables[4];

	if (PROCINFO_node == NULL)
		return;

	tables[0] = func_table;
	tables[1] = symbol_table;
	tables[2] = global_table;
	tables[3] = NULL;

	tmp = make_string("identifiers", 11);
	aptr = assoc_lookup(PROCINFO_node, tmp);

	getnode(sym_array);
	memset(sym_array, '\0', sizeof(NODE));	/* PPC Mac OS X wants this */
	null_array(sym_array);

	unref(tmp);
	unref(*aptr);
	*aptr = sym_array;

	sym_array->parent_array = PROCINFO_node;
	sym_array->vname = estrdup("identifiers", 11);

	user = make_string("user", 4);
	extension = make_string("extension", 9);
	scalar = make_string("scalar", 6);
	untyped = make_string("untyped", 7);
	array = make_string("array", 5);
	built_in = make_string("builtin", 7);

	for (i = 0; tables[i] != NULL; i++) {
		list = assoc_list(tables[i], "@unsorted", ASORTI);
		max = tables[i]->table_size * 2;
		if (max == 0)
			continue;
		for (j = 0; j < max; j += 2) {
			r = list[j+1];
			if (   r->type == Node_ext_func
			    || r->type == Node_func
			    || r->type == Node_builtin_func
			    || r->type == Node_var
			    || r->type == Node_var_array
			    || r->type == Node_var_new) {
				if (strncmp(r->vname, "awk::", 5) == 0)
					tmp = make_string(r->vname + 5, strlen(r->vname) - 5);
				else
					tmp = make_string(r->vname, strlen(r->vname));
				aptr = assoc_lookup(sym_array, tmp);
				unref(tmp);
				unref(*aptr);
				switch (r->type) {
				case Node_ext_func:
					*aptr = dupnode(extension);
					break;
				case Node_func:
					*aptr = dupnode(user);
					break;
				case Node_builtin_func:
					*aptr = dupnode(built_in);
					break;
				case Node_var:
					*aptr = dupnode(scalar);
					break;
				case Node_var_array:
					*aptr = dupnode(array);
					break;
				case Node_var_new:
					*aptr = dupnode(untyped);
					break;
				default:
					cant_happen("unexpected node type %s", nodetype2str(r->type));
					break;
				}
			}
		}
		efree(list);
	}

	unref(user);
	unref(extension);
	unref(scalar);
	unref(untyped);
	unref(array);
	unref(built_in);
}

/* check_param_names --- make sure no parameter is the name of a function */

bool
check_param_names(void)
{
	int i, j;
	NODE **list;
	NODE *f;
	long max;
	bool result = true;
	NODE n;

	if (assoc_empty(func_table))
		return result;

	max = func_table->table_size * 2;

	memset(& n, 0, sizeof n);
	n.type = Node_val;
	n.flags = STRING|STRCUR;
	n.stfmt = STFMT_UNUSED;
#ifdef HAVE_MPFR
	n.strndmode = MPFR_round_mode;
#endif

	/*
	 * assoc_list() returns an array with two elements per awk array
	 * element. Elements i and i+1 in the C array represent the key
	 * and value of element j in the awk array. Thus the loops use += 2
	 * to go through the awk array.
	 *
	 * In this case, the name is in list[i], and the function is
	 * in list[i+1]. Just what we need.
	 */

	list = assoc_list(func_table, "@unsorted", ASORTI);

	for (i = 0; i < max; i += 2) {
		f = list[i+1];
		if (f->type == Node_builtin_func || f->param_cnt == 0)
			continue;

		/* loop over each param in function i */
		for (j = 0; j < f->param_cnt; j++) {
			/* compare to function names */

			/* use a fake node to avoid malloc/free of make_string */
			n.stptr = f->fparms[j].param;
			n.stlen = strlen(f->fparms[j].param);

			if (in_array(func_table, & n)) {
				error(
			_("function `%s': cannot use function `%s' as a parameter name"),
					list[i]->stptr,
					f->fparms[j].param);
				result = false;
			}
		}
	}

	efree(list);
	return result;
}

static INSTRUCTION_POOL *pools;

/*
 * For best performance, the INSTR_CHUNK value should be divisible by all
 * possible sizes, i.e. 1 through MAX_INSTRUCTION_ALLOC. Otherwise, there
 * will be wasted space at the end of the block.
 */
#define INSTR_CHUNK (2*3*21)

struct instruction_block {
	struct instruction_block *next;
	INSTRUCTION i[INSTR_CHUNK];
};

/* bcfree --- deallocate instruction */

void
bcfree(INSTRUCTION *cp)
{
	assert(cp->pool_size >= 1 && cp->pool_size <= MAX_INSTRUCTION_ALLOC);

	cp->opcode = Op_illegal;
	cp->nexti = pools->pool[cp->pool_size - 1].free_list;
	pools->pool[cp->pool_size - 1].free_list = cp;
}

/* bcalloc --- allocate a new instruction */

INSTRUCTION *
bcalloc(OPCODE op, int size, int srcline)
{
	INSTRUCTION *cp;
	struct instruction_mem_pool *pool;

	assert(size >= 1 && size <= MAX_INSTRUCTION_ALLOC);
	pool = &pools->pool[size - 1];

	if (pool->free_list != NULL) {
		cp = pool->free_list;
		pool->free_list = cp->nexti;
	} else if (pool->free_space && pool->free_space + size <= & pool->block_list->i[INSTR_CHUNK]) {
		cp = pool->free_space;
		pool->free_space += size;
	} else {
		struct instruction_block *block;
		emalloc(block, struct instruction_block *, sizeof(struct instruction_block));
		block->next = pool->block_list;
		pool->block_list = block;
		cp = &block->i[0];
		pool->free_space = &block->i[size];
	}

	memset(cp, 0, size * sizeof(INSTRUCTION));
	cp->pool_size = size;
	cp->opcode = op;
	cp->source_line = srcline;
	return cp;
}

/* new_context --- create a new execution context. */

AWK_CONTEXT *
new_context()
{
	AWK_CONTEXT *ctxt;

	ezalloc(ctxt, AWK_CONTEXT *, sizeof(AWK_CONTEXT));
	ctxt->srcfiles.next = ctxt->srcfiles.prev = & ctxt->srcfiles;
	ctxt->rule_list.opcode = Op_list;
	ctxt->rule_list.lasti = & ctxt->rule_list;
	return ctxt;
}

/* set_context --- change current execution context. */

static void
set_context(AWK_CONTEXT *ctxt)
{
	pools = & ctxt->pools;
	symbol_list = & ctxt->symbols;
	srcfiles = & ctxt->srcfiles;
	rule_list = & ctxt->rule_list;
	install_func = ctxt->install_func;
	curr_ctxt = ctxt;
}

/*
 * push_context:
 *
 * Switch to the given context after saving the current one. The set
 * of active execution contexts forms a stack; the global or main context
 * is at the bottom of the stack.
 */

void
push_context(AWK_CONTEXT *ctxt)
{
	ctxt->prev = curr_ctxt;
	/* save current source and sourceline */
	if (curr_ctxt != NULL) {
		curr_ctxt->sourceline = sourceline;
		curr_ctxt->source = source;
	}
	sourceline = 0;
	source = NULL;
	set_context(ctxt);
	ctxt_level++;
}

/* pop_context --- switch to previous execution context. */

void
pop_context()
{
	AWK_CONTEXT *ctxt;

	assert(curr_ctxt != NULL);
	if (curr_ctxt->prev == NULL)
		fatal(_("cannot pop main context"));
	ctxt = curr_ctxt->prev;
	/* restore source and sourceline */
	sourceline = ctxt->sourceline;
	source = ctxt->source;
	set_context(ctxt);
	ctxt_level--;
}

/* in_main_context --- are we in the main context ? */

int
in_main_context()
{
	assert(ctxt_level > 0);
	return (ctxt_level == 1);
}

/* free_context --- free context structure and related data. */

void
free_context(AWK_CONTEXT *ctxt, bool keep_globals)
{
	SRCFILE *s, *sn;

	if (ctxt == NULL)
		return;

	assert(curr_ctxt != ctxt);

 	/* free all code including function codes */

	free_bcpool(& ctxt->pools);

	/* free symbols */

	release_symbols(& ctxt->symbols, keep_globals);

	/* free srcfiles */

	for (s = & ctxt->srcfiles; s != & ctxt->srcfiles; s = sn) {
		sn = s->next;
		if (s->stype != SRC_CMDLINE && s->stype != SRC_STDIN)
			efree(s->fullpath);
		efree(s->src);
		efree(s);
	}

	efree(ctxt);
}

/* free_bc_internal --- free internal memory of an instruction. */

static void
free_bc_internal(INSTRUCTION *cp)
{
	NODE *m;

	switch(cp->opcode) {
	case Op_func_call:
		if (cp->func_name != NULL)
			efree(cp->func_name);
		break;
	case Op_push_re:
	case Op_match_rec:
	case Op_match:
	case Op_nomatch:
		m = cp->memory;
		if (m->re_reg[0] != NULL)
			refree(m->re_reg[0]);
		if (m->re_reg[1] != NULL)
			refree(m->re_reg[1]);
		if (m->re_exp != NULL)
			unref(m->re_exp);
		if (m->re_text != NULL)
			unref(m->re_text);
		freenode(m);
		break;
	case Op_token:
		/* token lost during error recovery in yyparse */
		if (cp->lextok != NULL)
			efree(cp->lextok);
		break;
	case Op_push_i:
		m = cp->memory;
		unref(m);
		break;
	case Op_store_var:
		m = cp->initval;
		if (m != NULL)
			unref(m);
		break;
	case Op_illegal:
		cant_happen("unexpected opcode %s", opcode2str(cp->opcode));
	default:
		break;
	}
}

/* free_bc_mempool --- free a single pool */

static void
free_bc_mempool(struct instruction_mem_pool *pool, int size)
{
	bool first = true;
	struct instruction_block *block, *next;

	for (block = pool->block_list; block; block = next) {
		INSTRUCTION *cp, *end;

		end = (first ? pool->free_space : & block->i[INSTR_CHUNK]);
		for (cp = & block->i[0]; cp + size <= end; cp += size) {
			if (cp->opcode != Op_illegal)
				free_bc_internal(cp);
		}
		next = block->next;
		efree(block);
		first = false;
	}
}


/* free_bcpool --- free list of instruction memory pools */

static void
free_bcpool(INSTRUCTION_POOL *pl)
{
	int i;

	for (i = 0; i < MAX_INSTRUCTION_ALLOC; i++)
		free_bc_mempool(& pl->pool[i], i + 1);
}

/* is_all_upper --- return true if name is all uppercase letters */

/*
 * DON'T use isupper(), it's locale aware!
 */

bool
is_all_upper(const char *name)
{
	for (; *name != '\0'; name++) {
		switch (*name) {
		case 'A': case 'B': case 'C': case 'D': case 'E':
		case 'F': case 'G': case 'H': case 'I': case 'J':
		case 'K': case 'L': case 'M': case 'N': case 'O':
		case 'P': case 'Q': case 'R': case 'S': case 'T':
		case 'U': case 'V': case 'W': case 'X': case 'Y':
		case 'Z':
			break;
		default:
			return false;
		}
	}

	return true;
}

/* get_name_from_awk_ns --- get the name after awk:: or the full name */

static NODE *
get_name_from_awk_ns(const char *name)
{
	NODE *tmp;

	if (strncmp(name, "awk::", 5) == 0)
		tmp = make_string(name + 5, strlen(name) - 5);
	else
		tmp = make_string(name, strlen(name));

	return tmp;
}
/*
 * debug.c - gawk debugger
 */

/*
 * Copyright (C) 2004, 2010-2013, 2016-2025 the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"
#include "cmd.h"

#ifndef O_RDONLY
#include <fcntl.h>	/* open() */
#endif

#ifdef __MINGW32__
#define execvp(p,a) w32_execvp(p,a)
int w32_execvp(const char *, char **);
#endif

extern bool exiting;
extern SRCFILE *srcfiles;
extern INSTRUCTION *rule_list;
extern INSTRUCTION *code_block;
extern NODE **fcall_list;
extern long fcall_count;
extern FILE *output_fp;
extern IOBUF *curfile;
extern const char *command_file;
extern const char *get_spec_varname(Func_ptr fptr);
extern int zzparse(void);
#define read_command()		(void) zzparse()

extern const char *redir2str(int redirtype);

static char *linebuf = NULL;	/* used to print a single line of source */
static size_t linebuf_len;

FILE *out_fp;
const char *dbg_prompt;
const char *commands_prompt = "> ";	/* breakpoint or watchpoint commands list */
const char *eval_prompt = "@> ";	/* awk statement(s) */

bool input_from_tty = false;
int input_fd;

static SRCFILE *cur_srcfile;
static long cur_frame = 0;
static INSTRUCTION *cur_pc;
static int cur_rule = 0;

static bool prog_running = false;

struct condition {
	INSTRUCTION *code;
	AWK_CONTEXT *ctxt;
	char *expr;
};

struct commands_item {
	struct commands_item *next;
	struct commands_item *prev;
	int cmd;
	char *cmd_string;
	CMDARG *arg;
};

/* breakpoint structure */
typedef struct break_point {
	struct break_point *next;
	struct break_point *prev;
	int number;

	long ignore_count;
	long hit_count;
	char *src;
	INSTRUCTION *bpi;	/* Op_breakpoint */

	struct commands_item commands;  /* list of commands to run */
	bool silent;

	struct condition cndn;

	short flags;
#define BP_ENABLE       1
#define BP_ENABLE_ONCE  2		/* enable once */
#define BP_TEMP         4
#define BP_IGNORE       8

} BREAKPOINT;

static BREAKPOINT breakpoints = { &breakpoints, &breakpoints, 0 };

#ifdef HAVE_LIBREADLINE
/* do_save -- save command */
static int sess_history_base = 0;
#endif

#ifndef HAVE_HISTORY_LIST
#define HIST_ENTRY void
#define history_list()	NULL
#endif


/* 'list' command */
static int last_printed_line = 0;
static int last_print_count;	/* # of lines printed */

/* watch or display item */
struct list_item {
	struct list_item *next;
	struct list_item *prev;
	int number;     /* item number */

	NODE *symbol;   /* variable or function param */
	NODE **subs;    /* subscripts */
	int num_subs;	/* subscript(dimension) count */
	char *sname;	/* symbol or param name */

	long fcall_count;

	struct commands_item commands;
	int silent;
	struct condition cndn;

	/* This is for the value of the watched item */
	union {
		NODE *n;
		long l;
	} value[2];
#define cur_value value[0].n
#define cur_size  value[0].l
#define old_value value[1].n
#define old_size  value[1].l

	int flags;
#define PARAM           1
#define SUBSCRIPT       2
#define FIELD_NUM       4
#define OLD_IS_ARRAY    8    /* old item is array */
#define CUR_IS_ARRAY    16   /* current item is array */
};

#define IS_PARAM(d)	(((d)->flags & PARAM) != 0)
#define IS_SUBSCRIPT(d)	(((d)->flags & SUBSCRIPT) != 0)
#define IS_FIELD(d)	(((d)->flags & FIELD_NUM) != 0)
#define WATCHING_ARRAY(d)	(((d)->flags & CUR_IS_ARRAY) != 0)

static struct list_item display_list = { &display_list, &display_list, 0 };
static struct list_item watch_list = { &watch_list, &watch_list, 0 };


/* Structure to maintain data for processing debugger commands */

static struct {
	long fcall_count;    /* 'finish', 'until', 'next', 'step', 'nexti' commands */
	int sourceline;      /* source line number last
	                      * time we stopped execution,
	                      * used by next, until and step commands
	                      */
	char *source;        /* next, until and step */

	INSTRUCTION *pc;     /* 'until' and 'return' commands */
	int repeat_count;    /* 'step', 'next', 'stepi', 'nexti' commands */
	bool print_frame;    /* print frame info,  'finish' and 'until' */
	bool print_ret;      /* print returned value, 'finish' */
	int break_point;     /* non-zero (breakpoint number) if stopped at break point */
	int watch_point;     /* non-zero (watchpoint number) if stopped at watch point */

	int (*check_func)(INSTRUCTION **);      /* function to decide when to suspend
	                                         * awk interpreter and return control
	                                         * to debugger command interpreter.
	                                         */

	enum argtype command;		 /* command type */
} stop;


/* restart related stuff */
extern char **d_argv;	/* copy of argv array */
static bool need_restart = false;
enum { BREAK=1, WATCH, DISPLAY, HISTORY, OPTION };
static const char *const env_variable[] = {
	"",
	"DGAWK_BREAK",
	"DGAWK_WATCH",
	"DGAWK_DISPLAY",
	"DGAWK_HISTORY",
	"DGAWK_OPTION",
};
static void serialize_list(int type);
static void unserialize_list(int type);
static const char *commands_string = NULL;
static int commands_string_len = 0;
static char line_sep;
#define FSEP	(char)'\037'
#define RSEP	(char)'\036'
#define CSEP	(char)'\035'


/* debugger option */
struct dbg_option {
	const char *name;
	int *num_val;
	const char **str_val;
	void (*assign)(const char *);
	const char *help_txt;
};

#define DEFAULT_HISTFILE	"./.gawk_history"
#define DEFAULT_OPTFILE		"./.gawkrc"
#define DEFAULT_PROMPT		"gawk> "
#define DEFAULT_LISTSIZE	15
#define DEFAULT_HISTSIZE	100

static void set_gawk_output(const char *file);
static void set_prompt(const char *value);
static void set_listsize(const char *value);
static void set_trace(const char *value);
static void set_save_history(const char *value);
static void set_save_options(const char *value);
static void set_history_size(const char *value);
static const char *options_file = DEFAULT_OPTFILE;
#ifdef HAVE_LIBREADLINE
static const char *history_file = DEFAULT_HISTFILE;
#endif

/* debugger option related variables */

static const char *output_file = "/dev/stdout";  /* gawk output redirection */
const char *dgawk_prompt = NULL;                 /* initialized in interpret */
static int list_size = DEFAULT_LISTSIZE;   /* # of lines that 'list' prints */
static int do_trace = false;
static int do_save_history = true;
static int do_save_options = true;
static int history_size = DEFAULT_HISTSIZE;  /* max # of lines in history file */

static const struct dbg_option option_list[] = {
{"history_size", &history_size, NULL, &set_history_size,
	gettext_noop("set or show the number of lines to keep in history file") },
{"listsize", &list_size, NULL, &set_listsize,
	gettext_noop("set or show the list command window size") },
{"outfile", NULL, &output_file, &set_gawk_output,
	gettext_noop("set or show gawk output file") },
{"prompt", NULL, &dgawk_prompt, &set_prompt,
	gettext_noop("set or show debugger prompt"), },
{"save_history", &do_save_history, NULL, &set_save_history,
	gettext_noop("(un)set or show saving of command history (value=on|off)") },
{"save_options", &do_save_options, NULL, &set_save_options,
	gettext_noop("(un)set or show saving of options (value=on|off)") },
{"trace", &do_trace, NULL, &set_trace,
	gettext_noop("(un)set or show instruction tracing (value=on|off)") },
{0, NULL, NULL, NULL, 0},
};

static void save_options(const char *file);


/* pager */
jmp_buf pager_quit_tag;
int pager_quit_tag_valid = 0;
static int screen_width = INT_MAX;	/* no of columns */
static int screen_height = INT_MAX;	/* no of rows */
static int pager_lines_printed = 0;	/* no of lines printed so far */

static void restart(bool run) ATTRIBUTE_NORETURN;
static void close_all(void);
static int open_readfd(const char *file);
static int find_lines(SRCFILE *s);
static SRCFILE *source_find(char *src);
static int print_lines(char *src, int start_line, int nlines);
static void print_symbol(NODE *r, bool isparam);
static NODE *find_frame(long num);
static NODE *find_param(const char *name, long num, char **pname);
static NODE *find_symbol(const char *name, char **pname);
static NODE *find_array(const char *name);
static void print_field(long field_num);
static int print_function(INSTRUCTION *pc, void *);
static void print_frame(NODE *func, char *src, int srcline);
static void print_numbered_frame(long num);
static void print_cur_frame_and_sourceline(void);
static INSTRUCTION *find_rule(char *src, long lineno);
static INSTRUCTION *mk_breakpoint(char *src, int srcline);
static int execute_commands(struct commands_item *commands);
static void delete_commands_item(struct commands_item *c);
static NODE *execute_code(volatile INSTRUCTION *code);
static int pre_execute_code(INSTRUCTION **pi);
static int parse_condition(int type, int num, char *expr);
static BREAKPOINT *add_breakpoint(INSTRUCTION *prevp, INSTRUCTION *ip, char *src, bool silent);
static BREAKPOINT *set_breakpoint_next(INSTRUCTION *rp, INSTRUCTION *ip);
static BREAKPOINT *set_breakpoint_at(INSTRUCTION *rp, int lineno, bool silent);
static void delete_breakpoint(BREAKPOINT *b);
static BREAKPOINT *find_breakpoint(long num);
static void display(struct list_item *d);
static struct list_item *find_item(struct list_item *list, long num);
static struct list_item *add_item(struct list_item *list, int type, NODE *symbol, char *pname);
static void delete_item(struct list_item *d);
static int breakpoint_triggered(BREAKPOINT *b);
static int watchpoint_triggered(struct list_item *w);
static void print_instruction(INSTRUCTION *pc, Func_print print_func, FILE *fp, int in_dump);
static void print_ns_list(INSTRUCTION *pc, Func_print print_func, FILE *fp, int in_dump);
static int print_code(INSTRUCTION *pc, void *x);
static void next_command();
static void debug_post_execute(INSTRUCTION *pc);
static int debug_pre_execute(INSTRUCTION **pi);
static char *g_readline(const char *prompt);
static int prompt_yes_no(const char *, char , int , FILE *);
static struct pf_data {
	Func_print print_func;
	bool defn;
	FILE *fp;
} pf_data;

char * (*read_a_line)(const char *) = 0;	/* reads a line of input */

struct command_source
{
	int fd;
	int is_tty;
	char * (*read_func)(const char *);
	int (*close_func)(int);
	int eof_status;		/* see push_cmd_src */
	int cmd;		/* D_source or 0 */
	char *str;		/* sourced file */
	struct command_source *next;
};

static struct command_source *cmd_src = NULL;

#define PUSH_BINDING(stack, tag, val)	\
if (val++) \
	memcpy((char *) (stack), (const char *) tag, sizeof(jmp_buf))
#define POP_BINDING(stack, tag, val)	\
if (--val) \
	memcpy((char *) tag, (const char *) (stack), sizeof(jmp_buf))


#define CHECK_PROG_RUNNING() \
	do { \
		if (! prog_running) { \
			d_error(_("program not running")); \
			return false; \
		} \
	} while (false)

// On z/OS, one needs to use %#p to get the leading 0x in the output.
// Having that makes it consistent with Linux and makes the use of
// helper scripts easier.
#ifdef USE_EBCDIC
#define PTRFMT	"%#p"
#else
#define PTRFMT	"%p"
#endif


/* g_readline --  read a line of text; the interface is like 'readline' but
 *		without	any command-line editing; used when not compiled with
 *		readline support and/or input is not from terminal (prompt set to NULL).
 */

static char *
g_readline(const char *prompt)
{
	char *line;
	size_t line_size = 100;
	static char buf[2];
	char *p, *end;
	int n;

	if (input_from_tty && prompt && *prompt)
		fprintf(out_fp, "%s", prompt);

	emalloc(line, char *, line_size + 1);
	p = line;
	end = line + line_size;
	while ((n = read(input_fd, buf, 1)) > 0) {
		if (buf[0] == '\n') {
			if (p > line && p[-1] == '\r')
				p--;
			break;
		}
		if (p == end) {
			erealloc(line, char *, 2 * line_size + 1);
			p = line + line_size;
			line_size *= 2;
			end = line + line_size;
		}
		*p++ = buf[0];
	}
	if (n == -1 || (n == 0 && p == line)) {
		efree(line);
		return NULL;
	}
	*p = '\0';
	return line;
}


/* d_error --- print an error message */

void
d_error(const char *mesg, ...)
{
	va_list args;
	va_start(args, mesg);
	fprintf(out_fp, _("error: "));
	vfprintf(out_fp, mesg, args);
	fprintf(out_fp, "\n");
	va_end(args);
}

/* find_lines --- find the positions of the lines in the source file. */

static int
find_lines(SRCFILE *s)
{
	char *buf, *p, *end;
	int n;
	int ofs = 0;
	int *pos;
	int pos_size;
	int maxlen = 0;
	int numlines = 0;
	char lastchar = '\0';

	emalloc(buf, char *, s->bufsize);
	pos_size = s->srclines;
	emalloc(s->line_offset, int *, (pos_size + 2) * sizeof(int));
	pos = s->line_offset;
	pos[0] = 0;

	while ((n = read(s->fd, buf, s->bufsize)) > 0) {
		end = buf + n;
		lastchar = buf[n - 1];
		p = buf;
		while (p < end) {
			if (*p++ == '\n') {
				if (++numlines > pos_size) {
					erealloc(s->line_offset, int *, (2 * pos_size + 2) * sizeof(int));
					pos = s->line_offset + pos_size;
					pos_size *= 2;
				}
				*++pos = ofs + (p - buf);
				if ((pos[0] - pos[-1]) > maxlen)
					maxlen = pos[0] - pos[-1];	/* length including NEWLINE */
			}
		}
		ofs += n;
	}
	efree(buf);

	if (n == -1) {
		d_error(_("cannot read source file `%s': %s"),
					s->src, strerror(errno));
		return -1;
	}
	if (ofs <= 0) {
		fprintf(out_fp, _("source file `%s' is empty.\n"), s->src);
		return -1;
	}

	if (lastchar != '\n') {
		/* fake a NEWLINE at end */
		*++pos = ofs + 1;
		numlines++;
		if ((pos[0] - pos[-1]) > maxlen)
			maxlen = pos[0] - pos[-1];
	}
	s->maxlen = maxlen;
	s->srclines = numlines;
	return 0;
}

/* source_find --- return the SRCFILE struct for the source 'src' */

static SRCFILE *
source_find(char *src)
{
	SRCFILE *s;
	struct stat sbuf;
	char *path;
	int errno_val = 0;

	if (src == NULL || *src == '\0') {
		d_error(_("no current source file"));
		return NULL;
	}

	if (cur_srcfile->src == src)  /* strcmp(cur_srcfile->src, src) == 0 */
		return cur_srcfile;

	for (s = srcfiles->next; s != srcfiles; s = s->next) {
		if ((s->stype == SRC_FILE || s->stype == SRC_INC)
				&& strcmp(s->src, src) == 0)
			return s;
	}

	path = find_source(src, & sbuf, & errno_val, false);
	if (path != NULL) {
		for (s = srcfiles->next; s != srcfiles; s = s->next) {
			if ((s->stype == SRC_FILE || s->stype == SRC_INC)
			    		&& files_are_same(path, s)) {
				efree(path);
				return s;
			}
		}
		efree(path);
	}

	d_error(_("cannot find source file named `%s': %s"), src, strerror(errno_val));
	return NULL;
}

/* print_lines --- print source lines, and update 'cur_srcfile' */

static int
print_lines(char *src, int start_line, int nlines)
{
	SRCFILE *s;
	int *pos;
	int i;
	struct stat sbuf;

	s = source_find(src);
	if (s == NULL)
		return -1;
	if (s->fd <= INVALID_HANDLE && (s->fd = srcopen(s)) <= INVALID_HANDLE) {
		d_error(_("cannot open source file `%s' for reading: %s"),
				src, strerror(errno));
		return -1;
	}

	if (fstat(s->fd, &sbuf) == 0 && s->mtime < sbuf.st_mtime) {
		fprintf(out_fp, _("warning: source file `%s' modified since program compilation.\n"),
				src);
		efree(s->line_offset);
		s->line_offset = NULL;
		s->mtime = sbuf.st_mtime;

		/* reopen source file */
		close(s->fd);
		s->fd = INVALID_HANDLE;
		if ((s->fd = srcopen(s)) <= INVALID_HANDLE) {
			d_error(_("cannot open source file `%s' for reading: %s"),
					src, strerror(errno));
			return -1;
		}
	}

	/* set binary mode so that byte offset calculations will be right */
	os_setbinmode(s->fd, O_BINARY);

	if (s->line_offset == NULL && find_lines(s) != 0)
		return -1;
  	if (start_line < 1 || start_line > s->srclines) {
		d_error(_("line number %d out of range; `%s' has %d lines"),
					start_line, src, s->srclines);
		return -1;
	}

	assert(nlines > 0);
	if ((start_line + nlines - 1) > s->srclines)
		nlines = s->srclines - start_line + 1;

	pos = s->line_offset;
	if (lseek(s->fd, (off_t) pos[start_line - 1], SEEK_SET) < 0) {
		d_error("%s: %s", src, strerror(errno));
		return -1;
	}

	if (linebuf == NULL) {
		emalloc(linebuf, char *, s->maxlen + 20); /* 19 for line # */
		linebuf_len = s->maxlen;
	} else if (linebuf_len < s->maxlen) {
		erealloc(linebuf, char *, s->maxlen + 20);
		linebuf_len = s->maxlen;
	}

	for (i = start_line; i < start_line + nlines; i++) {
		int supposed_len, len;
		char *p;

		sprintf(linebuf, "%-8d", i);

		/* mark the line about to be executed with =>; nlines > 1
	 	 * condition makes sure that we are in list command
		 */
		if (nlines > 1) {
			BREAKPOINT *b;
			bool has_bpt = false;
			for (b = breakpoints.prev; b != &breakpoints; b = b->prev) {
				if (src == b->src && i == b->bpi->source_line) {
					has_bpt = true;
					break;
				}
			}
			if (prog_running && src == source && i == sourceline) {
				if (has_bpt)
					sprintf(linebuf, "%-4d:b=>", i);
				else
					sprintf(linebuf, "%-4d  =>", i);
			} else if (has_bpt)
				sprintf(linebuf, "%-4d:b  ", i);
		}

		p = linebuf + strlen(linebuf);
		supposed_len = pos[i] - pos[i - 1];
		len = read(s->fd, p, supposed_len);
		switch (len) {
		case -1:
			d_error(_("cannot read source file `%s': %s"),
						src, strerror(errno));
			return -1;

		case 0:
			d_error(_("unexpected eof while reading file `%s', line %d"),
						src, i);
			return -1;

		default:
			if (i == s->srclines && p[len - 1] != '\n')
				p[len++] = '\n';
#if 0
			if (len != supposed_len || p[len - 1] != '\n') {
				d_error(_("source file `%s' modified since start of program execution"),
						src);
				return -1;
			}
#endif
			len += (p - linebuf);
			if (fwrite(linebuf, sizeof(char), len, out_fp) != len)
				return -1;
		}
	}

	if (cur_srcfile != s) {
		if (cur_srcfile->fd != INVALID_HANDLE) {
			close(cur_srcfile->fd);
			cur_srcfile->fd = INVALID_HANDLE;
		}
		cur_srcfile = s;
	}
	return (i - 1);		/* no of lines printed */
}

/* do_list --- list command */

int
do_list(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	long line_first, line_last;
	long count = list_size;
	INSTRUCTION *rp;
	char *src = cur_srcfile->src;

	line_first = last_printed_line + 1;		/* default or no arg */
	if (arg == NULL)	/* list or list + */
		goto list;

	switch (arg->type) {
	case D_int:		/* list n or list - */
		if (arg->a_int < 0) {		/* list - */
			line_first = last_printed_line - last_print_count - list_size + 1;
			if (line_first < 1) {
				if (last_printed_line != last_print_count)
					line_first = 1;
				else
					return false;
			}
		} else {
line:
			line_first = arg->a_int - list_size / 2;
			if (line_first < 1)
				line_first = 1;
		}
		break;

	case D_range:	/* list m-n */
range:
		line_first = arg->a_int;
		arg = arg->next;
		assert(arg != NULL);
		assert(arg->type == D_int);
		count = arg->a_int - line_first + 1;
		break;

	case D_string:
		src = arg->a_string;
		if (arg->next != NULL) {
			arg = arg->next;
			if (arg->type == D_int)	/* list file:n */
				goto line;
			else if (arg->type == D_range)	/* list file:m-n */
				goto range;
			else if (arg->type == D_func)	/* list file:function */
				goto func;
			else
				line_first = 1;
		} else
			line_first = 1;
		break;

	case D_func:	/* list function */
func:
		rp = arg->a_node->code_ptr;
		src = rp->source_file;
		line_first = rp->source_line - list_size / 2;
		if (line_first < 1)
			line_first = 1;
		break;

	default:
		break;
 	}

list:
	line_last = print_lines(src, line_first, count);
	if (line_last != -1) {
		last_printed_line = line_last;
		last_print_count = line_last - line_first + 1;
	}
	return false;
}

/* do_info --- info command */

int
do_info(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	NODE **table;

	if (arg == NULL || arg->type != D_argument)
		return false;

	switch (arg->a_argument) {
	case A_SOURCE:
		fprintf(out_fp, _("Current source file: %s\n"), cur_srcfile->src);
		fprintf(out_fp, _("Number of lines: %d\n"), cur_srcfile->srclines);
		break;

	case A_SOURCES:
	{
		SRCFILE *s;
		for (s = srcfiles->next; s != srcfiles; s = s->next) {
			fprintf(out_fp, _("Source file (lines): %s (%d)\n"),
					(s->stype == SRC_FILE || s->stype == SRC_INC) ? s->src
			 		                                      : "cmd. line",
					s->srclines);
		}
	}
		break;

	case A_BREAK:
		initialize_pager(out_fp);
		if (setjmp(pager_quit_tag) == 0) {
			BREAKPOINT *b;
			struct commands_item *c;

			gprintf(out_fp, _("Number  Disp  Enabled  Location\n\n"));
			for (b = breakpoints.prev; b != &breakpoints; b = b->prev) {
				const char *disp = "keep";
				if ((b->flags & BP_ENABLE_ONCE) != 0)
					disp = "dis";
				else if ((b->flags & BP_TEMP) != 0)
					disp = "del";
				gprintf(out_fp, "%-6d  %-4.4s  %-7.7s  file %s, line #%d\n",
						b->number, disp, (b->flags & BP_ENABLE) != 0 ? "yes" : "no",
					 	b->src,	b->bpi->source_line);
				if (b->hit_count > 0)
					gprintf(out_fp, _("\tnumber of hits = %ld\n"), b->hit_count);
				if ((b->flags & BP_IGNORE) != 0)
					gprintf(out_fp, _("\tignore next %ld hit(s)\n"), b->ignore_count);
				if (b->cndn.code != NULL)
					gprintf(out_fp, _("\tstop condition: %s\n"), b->cndn.expr);
				if (b->commands.next != &b->commands)
					gprintf(out_fp, _("\tcommands:\n"));
				for (c = b->commands.next; c != &b->commands; c = c->next) {
					gprintf(out_fp, "\t%s\n", c->cmd_string);
					if (c->cmd == D_eval) {
						char *start, *end;
						CMDARG *a = c->arg;
						start = strchr(a->a_string, '{');
						end = strrchr(a->a_string, '}');
						if (start == NULL || end == NULL)
							continue;
						start++;
						*end = '\0';
						gprintf(out_fp, "%s", start);	/* FIXME: translate ? */
						*end = '}';
					}
				}
			}
		}
		break;

	case A_FRAME:
		CHECK_PROG_RUNNING();
		fprintf(out_fp, _("Current frame: "));
		print_numbered_frame(cur_frame);
		if (cur_frame < fcall_count) {
			fprintf(out_fp, _("Called by frame: "));
			print_numbered_frame(cur_frame + 1);
		}
		if (cur_frame > 0) {
			fprintf(out_fp, _("Caller of frame: "));
			print_numbered_frame(cur_frame - 1);
		}
		break;

	case A_ARGS:
	case A_LOCALS:
	{
		NODE *f, *func;
		INSTRUCTION *pc;
		int arg_count, pcount;
		int i, from, to;

		CHECK_PROG_RUNNING();
		f = find_frame(cur_frame);
		func = f->func_node;
		if (func == NULL) {
			/* print ARGV ? */
			fprintf(out_fp, _("None in main().\n"));
			return false;
		}

		pcount = func->param_cnt;              /* # of defined params */

		pc = (INSTRUCTION *) f->reti;          /* Op_func_call instruction */
		arg_count = (pc + 1)->expr_count;      /* # of arguments supplied */

		if (arg_count > pcount)                /* extra args */
			arg_count = pcount;
		if (arg->a_argument == A_ARGS) {
			from = 0;
			to = arg_count - 1;
		} else {
			from = arg_count;
			to = pcount - 1;
		}

		for (i = from; i <= to; i++) {
			NODE *r;
			r = f->stack[i];
			if (r->type == Node_array_ref)
				r = r->orig_array;
			fprintf(out_fp, "%s = ", func->fparms[i].param);
			print_symbol(r, true);
		}
		if (to < from)
			fprintf(out_fp, "%s",
				arg->a_argument == A_ARGS ?
					_("No arguments.\n") :
					_("No locals.\n"));
	}
		break;

	case A_VARIABLES:
		table = variable_list();
		initialize_pager(out_fp);
		if (setjmp(pager_quit_tag) == 0) {
			gprintf(out_fp, _("All defined variables:\n\n"));
			print_vars(table, gprintf, out_fp);
		}
		efree(table);
		break;

	case A_FUNCTIONS:
		table = function_list(true);
		initialize_pager(out_fp);
		if (setjmp(pager_quit_tag) == 0) {
			gprintf(out_fp, _("All defined functions:\n\n"));
			pf_data.print_func = gprintf;
			pf_data.fp = out_fp;
			pf_data.defn = true;
			(void) foreach_func(table,
			            (int (*)(INSTRUCTION *, void *)) print_function,
			            &pf_data);
		}
		efree(table);
		break;

	case A_DISPLAY:
	case A_WATCH:
		initialize_pager(out_fp);
		if (setjmp(pager_quit_tag) == 0) {
			struct list_item *d, *list;

			if (arg->a_argument == A_DISPLAY) {
				list = &display_list;
				gprintf(out_fp, _("Auto-display variables:\n\n"));
			} else {
				list = &watch_list;
				gprintf(out_fp, _("Watch variables:\n\n"));
			}
			for (d = list->prev; d != list; d = d->prev) {
				int i;
				struct commands_item *c;
				NODE *symbol = d->symbol;

				if (IS_SUBSCRIPT(d)) {
					gprintf(out_fp, "%d:\t%s",  d->number, d->sname);
					for (i = 0; i < d->num_subs; i++) {
						NODE *sub;
						sub = d->subs[i];
						gprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);
					}
					gprintf(out_fp, "\n");
				} else if (IS_FIELD(d))
					gprintf(out_fp, "%d:\t$%ld\n", d->number, get_number_si(symbol));
				else
					gprintf(out_fp, "%d:\t%s\n", d->number, d->sname);
				if (d->cndn.code != NULL)
					gprintf(out_fp, _("\tstop condition: %s\n"), d->cndn.expr);
				if (d->commands.next != &d->commands)
					gprintf(out_fp, _("\tcommands:\n"));
				for (c = d->commands.next; c != &d->commands; c = c->next) {
					gprintf(out_fp, "\t%s\n", c->cmd_string);
					if (c->cmd == D_eval) {
						char *start, *end;
						CMDARG *a = c->arg;
						start = strchr(a->a_string, '{');
						end = strrchr(a->a_string, '}');
						if (start == NULL || end == NULL)
							continue;
						start++;
						*end = '\0';
						gprintf(out_fp, "%s", start);	/* FIXME: translate ? */
						*end = '}';
					}
				}

			}
		}
		break;

	default:
		break;
	}

	return false;
}

/* print_symbol --- print a symbol table entry */

static void
print_symbol(NODE *r, bool isparam)
{
	switch (r->type) {
	case Node_var_new:
		fprintf(out_fp, "untyped variable\n");
		break;
	case Node_elem_new:
		fprintf(out_fp, "untyped element\n");
		break;
	case Node_var:
		if (! isparam && r->var_update)
			r->var_update();
		valinfo(r->var_value, fprintf, out_fp);
		break;
	case Node_var_array:
		fprintf(out_fp, "array, %ld elements\n", (long) assoc_length(r));
		break;
	case Node_func:
		fprintf(out_fp, "`function'\n");
		break;
	default:
		break;
	}
}

/* find_frame --- find frame given a frame number */

static NODE *
find_frame(long num)
{
	assert(num >= 0);
	if (num == 0)
		return frame_ptr;

	assert(prog_running == true);
	assert(num <= fcall_count);
	assert(fcall_list[num] != NULL);
	return fcall_list[num];
}

/* find_param --- find a function parameter in a given frame number */

static NODE *
find_param(const char *name, long num, char **pname)
{
	NODE *r = NULL;
	NODE *f;
	char *fparam;

	if (pname)
		*pname = NULL;

	if (num < 0 || num > fcall_count || name == NULL)
		return NULL;
	f = find_frame(num);
	if (f->func_node != NULL) {		/* in function */
		NODE *func;
		int i, pcount;

		func = f->func_node;
		pcount = func->param_cnt;
		for (i = 0; i < pcount; i++) {
			fparam = func->fparms[i].param;
			if (strcmp(name, fparam) == 0) {
				r = f->stack[i];
				if (r->type == Node_array_ref)
					r = r->orig_array;
				if (pname)
					*pname = fparam;
				break;
			}
		}
	}
	return r;
}

/* find_symbol --- find a symbol in current context */

static
NODE *find_symbol(const char *name, char **pname)
{
	NODE *r = NULL;

	if (pname)
		*pname = NULL;
	if (prog_running)
		r = find_param(name, cur_frame, pname);
	if (r == NULL)
		r = lookup(name); // for now, require fully qualified name
	if (r == NULL)
		fprintf(out_fp, _("no symbol `%s' in current context\n"), name);
	return r;
}

/* find_array -- find an array in current context */

static NODE *
find_array(const char *name)
{
	NODE *r;
	r = find_symbol(name, NULL);
	if (r != NULL && r->type != Node_var_array) {
		fprintf(out_fp, _("`%s' is not an array\n"), name);
		return NULL;
	}
	return r;
}

/* print_field --- print the value of $n */

static void
print_field(long field_num)
{
	NODE **lhs;
	lhs = get_field(field_num, NULL);
	if (*lhs == Null_field || *lhs == Nnull_string)
		fprintf(out_fp, _("$%ld = uninitialized field\n"), field_num);
	else {
		fprintf(out_fp, "$%ld = ", field_num);
		valinfo(*lhs, fprintf, out_fp);
	}
}

/* print_array_names --- print the stack of array names */

static void
print_array_names(const char **names, size_t num_names, FILE *out_fp)
{
	size_t i;

	gprintf(out_fp, "%s", names[0]);
	for (i = 1; i < num_names; i++)
		gprintf(out_fp, "[\"%s\"]", names[i]);
}

/* print_array --- print the contents of an array */

static int
print_array(volatile NODE *arr, char *arr_name)
{
	NODE *subs;
	NODE **list;
	int i;
	size_t num_elems = 0;
	volatile NODE *r;
	volatile int ret = 0;
	volatile jmp_buf pager_quit_tag_stack;

	// manage a stack of names for printing deeply nested arrays
	static const char **names = NULL;
	static size_t cur_name = 0;
	static size_t num_names = 0;
#define INITIAL_NAME_COUNT	10

	if (names == NULL) {
		emalloc(names, const char **, INITIAL_NAME_COUNT * sizeof(char *));
		memset(names, 0, INITIAL_NAME_COUNT * sizeof(char *));
		num_names = INITIAL_NAME_COUNT;
	}

	if (assoc_empty((NODE *) arr)) {
		gprintf(out_fp, _("array `%s' is empty\n"), arr_name);
		return 0;
	}

	num_elems = assoc_length((NODE *) arr);

	/* sort indices, sub_arrays are also sorted! */
	list = assoc_list((NODE *) arr, "@ind_str_asc", SORTED_IN);

	PUSH_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);
	if (setjmp(pager_quit_tag) == 0) {
		// push name onto stack
		if (cur_name >= num_names) {
			num_names *= 2;
			erealloc(names, const char **, num_names * sizeof(char *));
		}
		names[cur_name++] = arr_name;

		// and print the array
		for (i = 0; ret == 0 && i < num_elems; i++) {
			subs = list[i];
			r = *assoc_lookup((NODE *) arr, subs);
			if (r->type == Node_var_array) {
				// 12/2023: Use sub->stptr here, not r->vname, since
				// a subarray could have been created via
				// split() or some other mechanism where flags has NUMINT in it.
				// In this case, r->vname can be NULL, so pass in the
				// subscript itself.  This should be fixed in the code that
				// builds such arrays.
				ret = print_array(r, subs->stptr);
			} else {
				print_array_names(names, cur_name, out_fp);
				gprintf(out_fp, "[\"%.*s\"] = ", (int) subs->stlen, subs->stptr);
				valinfo((NODE *) r, gprintf, out_fp);
			}
		}
	} else
		ret = 1;

	POP_BINDING(pager_quit_tag_stack, pager_quit_tag, pager_quit_tag_valid);
	cur_name--;

	for (i = 0; i < num_elems; i++)
		unref(list[i]);
	efree(list);

	return ret;
}

/* print_subscript --- print an array element */

static void
print_subscript(NODE *arr, char *arr_name, CMDARG *a, int count)
{
	NODE *r, *subs;

	subs = a->a_node;
	r = in_array(arr, subs);
	if (r == NULL)
		fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"), (int) subs->stlen, subs->stptr, arr_name);
	else if (r->type == Node_var_array) {
		if (count > 1)
			print_subscript(r, r->vname, a->next, count - 1);
		else {
			/* print # of elements in array */
			fprintf(out_fp, "%s = ", r->vname);
			print_symbol(r, false);
		}
	} else {
		fprintf(out_fp, "%s[\"%.*s\"] = ", arr_name, (int) subs->stlen, subs->stptr);
		valinfo(r, fprintf, out_fp);
	}
}

/* do_print_var --- print command */

int
do_print_var(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	NODE *r;
	CMDARG *a;
	char *name, *pname;

	for (a = arg; a != NULL; a = a->next) {
		switch (a->type) {
		case D_variable:
			name = a->a_string;
			if ((r = find_symbol(name, &pname)) != NULL) {
				fprintf(out_fp, "%s = ", name);
				print_symbol(r, (pname != NULL));
			}
			break;

		case D_subscript:
			assert(a->a_count > 0);
			name = a->a_string;
			r = find_array(name);
			if (r != NULL)
				print_subscript(r, name, a->next, a->a_count);
			break;

		case D_array:
			name = a->a_string;
			if ((r = find_array(name)) != NULL) {
				int count = a->a_count;
				for (; count > 0; count--) {
					NODE *value, *subs;
					a = a->next;
					subs = a->a_node;
					value = in_array(r, subs);
					if (value == NULL) {
						fprintf(out_fp, _("subscript \"%.*s\" is not in array `%s'\n"),
									(int) subs->stlen, subs->stptr, name);
						break;
					} else if (value->type != Node_var_array) {
						fprintf(out_fp, _("`%s[\"%.*s\"]' is not an array\n"),
									name, (int) subs->stlen, subs->stptr);
						break;
					} else {
						r = value;
						name = r->vname;
					}
				}
				if (count == 0) {
					initialize_pager(out_fp);
					print_array((volatile NODE *) r, name);
				}
			}
			break;

		case D_field:
			print_field(get_number_si(a->a_node));
			break;

		default:
			/* notably D_node, subscript for invalid array name; skip */
			break;
		}
	}
	return false;
}

/* do_set_var --- set command */

int
do_set_var(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	NODE *r, *val;
	NODE **lhs;
	char *name, *pname;

	switch (arg->type) {
	case D_variable:
		name = arg->a_string;
		arg = arg->next;
		val = arg->a_node;

		if ((r = find_symbol(name, &pname)) == NULL)
			break;

		switch (r->type) {
		case Node_var_new:
		case Node_elem_new:
			r->type = Node_var;
			r->var_value = dupnode(Nnull_string);
			/* fall through */
		case Node_var:
			lhs = &r->var_value;
			unref(*lhs);
			*lhs = dupnode(val);
			if (pname == NULL && r->var_assign != NULL)
				r->var_assign();
			fprintf(out_fp, "%s = ", name);
			print_symbol(r, (pname != NULL));
			break;

		default:
			d_error(_("`%s' is not a scalar variable"), name);
			break;
		}
		break;

	case D_subscript:
	{
		NODE *subs, *value;
		int count = arg->a_count;
		NODE *newval;

		assert(count > 0);
		name = arg->a_string;
		r = find_array(name);
		if (r == NULL)
			break;
		for (; count > 0; count--) {
			arg = arg->next;
			subs = arg->a_node;
			value = in_array(r, subs);

			if (count == 1) {
				if (value != NULL && value->type == Node_var_array)
					d_error(_("attempt to use array `%s[\"%.*s\"]' in a scalar context"),
								name, (int) subs->stlen, subs->stptr);
				else {
					arg = arg->next;
					val = arg->a_node;
					newval = dupnode(val);
					// subs should not be freed, so
					// use dupnode in call to assoc_set.
					assoc_set(r, dupnode(subs), newval);
					fprintf(out_fp, "%s[\"%.*s\"] = ", name, (int) subs->stlen, subs->stptr);
					valinfo(newval, fprintf, out_fp);
				}
			} else {
				if (value == NULL) {
					NODE *array;
					array = make_array();
					array->vname = estrdup(subs->stptr, subs->stlen);
					array->parent_array = r;
					// subs should not be freed, so
					// use dupnode in call to assoc_set.
					assoc_set(r, dupnode(subs), array);
					r = array;
				} else if (value->type != Node_var_array) {
					d_error(_("attempt to use scalar `%s[\"%.*s\"]' as array"),
							name, (int) subs->stlen, subs->stptr);
					break;
				} else {
					r = value;
					name = r->vname;
				}
			}
		}
	}
		break;

	case D_field:
	{
		long field_num;
		Func_ptr assign = NULL;

		field_num = get_number_si(arg->a_node);
		assert(field_num >= 0);
		arg = arg->next;
		val = arg->a_node;
		lhs = get_field(field_num, &assign);
		if (assign)
			/* call assign to copy fields before unref frees $0 */
			assign();
		unref(*lhs);
		*lhs = dupnode(val);
		print_field(field_num);
	}
		break;

	default:
		break;
	}
	return false;
}

/* find_item --- find an item in the watch/display list */

static struct list_item *
find_item(struct list_item *list, long num)
{
	struct list_item *d;

	if (num <= 0)
		return NULL;
	for (d = list->next; d != list; d = d->next) {
		if (d->number == num)
			return d;
	}
	return NULL;
}

/* delete_item --- delete an item from the watch/display list */

static void
delete_item(struct list_item *d)
{
	struct commands_item *c;
	int i;

	if (IS_SUBSCRIPT(d)) {
		for (i = 0; i < d->num_subs; i++)
			unref(d->subs[i]);
		efree(d->subs);
	} else if (IS_FIELD(d))
		unref(d->symbol);

	if ((d->flags & CUR_IS_ARRAY) == 0)
		unref(d->cur_value);
	if ((d->flags & OLD_IS_ARRAY) == 0)
		unref(d->old_value);

	/* delete commands */
	for (c = d->commands.next; c != &d->commands; c = c->next) {
		c = c->prev;
		delete_commands_item(c->next);
	}

	free_context(d->cndn.ctxt, false);
	if (d->cndn.expr != NULL)
		efree(d->cndn.expr);

	d->next->prev = d->prev;
	d->prev->next = d->next;
	efree(d);
}

/* add_item --- craete a watch/display item and add it to the list */

static struct list_item *
add_item(struct list_item *list, int type, NODE *symbol, char *pname)
{
	struct list_item *d;

	ezalloc(d, struct list_item *, sizeof(struct list_item));
	d->commands.next = d->commands.prev = &d->commands;

	d->number = ++list->number;
	d->sname = symbol->vname;
	if (pname != NULL) {	/* function param */
		d->sname = pname;
		d->flags |= PARAM;
		d->fcall_count = fcall_count - cur_frame;
	}

	if (type == D_field) {
		/* field number */
		d->symbol = symbol;
		d->flags |= FIELD_NUM;
	} else if (type == D_subscript) {
		/* subscript */
		d->symbol = symbol;
		d->flags |= SUBSCRIPT;
	} else {
		/* array or variable */
		d->symbol = symbol;
	}

	/* add to list */
	d->next = list->next;
	d->prev = list;
	list->next = d;
	d->next->prev = d;
	return d;
}

/* do_add_item --- add an item to the watch/display list */

static struct list_item *
do_add_item(struct list_item *list, CMDARG *arg)
{
	NODE *symbol = NULL;
	char *name, *pname = NULL;
	struct list_item *item = NULL;

	switch (arg->type) {
	case D_subscript:
	case D_variable:
		name = arg->a_string;
		if ((symbol = find_symbol(name, &pname)) == NULL)
			return NULL;
		if (symbol->type == Node_func) {
			d_error(_("`%s' is a function"), name);
			return NULL;
		}
		if (arg->type == D_subscript && symbol->type != Node_var_array) {
			d_error(_("`%s' is not an array\n"), name);
			return NULL;
		}

		item = add_item(list, arg->type, symbol, pname);
		if (item != NULL && arg->type == D_subscript) {
			NODE **subs;
			int count = arg->a_count;
			int i;

			assert(count > 0);
			emalloc(subs, NODE **, count * sizeof(NODE *));
			for (i = 0; i < count; i++) {
				arg = arg->next;
				subs[i] = dupnode(arg->a_node);
				subs[i] = force_string(subs[i]);
			}
			item->subs = subs;
			item->num_subs = count;
		}
		break;

	case D_field:
		symbol = dupnode(arg->a_node);
		item = add_item(list, D_field, symbol, NULL);
		break;

	default:
		break;
	}

	/* watch condition if any */
	if (list == &watch_list) {
		arg = arg->next;
		if (item != NULL && arg != NULL) {
			if (parse_condition(D_watch, item->number, arg->a_string) == 0)
				arg->a_string = NULL;	/* don't let free_cmdarg free it */
			else
				fprintf(out_fp, _("watchpoint %d is unconditional\n"), item->number);
		}
	}
	return item;
}

/* do_delete_item --- delete a watch/display item from list. */

static void
do_delete_item(struct list_item *list, CMDARG *arg)
{
	if (arg == NULL) {
		while (list->next != list)
			delete_item(list->next);
	}

	for (; arg != NULL; arg = arg->next) {
		struct list_item *d;
		if (arg->type == D_range) {
			long i, j;

			i = arg->a_int;
			arg = arg->next;
			j = arg->a_int;
			if (j > list->number)
				j = list->number;
			for (; i <= j; i++) {
				if ((d = find_item(list, i)) != NULL)
					delete_item(d);
			}
		} else {
			if ((d = find_item(list, arg->a_int)) == NULL) {
				/* split into two for easier message translation */
				if (list == &display_list)
					d_error(_("no display item numbered %ld"),
						arg->a_int);
				else
					d_error(_("no watch item numbered %ld"),
						arg->a_int);
			} else
				delete_item(d);
		}
	}
}

/* display --- print an item from the auto-display list */

static void
display(struct list_item *d)
{
	NODE *symbol;

	symbol = d->symbol;
	if (IS_PARAM(d)	&& (d->fcall_count != (fcall_count - cur_frame)))
		return;

	if (IS_SUBSCRIPT(d)) {
		NODE *sub, *r;
		int i = 0, count = d->num_subs;
		for (i = 0; i < count; i++) {
			sub = d->subs[i];
			r = in_array(symbol, sub);
			if (r == NULL) {
				fprintf(out_fp, _("%d: subscript \"%.*s\" is not in array `%s'\n"),
							d->number, (int) sub->stlen, sub->stptr, d->sname);
				break;
			}
			if (r->type == Node_var_array) {
				symbol = r;
				if (i == count - 1)	/* it's a sub-array */
					goto print_sym;		/* print # of elements in sub-array */
			} else {
				if (i != count - 1)
					return;		/* FIXME msg and delete item ? */
				fprintf(out_fp, "%d: %s[\"%.*s\"] = ", d->number,
							d->sname, (int) sub->stlen, sub->stptr);
				valinfo(r, fprintf, out_fp);
			}
		}
	} else if (IS_FIELD(d)) {
		NODE *r = d->symbol;
		fprintf(out_fp, "%d: ", d->number);
		print_field(get_number_si(r));
	} else {
print_sym:
		fprintf(out_fp, "%d: %s = ", d->number, d->sname);
		print_symbol(symbol, IS_PARAM(d));
	}
}


/* do_display --- display command */

int
do_display(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	struct list_item *d;

	if (arg == NULL) {
		/* display all items */
		for (d = display_list.prev; d != &display_list; d = d->prev)
			display(d);
		return false;
	}

	if ((d = do_add_item(&display_list, arg)) != NULL)
		display(d);

	return false;
}

/* do_undisplay --- undisplay command */

int
do_undisplay(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	do_delete_item(&display_list, arg);
	return false;
}

/* condition_triggered --- test if a condition expression is true */

static int
condition_triggered(struct condition *cndn)
{
	NODE *r;
	int di;

	assert(cndn != NULL);
	if (cndn->code == NULL)
		return true;

	push_context(cndn->ctxt);
	r = execute_code((volatile INSTRUCTION *) cndn->code);
	pop_context();  /* switch to prev context */
	if (r == NULL)      /* fatal error */
		return false;   /* not triggered */

	force_number(r);
	di = ! is_zero(r);
	DEREF(r);
	return di;
}


static int
find_subscript(struct list_item *item, NODE **ptr)
{
	NODE *symbol = item->symbol;
	NODE *sub, *r;
	int i = 0, count = item->num_subs;

	// without this check, in_array() will SEGV...
	if (symbol->type == Node_var_new || symbol->type == Node_elem_new)
		return -1;

	r = *ptr = NULL;
	for (i = 0; i < count; i++) {
		sub = item->subs[i];
		r = in_array(symbol, sub);
		if (r == NULL)
			return 0;
		if (r->type == Node_var_array)
			symbol = r;
		else if (i < count - 1)
			return -1;
	}
	if (r != NULL)
		*ptr = r;
	return 0;
}

/* cmp_val --- compare values of watched item, returns true if different; */

static int
cmp_val(struct list_item *w, NODE *old, NODE *new)
{
		/*
		 *	case    old     new     result
		 *	------------------------------
		 *	1:      NULL    ARRAY   true
		 *	2:      NULL    SCALAR  true
		 *	3:      NULL    NULL    false
		 *	4:      SCALAR  SCALAR  cmp_node
		 *	5:      SCALAR  ARRAY   true
		 *	6:      SCALAR  NULL    true
		 *	7:      ARRAY   SCALAR  true
		 *	8:      ARRAY   ARRAY   compare size
		 *	9:      ARRAY   NULL    true
		 */

	if (WATCHING_ARRAY(w)) {
		long size = 0;
		if (! new)		/* 9 */
			return true;
		if (new->type == Node_val)	/* 7 */
			return true;
		/* new->type == Node_var_array */	/* 8 */
		size = assoc_length(new);
		if (w->cur_size == size)
			return false;
		return true;
	}

	if (! old && ! new)	/* 3 */
		return false;
	if ((! old && new)	/* 1, 2 */
			|| (old && ! new))	/* 6 */
		return true;

	if (new->type == Node_var_array)	/* 5 */
		return true;
	return cmp_nodes(old, new, true);	/* 4 */
}

/* watchpoint_triggered --- check if we should stop at this watchpoint;
 *                          update old and current values accordingly.
 */

static int
watchpoint_triggered(struct list_item *w)
{
	NODE *symbol;
	NODE *t1, *t2;

	symbol = w->symbol;
	if (IS_PARAM(w) && (w->fcall_count != (fcall_count - cur_frame)))
		return 0; /* parameter with same name in a different function */
	if (! condition_triggered(&w->cndn))
		return 0;

	t1 = w->cur_value;
	t2 = (NODE *) 0;
	if (IS_SUBSCRIPT(w))
		(void) find_subscript(w, &t2);
	else if (IS_FIELD(w)) {
		long field_num;
		field_num = get_number_si(w->symbol);
		t2 = *get_field(field_num, NULL);
	} else {
		switch (symbol->type) {
		case Node_var:
			t2 = symbol->var_value;
			break;
		case Node_var_array:
			t2 = symbol;
			break;
		case Node_var_new:
		case Node_elem_new:
			break;
		default:
			cant_happen("unexpected symbol type %s", nodetype2str(symbol->type));
		}
	}

	if (! cmp_val(w, t1, t2))
		return 0;

	/* update old and current values */

	if ((w->flags & OLD_IS_ARRAY) == 0)
		unref(w->old_value);
	w->flags &= ~OLD_IS_ARRAY;
	if (WATCHING_ARRAY(w)) {	/* 7, 8, 9 */
		w->old_size = w->cur_size;
		w->flags |= OLD_IS_ARRAY;
		if (! t2) {
			w->flags &= ~CUR_IS_ARRAY;
			w->cur_value = 0;
		} else if (t2->type == Node_val) {
			w->flags &= ~CUR_IS_ARRAY;
			w->cur_value = dupnode(t2);
		} else
			w->cur_size = (t2->type == Node_var_array) ? assoc_length(t2) : 0;
	} else if (! t1) { /* 1, 2 */
		w->old_value = 0;
		/* new != NULL */
		if (t2->type == Node_val)
			w->cur_value = dupnode(t2);
		else {
			w->flags |= CUR_IS_ARRAY;
			w->cur_size = (t2->type == Node_var_array) ? assoc_length(t2) : 0;
		}
	} else /* if (t1->type == Node_val) */ {	/* 4, 5, 6 */
		w->old_value = w->cur_value;
		if (! t2)
			w->cur_value = 0;
		else if (t2->type == Node_var_array) {
			w->flags |= CUR_IS_ARRAY;
			w->cur_size = assoc_length(t2);
		} else
			w->cur_value = dupnode(t2);
	}

	return w->number;
}

/* initialize_watch_item --- initialize current value of a watched item */

static int
initialize_watch_item(struct list_item *w)
{
	NODE *t, *r;
	NODE *symbol = w->symbol;

	if (IS_SUBSCRIPT(w)) {
		if (find_subscript(w, &r) == -1) {
			d_error(_("attempt to use scalar value as array"));
			return -1;
		}

		if (r == NULL)
			w->cur_value = (NODE *) 0;
		else if (r->type == Node_var_array) { /* it's a sub-array */
			w->flags |= CUR_IS_ARRAY;
			w->cur_size = assoc_length(r);
		} else
			w->cur_value = dupnode(r);
	} else if (IS_FIELD(w)) {
		long field_num;
		t = w->symbol;
		field_num = get_number_si(t);
		r = *get_field(field_num, NULL);
		w->cur_value = dupnode(r);
	} else {
		if (symbol->type == Node_var_new || symbol->type == Node_elem_new)
			w->cur_value = (NODE *) 0;
		else if (symbol->type == Node_var) {
			r = symbol->var_value;
			w->cur_value = dupnode(r);
		} else if (symbol->type == Node_var_array) {
			w->flags |= CUR_IS_ARRAY;
			w->cur_size = assoc_length(symbol);
		} else if (symbol->type == Node_val && (symbol->flags & REGEX) != 0) {
			w->cur_value = dupnode(symbol);
		} /* else
			can't happen */
	}
	return 0;
}

/* do_watch --- watch command */

int
do_watch(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	struct list_item *w;
	NODE *symbol, *sub;
	int i;

	w = do_add_item(&watch_list, arg);
	if (w == NULL)
		return false;

	if (initialize_watch_item(w) == -1) {
		delete_item(w);
		return false;
	}

	fprintf(out_fp, "Watchpoint %d: ", w->number);
	symbol = w->symbol;

	/* FIXME: common code also in print_watch_item */
	if (IS_SUBSCRIPT(w)) {
		fprintf(out_fp, "%s", w->sname);
		for (i = 0; i < w->num_subs; i++) {
			sub = w->subs[i];
			fprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);
		}
		fprintf(out_fp, "\n");
	} else if (IS_FIELD(w))
		fprintf(out_fp, "$%ld\n", get_number_si(symbol));
	else
		fprintf(out_fp, "%s\n", w->sname);

	return false;
}

/* do_unwatch --- unwatch command */

int
do_unwatch(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	do_delete_item(&watch_list, arg);
	return false;
}

/* callback from pop_frame in eval.c */

void
frame_popped()
{
	struct list_item *item;

	/* delete all out of scope watchpoints */
	for (item = watch_list.next; item != &watch_list; item = item->next) {
		if (IS_PARAM(item) && (item->fcall_count > fcall_count)) {
			fprintf(out_fp,
				_("Watchpoint %d deleted because parameter is out of scope.\n"),
				item->number);
			item = item->prev;
			delete_item(item->next);
		}
	}

	/* delete all out of scope display items */
	for (item = display_list.next; item != &display_list; item = item->next) {
		if (IS_PARAM(item) && (item->fcall_count > fcall_count)) {
			fprintf(out_fp,
				_("Display %d deleted because parameter is out of scope.\n"),
				item->number);
			item = item->prev;
			delete_item(item->next);
		}
	}
}

/* print_function --- print function name, parameters, and optionally
 *                file and line number.
 */

static int
print_function(INSTRUCTION *pc, void *x)
{
	NODE *func;
	int i, pcount;
	struct pf_data *data = (struct pf_data *) x;
	int defn = data->defn;
	Func_print print_func = data->print_func;
	FILE *fp = data->fp;

	func = pc->func_body;
	pcount = func->param_cnt;

	print_func(fp, "%s(", func->vname);
	for (i = 0; i < pcount; i++) {
		print_func(fp, "%s", func->fparms[i].param);
		if (i < pcount - 1)
			print_func(fp, ", ");
	}
	print_func(fp, ")");
	if (defn)
		print_func(fp, _(" in file `%s', line %d\n"),
				pc->source_file, pc->source_line);
	return 0;
}

/* print_frame --- print function name, parameters,
 *                 source and line number of where it is
 *                 executing.
 */

static void
print_frame(NODE *func, char *src, int srcline)
{
	if (func == NULL)
		fprintf(out_fp, "main()");
	else {
		pf_data.print_func = fprintf;
		pf_data.fp = out_fp;
		pf_data.defn = false;
		(void) print_function(func->code_ptr, &pf_data);
	}
	fprintf(out_fp, _(" at `%s':%d"), src, srcline);
}

/* print_numbered_frame --- print a frame given its number */

static void
print_numbered_frame(long num)
{
	NODE *f;

	assert(prog_running == true);
	f = find_frame(num);
	if (num == 0) {
		fprintf(out_fp, "#%ld\t ", num);
		print_frame(f->func_node, source, sourceline);
	} else {
		fprintf(out_fp, _("#%ld\tin "), num);
		print_frame(f->func_node, f->vname,
			((INSTRUCTION *) find_frame(num - 1)->reti)->source_line);
	}
	fprintf(out_fp, "\n");
}

/* do_backtrace --- backtrace command */

int
do_backtrace(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	long cur = 0;
	long last = fcall_count;

	CHECK_PROG_RUNNING();
	if (arg != NULL && arg->type == D_int) {
		long count = arg->a_int;

		/* frame_ptr (frame #0),  fcall_list[1, 2, ... fcall_count] => total count */
		if (count >= 0) {
			/* toward outermost frame #fcall_count */
			last = count - 1;
			if (last > fcall_count)
				 last = fcall_count;
		} else {
			/* toward innermost frame #0 */
			cur = 1 + fcall_count + count;
			if (cur < 0)
				cur = 0;
		}
	}

	for (; cur <= last; cur++) {
		print_numbered_frame(cur);
	}
	if (cur <= fcall_count)
		fprintf(out_fp, _("More stack frames follow ...\n"));
	return false;
}

/* print_cur_frame_and_sourceline --- print current frame, and
 *                                    current source line.
 */

static void
print_cur_frame_and_sourceline()
{
	NODE *f;
	int srcline;
	char *src;

	assert(prog_running == true);
	f = find_frame(cur_frame);
	if (cur_frame == 0) {
		src = source;
		srcline = sourceline;
	} else {
		f = find_frame(cur_frame);
		src = f->vname;
		srcline = ((INSTRUCTION *) find_frame(cur_frame - 1)->reti)->source_line;
	}

	fprintf(out_fp, (cur_frame > 0 ? _("#%ld\tin ") : "#%ld\t "), cur_frame);
	print_frame(f->func_node, src, srcline);
	fprintf(out_fp, "\n");
	print_lines(src, srcline, 1);
	last_printed_line = srcline - list_size / 2;
	if (last_printed_line < 0)
		last_printed_line = 0;
}

/* do_frame --- frame command */

int
do_frame(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	CHECK_PROG_RUNNING();
	if (arg && arg->type == D_int) {
		if (arg->a_int < 0 || arg->a_int > fcall_count) {
			d_error(_("invalid frame number"));
			return false;
		}
		cur_frame = arg->a_int;
	}
	print_cur_frame_and_sourceline();
	return false;
}

/* do_up --- up command */

int
do_up(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	CHECK_PROG_RUNNING();
	if (arg != NULL && arg->type == D_int)
		cur_frame += arg->a_int;
	else
		cur_frame++;
	if (cur_frame < 0)
		cur_frame = 0;
	else if (cur_frame > fcall_count)
		cur_frame = fcall_count;
	print_cur_frame_and_sourceline();
	return false;
}

/* do_down --- down command */

int
do_down(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	CHECK_PROG_RUNNING();
	if (arg != NULL && arg->type == D_int)
		cur_frame -= arg->a_int;
	else
		cur_frame--;
	if (cur_frame < 0)
		cur_frame = 0;
	else if (cur_frame > fcall_count)
		cur_frame = fcall_count;
	print_cur_frame_and_sourceline();
	return false;
}

/* find_rule --- find a rule or function in file 'src' containing
 *               source line 'lineno'
 */

static INSTRUCTION *
find_rule(char *src, long lineno)
{
	INSTRUCTION *rp;

	/*
	 * FIXME: The check for zero and code that goes with it
	 * are probably fragile.  A break with no arguments can
	 * cause this in certain cases. Try to review how this works.
	 */
	if (lineno == 0) {
		for (rp = rule_list->nexti; rp != NULL; rp = rp->nexti) {
			if ((rp - 1)->source_file == src && (rp - 1)->source_line > 0)
				return (rp - 1);
		}
	} else {
		for (rp = rule_list->nexti; rp != NULL; rp = rp->nexti) {
			if ((rp - 1)->source_file == src
					&& lineno >= (rp + 1)->first_line
					&& lineno <= (rp + 1)->last_line)
				return (rp - 1);
		}
	}
	return NULL;
}

/* mk_breakpoint --- create a breakpoint instruction and the corresponding
 *                   breakpoint structure.
 */

static INSTRUCTION *
mk_breakpoint(char *src, int srcline)
{
	INSTRUCTION *bp;
	BREAKPOINT *b;

	bp = bcalloc(Op_breakpoint, 1, srcline);
	emalloc(b, BREAKPOINT *, sizeof(BREAKPOINT));
	memset(&b->cndn, 0, sizeof(struct condition));
	b->commands.next = b->commands.prev = &b->commands;
	b->silent = false;


	b->number = ++watch_list.number;	/* breakpoints and watchpoints use same counter */
	b->ignore_count = 0;
	b->hit_count = 0;
	b->flags = BP_ENABLE;
	b->src = src;
	bp->break_pt = b;
	b->bpi = bp;

	/* prepend to list */
	b->next = breakpoints.next;
	b->prev = &breakpoints;
	breakpoints.next = b;
	b->next->prev = b;
	return bp;
}

/* delete_breakpoint --- delete a breakpoint structure and
 *                       disable the breakpoint instruction.
 */

static void
delete_breakpoint(BREAKPOINT *b)
{
	INSTRUCTION *pc = b->bpi;
	struct commands_item *c;

	/* N.B.: easiest thing to do is to turn Op_breakpoint into a no-op;
	 * deleteing the instruction is not that simple,
	 * since could have reference to it somewhere else (e.g. cur_pc).
	 */

	pc->opcode = Op_no_op;
	pc->source_line = 0;
	pc->break_pt = NULL;

	/* delete commands */
	for (c = b->commands.next; c != &b->commands; c = c->next) {
		c = c->prev;
		delete_commands_item(c->next);
	}

	free_context(b->cndn.ctxt, false);
	if (b->cndn.expr != NULL)
		efree(b->cndn.expr);

	/* remove from list */
	b->next->prev = b->prev;
	b->prev->next = b->next;
	efree(b);
}

/* find_breakpoint --- find the breakpoint structure from a breakpoint number */

static BREAKPOINT *
find_breakpoint(long num)
{
	BREAKPOINT *b;

	if (num <= 0)
		return NULL;

	for (b = breakpoints.next; b != &breakpoints; b = b->next) {
		if (b->number == num)
			return b;
	}
	return NULL;
}

/* add_breakpoint --- add a breakpoint instruction between PREVP and IP */

static BREAKPOINT *
add_breakpoint(INSTRUCTION *prevp, INSTRUCTION *ip, char *src, bool silent)
{
	BREAKPOINT *b;
	INSTRUCTION *bp;
	int lineno = ip->source_line;

	/* add new breakpoint instruction at the end of
	 * already set breakpoints at this line number.
	 */

	while (ip->opcode == Op_breakpoint && ip->source_line == lineno) {
		if (! silent) {
			b = ip->break_pt;
			/*
			 * This is more verbose that it might otherwise be,
			 * in order to provide easily translatable strings.
			 */
			if ((b->flags & BP_ENABLE) != 0) {
				if ((b->flags & BP_IGNORE) != 0)
					fprintf(out_fp,
			_("Note: breakpoint %d (enabled, ignore next %ld hits), also set at %s:%d"),
						b->number,
						b->ignore_count,
						b->src,
						lineno);
				else
					fprintf(out_fp,
			_("Note: breakpoint %d (enabled), also set at %s:%d"),
						b->number,
						b->src,
						lineno);
			} else {
				if ((b->flags & BP_IGNORE) != 0)
					fprintf(out_fp,
			_("Note: breakpoint %d (disabled, ignore next %ld hits), also set at %s:%d"),
						b->number,
						b->ignore_count,
						b->src,
						lineno);
				else
					fprintf(out_fp,
			_("Note: breakpoint %d (disabled), also set at %s:%d"),
						b->number,
						b->src,
						lineno);
			}
		}
		prevp = ip;
		ip = ip->nexti;
	}

	assert(ip->source_line == lineno);

	bp = mk_breakpoint(src, lineno);
	prevp->nexti = bp;
	bp->nexti = ip;
	b = bp->break_pt;
	if (! silent)
		fprintf(out_fp, _("Breakpoint %d set at file `%s', line %d\n"),
						b->number, src, lineno);
	return b;
}

/* set_breakpoint_at --- set a breakpoint at given line number*/

static BREAKPOINT *
set_breakpoint_at(INSTRUCTION *rp, int lineno, bool silent)
{
	INSTRUCTION *ip, *prevp;

	for (prevp = rp, ip = rp->nexti; ip; prevp = ip, ip = ip->nexti) {
		if (ip->opcode == Op_K_case) {
			INSTRUCTION *i1, *i2;

			/* Special case: the code line numbers for a switch do not form
			 * a monotonically increasing sequence. Check if the line # is between
			 * the first and last statements of the case block before continuing
			 * the search.
			 */
			for (i2 = ip->stmt_start, i1 = i2->nexti; i2 != ip->stmt_end;
								i2 = i1, i1 = i1->nexti) {
				if (i1->source_line >= lineno)
					return add_breakpoint(i2, i1, rp->source_file, silent);
				if (i1 == ip->stmt_end)
					break;
			}
		}

		if (ip->source_line >= lineno)
			return add_breakpoint(prevp, ip, rp->source_file, silent);
		if (ip == (rp + 1)->lasti)
			break;
	}
	return NULL;
}

/* set_breakpoint_next --- set a breakpoint at the next instruction */

static BREAKPOINT *
set_breakpoint_next(INSTRUCTION *rp, INSTRUCTION *ip)
{
	INSTRUCTION *prevp;

	if (ip == (rp + 1)->lasti)
		return NULL;
	prevp = ip;
	if (ip->opcode != Op_breakpoint)
		ip = ip->nexti;
	for (; ip; prevp = ip, ip = ip->nexti) {
		if (ip->source_line > 0)
			return add_breakpoint(prevp, ip, rp->source_file, false);
		if (ip == (rp + 1)->lasti)
			break;
	}
	return NULL;
}

/* set_breakpoint --- set a breakpoint */

static int
set_breakpoint(CMDARG *arg, bool temporary)
{
	int lineno;
	BREAKPOINT *b = NULL;
	INSTRUCTION *rp, *ip;
	NODE *func;
	SRCFILE *s = cur_srcfile;
	char *src = cur_srcfile->src;

	if (arg == NULL) {
/*
* (From GDB Documentation):
*
* When called without any arguments, break sets a breakpoint at the next instruction
* to be executed in the selected stack frame (see section Examining the Stack).
* In any selected frame but the innermost, this makes your program stop as soon
* as control returns to that frame. This is similar to the effect of a finish command
* in the frame inside the selected frame--except that finish does not leave an
* active breakpoint. If you use break without an argument in the innermost frame,
* GDB stops the next time it reaches the current location; this may be useful
* inside loops.
* GDB normally ignores breakpoints when it resumes execution, until at least
* one instruction has been executed. If it did not do this,
* you would be unable to proceed past a breakpoint without first disabling the
* breakpoint. This rule applies whether or not the breakpoint already existed
* when your program stopped.
*/
		CHECK_PROG_RUNNING();
		if (cur_frame == 0) {
			src = source;
			ip = cur_pc;
		} else {
			NODE *f;
			f = find_frame(cur_frame);
			src = f->vname;
			ip = (INSTRUCTION *) find_frame(cur_frame - 1)->reti;  /* Op_func_call */
		}
		rp = find_rule(src, ip->source_line);
		assert(rp != NULL);
		if ((b = set_breakpoint_next(rp, ip)) == NULL)
			fprintf(out_fp, _("cannot set breakpoint in file `%s'\n"), src);
		else {
			if (cur_frame == 0) {	/* stop next time */
				b->flags |= BP_IGNORE;
				b->ignore_count = 1;
			}
			if (temporary)
				b->flags |= BP_TEMP;
		}
		return false;
	}

	/* arg != NULL */

	switch (arg->type) {
	case D_string:	/* break filename:lineno|function */
		s = source_find(arg->a_string);
		arg = arg->next;
		if (s == NULL || arg == NULL
				|| (arg->type != D_int && arg->type != D_func))
			return false;
		src = s->src;
		if (arg->type == D_func) /* break filename:function */
			goto func;
		else
			/* fall through */
	case D_int:		/* break lineno */
		lineno = (int) arg->a_int;
		if (lineno <= 0 || lineno > s->srclines)
			d_error(_("line number %d in file `%s' is out of range"), lineno, src);
		else {
			rp = find_rule(src, lineno);
			if (rp == NULL)
				fprintf(out_fp, _("internal error: cannot find rule\n"));
			if (rp == NULL || (b = set_breakpoint_at(rp, lineno, false)) == NULL)
				fprintf(out_fp, _("cannot set breakpoint at `%s':%d\n"),
						src, lineno);
			if (b != NULL && temporary)
				b->flags |= BP_TEMP;
		}
		break;

	case D_func:	/* break function */
func:
		func = arg->a_node;
		rp = func->code_ptr;
		if ((b = set_breakpoint_at(rp, rp->source_line, false)) == NULL)
			fprintf(out_fp, _("cannot set breakpoint in function `%s'\n"),
						func->vname);
		else {
			if (temporary)
				b->flags |= BP_TEMP;
			lineno = b->bpi->source_line;
		}
		break;

	default:
		return false;
	}
	/* condition if any */
	arg = arg->next;
	if (b != NULL && arg != NULL) {
		if (parse_condition(D_break, b->number, arg->a_string) == 0)
			arg->a_string = NULL;	/* don't let free_cmdarg free it */
		else
			fprintf(out_fp, _("breakpoint %d set at file `%s', line %d is unconditional\n"),
							b->number, src, lineno);
	}
	return false;
}


/* breakpoint_triggered --- check if we should stop at this breakpoint */

static int
breakpoint_triggered(BREAKPOINT *b)
{
	if ((b->flags & BP_ENABLE) == 0)
		return 0;
	if ((b->flags & BP_IGNORE) != 0) {
		if (--b->ignore_count <= 0)
			b->flags &= ~BP_IGNORE;
		return 0;
	}

	if (! condition_triggered(&b->cndn))
		return 0;

	b->hit_count++;
	if ((b->flags & BP_ENABLE_ONCE) != 0) {
		b->flags &= ~BP_ENABLE_ONCE;
		b->flags &= ~BP_ENABLE;
	}
	return b->number;
}

/* do_breakpoint --- break command */

int
do_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	return set_breakpoint(arg, false);
}

/* do_tmp_breakpoint --- tbreak command */

int
do_tmp_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	return set_breakpoint(arg, true);
}

/* do_clear --- clear command */

int
do_clear(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	int lineno;
	BREAKPOINT *b;
	INSTRUCTION *rp, *ip;
	NODE *func;
	SRCFILE *s = cur_srcfile;
	char *src = cur_srcfile->src;
	int bp_found = 0;

	if (arg == NULL) {	/* clear */
		CHECK_PROG_RUNNING();
		if (cur_frame == 0) {
			lineno = sourceline;
			src = source;
		} else {
			NODE *f;
			f = find_frame(cur_frame);
			src = f->vname;
			lineno = ((INSTRUCTION *) find_frame(cur_frame - 1)->reti)->source_line;
		}
		goto delete_bp;
	}

	switch (arg->type) {
	case D_string:	/* clear filename:lineno|function */
		s = source_find(arg->a_string);
		arg = arg->next;
		if (s == NULL || arg == NULL ||
				(arg->type != D_int && arg->type != D_func))
			return false;
		src = s->src;
		if (arg->type == D_func)
			goto func;
		/* fall through */
	case D_int:	/* clear lineno */
		lineno = (int) arg->a_int;
		if (lineno <= 0 || lineno > s->srclines) {
			d_error(_("line number %d in file `%s' out of range"), lineno, src);
			return false;
		}
		break;

	case D_func:	/* clear function */
func:
		func = arg->a_node;
		rp = func->code_ptr;
		for (ip = rp->nexti; ip; ip = ip->nexti) {
			if (ip->source_line <= 0)
				continue;
			if (ip->opcode != Op_breakpoint)
				break;
			b = ip->break_pt;
			if (++bp_found == 1)
				fprintf(out_fp, _("Deleted breakpoint %d"), b->number);
			else
				fprintf(out_fp, ", %d", b->number);
			delete_breakpoint(b);
		}
		if (bp_found == 0)
			fprintf(out_fp, _("No breakpoint(s) at entry to function `%s'\n"),
					func->vname);
		else
			fprintf(out_fp, "\n");
		/* fall through */
	default:
		return false;
	}

delete_bp:
	rp = find_rule(src, lineno);
	if (rp != NULL) {
		for (ip = rp->nexti; ip; ip = ip->nexti) {
			if (ip->opcode == Op_breakpoint	&& ip->source_line == lineno) {
				b = ip->break_pt;
				if (++bp_found == 1)
					fprintf(out_fp, _("Deleted breakpoint %d"), b->number);
				else
					fprintf(out_fp, ", %d", b->number);
				delete_breakpoint(b);
			}
			if (ip == (rp + 1)->lasti)
				break;
		}
	}

	if (bp_found == 0)
		fprintf(out_fp, _("No breakpoint at file `%s', line #%d\n"),
					src, (int) lineno);
	else
		fprintf(out_fp, "\n");
	return false;
}

/* enable_breakpoint --- enable a breakpoint and set its disposition */

static inline void
enable_breakpoint(BREAKPOINT *b, short disp)
{
	b->flags &= ~(BP_ENABLE_ONCE|BP_TEMP);
	b->flags |= BP_ENABLE;
	if (disp)
		b->flags |= disp;
}

/* do_enable_breakpoint --- enable command */

int
do_enable_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	BREAKPOINT *b;
	short disp = 0;

	if (arg != NULL && arg->type == D_argument) {
		if (arg->a_argument == A_DEL)	/* del */
			disp = BP_TEMP;
		else						/* once */
			disp = BP_ENABLE_ONCE;
		arg = arg->next;
	}

	if (arg == NULL) {	/* enable [once|del] */
		for (b = breakpoints.next; b != &breakpoints; b = b->next)
			enable_breakpoint(b, disp);
	}

	for (; arg != NULL; arg = arg->next) {
		if (arg->type == D_range) {
			long i, j;

			i = arg->a_int;
			arg = arg->next;
			j = arg->a_int;
			if (j > breakpoints.number)
				j = breakpoints.number;
			for (; i <= j; i++) {
				if ((b = find_breakpoint(i)) != NULL)
					enable_breakpoint(b, disp);
			}
		} else {
			assert(arg->type == D_int);
			if ((b = find_breakpoint(arg->a_int)) == NULL)
				d_error(_("invalid breakpoint number"));
			else
				enable_breakpoint(b, disp);
		}
	}
	return false;
}

/* do_delete_breakpoint --- delete command */

int
do_delete_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	if (arg == NULL) {
		bool delete_all = true;
		delete_all = prompt_yes_no(
					_("Delete all breakpoints? (y or n) "),
					_("y")[0], true, out_fp);

		if (delete_all) {
			while (breakpoints.next != &breakpoints)
				delete_breakpoint(breakpoints.next);
		}
	}

	for (; arg != NULL; arg = arg->next) {
		BREAKPOINT *b;
		if (arg->type == D_range) {
			long i, j;

			i = arg->a_int;
			arg = arg->next;
			j = arg->a_int;
			if (j > breakpoints.number)
				j = breakpoints.number;
			for (; i <= j; i++) {
				if ((b = find_breakpoint(i)) != NULL)
					delete_breakpoint(b);
			}
		} else {
			if ((b = find_breakpoint(arg->a_int)) == NULL)
				d_error(_("invalid breakpoint number"));
			else
				delete_breakpoint(b);
		}
	}
	return false;
}

/* do_ignore_breakpoint --- ignore command */

int
do_ignore_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	BREAKPOINT *b;

	if (arg == NULL || arg->type != D_int
			|| arg->next == NULL || arg->next->type != D_int)
		return false;

	if ((b = find_breakpoint(arg->a_int)) == NULL)
		d_error(_("invalid breakpoint number"));
	else {
		b->ignore_count = arg->next->a_int;
		if (b->ignore_count > 0) {
			b->flags |= BP_IGNORE;
			fprintf(out_fp, _("Will ignore next %ld crossing(s) of breakpoint %d.\n"),
					b->ignore_count, b->number);
		} else {
			b->flags &= ~BP_IGNORE;
 			fprintf(out_fp, _("Will stop next time breakpoint %d is reached.\n"),
					b->number);
		}
	}
	return false;
}

/* do_disable_breakpoint --- disable command */

int
do_disable_breakpoint(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	BREAKPOINT *b;

	if (arg == NULL) {
		/* disable all */
		for (b = breakpoints.next; b != &breakpoints; b = b->next)
			b->flags &= ~BP_ENABLE;
	}

	for (; arg != NULL; arg = arg->next) {
		if (arg->type == D_range) {
			long i, j;

			i = arg->a_int;
			arg = arg->next;
			j = arg->a_int;
			if (j > breakpoints.number)
				j = breakpoints.number;
			for (; i <= j; i++)
				if ((b = find_breakpoint(i)) != NULL)
					b->flags &= ~BP_ENABLE;
		} else {
			if ((b = find_breakpoint(arg->a_int)) == NULL)
				d_error(_("invalid breakpoint number"));
			else
				b->flags &= ~BP_ENABLE;
		}
	}
	return false;
}

#ifdef HAVE_LIBREADLINE

/* get_function --- function definition in current context */

NODE *
get_function()
{
	NODE *func;

	if (! prog_running)
		return NULL;
	func = find_frame(cur_frame)->func_node;
	return func;
}

/* initialize_readline --- initialize readline */

static void
initialize_readline()
{
	/* tell readline which stream to use for output,
	 * default input stream is stdin.
	 */
	rl_outstream = out_fp;

	/* allow conditional parsing of the ~/.inputrc file. */
	rl_readline_name = "gawk";

	/* our completion function. */
	rl_attempted_completion_function = command_completion;

	read_a_line = readline;
}
#else
#define initialize_readline()	/* nothing */
#endif


/* init_debug --- register debugger exec hooks */

void
init_debug()
{
	register_exec_hook(debug_pre_execute, debug_post_execute);
}


/* debug_prog --- debugger entry point */

int
debug_prog(INSTRUCTION *pc)
{
	char *run;

	input_fd = fileno(stdin);
	out_fp = stdout;
	if (os_isatty(input_fd))
		input_from_tty = true;
	if (input_fd == 0 && input_from_tty)
		initialize_readline();

	if (! read_a_line)
		read_a_line = g_readline;

	push_cmd_src(input_fd, input_from_tty, read_a_line, 0, 0, EXIT_FATAL);

	setbuf(out_fp, (char *) NULL);
	for (cur_srcfile = srcfiles->prev; cur_srcfile != srcfiles;
			cur_srcfile = cur_srcfile->prev) {
		if (cur_srcfile->stype == SRC_FILE
			|| cur_srcfile->stype == SRC_INC)
			break;
	}

	if (cur_srcfile == srcfiles) {
		fprintf(out_fp, _("Can only debug programs provided with the `-f' option.\n"));
		exit(EXIT_FAILURE);
	}

	dgawk_prompt = estrdup(DEFAULT_PROMPT, strlen(DEFAULT_PROMPT));
	dbg_prompt = dgawk_prompt;

	memset(&stop, 0, sizeof(stop));
	stop.command = D_illegal;

	if ((run = getenv("DGAWK_RESTART")) != NULL) {
		/* We are restarting; restore state (breakpoints, history etc.)
		 * passed as environment variables and optionally execute the run command.
		 */
		unserialize_list(BREAK);
		unserialize_list(WATCH);
		unserialize_list(DISPLAY);
		unserialize_list(HISTORY);
		unserialize_list(OPTION);
		unsetenv("DGAWK_RESTART");
		fprintf(out_fp, _("Restarting ...\n"));
		if (strcasecmp(run, "true") == 0)
			(void) do_run(NULL, 0);

	} else if (command_file != NULL) {
		/* run commands from a file (--debug=file  or -D file) */
		int fd;
		fd = open_readfd(command_file);
		if (fd == INVALID_HANDLE) {
			fprintf(stderr, _("cannot open source file `%s' for reading: %s"),
						command_file, strerror(errno));
			exit(EXIT_FAILURE);
		}
		push_cmd_src(fd, false, g_readline, close, 0, EXIT_FAILURE);
		cmd_src->str = estrdup(command_file, strlen(command_file));

	} else {
		int fd;

#ifdef HAVE_LIBREADLINE
		(void) read_history(history_file);
		sess_history_base = history_length;
#endif

		/* read saved options */
		fd = open_readfd(options_file);
		if (fd > INVALID_HANDLE)
			push_cmd_src(fd, false, g_readline, close, 0, EXIT_SUCCESS);
	}

	/* start the command interpreter */
	read_command();	/* yyparse */
	return EXIT_SUCCESS;
}


/* N.B.: ignore breakpoints and watchpoints for return command */

/* check_watchpoint --- check if any watchpoint triggered */

static int
check_watchpoint()
{
	struct list_item *w;

	if (stop.command == D_return)
		return false;
	for (w = watch_list.prev; w != &watch_list; w = w->prev) {
		int wnum = watchpoint_triggered(w);
		if (wnum > 0) {
			stop.watch_point = wnum;
			stop.print_frame = true;
			return true;
		}
	}
	return false;
}

/* check_breakpoint --- check if breakpoint triggered */

static int
check_breakpoint(INSTRUCTION **pi)
{
	INSTRUCTION *pc;

	pc = *pi;
	if (stop.command == D_return)
		return false;
	if (pc->opcode == Op_breakpoint) {
		int bnum;
		*pi = pc->nexti;    /* skip past the breakpoint instruction;
		                     * interpreter doesn't process Op_breakpoint.
		                     */
		bnum = breakpoint_triggered(pc->break_pt);
		if (bnum > 0) {
			stop.break_point = bnum;
			stop.print_frame = true;
			return true;
		}
	}
	return false;
}

/* restart --- restart the debugger */

static void
restart(bool run)
{
	/* save state in the environment after serialization */
	serialize_list(BREAK);
	serialize_list(WATCH);
	serialize_list(DISPLAY);
	serialize_list(HISTORY);
	serialize_list(OPTION);

	/* tell the new process to restore state from the environment */
	setenv("DGAWK_RESTART", (run ? "true" : "false"), 1);

	/* close all open files */
	close_all();

	/* start a new process replacing the current process */
	execvp(d_argv[0], d_argv);

	/* execvp failed !!! */
	fprintf(out_fp, _("Failed to restart debugger"));
	exit(EXIT_FAILURE);
}

/* do_run --- run command */

int
do_run(CMDARG *arg ATTRIBUTE_UNUSED, int cmd ATTRIBUTE_UNUSED)
{
	if (prog_running) {
		if (! input_from_tty)
			need_restart = true;	/* handled later */
		else {
			need_restart = prompt_yes_no(
			         _("Program already running. Restart from beginning (y/n)? "),
			         _("y")[0], false, out_fp);

			if (! need_restart) {
				fprintf(out_fp, _("Program not restarted\n"));
				return false;
			}
		}
	}

	if (need_restart) {
		/* avoid endless cycles of restarting */
		if (command_file != NULL) {
			/* input_from_tty = false */
			fprintf(stderr, _("error: cannot restart, operation not allowed\n"));
			exit(EXIT_FAILURE);
		}

		if (cmd_src->cmd == D_source) {
			/* input_from_tty = false */
			fprintf(out_fp, _("error (%s): cannot restart, ignoring rest of the commands\n"), cmd_src->str);
			pop_cmd_src();
			return false;
		}

		restart(true);	/* does not return */
	}

	fprintf(out_fp, _("Starting program:\n"));

	prog_running = true;
	fatal_tag_valid = 1;
	if (setjmp(fatal_tag) == 0)
		(void) interpret(code_block);

	fatal_tag_valid = 0;
	prog_running = false;
	fprintf(out_fp, (! exiting && exit_val != EXIT_SUCCESS)
				? _("Program exited abnormally with exit value: %d\n")
				: _("Program exited normally with exit value: %d\n"),
			exit_val);
	need_restart = true;
	return false;
}

/* do_quit --- quit command */

int
do_quit(CMDARG *arg ATTRIBUTE_UNUSED, int cmd ATTRIBUTE_UNUSED)
{
	bool terminate = true;
	if (prog_running)
		terminate = prompt_yes_no(
		            _("The program is running. Exit anyway (y/n)? "),
		            _("y")[0], true, out_fp);
	if (terminate) {
		close_all();
		do_trace = false; 	/* don't save 'trace on' */

#ifdef HAVE_LIBREADLINE
		if (do_save_history && input_from_tty) {
			int ret;
			ret = write_history(history_file);
			if (ret == 0 && history_length > history_size)
				(void) history_truncate_file(history_file, history_size);
		}
#endif
		if (do_save_options && input_from_tty)
			save_options(options_file);

		exit(exit_val);
	}
	return false;
}

/* do_continue --- continue command */

int
do_continue(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	BREAKPOINT *b;

	CHECK_PROG_RUNNING();
	if (! arg || arg->type != D_int)
		return true;

	/* arg is breakpoint ignore count if stopped at a breakpoint */
	if (! stop.break_point) {
		fprintf(out_fp, _("Not stopped at any breakpoint; argument ignored.\n"));
		return true;
	}
	b = find_breakpoint(stop.break_point);
	if (b == NULL) {
		d_error(_("invalid breakpoint number %d"), stop.break_point);
		return false;
	}
	b->flags |= BP_IGNORE;
	b->ignore_count = arg->a_int;
	fprintf(out_fp, _("Will ignore next %ld crossings of breakpoint %d.\n"),
				b->ignore_count, stop.break_point);
	return true;
}

/* next_step --- common code for next and step commands */

static int
next_step(CMDARG *arg, int cmd)
{
	CHECK_PROG_RUNNING();
	if (arg != NULL && arg->type == D_int)
		stop.repeat_count = arg->a_int;
	else
		stop.repeat_count = 1;
	stop.command = (enum argtype) cmd;
	return true;
}

/* check_step --- process step command, return true if stopping */

static int
check_step(INSTRUCTION **pi)
{
	if (fcall_count != stop.fcall_count) {
		stop.fcall_count = fcall_count;
		stop.sourceline = sourceline;
		stop.source = source;
		stop.print_frame = true;
		return (--stop.repeat_count == 0);
	}

	if (source != stop.source) {
		stop.source = source;
		stop.sourceline = sourceline;
		return (--stop.repeat_count == 0);
	}

	if (sourceline != stop.sourceline) {
		stop.sourceline = sourceline;
		return (--stop.repeat_count == 0);
	}
	return false;
}

/* do_step -- process step command, return true if stopping */

int
do_step(CMDARG *arg, int cmd)
{
	int ret;
	ret = next_step(arg, cmd);
	if (ret) {
		stop.fcall_count = fcall_count;
		stop.source = source;
		stop.sourceline = sourceline;
		stop.check_func = check_step;
	}
	return ret;
}

/* do_stepi -- process stepi command, return true if stopping */

static int
check_stepi(INSTRUCTION **pi)
{
	return (--stop.repeat_count == 0);
}

/* do_stepi -- stepi command */

int
do_stepi(CMDARG *arg, int cmd)
{
	int ret;
	ret = next_step(arg, cmd);
	if (ret)
		stop.check_func = check_stepi;
	return ret;
}


/* check_next -- process next command returning true if stopping */

static int
check_next(INSTRUCTION **pi)
{
	/* make sure not to step inside function calls */

	if (fcall_count < stop.fcall_count) {
		stop.fcall_count = fcall_count;
		stop.sourceline = sourceline;
		stop.source = source;
		stop.print_frame = true;
		return (--stop.repeat_count == 0);
	}

	if (fcall_count == stop.fcall_count) {
		if (source != stop.source) {
			stop.source = source;
			stop.sourceline = sourceline;
			return (--stop.repeat_count == 0);
		}
		if (sourceline != stop.sourceline) {
			stop.sourceline = sourceline;
			return (--stop.repeat_count == 0);
		}
	}

#if 0
	/* redundant ? */
	if (fcall_count > stop.fcall_count) {
		stop.source = source;
		stop.sourceline = sourceline;
	}
#endif

	return false;
}

/* do_next -- next command */

int
do_next(CMDARG *arg, int cmd)
{
	int ret;

	ret = next_step(arg, cmd);
	if (ret) {
		stop.source = source;
		stop.sourceline = sourceline;
		stop.fcall_count = fcall_count;
		stop.check_func = check_next;
	}
	return ret;
}

/* check_nexti --- process nexti command, returns true if stopping */

static int
check_nexti(INSTRUCTION **pi)
{
	/* make sure not to step inside function calls */

	if (fcall_count < stop.fcall_count) {
		stop.print_frame = true;
		stop.fcall_count = fcall_count;
	}
	return (fcall_count == stop.fcall_count
			&& --stop.repeat_count == 0);
}

/* do_nexti -- nexti command */

int
do_nexti(CMDARG *arg, int cmd)
{
	int ret;

	ret = next_step(arg, cmd);
	if (ret) {
		stop.fcall_count = fcall_count;
		stop.check_func = check_nexti;
	}
	return ret;
}

/* check_finish --- process finish command, returns true if stopping */

static int
check_finish(INSTRUCTION **pi)
{
	if (fcall_count == stop.fcall_count) {
		stop.print_frame = true;
		return true;
	}
	return false;
}

/* do_finish --- finish command */

int
do_finish(CMDARG *arg ATTRIBUTE_UNUSED, int cmd)
{
	CHECK_PROG_RUNNING();
	if (cur_frame == fcall_count) {
		fprintf(out_fp,
			_("'finish' not meaningful in the outermost frame main()\n"));
		return false;
	}
	stop.fcall_count = fcall_count - cur_frame - 1;
	assert(stop.fcall_count >= 0);
	fprintf(out_fp, _("Run until return from "));
	print_numbered_frame(cur_frame);
	stop.check_func = check_finish;
	stop.command = (enum argtype) cmd;
	stop.print_ret = true;
	return true;
}

/* check_return --- process return, returns true if stopping */

static int
check_return(INSTRUCTION **pi)
{
	assert(fcall_count >= stop.fcall_count);

	if (fcall_count == stop.fcall_count) {
		stop.print_frame = true;
		return true;
	}

	if (fcall_count > stop.fcall_count) {	/* innermost frame just returned */
		/* force this one to return too */
		NODE *func;

		func = find_frame(cur_frame)->func_node;
		assert(func != NULL);
		*pi = (func->code_ptr + 1)->lasti;
		/* assert((*pi)->opcode == Op_K_return); */
	}

	return false;
}

/* do_return --- return command */

int
do_return(CMDARG *arg, int cmd)
{
	NODE *func, *n;

	CHECK_PROG_RUNNING();
	func = find_frame(cur_frame)->func_node;
	if (func == NULL) {
		fprintf(out_fp, _("'return' not meaningful in the outermost frame main()\n"));
		return false;
	}

	stop.fcall_count = fcall_count - cur_frame - 1;
	assert(stop.fcall_count >= 0);
	stop.pc = (func->code_ptr + 1)->lasti;
	assert(stop.pc->opcode == Op_K_return);
	stop.command = (enum argtype) cmd;

	stop.check_func = check_return;

	if (arg != NULL && arg->type == D_node)	/* optional return value */
		n = dupnode(arg->a_node);
	else
		n = dupnode(Nnull_string);
	PUSH(n);

	return true;
}

/* check_until --- process until, returns true if stopping */

static int
check_until(INSTRUCTION **pi)
{
	if (fcall_count < stop.fcall_count) { /* current stack frame returned */
		stop.print_frame = true;
		return true;
	} else if (fcall_count == stop.fcall_count) {
		if (stop.pc && *pi == stop.pc)		/* until location */
			return true;
		if (stop.sourceline > 0		/* until */
				&& source == stop.source
				&& sourceline > stop.sourceline)
			return true;
	}
	return false;
}

/* do_until --- until command */

int
do_until(CMDARG *arg, int cmd)
{
	SRCFILE *s = cur_srcfile;
	char *src = cur_srcfile->src;
	int lineno;
	INSTRUCTION *rp, *ip;
	NODE *func;

	CHECK_PROG_RUNNING();
	stop.pc = NULL;
	stop.sourceline = 0;

	if (arg == NULL) {	/* until without argument */

    /* GDB doc.: continue running until a source line past the current line,
     * in the current stack frame, is reached. Is used to avoid single
     * stepping through a loop more than once. ...
     * This means that when you reach the end of a loop after single
     * stepping though it, until makes your program continue execution
     * until it exits the loop. In contrast, a next command at the end
     * of a loop simply steps back to the beginning of the loop, which
     * forces you to step through the next iteration.
     */

		stop.source = source;
		stop.sourceline = sourceline;
		stop.fcall_count = fcall_count - cur_frame;
		stop.check_func = check_until;
		stop.command = (enum argtype) cmd;
		return true;
	}

    /* GDB: until location - continue running program until
     * either the specified location is reached, or the
     * current stack frame returns.
     */

	switch (arg->type) {
	case D_string:	/* until filename : lineno|function */
		s = source_find(arg->a_string);
		arg = arg->next;
		if (s == NULL || arg == NULL
				|| (arg->type != D_int && arg->type != D_func))
			return false;
		src = s->src;
		if (arg->type == D_func)
			goto func;
		/* fall through */
	case D_int:	/* until lineno */
		lineno = arg->a_int;
		if (lineno <= 0 || lineno > s->srclines) {
			d_error(_("line number %d in file `%s' out of range"),
						lineno, src);
			return false;
		}
		break;

	case D_func:	/* until function */
func:
		func = arg->a_node;
		rp = func->code_ptr;
		for (ip = rp->nexti; ip; ip = ip->nexti) {
			if (ip->opcode != Op_breakpoint && ip->source_line > 0) {
				stop.pc = ip;
				stop.fcall_count = fcall_count - cur_frame;
				stop.check_func = check_until;
				stop.command = (enum argtype) cmd;
				return true;
			}
		}
		fprintf(out_fp, _("cannot find specified location in function `%s'\n"),
				func->vname);
		/* fall through */
	default:
		return false;
	}

	if ((rp = find_rule(src, lineno)) == NULL) {
		d_error(_("invalid source line %d in file `%s'"), lineno, src);
		return false;
	}

	for (ip = rp->nexti; ip; ip = ip->nexti) {
		if (ip->opcode != Op_breakpoint && ip->source_line >= lineno) {
			stop.pc = ip;
			stop.fcall_count = fcall_count - cur_frame;
			stop.check_func = check_until;
			stop.command = (enum argtype) cmd;
			return true;
		}
		if (ip == (rp + 1)->lasti)
			break;
	}
	fprintf(out_fp, _("cannot find specified location %d in file `%s'\n"),
				lineno, src);
	return false;
}

/* print_watch_item --- print watched item name, old and current values */

static void
print_watch_item(struct list_item *w)
{
	NODE *symbol, *sub;
	int i;

	symbol = w->symbol;
	if (IS_SUBSCRIPT(w)) {
		fprintf(out_fp, "%s", w->sname);
		for (i = 0; i < w->num_subs; i++) {
			sub = w->subs[i];
			fprintf(out_fp, "[\"%.*s\"]", (int) sub->stlen, sub->stptr);
		}
		fprintf(out_fp, "\n");
	} else if (IS_FIELD(w))
		fprintf(out_fp, "$%ld\n", get_number_si(symbol));
	else
		fprintf(out_fp, "%s\n", w->sname);


#define print_value(X, S, V)                                        \
if (X)                                                              \
	fprintf(out_fp, "array, %ld elements\n", w->S);                 \
else if (! w->V)                                                    \
	fprintf(out_fp, IS_SUBSCRIPT(w) ?                               \
			_("element not in array\n") : _("untyped variable\n")); \
else                                                                \
	valinfo(w->V, fprintf, out_fp);

	fprintf(out_fp, "  Old value: ");
	print_value((w->flags & OLD_IS_ARRAY) != 0, old_size, old_value);
	fprintf(out_fp, "  New value: ");
	print_value((w->flags & CUR_IS_ARRAY) != 0, cur_size, cur_value);

#undef print_value
}

/* next_command --- (optionally) print stoppage location and reason;
 *                  also fetch next debug command from the user.
 */

static void
next_command()
{
	static int last_rule = 0;
	struct list_item *d = NULL, *w = NULL;
	BREAKPOINT *b = NULL;
	SRCFILE *s;

	if (source == NULL) {
		stop.command = D_illegal;
		stop.check_func = NULL;
		return;
	}

	if (stop.break_point) {
		b = find_breakpoint(stop.break_point);
		assert(b != NULL);
		if (b->silent)
			goto no_output;
	} else if (stop.watch_point) {
		w = find_item(&watch_list, stop.watch_point);
		if (w->silent)
			goto no_output;
	}

	if (cur_rule != last_rule) {
		fprintf(out_fp, _("Stopping in %s ...\n"), ruletab[cur_rule]);
		last_rule = cur_rule;
	}

	if (b != NULL)
		fprintf(out_fp, "Breakpoint %d, ", b->number);
	else if (w != NULL) {
		fprintf(out_fp, "Watchpoint %d: ", w->number);
		print_watch_item(w);
	}

	/* frame info */
	if (stop.print_frame) {
		print_frame(frame_ptr->func_node, source, sourceline);
		fprintf(out_fp, "\n");
		stop.print_frame = false;
	}

	(void) print_lines(source, sourceline, 1);

	/* automatic display of variables */
	for (d = display_list.prev; d != &display_list; d = d->prev)
		display(d);

no_output:
	/* update last_printed_line, so that  output of 'list' is
	 * centered around current sourceline
	 */

	last_printed_line = sourceline - list_size / 2;
	if (last_printed_line < 0)
		last_printed_line = 0;

	/* update current source file */
	s = source_find(source);
	if (cur_srcfile != s) {
		if (cur_srcfile->fd != INVALID_HANDLE) {
			close(cur_srcfile->fd);
			cur_srcfile->fd = INVALID_HANDLE;
		}
		cur_srcfile = s;
	}

	stop.command = D_illegal;
	stop.check_func = NULL;

	if (b != NULL) {
		int ret;
		ret = execute_commands(&b->commands);
		if ((b->flags & BP_TEMP) != 0)
			delete_breakpoint(b);
		if (ret)	/* resume execution */
			return;
	} else if (w != NULL && execute_commands(&w->commands))
		return;

	read_command();		/* zzparse */
}

/* debug_post_execute --- post_hook in the interpreter */

static void
debug_post_execute(INSTRUCTION *pc)
{
	if (! in_main_context())
		return;

	switch (pc->opcode) {
	case Op_K_next:
	case Op_K_nextfile:
	case Op_K_exit:
		if (stop.command == D_finish) {
			/* cancel finish command */
			stop.print_ret = false;
			stop.print_frame = false;
			stop.command = D_illegal;
			stop.check_func = NULL;
			fprintf(out_fp, _("'finish' not meaningful with non-local jump '%s'\n"),
							op2str(pc->opcode));
		} else if (stop.command == D_until) {
			/* cancel until command */
			stop.print_frame = false;
			stop.command = D_illegal;
			stop.check_func = NULL;
			fprintf(out_fp, _("'until' not meaningful with non-local jump '%s'\n"),
							op2str(pc->opcode));
		}
		break;

	case Op_K_return:
		if (stop.command == D_finish
				&& fcall_count == stop.fcall_count
				&& stop.print_ret
		) {
			NODE *r;
			/* print the returned value before it disappears. */
			r = TOP();
			fprintf(out_fp, "Returned value = ");
			valinfo(r, fprintf, out_fp);
			stop.print_ret = false;
		}
		break;

	case Op_newfile:
	case Op_get_record:
		return;

	default:
		break;
	}
}

/* debug_pre_execute --- pre_hook, called by the interpreter before execution;
 *                 checks if execution needs to be suspended and control
 *                 transferred to the debugger.
 */

static int
debug_pre_execute(INSTRUCTION **pi)
{
	static bool cant_stop = false;
	NODE *m;

	if (! in_main_context())
		return pre_execute_code(pi);

	cur_pc = *pi;
	stop.break_point = 0;
	stop.watch_point = 0;
	cur_frame = 0;

	if (do_trace
		&& cur_pc->opcode != Op_breakpoint
		&& stop.command != D_return
	)
		print_instruction(cur_pc, fprintf, out_fp, false);

/* N.B.: For Op_field_spec_lhs must execute instructions upto Op_field_assign
 * as a group before stopping. Otherwise, watch/print of field variables
 * yield surprising results. Ditto for Op_push_lhs for special variables
 * (upto Op_var_assign, the set_FOO routine).
 */

	switch (cur_pc->opcode) {
	case Op_field_spec_lhs:
		cant_stop = true;
		break;

	case Op_field_assign:
		cant_stop = false;
		return true; /* may stop at next instruction */

	case Op_push_lhs:
		m = cur_pc->memory;
		if (m->type == Node_var && m->var_assign)
			cant_stop = true;
		break;

	case Op_arrayfor_incr:	/* can have special var as array variable !!! */
		m = cur_pc->array_var;
		if (m->type == Node_var && m->var_assign)
			cant_stop = true;
		break;

	case Op_var_assign:
		cant_stop = false;
		return true; /* may stop at next instruction */

	case Op_rule:
		cur_rule = cur_pc->in_rule;
		return true;

	case Op_func:
	case Op_var_update:
		return true;

	case Op_breakpoint:
		break;	/* processed later in check_breakpoint() */

	default:
		if (cur_pc->source_line <= 0)
			return true;
		break;
	}

	if (cant_stop)
		return true;

	assert(sourceline > 0);

	/*
	 * 11/2015: This used to check breakpoints first, but that could
	 * produce strange behavior, where a watchpoint doesn't print until
	 * some time after the data changed.  This reworks things so that
	 * watchpoints are checked first. It's a bit of a hack, but
	 * the behavior for the user is more logical.
	 */
	if (check_watchpoint()) {
		next_command();	/* return to debugger interface */
		if (stop.command == D_return)
			*pi = stop.pc;	/* jump to this instruction */
		else if (cur_pc->opcode == Op_breakpoint)
			cur_pc = cur_pc->nexti;    /* skip past the breakpoint instruction */
	} else if (check_breakpoint(pi)
			|| (stop.check_func && stop.check_func(pi))) {
		next_command();	/* return to debugger interface */
		if (stop.command == D_return)
			*pi = stop.pc;	/* jump to this instruction */
	}

	/* if cur_pc == *pi, interpreter executes cur_pc;
	 * Otherwise, jumps to instruction *pi.
	 */
	return (cur_pc == *pi);
}

/* print_memory --- print a scalar value */

static void
print_memory(NODE *m, NODE *func, Func_print print_func, FILE *fp)
{
	switch (m->type) {
	case Node_val:
		if (m == Nnull_string)
			print_func(fp, "Nnull_string");
		else if ((m->flags & NUMBER) != 0) {
#ifdef HAVE_MPFR
			if ((m->flags & MPFN) != 0)
				print_func(fp, "%s", mpg_fmt("%R*g", ROUND_MODE, m->mpg_numbr));
			else if ((m->flags & MPZN) != 0)
				print_func(fp, "%s", mpg_fmt("%Zd", m->mpg_i));
			else
#endif
				print_func(fp, "%g", m->numbr);
		} else if ((m->flags & STRING) != 0)
			pp_string_fp(print_func, fp, m->stptr, m->stlen, '"', false);
		else if ((m->flags & REGEX) != 0) {
			print_func(fp, "@");
			pp_string_fp(print_func, fp, m->stptr, m->stlen, '/', false);
		} else
			print_func(fp, "-?-");
		print_func(fp, " [%s]", flags2str(m->flags));
		break;

	case Node_regex:
		pp_string_fp(print_func, fp, m->re_exp->stptr, m->re_exp->stlen, '/', false);
		break;

	case Node_dynregex:
		break;

	case Node_param_list:
		assert(func != NULL);
		print_func(fp, "%s", func->fparms[m->param_cnt].param);
		break;

	case Node_var:
	case Node_var_new:
	case Node_var_array:
		print_func(fp, "%s", m->vname);
		break;

	case Node_elem_new:
		print_func(fp, "element - %p", m);
		break;

	default:
		print_func(fp, "?");  /* can't happen */
	}
}

/* print_instruction --- print a bytecode */

static void
print_instruction(INSTRUCTION *pc, Func_print print_func, FILE *fp, int in_dump)
{
	int pcount = 0;
	static NODE *func = NULL;
	static int noffset = 0;

	if (noffset == 0) {
		static char buf[50];
		/* offset for 2nd to last lines in a multi-line output */
		noffset = sprintf(buf, "[      :" PTRFMT "] %-20.20s: ", (void *) pc,
				opcode2str(pc->opcode));
	}

	if (pc->opcode == Op_func) {
		func = pc->func_body;
		pcount = func->param_cnt;
		if (in_dump) {
			int j;
			print_func(fp, "\n\t# Function: %s (", func->vname);
			for (j = 0; j < pcount; j++) {
				print_func(fp, "%s", func->fparms[j].param);
				if (j < pcount - 1)
					print_func(fp, ", ");
			}
			print_func(fp, ")\n\n");
		}
	} else if (pc->opcode == Op_rule) {
		if (in_dump)
			print_func(fp, "\n\t# %s\n\n", ruletab[pc->in_rule]);
	}

	if (pc->opcode == Op_newfile)
		print_func(fp, "\n");

	if (pc->source_line <= 0)
		print_func(fp, "[      :" PTRFMT "] %-20.20s: ", pc, opcode2str(pc->opcode));
	else
		print_func(fp, "[%6d:" PTRFMT "] %-20.20s: ",
		                pc->source_line, pc, opcode2str(pc->opcode));

	if (prog_running && ! in_dump) {
		/* find Node_func if in function */
		func = find_frame(0)->func_node;
	}


	switch (pc->opcode) {
	case Op_K_if:
		print_func(fp, "[branch_if = " PTRFMT "] [branch_else = " PTRFMT "] [branch_else->lasti = " PTRFMT "]\n",
				pc->branch_if, pc->branch_else, pc->branch_else->lasti);
		break;

	case Op_K_else:
		print_func(fp, "[branch_end = " PTRFMT "]\n", pc->branch_end);
		break;

	case Op_K_while:
		print_func(fp, "[while_body = " PTRFMT "] [target_break = " PTRFMT "]\n", (pc+1)->while_body, pc->target_break);
		break;

	case Op_K_do:
		print_func(fp, "[doloop_cond = " PTRFMT "] [target_break = " PTRFMT "]", (pc+1)->doloop_cond, pc->target_break);
		if (pc->comment)
			print_func(fp, " [comment = " PTRFMT "]", pc->comment);
		print_func(fp, "\n");
		if (pc->comment)
			print_instruction(pc->comment, print_func, fp, in_dump);
		break;

	case Op_K_for:
		print_func(fp, "[forloop_cond = " PTRFMT "] ", (pc+1)->forloop_cond);
		/* fall through */
	case Op_K_arrayfor:
		print_func(fp, "[forloop_body = " PTRFMT "] ", (pc+1)->forloop_body);
		print_func(fp, "[target_break = " PTRFMT "] [target_continue = " PTRFMT "]", pc->target_break, pc->target_continue);
		if (pc->comment != NULL) {
			print_func(fp, " [comment = " PTRFMT "]\n", (pc)->comment);
			print_instruction(pc->comment, print_func, fp, in_dump);
		} else
			print_func(fp, "\n");
		break;

	case Op_K_switch:
	{
		bool need_newline = false;
		print_func(fp, "[switch_start = " PTRFMT "] [switch_end = " PTRFMT "]\n", (pc+1)->switch_start, (pc+1)->switch_end);
		if (pc->comment || (pc+1)->switch_end->comment)
			print_func(fp, "%*s", noffset, "");
		if (pc->comment) {
			print_func(fp, "[start_comment = " PTRFMT "]", pc->comment);
			need_newline = true;
		}
		if ((pc+1)->switch_end->comment) {
			print_func(fp, "[end_comment = " PTRFMT "]", (pc + 1)->switch_end->comment);
			need_newline = true;
		}
		if (need_newline)
			print_func(fp, "\n");
		if (pc->comment)
			print_instruction(pc->comment, print_func, fp, in_dump);
		if ((pc+1)->switch_end->comment)
			print_instruction((pc+1)->switch_end->comment, print_func, fp, in_dump);
	}
		break;

	case Op_K_default:
		print_func(fp, "[stmt_start = " PTRFMT "] [stmt_end = " PTRFMT "]", pc->stmt_start, pc->stmt_end);
		if (pc->comment) {
			print_func(fp, " [comment = " PTRFMT "]\n", pc->comment);
			print_instruction(pc->comment, print_func, fp, in_dump);
		} else
			print_func(fp, "\n");
		break;

	case Op_var_update:
		print_func(fp, "[update_%s()]\n", get_spec_varname(pc->update_var));
		break;

	case Op_var_assign:
		print_func(fp, "[set_%s()]", get_spec_varname(pc->assign_var));
		if (pc->assign_ctxt != 0)
			print_func(fp, " [assign_ctxt = %s]", opcode2str((OPCODE) pc->assign_ctxt));
		print_func(fp, "\n");
		break;

	case Op_field_assign:
		print_func(fp, "[%s]\n", pc->field_assign == reset_record ?
					"reset_record()" : "invalidate_field0()");
		break;

	case Op_field_spec_lhs:
		print_func(fp, "[target_assign = " PTRFMT "] [do_reference = %s]\n",
				pc->target_assign, pc->do_reference ? "true" : "false");
		break;

	case Op_func:
		print_func(fp, "[param_cnt = %d] [source_file = %s]", pcount,
				pc->source_file ? pc->source_file : "cmd. line");
		if (pc[3].nexti != NULL) {
			print_func(fp, "[ns_list = " PTRFMT "]\n", pc[3].nexti);
			print_ns_list(pc[3].nexti, print_func, fp, in_dump);
		} else
			print_func(fp, "\n");
		break;

	case Op_K_getline_redir:
		print_func(fp, "[into_var = %s] [redir_type = \"%s\"]\n",
		                pc->into_var ? "true" : "false",
		                redir2str(pc->redir_type));
		break;

	case Op_K_getline:
		print_func(fp, "[into_var = %s]\n", pc->into_var ? "true" : "false");
		print_func(fp, "%*s[target_beginfile = " PTRFMT "] [target_endfile = " PTRFMT "]\n",
		                noffset, "",
		                (pc + 1)->target_beginfile, (pc + 1)->target_endfile);
		break;

	case Op_K_print_rec:
		print_func(fp, "[redir_type = \"%s\"]\n", redir2str(pc->redir_type));
		break;

	case Op_K_print:
	case Op_K_printf:
		print_func(fp, "[expr_count = %ld] [redir_type = \"%s\"]\n",
		                pc->expr_count, redir2str(pc->redir_type));
		break;

	case Op_indirect_func_call:
	case Op_func_call:
		print_func(fp, "[func_name = %s] [arg_count = %ld]\n",
		                pc->func_name, (pc + 1)->expr_count);
		break;

	case Op_K_nextfile:
		print_func(fp, "[target_newfile = " PTRFMT "] [target_endfile = " PTRFMT "]\n",
		                pc->target_newfile, pc->target_endfile);
		break;

	case Op_newfile:
		print_func(fp, "[target_jmp = " PTRFMT "] [target_endfile = " PTRFMT "]\n",
		                pc->target_jmp, pc->target_endfile);
		print_func(fp, "%*s[target_get_record = " PTRFMT "]\n",
		                noffset, "", (pc + 1)->target_get_record);
		break;

	case Op_get_record:
		print_func(fp, "[target_newfile = " PTRFMT "]\n", pc->target_newfile);
		break;

	case Op_jmp:
	case Op_jmp_false:
	case Op_jmp_true:
	case Op_and:
	case Op_or:
	case Op_K_next:
	case Op_arrayfor_init:
	case Op_K_break:
	case Op_K_continue:
		print_func(fp, "[target_jmp = " PTRFMT "]\n", pc->target_jmp);
		break;

	case Op_K_exit:
		print_func(fp, "[target_end = " PTRFMT "] [target_atexit = " PTRFMT "]\n",
						pc->target_end, pc->target_atexit);
		break;

	case Op_K_case:
		print_func(fp, "[target_jmp = " PTRFMT "] [match_exp = %s]",
						pc->target_jmp,	(pc + 1)->match_exp ? "true" : "false");
		if (pc->comment) {
			print_func(fp, " [comment = " PTRFMT "]\n", pc->comment);
			print_instruction(pc->comment, print_func, fp, in_dump);
		} else
			print_func(fp, "\n");
		break;

	case Op_K_namespace:
		print_func(fp, "[namespace = %s]", pc->ns_name);
		if (pc->nexti)
			print_func(fp, "[nexti = " PTRFMT "]", pc->nexti);
		if (pc->comment)
			print_func(fp, "[comment = " PTRFMT "]", pc->comment);
		print_func(fp, "\n");
		break;

	case Op_arrayfor_incr:
		print_func(fp, "[array_var = %s] [target_jmp = " PTRFMT "]\n",
		                pc->array_var->type == Node_param_list ?
		                   func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,
		                pc->target_jmp);
		break;

	case Op_line_range:
		print_func(fp, "[triggered = %ld] [target_jmp = " PTRFMT "]\n",
		                pc->triggered, pc->target_jmp);
		break;

	case Op_cond_pair:
		print_func(fp, "[line_range = " PTRFMT "] [target_jmp = " PTRFMT "]\n",
		                pc->line_range, pc->target_jmp);
		break;

	case Op_sub_builtin:
	{
		const char *fname = "sub";
		static const struct flagtab values[] = {
			{ GSUB, "GSUB" },
			{ GENSUB, "GENSUB" },
			{ LITERAL, "LITERAL" },
			{ 0, NULL }
		};

		if ((pc->sub_flags & GSUB) != 0)
			fname = "gsub";
		else if ((pc->sub_flags & GENSUB) != 0)
			fname = "gensub";
		print_func(fp, "%s [arg_count = %ld] [sub_flags = %s]\n",
				fname, pc->expr_count,
				genflags2str(pc->sub_flags, values));
	}
		break;

	case Op_builtin:
		print_func(fp, "%s [arg_count = %ld]\n", getfname(pc->builtin, false),
						pc->expr_count);
		break;

	case Op_ext_builtin:
		print_func(fp, "%s [arg_count = %ld]\n", (pc + 1)->func_name,
						pc->expr_count);
		break;

	case Op_subscript:
	case Op_sub_array:
		print_func(fp, "[sub_count = %ld]\n", pc->sub_count);
		break;

	case Op_store_sub:
		print_memory(pc->memory, func, print_func, fp);
		print_func(fp, " [sub_count = %ld]\n", pc->expr_count);
		break;

	case Op_subscript_lhs:
		print_func(fp, "[sub_count = %ld] [do_reference = %s]\n",
		                pc->sub_count,
		                pc->do_reference ? "true" : "false");
		break;

	case Op_K_delete:
	case Op_in_array:
		print_func(fp, "[expr_count = %ld]\n", pc->expr_count);
		break;

	case Op_concat:
		/* NB: concat_flag CSVAR only used in grammar, don't display it */
		print_func(fp, "[expr_count = %ld] [concat_flag = %s]\n",
						pc->expr_count,
						(pc->concat_flag & CSUBSEP) != 0 ? "CSUBSEP" : "0");
		break;

	case Op_rule:
		print_func(fp, "[in_rule = %s] [source_file = %s]",
		                ruletab[pc->in_rule],
		                pc->source_file ? pc->source_file : "cmd. line");
		if (pc[3].nexti != NULL) {
			print_func(fp, "[ns_list = " PTRFMT "]\n", pc[3].nexti);
			print_ns_list(pc[3].nexti, print_func, fp, in_dump);
		} else
			print_func(fp, "\n");
		break;

	case Op_lint:
	{
		static const char *const linttypetab[] = {
			"LINT_illegal",
			"LINT_assign_in_cond",
			"LINT_no_effect"
		};
		print_func(fp, "[lint_type = %s]\n", linttypetab[pc->lint_type]);
	}
		break;

	case Op_exec_count:
		print_func(fp, "[exec_count = " EXEC_COUNT_FMT "]\n", pc->exec_count);
		break;

 	case Op_store_var:
		print_memory(pc->memory, func, print_func, fp);
		if (pc->initval != NULL) {
			print_func(fp, " = ");
			print_memory(pc->initval, func, print_func, fp);
		}
		print_func(fp, "\n");
		break;

	case Op_push_lhs:
		print_memory(pc->memory, func, print_func, fp);
		print_func(fp, " [do_reference = %s]\n",
		                pc->do_reference ? "true" : "false");
		break;

	case Op_comment:
		print_memory(pc->memory, func, print_func, fp);
		print_func(fp, " [comment_type = %s]",
			pc->memory->comment_type == EOL_COMMENT ?
						"EOL" : "BLOCK");
		if (pc->comment) {
			print_func(fp, " [comment = " PTRFMT "]\n", pc->comment);
			print_instruction(pc->comment, print_func, fp, in_dump);
		} else
			print_func(fp, "\n");
		break;

	case Op_push_i:
	case Op_push:
	case Op_push_arg:
	case Op_push_arg_untyped:
	case Op_push_param:
	case Op_push_array:
	case Op_push_re:
	case Op_match_rec:
	case Op_match:
	case Op_nomatch:
	case Op_plus_i:
	case Op_minus_i:
	case Op_times_i:
	case Op_exp_i:
	case Op_quotient_i:
	case Op_mod_i:
	case Op_assign_concat:
		print_memory(pc->memory, func, print_func, fp);
		/* fall through */
	default:
		print_func(fp, "\n");
		break;
	}
}

/* do_trace_instruction --- trace command */

int
do_trace_instruction(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	if (arg != NULL && arg->type == D_argument
			&& arg->a_argument == A_TRACE_ON)
		do_trace = true;
	else
		do_trace = false;
	return false;
}

/* print_code --- print a list of instructions */

static int
print_code(INSTRUCTION *pc, void *x)
{
	struct pf_data *data = (struct pf_data *) x;
	for (; pc != NULL; pc = pc->nexti)
		print_instruction(pc, data->print_func, data->fp, data->defn /* in_dump */);
	return 0;
}

/* print_ns_list --- print the list of namespaces */

static void
print_ns_list(INSTRUCTION *pc, Func_print print_func, FILE *fp, int in_dump)
{
	for (; pc != NULL; pc = pc->nexti) {
		print_instruction(pc, print_func, fp, in_dump);
		if (pc->comment != NULL)
			print_instruction(pc->comment, print_func, fp, in_dump);
	}
}

/* do_dump_instructions --- dump command */

int
do_dump_instructions(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	FILE *fp;
  	NODE **funcs;

	if (arg != NULL && arg->type == D_string) {
		/* dump to a file */
		if ((fp = fopen(arg->a_string, "w")) == NULL) {
			d_error(_("could not open `%s' for writing: %s"),
					arg->a_string, strerror(errno));
			return false;
		}
		pf_data.print_func = fprintf;
		pf_data.fp = fp;
		pf_data.defn = true;	/* in_dump = true */
		(void) print_code(code_block, &pf_data);
		funcs = function_list(true);
		(void) foreach_func(funcs,
		                     (int (*)(INSTRUCTION *, void *)) print_code,
		                     &pf_data);
		efree(funcs);
		fclose(fp);
		return false;
	}

	funcs = function_list(true);
	initialize_pager(out_fp);
	if (setjmp(pager_quit_tag) == 0) {
		pf_data.print_func = gprintf;
		pf_data.fp = out_fp;
		pf_data.defn = true;	/* in_dump = true */
		(void) print_code(code_block, &pf_data);
		(void) foreach_func(funcs,
		                    (int (*)(INSTRUCTION *, void *)) print_code,
		                     &pf_data);
	}
	efree(funcs);
	return false;
}

/* do_save --- save command */

int
do_save(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
#if defined(HAVE_LIBREADLINE) && defined(HAVE_HISTORY_LIST)
	FILE *fp;
	HIST_ENTRY **hist_list;
	int i;

	if ((fp = fopen(arg->a_string, "w")) == NULL) {
		d_error(_("could not open `%s' for writing: %s"),
				arg->a_string, strerror(errno));
		return false;
	}

	hist_list = history_list();
	if (hist_list && history_length > sess_history_base) {
		for (i = sess_history_base; hist_list[i] != NULL; i++) {
			char *line;
			line = hist_list[i]->line;

			/* exclude save commands;
			 * N.B.: this test may fail if there is another
			 * command with the same first 2 letters.
			 */

			if (strlen(line) > 1
			    && strncmp(line, "sa", 2) == 0)
				continue;

			fprintf(fp, "%s\n", line);
		}
	}
	fclose(fp);
#endif
	return false;
}

/* do_option --- option command */

int
do_option(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	const struct dbg_option *opt;
	char *name, *value;

	if (arg == NULL) {	/* display all available options and corresponding values */
		for (opt = option_list; opt->name; opt++) {
			if (opt->str_val != NULL)
				fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));
			else
				fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));
		}
		return false;
	}

	name = arg->a_string;
	arg = arg->next;
	value = arg ? arg->a_string : NULL;

	for (opt = option_list; opt->name; opt++) {	/* linear search */
		if (strcmp(name, opt->name) == 0)
			break;
	}
	if (! opt->name)
		return false;

	if (value == NULL) {	/* display current setting */
		if (opt->str_val != NULL)
			fprintf(out_fp, "%s = \"%s\"\n", opt->name, *(opt->str_val));
		else
			fprintf(out_fp, "%s = %d\n", opt->name, *(opt->num_val));
	} else
		(*(opt->assign))(value);
	return false;
}


#ifdef HAVE_LIBREADLINE

/* initialize_pager --- initialize our idea of the terminal size */

void
initialize_pager(FILE *fp)
{
	if (! os_isatty(fileno(fp)) || ! input_from_tty || input_fd != 0) {
		screen_width = INT_MAX;
		screen_height = INT_MAX;
	} else {
		/* get the terminal size from readline. */

		rl_reset_terminal(NULL); /* N.B.: NULL argument means
		                          * "use TERM env variable for terminal name".
		                          */
		rl_get_screen_size(&screen_height, &screen_width);
		if (screen_height <= 1)
			screen_height = INT_MAX;
		if (screen_width <= 1)
			screen_width = INT_MAX;
	}
	pager_lines_printed = 0;
}
#endif

static void
prompt_continue(FILE *fp)
{
	bool quit_pager = false;

	if (os_isatty(fileno(fp)) && input_fd == 0)
		quit_pager = prompt_yes_no(
			// TRANSLATORS: don't translate the 'q' inside the brackets.
	                _("\t------[Enter] to continue or [q] + [Enter] to quit------"),
	                'q', false, fp);
	if (quit_pager)
		longjmp(pager_quit_tag, 1);
	pager_lines_printed = 0;
}

/* gprintf --- like fprintf but allows paging */

int
gprintf(FILE *fp, const char *format, ...)
{
	va_list args;
	static char *buf = NULL;
	static size_t buflen = 0;
	static int bl = 0;
	char *p, *q;
	int nchar;

#define GPRINTF_BUFSIZ 512
	if (buf == NULL) {
		buflen = GPRINTF_BUFSIZ;
		emalloc(buf, char *, buflen * sizeof(char));
	} else if (buflen - bl < GPRINTF_BUFSIZ/2) {
		buflen += GPRINTF_BUFSIZ;
		erealloc(buf, char *, buflen * sizeof(char));
	}
#undef GPRINTF_BUFSIZ

	while (true) {
		va_start(args, format);
		nchar = vsnprintf(buf + bl, buflen - bl, format, args);
		va_end(args);
		if (nchar == 0)
			return 0;
		if (nchar > 0 && nchar < buflen - bl) {
			bl += nchar;
			if (buf[bl-1] != '\n') /* buffer output until see a newline at end */
				return nchar;
			break;
		}

		/* enlarge buffer, and try again */
		buflen *= 2;
		erealloc(buf, char *, buflen * sizeof(char));
	}

	bl = 0;
	for (p = buf; (q = strchr(p, '\n')) != NULL; p = q + 1) {
		int sz = (int) (q - p);

		while (sz > 0) {
			int cnt;
			cnt = sz > screen_width ? screen_width : sz;

			/* do not print partial line before scrolling */
			if (cnt < sz && (pager_lines_printed == (screen_height - 2)))
				prompt_continue(fp);

			if (fwrite(p, sizeof(char), cnt, fp) != cnt)
				return -1;
			if (cnt == sz)
				break;
			else {
				if (++pager_lines_printed == (screen_height - 1))
					prompt_continue(fp);
				sz -= screen_width;
				assert(sz > 0);
				p += cnt;
			}
		}

		fprintf(fp, "\n");
		if (++pager_lines_printed == (screen_height - 1))
			prompt_continue(fp);
		p++;
	}
	return nchar;
}


static int
serialize_subscript(char *buf, int buflen, struct list_item *item)
{
	int bl, nchar, i;
	NODE *sub;

	nchar = snprintf(buf, buflen, "%d%c%d%c%s%c%d%c",
				item->number, FSEP, D_subscript, FSEP, item->sname, FSEP,
				item->num_subs, FSEP);
	if (nchar <= 0)
		return 0;
	else if (nchar >= buflen)	/* need larger buffer */
		return nchar;
 	bl = nchar;
	for (i = 0; i < item->num_subs; i++) {
		sub = item->subs[i];
		nchar = snprintf(buf + bl, buflen - bl, "%lu%c%.*s%c",
					(unsigned long) sub->stlen, FSEP,
					(int) sub->stlen, sub->stptr, FSEP);
		if (nchar <= 0)
			return 0;
		bl += nchar;
		if (bl >= buflen)	/* need larger buffer */
			return bl;
	}
	return bl;
}


/*
 * serialize_list--- convert a list structure to a byte stream and
 *               save in environment.
 */

static void
serialize_list(int type)
{
	static char *buf = NULL;
	static int buflen = 0;
	int bl;
	BREAKPOINT *b = NULL;
	struct list_item *wd = NULL;
	HIST_ENTRY **hist_list = NULL;
	int hist_index = 0;
	struct dbg_option *opt = NULL;
	struct commands_item *commands = NULL, *c;
	int cnum = 0;
	struct condition *cndn = NULL;
	void *ptr, *end_ptr;
#if defined(HAVE_LIBREADLINE) && defined(HAVE_HISTORY_LIST)
	HIST_ENTRY *h = NULL;
#endif

	switch (type) {
	case BREAK:
		end_ptr = (void *) &breakpoints;
		ptr = (void *) breakpoints.prev;
		break;
	case WATCH:
		end_ptr = (void *) &watch_list;
		ptr = (void *) watch_list.prev;
		break;
	case DISPLAY:
		end_ptr = (void *) &display_list;
		ptr = (void *) display_list.prev;
		break;
	case HISTORY:
		hist_list = history_list();
		if (hist_list == NULL) /* empty history list */
			return;
		end_ptr = NULL;
		ptr = (void *) hist_list[0];
		break;
	case OPTION:
	{
		int n;
		n = sizeof(option_list)/sizeof(option_list[0]);
		end_ptr = (void *) &option_list[n - 1];
		ptr = (void *) option_list;
	}
		break;

	default:
		return;
	}

	if (type != HISTORY && ptr == end_ptr)		/* empty list */
		return;

#define SERIALIZE_BUFSIZ 512

	if (buf == NULL) {	/* first time */
		buflen = SERIALIZE_BUFSIZ;
		emalloc(buf, char *, buflen + 1);
	}
	bl = 0;

	while (ptr != end_ptr) {
		int nchar = 0;
		if (buflen - bl < SERIALIZE_BUFSIZ/2) {
enlarge_buffer:
			buflen *= 2;
			erealloc(buf, char *, buflen + 1);
		}

#undef SERIALIZE_BUFSIZ

		/* field seperator is FSEP ('\037'), and the record separator is RSEP ('\036') */

		switch (type) {
		case BREAK:
			b = (BREAKPOINT *) ptr;

			/* src source_line flags ignore_count hit_count number;
			 * commands and condition processed later in the end switch
			 */

			nchar = snprintf(buf + bl, buflen - bl,
			                 "%s%c%d%c%d%c%d%c%d%c%d%c",
			                 b->src, FSEP, b->bpi->source_line, FSEP, b->flags, FSEP,
			                 (int) b->ignore_count, FSEP,
			                 (int) b->hit_count, FSEP, b->number, FSEP);
			cnum = b->number;
			commands = &b->commands;
			cndn = &b->cndn;
			break;
		case DISPLAY:
		case WATCH:
			wd = (struct list_item *) ptr;

			/* subscript    -- number type sname num_subs subs(stlen + stptr) [commands [condition]]
			 * variable     -- number type sname [commands [condition]]
			 * field        -- number type symbol(numbr) [commands [condition]]
			 */

			if (IS_PARAM(wd))	/* exclude parameters */
				nchar = 0;
			else if (IS_SUBSCRIPT(wd))
				nchar = serialize_subscript(buf + bl, buflen - bl, wd);
			else if (IS_FIELD(wd))
				nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%d%c",
				            wd->number, FSEP, D_field, FSEP, (int) get_number_si(wd->symbol), FSEP);
			else
				nchar = snprintf(buf + bl, buflen - bl, "%d%c%d%c%s%c",
				            wd->number, FSEP, D_variable, FSEP, wd->sname, FSEP);
			cnum = wd->number;
			commands = &wd->commands;
			cndn = &wd->cndn;
			break;
		case HISTORY:
#if defined(HAVE_LIBREADLINE) && defined(HAVE_HISTORY_LIST)
			h = (HIST_ENTRY *) ptr;
			nchar = strlen(h->line);
			if (nchar >= buflen - bl)
				goto enlarge_buffer;
			strcpy(buf + bl, h->line);
#endif
			break;
		case OPTION:
			opt = (struct dbg_option *) ptr;
			if (opt->num_val != NULL)
				nchar = snprintf(buf + bl, buflen - bl,
								"%s%c%d%c", opt->name, FSEP, *(opt->num_val), FSEP);
			else
				nchar = snprintf(buf + bl, buflen - bl,
								"%s%c%s%c", opt->name, FSEP, *(opt->str_val), FSEP);
			break;
		default:
			break;
		}

		if (nchar == 0)	/* skip empty history lines etc.*/
			;
		else if (nchar > 0 && nchar  < buflen - bl) {
			bl += nchar;
			buf[bl] = RSEP;	/* record */
			buf[++bl] = '\0';
		} else
			goto enlarge_buffer;

		switch (type) {
		case BREAK:
		case WATCH:
			/* recreate the `commands' command strings including the `commands'
			 * and `end' commands; command seperator is '\034'.
			 * re-parsed in unserialize_list to recover the commands list.
			 * Alternatively, one could encode(serialize) each command and it's arguments.
			 */

			bl--;	/* undo RSEP from above */

			/* compute required room in buffer */
			nchar = 0;
			for (c = commands->next; c != commands; c = c->next) {
				nchar += (strlen(c->cmd_string) + 1);
				if (c->cmd == D_eval) {
					CMDARG *a = c->arg;
					nchar += (strlen(a->a_string) + 1);	/* awk statements */
					nchar += (strlen("end") + 1);
				}
			}

			if (nchar > 0) {	/* non-empty commands list */
				nchar += (strlen("commands ") + 20 /*cnum*/ + 1 /*CSEP*/ + strlen("end") + 1 /*FSEP*/);
				if (nchar >= buflen - bl) {
					buflen = bl + nchar + 1 /*RSEP*/;
					erealloc(buf, char *, buflen + 1);
				}
				nchar = sprintf(buf + bl, "commands %d", cnum);
				bl += nchar;
				buf[bl++] = CSEP;
				for (c = commands->next; c != commands; c = c->next) {
					nchar = strlen(c->cmd_string);
					memcpy(buf + bl, c->cmd_string, nchar);
					bl += nchar;
					buf[bl++] = CSEP;

					if (c->cmd == D_eval) {
						CMDARG *a = c->arg;
						nchar = strlen(a->a_string);	/* statements */
						memcpy(buf + bl, a->a_string, nchar);
						bl += nchar;
						buf[bl++] = CSEP;
						nchar = strlen("end");	/* end of 'eval' */
						memcpy(buf + bl, "end", nchar);
						bl += nchar;
						buf[bl++] = CSEP;
					}
				}
				nchar = strlen("end");	/* end of 'commands' */
				memcpy(buf + bl, "end", nchar);
				bl += nchar;
				buf[bl++] = FSEP;		/* field */
			}
			buf[bl++] = RSEP;		/* record */
			buf[bl] = '\0';

			/* condition expression */
			if (cndn->expr) {
				bl--;	/* undo RSEP from above */
				nchar = strlen(cndn->expr);
				if (nchar + 1 /*FSEP*/ >= buflen - bl) {
					buflen = bl + nchar + 1 /*FSEP*/ + 1 /*RSEP*/;
					erealloc(buf, char *, buflen + 1);
				}
				memcpy(buf + bl, cndn->expr, nchar);
				bl += nchar;
				buf[bl++] = FSEP;		/* field */
				buf[bl++] = RSEP;		/* record */
				buf[bl] = '\0';
			}

			ptr = (type == BREAK) ? (void *) b->prev : (void *) wd->prev;
			break;
		case DISPLAY:
			ptr = (void *) wd->prev;
			break;
		case HISTORY:
			ptr = (void *) hist_list[++hist_index];
			break;
		case OPTION:
			ptr = (void *) (++opt);
			break;
		default:
			break;
		}
	}

	if (bl > 0)	/* non-empty list */
		setenv(env_variable[type], buf, 1);
}


static void
unserialize_commands(char *str, int str_len)
{
	if (str_len <= 0 || str == NULL)
		return;
	commands_string = str;
	commands_string_len = str_len;
	push_cmd_src(INVALID_HANDLE, false, read_commands_string, 0, 0, EXIT_FATAL);
	line_sep = CSEP;
	read_command();		/* forced to return in do_commands */
	pop_cmd_src();
}


/* unserialize_list_item --- create a list_item structure from unserialized data */

static struct list_item *
unserialize_list_item(struct list_item *list, char **pstr, int *pstr_len, int field_cnt)
{
	int num, type, i;
	struct list_item *l;
	NODE *symbol = NULL;
	int sub_cnt = 0, cnt;
	NODE **subs = NULL;

	/* subscript	-- number type sname num_subs subs [commands [condition]]
	 * variable		-- number type sname [commands [condition]]
	 * field		-- number type symbol(numbr) commands [commands [condition]]
	 */

	num = strtol(pstr[0], NULL, 0);
	type = strtol(pstr[1], NULL, 0);

	if (type == D_field) {
		int field_num;
		field_num = strtol(pstr[2], NULL, 0);
		symbol = make_number((AWKNUM) field_num);
		cnt = 3;
	} else {
		char *name;
		name = estrdup(pstr[2], pstr_len[2]);
		symbol = find_symbol(name, NULL);
		efree(name);
		if (symbol == NULL)
			return NULL;
		cnt = 3;
		if (type == D_subscript) {
			int sub_len;
			sub_cnt = strtol(pstr[3], NULL, 0);
			emalloc(subs, NODE **, sub_cnt * sizeof(NODE *));
			cnt++;
			for (i = 0; i < sub_cnt; i++) {
				sub_len = strtol(pstr[cnt], NULL, 0);
				subs[i] = make_string(pstr[cnt + 1], sub_len);
				cnt += 2;
			}
		}
	}

	l = add_item(list, type, symbol, NULL);
	if (type == D_subscript) {
		l->num_subs = sub_cnt;
		l->subs = subs;
	}
	l->number = num;	/* keep same item number across executions */

	if (list == &watch_list) {
		initialize_watch_item(l);
		/* unserialize watchpoint `commands' */
		unserialize_commands(pstr[cnt], pstr_len[cnt]);
		cnt++;
		if (field_cnt > cnt) {
			char *expr;
			expr = estrdup(pstr[cnt], pstr_len[cnt]);
			if (parse_condition(D_watch, l->number, expr) != 0)
				efree(expr);
		}
		if (num > list->number)   /* update list number counter */
			list->number = num;
	} else
		list->number = num;

	return l;
}

/* unserialize_breakpoint --- create a breakpoint structure from unserialized data */

static BREAKPOINT *
unserialize_breakpoint(char **pstr, int *pstr_len, int field_cnt)
{
	char *src;
	int lineno;
	BREAKPOINT *b = NULL;
	INSTRUCTION *rp;
	SRCFILE *s;

	/* src source_line flags ignore_count hit_count number commands [condition] */

	src = estrdup(pstr[0], pstr_len[0]);
	s = source_find(src);
	efree(src);
	if (s == NULL)
		return NULL;
	src = s->src;
	lineno = strtol(pstr[1], NULL, 0);
	if (lineno <= 0 || lineno > s->srclines)
		return NULL;
	rp = find_rule(src, lineno);
	if (rp == NULL
			||  (b = set_breakpoint_at(rp, lineno, true)) == NULL
	)
		return NULL;

	b->flags =  strtol(pstr[2], NULL, 0);
	b->ignore_count = strtol(pstr[3], NULL, 0);
	b->hit_count = strtol(pstr[4], NULL, 0);
	b->number =  strtol(pstr[5], NULL, 0);	/* same number as previous run */

	if (field_cnt > 6)	/* unserialize breakpoint `commands' */
		unserialize_commands(pstr[6], pstr_len[6]);

	if (field_cnt > 7) {	/* condition expression */
		char *expr;
		expr = estrdup(pstr[7], pstr_len[7]);
		if (parse_condition(D_break, b->number, expr) != 0)
			efree(expr);
	}

	if (b->number > watch_list.number)  /* watch and break has same number counter */
		watch_list.number = b->number;  /* update counter */
	return b;
}

/* unserialize_option --- set a debugger option from unserialized data. */

static struct dbg_option *
unserialize_option(char **pstr, int *pstr_len, int field_cnt ATTRIBUTE_UNUSED)
{
	const struct dbg_option *opt;

	for (opt = option_list; opt->name; opt++) {
		if (strncmp(pstr[0], opt->name, pstr_len[0]) == 0) {
			char *value;

			value = estrdup(pstr[1], pstr_len[1]);
			(*(opt->assign))(value);
			efree(value);
			return ((struct dbg_option *) opt);
		}
	}
	return NULL;
}

/* unserialize_list -- reconstruct list from serialized data stored in
 *                environment variable.
 */

static void
unserialize_list(int type)
{
	char *val;
	char *p, *q, *r, *s;
#define MAX_FIELD 30
	static char *pstr[MAX_FIELD];
	static int pstr_len[MAX_FIELD];

	val = getenv(env_variable[type]);
	if (val == NULL)
		return;

	for (p = val; (q = strchr(p, RSEP)) != NULL; p = q + 1) {
		int field_cnt = 0;
		if (type == HISTORY) {
			*q = '\0';
			add_history(p);
			*q = RSEP;
			continue;
		}

		r = p;
		while ((s = strchr(r, FSEP)) != NULL && s < q) {
			pstr[field_cnt] = r;
			pstr_len[field_cnt] = (int) (s - r);
			r = s + 1;
			field_cnt++;
			if (field_cnt == MAX_FIELD)
#ifdef GAWKDEBUG
				fatal("Increase MAX_FIELD and recompile");
#else
				return;
#endif
		}

		switch (type) {
		case BREAK:
			(void) unserialize_breakpoint(pstr, pstr_len, field_cnt);
			break;
		case DISPLAY:
			(void) unserialize_list_item(&display_list, pstr, pstr_len, field_cnt);
			break;
		case WATCH:
			(void) unserialize_list_item(&watch_list, pstr, pstr_len, field_cnt);
			break;
		case OPTION:
			(void) unserialize_option(pstr, pstr_len, field_cnt);
			break;
		case HISTORY:
			/* processed at the beginning of for loop */
			break;
		default:
			break;
		}
	}

#ifdef HAVE_LIBREADLINE
	if (type == HISTORY)
		sess_history_base = history_length;
#endif

	unsetenv(env_variable[type]);
#undef MAX_FIELD
}

static int
prompt_yes_no(const char *mesg, char res_true, int res_default, FILE *fp)
{
	char *in_str;
	int ret = res_default; /* default */

	if (input_from_tty) {
		fprintf(fp, "%s", _(mesg));
		in_str = read_a_line(NULL);
		if (in_str == NULL)	/* EOF */
			exit(EXIT_FAILURE);
		ret = (*in_str == res_true);
		efree(in_str);
	}
	return ret;
}

/* has_break_or_watch_point --- check if given breakpoint or watchpoint
 *                              number exists. When flag any is true,
 *                              check if any breakpoint/watchpoint
 *                              has been set (ignores num). Returns
 *                              type (breakpoint or watchpoint) or 0.
 */

int
has_break_or_watch_point(int *pnum, bool any)
{
	BREAKPOINT *b = NULL;
	struct list_item *w = NULL;

	if (any) {
		if (breakpoints.next != &breakpoints)
			b = breakpoints.next;
		if (watch_list.next != &watch_list)
			w = watch_list.next;

		if (! b && ! w)
			return 0;
		if (b && ! w) {
			*pnum = b->number;
			return D_break;
		}
		if (w && ! b) {
			*pnum = w->number;
			return D_watch;
		}
		if (w->number > b->number) {
			*pnum = w->number;
			return D_watch;
		}
		*pnum = b->number;
		return D_break;
	}

	/* N.B: breakpoints and watchpoints get numbers from a single
	 * counter/sequencer watch_list.number.
	 */

	for (b = breakpoints.next; b != &breakpoints; b = b->next) {
		if (b->number == *pnum)
			return D_break;
	}
	for (w = watch_list.next; w != &watch_list; w = w->next) {
		if (w->number == *pnum)
			return D_watch;
	}

	return 0;
}

/* delete_commands_item --- delete item(command) from `commands' list. */

static void
delete_commands_item(struct commands_item *c)
{
	efree(c->cmd_string);
	free_cmdarg(c->arg);
	c->next->prev = c->prev;
	c->prev->next = c->next;
	efree(c);
}

/* do_commands --- commands command */

int
do_commands(CMDARG *arg, int cmd)
{
	static BREAKPOINT *b;
	static struct list_item *w;
	static struct commands_item *commands;
	struct commands_item *c;

	if (cmd == D_commands) {
		int num = -1, type;
		if (arg == NULL)
			type = has_break_or_watch_point(&num, true);
		else {
			num = arg->a_int;
			type = has_break_or_watch_point(&num, false);
		}
		b = NULL;
		w = NULL;
		if (type == D_break)
			b = find_breakpoint(num);
		else if (type == D_watch)
			w = find_item(&watch_list, num);
		assert((b != NULL) || (w != NULL));
		commands = (b != NULL) ? &b->commands : &w->commands;

		/* delete current commands */
		for (c = commands->next; c != commands; c = c->next) {
			c = c->prev;
			delete_commands_item(c->next);
		}
		return false;

	} else if (cmd == D_end) {
		commands = NULL;
		if (read_a_line == read_commands_string) /* unserializig commands */
			return true;	/* done unserializing, terminate zzparse() */
		return false;

	} else if (cmd == D_silent) {
		if (b != NULL)
			b->silent = true;
		else if (w != NULL)
			w->silent = true;
		/* we also append silent command to the list for use
		 * in `info break(watch)', and to simplify
		 * serialization/unserialization of commands.
		 */
	}

	assert(commands != NULL);

	emalloc(c, struct commands_item *, sizeof(struct commands_item));
	c->next = NULL;
	c->cmd = cmd;

	/* N.B.: first arg is the command string, see command.y */
	c->cmd_string = arg->a_string;
	c->arg = arg->next; /* actual arguments to the command */
	efree(arg);

	/* append to the list */
	c->prev = commands->prev;
	c->next = commands;
	commands->prev = c;
	c->prev->next = c;
	return false;
}

/* execute_commands --- execute breakpoint/watchpoint commands, the first
 *                      command that resumes execution terminates
 *                      commands processing.
 */

static int
execute_commands(struct commands_item *commands)
{
	struct commands_item *c;
	Func_cmd cmd_ptr;
	bool ret = false;

	for (c = commands->next; c != commands; c = c->next) {
		if (c->cmd == D_silent)
			continue;
		cmd_ptr = get_command(c->cmd);		/* command handler */
		ret = (*cmd_ptr)(c->arg, c->cmd);
		if (ret)	/* resume execution (continue, next etc.) */
			break;
	}
	return ret;
}

/* do_print_f --- printf command */

int
do_print_f(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	int count = 0;
	int i;
	CMDARG *a;
	NODE **tmp;
	char *name;
	NODE *r;
	volatile jmp_buf fatal_tag_stack;

	/* count maximum required size for tmp */
	for (a = arg; a != NULL ; a = a->next)
		count++;
	emalloc(tmp, NODE **, count * sizeof(NODE *));

	for (i = 0, a = arg; a != NULL ; i++, a = a->next) {
		switch (a->type) {
		case D_variable:
			name = a->a_string;
			r = find_symbol(name, NULL);
			if (r == NULL)
				goto done;
			if (r->type == Node_var_new || r->type == Node_elem_new)
				tmp[i] = Nnull_string;
			else if (r->type != Node_var) {
				d_error(_("`%s' is not a scalar variable"), name);
				goto done;
			} else
				tmp[i] = r->var_value;
			break;
		case D_field:
		{
			long field_num;
			r = a->a_node;
			field_num = get_number_si(r);
			tmp[i] = *get_field(field_num, NULL);
		}
			break;
		case D_subscript:
		{
			int cnt = a->a_count;
			name = a->a_string;
			r = find_array(name);
			if (r == NULL)
				goto done;

			for (; cnt > 0; cnt--) {
				NODE *value, *subs;
				a = a->next;
				subs = a->a_node;
				value = in_array(r, subs);
				if (cnt == 1) {
					if (value == NULL)
						tmp[i] = Nnull_string;		/* FIXME: goto done ? */
					else if (value->type == Node_var_array) {
						d_error(_("attempt to use array `%s[\"%.*s\"]' in a scalar context"),
									name, (int) subs->stlen, subs->stptr);
						goto done;
					} else
						tmp[i] = value;
				} else {
					if (value == NULL) {
						d_error(_("[\"%.*s\"] not in array `%s'"),
									(int) subs->stlen, subs->stptr, name);
						goto done;
					} else if (value->type != Node_var_array) {
						d_error(_("attempt to use scalar `%s[\"%.*s\"]' as array"),
									name, (int) subs->stlen, subs->stptr);
						goto done;
					} else {
						r = value;
						name = r->vname;
					}
				}
			}
		}
			break;
		case D_node:
			tmp[i] = a->a_node;
			break;
		default:
			break;
		}
	}

	tmp[0] = force_string(tmp[0]);

	PUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);
	if (setjmp(fatal_tag) == 0)
		r = format_args(tmp[0]->stptr, tmp[0]->stlen, tmp, i);
	else {
		/* fatal error, restore exit_val of program */
		exit_val = EXIT_SUCCESS;
		r = NULL;
	}
	POP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);

	if (r != NULL) {
		(void) fwrite(r->stptr, sizeof(char), r->stlen, out_fp);
		unref(r);
	}
done:
	efree(tmp);
	return false;
}

/* do_source --- source command */

int
do_source(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	int fd;
	char *file = arg->a_string;

	fd = open_readfd(file);
	if (fd <= INVALID_HANDLE) {
		d_error(_("cannot open source file `%s' for reading: %s"),
					file, strerror(errno));
		return false;
	}

	push_cmd_src(fd, false, g_readline, close, D_source, EXIT_SUCCESS);
	cmd_src->str = estrdup(file, strlen(file));
	return false;
}

/* open_readfd --- open a file for reading */

static int
open_readfd(const char *file)
{
	int fd;

	fd = open(file, O_RDONLY);
	if (fd <= INVALID_HANDLE)
		return INVALID_HANDLE;
	else if (os_isdir(fd)) {
		(void) close(fd);
		errno = EISDIR;
		return INVALID_HANDLE;
	}
	return fd;
}

/* find_option --- check if option name is valid */

int
find_option(char *name)
{
	const char *p;
	int idx;

	for (idx = 0; (p = option_list[idx].name); idx++) {
		if (strcmp(p, name) == 0)
			return idx;
	}
	return -1;
}

/* option_help --- display help text for debugger options */

void
option_help()
{
	const struct dbg_option *opt;

	for (opt = option_list; opt->name; opt++)
		fprintf(out_fp, "\t%-15.15s - %s\n", opt->name, _(opt->help_txt));
}

#ifdef HAVE_LIBREADLINE

/* option_generator --- generator function for option name completion */

char *
option_generator(const char *text, int state)
{
	static size_t textlen;
	static int idx;
	const char *name;

	if (! state) {	/* first time */
		textlen = strlen(text);
		idx = 0;
	}

	while ((name = option_list[idx++].name)) {
		if (strncmp(name, text, textlen) == 0)
			return estrdup(name, strlen(name));
	}
	return NULL;
}

#endif

/* set_gawk_output --- redirect gawk (normal) output */

static void
set_gawk_output(const char *file)
{
	int fd = INVALID_HANDLE;
	FILE *fp = NULL;

	if (output_fp != stdout) {
		if (output_fp != stderr) {
			fclose(output_fp);
			efree((void*) output_file);
		}
		output_fp = stdout;
		output_is_tty = os_isatty(fileno(stdout));
		output_file = "/dev/stdout";
	}

	if (file == NULL || file[0] == '\0')
		return;

	errno = 0;
	if ((fd = os_devopen(file, O_WRONLY)) != INVALID_HANDLE) {
		fp = fdopen(fd, "w");
		if (fp == NULL)
			close(fd);

	} else if (strncmp(file, "/dev/", 5) == 0) {
		char *cp = (char *) file + 5;

		if (strcmp(cp, "stdout") == 0)
			return;
		if (strcmp(cp, "stderr") == 0) {
			output_fp = stderr;
			output_file = "/dev/stderr";
			output_is_tty = os_isatty(fileno(stderr));
			return;
		}

		if (strncmp(cp, "fd/", 3) == 0) {
			cp += 3;
			fd = (int) strtoul(cp, NULL, 10);
			if (errno == 0 && fd > INVALID_HANDLE) {
				fp = fdopen(fd, "w");
				if (fp == NULL)
					fd = INVALID_HANDLE;
			} else
				fd = INVALID_HANDLE;
		} else {
			/* /dev/ttyN, /dev/pts/N, /dev/null etc. */
			fd = open(file, O_WRONLY);
		}

		if (fd > INVALID_HANDLE && fp == NULL) {
			fp = fdopen(fd, "w");
			if (fp == NULL)
				close(fd);
		}

	} else {
		/* regular file */
		fp = fopen(file, "w");
	}

	if (fp != NULL) {
		output_fp = fp;
		output_file = estrdup(file, strlen(file));
		setbuf(fp, (char *) NULL);
		output_is_tty = os_isatty(fileno(fp));
	} else {
		d_error(_("could not open `%s' for writing: %s"),
					file,
					errno != 0 ? strerror(errno) : _("reason unknown"));
		fprintf(out_fp, _("sending output to stdout\n"));
	}
}

/* set_prompt --- set debugger prompt */

static void
set_prompt(const char *value)
{
	efree((void *) dgawk_prompt);
	dgawk_prompt = estrdup(value, strlen(value));
	dbg_prompt = dgawk_prompt;
}

/* set_option_flag --- convert option string to flag value */

static int
set_option_flag(const char *value)
{
	long n;
	if (strcmp(value, "on") == 0)
		return true;
	if (strcmp(value, "off") == 0)
		return false;
	errno = 0;
	n = strtol(value, NULL, 0);
	return (errno == 0 && n != 0);
}

/* set_option_num --- set integer option value from string */

static void
set_option_num(int *pnum, const char *value)
{
	long n;
	errno = 0;
	n = strtol(value, NULL, 0);
	if (errno == 0 && n > 0)
		*pnum = n;
	else
		d_error(_("invalid number"));
}

/* set_listsize --- set list output window size */

static void
set_listsize(const char *value)
{
	set_option_num(&list_size, value);
}

/* set_trace --- set instruction tracing on or off */

static void
set_trace(const char *value)
{
	do_trace = set_option_flag(value);
}

/* set_save_history --- save history on exit */

static void
set_save_history(const char *value)
{
	do_save_history = set_option_flag(value);
}

/* set_save_options --- save options on exit */

static void
set_save_options(const char *value)
{
	do_save_options = set_option_flag(value);
}

/* set_history_size --- maximum entries in history file */

static void
set_history_size(const char *value)
{
	set_option_num(&history_size, value);
}


/* read_commands_string --- one of the many ways zzlex fetches a line to parse;
 *                          this one is used to parse `commands' string during
 *                          unserialization.
 */

char *
read_commands_string(const char *prompt ATTRIBUTE_UNUSED)
{
	char *p, *end, *line;

	if (commands_string == NULL)
		return NULL;

	p = (char *) commands_string;
	end = (char *) commands_string + commands_string_len;
	for (; p < end; p++) {
		if (*p == line_sep) {
			line = estrdup(commands_string, p - commands_string);
			commands_string = p + 1;
			commands_string_len = end - commands_string;
			return line;
		}
	}

	line = estrdup(commands_string, commands_string_len);
	commands_string = NULL;
	commands_string_len = 0;
	return line;
}

/* save_options --- save current options to file */

static void
save_options(const char *file)
{
	FILE *fp;
	const struct dbg_option *opt;

	fp = fopen(file, "w");
	if (fp == NULL)
		return;

	for (opt = option_list; opt->name; opt++) {
		if (opt->str_val != NULL)
			fprintf(fp, "option %s = \"%s\"\n", opt->name, *(opt->str_val));
		else
			fprintf(fp, "option %s = %d\n", opt->name, *(opt->num_val));
	}
	fclose(fp);
	chmod(file, 0600);
}

/* close_all --- close all open files */

static void
close_all()
{
	bool stdio_problem, got_EPIPE;
	struct command_source *cs;

	(void) nextfile(& curfile, true);	/* close input data file */
	(void) close_io(& stdio_problem, & got_EPIPE);
	if (cur_srcfile->fd != INVALID_HANDLE) {
		close(cur_srcfile->fd);
		cur_srcfile->fd = INVALID_HANDLE;
	}
	for (cs = cmd_src; cs != NULL; cs = cs->next) {
		if (cs->close_func && cs->fd != INVALID_HANDLE) {
			cs->close_func(cs->fd);
			cs->fd = INVALID_HANDLE;
		}
	}

	close_extensions();

	set_gawk_output(NULL);	/* closes output_fp if not stdout */
}

/* pre_execute_code --- pre_hook for execute_code, called by pre_execute */

static int
pre_execute_code(INSTRUCTION **pi)
{
	INSTRUCTION *ei = *pi;

	switch (ei->opcode) {
	case Op_K_exit:
	case Op_K_next:
	case Op_K_nextfile:
	case Op_K_getline:	/* getline without redirection */
		d_error(_("`%s' not allowed in current context;"
				" statement ignored"),
				op2str(ei->opcode));
		*pi = ei->nexti;
		break;
	case Op_K_return_from_eval:
		if (ei->nexti != NULL) {	/* not an implicit return */
			NODE *r;
			d_error(_("`return' not allowed in current context;"
					" statement ignored"));
			/* throw away return value already pushed onto stack */
			r = POP_SCALAR();
			DEREF(r);
			*pi = ei->nexti;
		}
		break;
	default:
		break;
	}
	return (ei == *pi);
}

extern INSTRUCTION *unwind_stack(long n);

static NODE *
execute_code(volatile INSTRUCTION *code)
{
	volatile NODE *r = NULL;
	volatile jmp_buf fatal_tag_stack;
	// long save_stack_size;	// see comment below
	int save_flags = do_flags;

	/* We use one global stack for all contexts.
	 * Save # of items in stack; in case of
	 * a fatal error, pop stack until it has that many items.
	 */

	// save_stack_size = (stack_ptr  - stack_bottom) + 1;	// see comment below
	do_flags = false;

	PUSH_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);
	if (setjmp(fatal_tag) == 0) {
		(void) interpret((INSTRUCTION *) code);
		r = POP_SCALAR();
	} else {	/* fatal error */
		/*
		 * 9/2022:
		 * Initially, the code did this:
		 *
		 * (void) unwind_stack(save_stack_size);
		 *
		 * to attempt to recover and keep going. But a fatal error
		 * can corrupt memory. Instead of trying to recover, just
		 * start over.
		 */
		// Let the user know, but DON'T use the fatal() function!
		fprintf(stderr, _("fatal error during eval, need to restart.\n"));
		// Go back to debugger
		restart(false);		// does not return
	}

	POP_BINDING(fatal_tag_stack, fatal_tag, fatal_tag_valid);
	do_flags = save_flags;
	if (exit_val != EXIT_SUCCESS) {	/* must be EXIT_FATAL? */
		exit_val = EXIT_SUCCESS;
		return NULL;
	}
	return (NODE *) r;
}

/* do_eval --- eval command */

int
do_eval(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	NODE *r, *ret_val;
	NODE *f = NULL;
	NODE *this_frame = NULL, *this_func = NULL;
	NODE **sp;
	INSTRUCTION *eval, *code = NULL;
	AWK_CONTEXT *ctxt;
	int ecount = 0, pcount = 0;
	int ret;
	int save_flags = do_flags;
	SRCFILE *the_source;

	if (prog_running) {
		this_frame = find_frame(0);
		this_func = this_frame->func_node;
	}

	install_params(this_func);	/* expose current function parameters to eval */
	ctxt = new_context();
	ctxt->install_func = append_symbol;	/* keep track of newly installed globals */
	push_context(ctxt);
	the_source = add_srcfile(SRC_CMDLINE, arg->a_string, srcfiles, NULL, NULL);
	do_flags &= DO_MPFR;	// preserve this flag only
	ret = parse_program(&code, true);
	do_flags = save_flags;
	remove_params(this_func);
	if (ret != 0) {
		pop_context();	/* switch to prev context */
		free_context(ctxt, false /* keep_globals */);

		/* Remove @eval from FUNCTAB. */
		NODE *s = make_string("@eval", 5);
		(void) assoc_remove(func_table, s);
		unref(s);

		return false;
	}

	f = lookup("@eval");
	assert(f != NULL);
	if (this_func == NULL) {	/* in main */
		/* do a function call */
		eval = bcalloc(Op_func_call, 2, 0);
		eval->source_file = cur_srcfile->src;
		eval->func_body = f;
		eval->func_name = NULL;	/* not needed, func_body already assigned */
		(eval + 1)->expr_count = 0;
		eval->nexti = bcalloc(Op_stop, 1, 0);

	} else {
		/* execute as a part of the current function */
		int i;
		INSTRUCTION *t;

		eval = f->code_ptr;	/* Op_func */
		eval->source_file = cur_srcfile->src;
		/* turn implicit Op_K_return into Op_stop */
		t = (eval + 1)->lasti;	/* Op_K_return */
		t->opcode = Op_stop;

		/* add or append eval locals to the current frame stack */
		ecount = f->param_cnt;	/* eval local count */
		pcount = this_func->param_cnt;

		if (ecount > 0) {
			if (pcount == 0)
				emalloc(this_frame->stack, NODE **, ecount * sizeof(NODE *));
			else
				erealloc(this_frame->stack, NODE **, (pcount + ecount) * sizeof(NODE *));

			sp = this_frame->stack + pcount;
			for (i = 0; i < ecount; i++) {
				NODE *np;

				np = f->fparms + i;
				np->param_cnt += pcount;	/* appending eval locals: fixup param_cnt */

				getnode(r);
				memset(r, 0, sizeof(NODE));
				*sp++ = r;
				/* local variable */
				r->type = Node_var_new;
				r->vname = np->param;
			}

			this_func->param_cnt += ecount;
		}
	}

#if 0
	pf_data.print_func = fprintf;
	pf_data.fp = out_fp;
	pf_data.defn = false;	/* in_dump = false */
	(void) print_code(f->code_ptr, &pf_data);
#endif

	ret_val = execute_code((volatile INSTRUCTION *) eval);

	if (ret_val != NULL)
		DEREF(ret_val);	/* throw away return value */
	/* else
		fatal error */

	if (this_func != NULL && ecount > 0) {
		int i;

		/* undo frame manipulation from above */

		/* free eval locals */
		sp = this_frame->stack + pcount;
		for (i = ecount; i > 0; i--) {
			r = *sp;
			if (r->type == Node_var)     /* eval local variable */
				DEREF(r->var_value);
			else if (r->type == Node_var_array)     /* eval local array */
				assoc_clear(r);
			freenode(r);
			*sp++ = (NODE *) 0;
		}
		if (pcount == 0) {
			efree(this_frame->stack);
			this_frame->stack = NULL;
		} /* else
				restore_frame() will free it */

		this_func->param_cnt -= ecount;
	}

	/*
	 * Always destroy symbol "@eval", however destroy all newly installed
	 * globals only if fatal error (execute_code() returing NULL).
	 */

	pop_context();	/* switch to prev context */
	free_context(ctxt, (ret_val != NULL));   /* free all instructions and optionally symbols */

	if (ret_val != NULL) {
		/*
		 * Remove @eval from FUNCTAB, so that above code
		 * will work the next time around.
		 */
		NODE *s = make_string("@eval", 5);

		(void) assoc_remove(func_table, s);
		unref(s);
	}

	free(f->vname);
	freenode(f);

	free_srcfile(the_source);

	return false;
}

/*
GDB Documentation:
	... When you use condition, GDB checks expression
immediately for syntactic correctness, and to determine whether symbols
in it have referents in the context of your breakpoint. If expression
uses symbols not referenced in the context of the breakpoint, GDB prints
an error message:

    No symbol "foo" in current context.
*/

static int invalid_symbol = 0;

static void
check_symbol(NODE *r)
{
	invalid_symbol++;
	d_error(_("no symbol `%s' in current context"), r->vname);
	/* install anyway, but keep track of it */
	append_symbol(r);
}

/* parse_condition --- compile a condition expression */

static int
parse_condition(int type, int num, char *expr)
{
	INSTRUCTION *code = NULL;
	AWK_CONTEXT *ctxt = NULL;
	int ret;
	BREAKPOINT *b;
	struct list_item *w;
	NODE *this_func = NULL;
	INSTRUCTION *it, *stop, *rule;
	struct condition *cndn = NULL;
	int save_flags = do_flags;

	if (type == D_break && (b = find_breakpoint(num)) != NULL) {
		INSTRUCTION *rp;
		cndn = &b->cndn;
		rp = find_rule(b->src, b->bpi->source_line);
		if (rp != NULL && rp->opcode == Op_func)
			this_func = rp->func_body;
	} else if (type == D_watch && (w = find_item(&watch_list, num)) != NULL) {
		cndn = &w->cndn;
		this_func = find_frame(cur_frame)->func_node;
	}

	if (cndn == NULL)
		return -1;
	if (expr == NULL)
		goto out;	/* delete condition */

	install_params(this_func);
	ctxt = new_context();
	invalid_symbol = 0;
	ctxt->install_func = check_symbol;
	push_context(ctxt);
	(void) add_srcfile(SRC_CMDLINE, expr, srcfiles, NULL, NULL);
	do_flags = false;
	ret = parse_program(&code, true);
	do_flags = save_flags;
	remove_params(this_func);
	pop_context();

	if (ret != 0 || invalid_symbol) {
		free_context(ctxt, false /* keep_globals */);
		return -1;
	}

	/* condition expression is parsed as awk pattern without
	 * any action. The code is then modified to end up with
	 * a `1.0' on stack when the expression is true, `0.0' otherwise.
	 */

	assert(code != NULL);
	rule = ctxt->rule_list.nexti;
	stop = bcalloc(Op_stop, 1, 0);

	it = rule->firsti;	/* Op_K_print_rec */
	assert(it->opcode == Op_K_print_rec);
	it->opcode = Op_push_i;
	it->memory = make_number(1.0);
	it->nexti = bcalloc(Op_jmp, 1, 0);
	it->nexti->target_jmp = stop;
	it->nexti->nexti = rule->lasti;

	it = rule->lasti;		/* Op_no_op, target for Op_jmp_false */
	assert(it->opcode == Op_no_op);
	it->opcode = Op_push_i;
	it->memory = make_number(0.0);
	it->nexti = stop;

out:
	if (cndn->expr != NULL)
		efree(cndn->expr);
	free_context(cndn->ctxt, false);
	cndn->code = code;
	cndn->expr = expr;
	cndn->ctxt = ctxt;

	return 0;
}

/* do_condition --- condition command */

int
do_condition(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)
{
	int type, num;
	char *expr = NULL;

	num = arg->a_int;
	type = has_break_or_watch_point(&num, false);
	if (! type)
		return false;
	arg = arg->next;	/* condition expression */
	if (arg != NULL)
		expr = arg->a_string;
	if (parse_condition(type, num, expr) == 0 && arg != NULL)
		arg->a_string = NULL;	/* don't let free_cmdarg free it */
	return false;
}

/* in_cmd_src --- check if filename already in cmd_src */

int
in_cmd_src(const char *filename)
{
	struct command_source *cs;
	for (cs = cmd_src; cs != NULL; cs = cs->next) {
		if (cs->str != NULL && strcmp(cs->str, filename) == 0)
			return true;
	}
	return false;
}

int
get_eof_status()
{
	if (cmd_src == NULL)
		return EXIT_FATAL;
	return cmd_src->eof_status;
}

void
push_cmd_src(
	int fd,
	bool istty,
	char * (*readfunc)(const char *),
	int (*closefunc)(int),
	int ctype,
	int eofstatus)
{
	struct command_source *cs;
	emalloc(cs, struct command_source *, sizeof(struct command_source));
	cs->fd = fd;
	cs->is_tty = istty;
	cs->read_func = readfunc;
	cs->close_func = closefunc;
	cs->cmd = ctype;

	/* eof_status = EXIT_FATAL     - exit with status EXIT_FATAL on EOF or error.
	 *            = EXIT_FAILURE   - exit status EXIT_FAILURE on error.
	 *            = EXIT_SUCCESS   - don't exit on EOF or error.
	 */
	cs->eof_status = eofstatus;
	cs->str = NULL;
	cs->next = cmd_src;
	cmd_src = cs;

	input_fd = fd;
	input_from_tty = istty;
	read_a_line = readfunc;
}

int
pop_cmd_src()
{
	struct command_source *cs;

	if (cmd_src->next == NULL)
		return -1;

	cs = cmd_src;
	cmd_src = cs->next;
	if (cs->close_func && cs->fd != INVALID_HANDLE)
		cs->close_func(cs->fd);
	if (cs->str != NULL)
		efree(cs->str);
	efree(cs);

	input_fd = cmd_src->fd;
	input_from_tty = cmd_src->is_tty;
	read_a_line = cmd_src->read_func;
	return 0;
}
/*
 * int_array.c - routines for arrays of integer indices.
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2013, 2016, 2017, 2019, 2020, 2022, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

extern FILE *output_fp;
extern void indent(int indent_level);
extern NODE **is_integer(NODE *symbol, NODE *subs);

static size_t INT_CHAIN_MAX = 10;

static NODE **int_array_init(NODE *symbol, NODE *subs);
static NODE **int_lookup(NODE *symbol, NODE *subs);
static NODE **int_exists(NODE *symbol, NODE *subs);
static NODE **int_clear(NODE *symbol, NODE *subs);
static NODE **int_remove(NODE *symbol, NODE *subs);
static NODE **int_list(NODE *symbol, NODE *t);
static NODE **int_copy(NODE *symbol, NODE *newsymb);
static NODE **int_dump(NODE *symbol, NODE *ndump);

static uint32_t int_hash(uint32_t k, uint32_t hsize);
static inline NODE **int_find(NODE *symbol, long k, uint32_t hash1);
static NODE **int_insert(NODE *symbol, long k, uint32_t hash1);
static void grow_int_table(NODE *symbol);

const array_funcs_t int_array_func = {
	"int",
	int_array_init,
	is_integer,
	int_lookup,
	int_exists,
	int_clear,
	int_remove,
	int_list,
	int_copy,
	int_dump,
	(afunc_t) 0,
};


/* int_array_init --- array initialization routine */

static NODE **
int_array_init(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)
{
	if (symbol == NULL) {	/* first time */
		long newval;

		/* check relevant environment variables */
		if ((newval = getenv_long("INT_CHAIN_MAX")) > 0)
			INT_CHAIN_MAX = newval;
	} else
		null_array(symbol);

	return & success_node;
}

/*
 * standard_integer_string -- check whether the string matches what
 * sprintf("%ld", <value>) would produce. This is accomplished by accepting
 * only strings that look like /^0$/ or /^-?[1-9][0-9]*$/. This should be
 * faster than comparing vs. the results of actually calling sprintf.
 */

static bool
standard_integer_string(const char *s, size_t len)
{
	const char *end;

	if (len == 0)
		return false;
	if (*s == '0' && len == 1)
		return true;
	end = s + len;
	/* ignore leading minus sign */
	if (*s == '-' && ++s == end)
		return false;
	/* check first char is [1-9] */
	if (*s < '1' || *s > '9')
		return false;
	while (++s < end) {
		if (*s < '0' || *s > '9')
			return false;
	}
	return true;
}

/* is_integer --- check if subscript is an integer */

NODE **
is_integer(NODE *symbol, NODE *subs)
{
#ifndef CHECK_INTEGER_USING_FORCE_NUMBER
	long l;
#endif
	AWKNUM d;

	if ((subs->flags & NUMINT) != 0)
		/* quick exit */
		return & success_node;

	if (subs == Nnull_string || do_mpfr)
		return NULL;

#ifdef CHECK_INTEGER_USING_FORCE_NUMBER
	/*
	 * This approach is much simpler, because we remove all of the strtol
	 * logic below. But this may be slower in some usage cases.
	 */
	if ((subs->flags & NUMCUR) == 0) {
		str2number(subs);

		/* check again in case force_number set NUMINT */
		if ((subs->flags & NUMINT) != 0)
			return & success_node;
	}
#else /* CHECK_INTEGER_USING_FORCE_NUMBER */
	if ((subs->flags & NUMCUR) != 0) {
#endif /* CHECK_INTEGER_USING_FORCE_NUMBER */
		d = subs->numbr;
		if (d <= INT32_MAX && d >= INT32_MIN && d == (int32_t) d) {
			/*
			 * The numeric value is an integer, but we must
			 * protect against strings that cannot be generated
			 * from sprintf("%ld", <subscript>). This can happen
			 * with strnum or string values. We could skip this
			 * check for pure NUMBER values, but unfortunately the
			 * code does not currently distinguish between NUMBER
			 * and strnum values.
			 */
			if (   (subs->flags & STRCUR) == 0
			    || standard_integer_string(subs->stptr, subs->stlen)) {
				subs->flags |= NUMINT;
				return & success_node;
			}
		}
		return NULL;
#ifndef CHECK_INTEGER_USING_FORCE_NUMBER
	}

	/* a[3]=1; print "3" in a    -- true
	 * a[3]=1; print "+3" in a   -- false
	 * a[3]=1; print "03" in a   -- false
	 * a[-3]=1; print "-3" in a  -- true
	 */

	/* must be a STRING */
	char *cp = subs->stptr, *cpend, *ptr;
	char save;
	size_t len = subs->stlen;

	if (len == 0 || (! isdigit((unsigned char) *cp) && *cp != '-'))
		return NULL;

	if (len > 1 &&
		((*cp == '0')		/* "00", "011" .. */
			|| (*cp == '-' && *(cp + 1) == '0')	/* "-0", "-011" .. */
		)
	)
		return NULL;
	if (len == 1 && *cp != '-') {	/* single digit */
		subs->numbr = (long) (*cp - '0');
		if ((subs->flags & USER_INPUT) != 0) {
			/* leave USER_INPUT set */
			subs->flags &= ~STRING;
			subs->flags |= NUMBER;
		}
		subs->flags |= (NUMCUR|NUMINT);
		return & success_node;
	}

	cpend = cp + len;
	save = *cpend;
	*cpend = '\0';

	errno = 0;
	l = strtol(cp, & ptr, 10);
	*cpend = save;
	if (errno != 0 || ptr != cpend)
		return NULL;

	subs->numbr = l;
	if ((subs->flags & USER_INPUT) != 0) {
		/* leave USER_INPUT set */
		subs->flags &= ~STRING;
		subs->flags |= NUMBER;
	}
	subs->flags |= NUMCUR;
	if (l <= INT32_MAX && l >= INT32_MIN) {
		subs->flags |= NUMINT;
		return & success_node;
	}

	return NULL;
#endif /* CHECK_INTEGER_USING_FORCE_NUMBER */
}


/*
 * int_lookup --- Find SYMBOL[SUBS] in the assoc array.  Install it with value ""
 * if it isn't there. Returns a pointer ala get_lhs to where its value is stored.
 */

static NODE **
int_lookup(NODE *symbol, NODE *subs)
{
	uint32_t hash1;
	long k;
	unsigned long size;
	NODE **lhs;
	NODE *xn;

	/*
	 * N.B: symbol->table_size is the total # of non-integers (symbol->xarray)
	 *	and integer elements. Also, symbol->xarray must have at least one
	 *	item in it, and cannot exist if there are no integer elements.
	 * 	In that case, symbol->xarray is promoted to 'symbol' (See int_remove).
	 */


	if (! is_integer(symbol, subs)) {
		xn = symbol->xarray;
		if (xn == NULL) {
			xn = symbol->xarray = make_array();
			xn->vname = symbol->vname;	/* shallow copy */
			xn->flags |= XARRAY;
		} else if ((lhs = xn->aexists(xn, subs)) != NULL)
			return lhs;
		symbol->table_size++;
		return assoc_lookup(xn, subs);
	}

	k = subs->numbr;
	if (symbol->buckets == NULL)
		grow_int_table(symbol);

 	hash1 = int_hash(k, symbol->array_size);
	if ((lhs = int_find(symbol, k, hash1)) != NULL)
		return lhs;

	/* It's not there, install it */

	symbol->table_size++;

	/* first see if we would need to grow the array, before installing */
	size = symbol->table_size;
	if ((xn = symbol->xarray) != NULL)
		size -= xn->table_size;

	if ((symbol->flags & ARRAYMAXED) == 0
		    && (size / symbol->array_size) > INT_CHAIN_MAX) {
		grow_int_table(symbol);
		/* have to recompute hash value for new size */
		hash1 = int_hash(k, symbol->array_size);
	}

	return int_insert(symbol, k, hash1);
}


/*
 * int_exists --- test whether the array element symbol[subs] exists or not,
 *	return pointer to value if it does.
 */

static NODE **
int_exists(NODE *symbol, NODE *subs)
{
	long k;
	uint32_t hash1;

	if (! is_integer(symbol, subs)) {
		NODE *xn = symbol->xarray;
		if (xn == NULL)
			return NULL;
		return xn->aexists(xn, subs);
	}
	if (symbol->buckets == NULL)
		return NULL;

	k = subs->numbr;
	hash1 = int_hash(k, symbol->array_size);
	return int_find(symbol, k, hash1);
}

/* int_clear --- flush all the values in symbol[] */

static NODE **
int_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)
{
	unsigned long i;
	int j;
	BUCKET *b, *next;
	NODE *r;

	if (symbol->xarray != NULL) {
		NODE *xn = symbol->xarray;
		assoc_clear(xn);
		freenode(xn);
		symbol->xarray = NULL;
	}

	for (i = 0; i < symbol->array_size; i++) {
		for (b = symbol->buckets[i]; b != NULL;	b = next) {
			next = b->ainext;
			for (j = 0; j < b->aicount; j++) {
				r = b->aivalue[j];
				if (r->type == Node_var_array) {
					assoc_clear(r);	/* recursively clear all sub-arrays */
					efree(r->vname);
					freenode(r);
				} else
					unref(r);
			}
			freebucket(b);
		}
		symbol->buckets[i] = NULL;
	}
	if (symbol->buckets != NULL)
		efree(symbol->buckets);
	symbol->ainit(symbol, NULL);	/* re-initialize symbol */
	return NULL;
}


/* int_remove --- If SUBS is already in the table, remove it. */

static NODE **
int_remove(NODE *symbol, NODE *subs)
{
	uint32_t hash1;
	BUCKET *b, *prev = NULL;
	long k;
	int i;
	NODE *xn = symbol->xarray;

	if (symbol->table_size == 0 || symbol->buckets == NULL)
		return NULL;

	if (! is_integer(symbol, subs)) {
		if (xn == NULL || xn->aremove(xn, subs) == NULL)
			return NULL;
		if (xn->table_size == 0) {
			freenode(xn);
			symbol->xarray = NULL;
		}
		symbol->table_size--;
		assert(symbol->table_size > 0);
		return & success_node;
	}

	k = subs->numbr;
	hash1 = int_hash(k, symbol->array_size);

	for (b = symbol->buckets[hash1]; b != NULL; prev = b, b = b->ainext) {
		for (i = 0; i < b->aicount; i++) {
			if (k != b->ainum[i])
				continue;

			/* item found */
			if (i == 0 && b->aicount == 2) {
				/* removing the 1st item; move 2nd item from position 1 to 0 */

				b->ainum[0] = b->ainum[1];
				b->aivalue[0] = b->aivalue[1];
			} /* else
				removing the only item or the 2nd item */

			goto removed;
		}
	}

	if (b == NULL)	/* item not in array */
		return NULL;

removed:
	b->aicount--;

	if (b->aicount == 0) {
		/* detach bucket */
		if (prev != NULL)
			prev->ainext = b->ainext;
		else
			symbol->buckets[hash1] = b->ainext;

		/* delete bucket */
		freebucket(b);
	} else if (b != symbol->buckets[hash1]) {
		BUCKET *head = symbol->buckets[hash1];

		assert(b->aicount == 1);
		/* move the last element from head to bucket to make it full. */
		i = --head->aicount;	/* head has one less element */
		b->ainum[1] = head->ainum[i];
		b->aivalue[1] = head->aivalue[i];
		b->aicount++;	/* bucket has one more element */
		if (i == 0) {
			/* head is now empty; delete head */
			symbol->buckets[hash1] = head->ainext;
			freebucket(head);
		}
	} /* else
		do nothing */

	symbol->table_size--;
	if (xn == NULL && symbol->table_size == 0) {
		efree(symbol->buckets);
		symbol->ainit(symbol, NULL);	/* re-initialize array 'symbol' */
	} else if (xn != NULL && symbol->table_size == xn->table_size) {
		/* promote xn (str_array) to symbol */
		xn->flags &= ~XARRAY;
		xn->parent_array = symbol->parent_array;
		efree(symbol->buckets);
		*symbol = *xn;
		freenode(xn);
	}

	return & success_node;	/* return success */
}


/* int_copy --- duplicate input array "symbol" */

static NODE **
int_copy(NODE *symbol, NODE *newsymb)
{
	BUCKET **old, **new, **pnew;
	BUCKET *chain, *newchain;
	int j;
	unsigned long i, cursize;

	assert(symbol->buckets != NULL);

	/* find the current hash size */
	cursize = symbol->array_size;

	/* allocate new table */
	ezalloc(new, BUCKET **, cursize * sizeof(BUCKET *));

	old = symbol->buckets;

	for (i = 0; i < cursize; i++) {
		for (chain = old[i], pnew = & new[i]; chain != NULL;
				chain = chain->ainext
		) {
			getbucket(newchain);
			newchain->aicount = chain->aicount;
			newchain->ainext = NULL;
			for (j = 0; j < chain->aicount; j++) {
				NODE *oldval;

				/*
				 * copy the corresponding key and
				 * value from the original input list
				 */
				newchain->ainum[j] = chain->ainum[j];

				oldval = chain->aivalue[j];
				if (oldval->type == Node_val)
					newchain->aivalue[j] = dupnode(oldval);
				else {
					NODE *r;
					r = make_array();
					r->vname = estrdup(oldval->vname, strlen(oldval->vname));
					r->parent_array = newsymb;
					newchain->aivalue[j] = assoc_copy(oldval, r);
				}
			}

			*pnew = newchain;
			newchain->ainext = NULL;
			pnew = & newchain->ainext;
		}
	}

	if (symbol->xarray != NULL) {
		NODE *xn, *n;
		xn = symbol->xarray;
		n = make_array();
		n->vname = newsymb->vname;	/* shallow copy */
		(void) xn->acopy(xn, n);
		newsymb->xarray = n;
	} else
		newsymb->xarray = NULL;

	newsymb->table_size = symbol->table_size;
	newsymb->buckets = new;
	newsymb->array_size = cursize;
	newsymb->flags = symbol->flags;

	return NULL;
}


/* int_list --- return a list of array items */

static NODE**
int_list(NODE *symbol, NODE *t)
{
	NODE **list = NULL;
	unsigned long num_elems, list_size, i, k = 0;
	BUCKET *b;
	NODE *r, *subs, *xn;
	int j, elem_size = 1;
	long num;
	static char buf[100];
	assoc_kind_t assoc_kind;

	if (symbol->table_size == 0)
		return NULL;

	assoc_kind = (assoc_kind_t) t->flags;
	num_elems = symbol->table_size;
	if ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))
		num_elems = 1;

	if ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))
		elem_size = 2;
	list_size = elem_size * num_elems;

	if (symbol->xarray != NULL) {
		xn = symbol->xarray;
		list = xn->alist(xn, t);
		assert(list != NULL);
		if (num_elems == 1 || num_elems == xn->table_size)
			return list;
		erealloc(list, NODE **, list_size * sizeof(NODE *));
		k = elem_size * xn->table_size;
	} else
		emalloc(list, NODE **, list_size * sizeof(NODE *));

	/* populate it */

	for (i = 0; i < symbol->array_size; i++) {
		for (b = symbol->buckets[i]; b != NULL;	b = b->ainext) {
			for (j = 0; j < b->aicount; j++) {
				/* index */
				num = b->ainum[j];
				if ((assoc_kind & AISTR) != 0) {
					sprintf(buf, "%ld", num);
					subs = make_string(buf, strlen(buf));
					subs->numbr = num;
					subs->flags |= (NUMCUR|NUMINT);
				} else {
					subs = make_number((AWKNUM) num);
					subs->flags |= (INTIND|NUMINT);
				}
				list[k++] = subs;

				/* value */
				if ((assoc_kind & AVALUE) != 0) {
					r = b->aivalue[j];
					if (r->type == Node_val) {
						if ((assoc_kind & AVNUM) != 0)
							(void) force_number(r);
						else if ((assoc_kind & AVSTR) != 0)
							r = force_string(r);
					}
					list[k++] = r;
				}

				if (k >= list_size)
					return list;
			}
		}
	}
	return list;
}


/* int_kilobytes --- calculate memory consumption of the assoc array */

AWKNUM
int_kilobytes(NODE *symbol)
{
	unsigned long i, bucket_cnt = 0;
	BUCKET *b;
	AWKNUM kb;
	extern AWKNUM str_kilobytes(NODE *symbol);

	for (i = 0; i < symbol->array_size; i++) {
		for (b = symbol->buckets[i]; b != NULL; b = b->ainext)
			bucket_cnt++;
	}
	kb = (((AWKNUM) bucket_cnt) * sizeof (BUCKET) +
			((AWKNUM) symbol->array_size) * sizeof (BUCKET *)) / 1024.0;

	if (symbol->xarray != NULL)
		kb += str_kilobytes(symbol->xarray);

	return kb;
}


/* int_dump --- dump array info */

static NODE **
int_dump(NODE *symbol, NODE *ndump)
{
#define HCNT	31

	int indent_level;
	BUCKET *b;
	NODE *xn = NULL;
	unsigned long str_size = 0, int_size = 0;
	unsigned long i;
	size_t j, bucket_cnt;
	static size_t hash_dist[HCNT + 1];

	indent_level = ndump->alevel;

	if (symbol->xarray != NULL) {
		xn = symbol->xarray;
		str_size = xn->table_size;
	}
	int_size = symbol->table_size - str_size;

	if ((symbol->flags & XARRAY) == 0)
		fprintf(output_fp, "%s `%s'\n",
				(symbol->parent_array == NULL) ? "array" : "sub-array",
				array_vname(symbol));

	indent_level++;
	indent(indent_level);
	fprintf(output_fp, "array_func: int_array_func\n");
	if (symbol->flags != 0) {
		indent(indent_level);
		fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));
	}
	indent(indent_level);
	fprintf(output_fp, "INT_CHAIN_MAX: %lu\n", (unsigned long) INT_CHAIN_MAX);
	indent(indent_level);
	fprintf(output_fp, "array_size: %lu (int)\n", (unsigned long) symbol->array_size);
	indent(indent_level);
	fprintf(output_fp, "table_size: %lu (total), %lu (int), %lu (str)\n",
			(unsigned long) symbol->table_size, int_size, str_size);
	indent(indent_level);
	fprintf(output_fp, "Avg # of items per chain (int): %.2g\n",
			((AWKNUM) int_size) / symbol->array_size);

	indent(indent_level);
	fprintf(output_fp, "memory: %.2g kB (total)\n", int_kilobytes(symbol));

	/* hash value distribution */

	memset(hash_dist, '\0', (HCNT + 1) * sizeof(size_t));
	for (i = 0; i < symbol->array_size; i++) {
		bucket_cnt = 0;
		for (b = symbol->buckets[i]; b != NULL;	b = b->ainext)
			bucket_cnt += b->aicount;
		if (bucket_cnt >= HCNT)
			bucket_cnt = HCNT;
		hash_dist[bucket_cnt]++;
	}

	indent(indent_level);
	fprintf(output_fp, "Hash distribution:\n");
	indent_level++;
	for (j = 0; j <= HCNT; j++) {
		if (hash_dist[j] > 0) {
			indent(indent_level);
			if (j == HCNT)
				fprintf(output_fp, "[>=%lu]:%lu\n",
					(unsigned long) HCNT, (unsigned long) hash_dist[j]);
			else
				fprintf(output_fp, "[%lu]:%lu\n",
					(unsigned long) j, (unsigned long) hash_dist[j]);
		}
	}
	indent_level--;

	/* dump elements */

	if (ndump->adepth >= 0) {
		NODE *subs;
		const char *aname;

		fprintf(output_fp, "\n");

		aname = make_aname(symbol);
		subs = make_number((AWKNUM) 0);
		subs->flags |= (INTIND|NUMINT);

		for (i = 0; i < symbol->array_size; i++) {
			for (b = symbol->buckets[i]; b != NULL; b = b->ainext) {
				for (j = 0; j < b->aicount; j++) {
					subs->numbr = b->ainum[j];
					assoc_info(subs, b->aivalue[j], ndump, aname);
				}
			}
		}
		unref(subs);
	}

	if (xn != NULL)	{
		fprintf(output_fp, "\n");
		xn->adump(xn, ndump);
	}

	return NULL;

#undef HCNT
}


/* int_hash --- calculate the hash function of the integer subs */

static uint32_t
int_hash(uint32_t k, uint32_t hsize)
{

/*
 * Code snippet copied from:
 *	Hash functions (http://www.azillionmonkeys.com/qed/hash.html).
 *	Copyright 2004-2008 by Paul Hsieh. Licenced under LGPL 2.1.
 */

	/* This is the final mixing function used by Paul Hsieh in SuperFastHash. */

	k ^= k << 3;
	k += k >> 5;
	k ^= k << 4;
	k += k >> 17;
	k ^= k << 25;
	k += k >> 6;

	if (k >= hsize)
		k %= hsize;
	return k;
}

/* int_find --- locate symbol[subs] */

static inline NODE **
int_find(NODE *symbol, long k, uint32_t hash1)
{
	BUCKET *b;
	int i;

	assert(symbol->buckets != NULL);
	for (b = symbol->buckets[hash1]; b != NULL; b = b->ainext) {
		for (i = 0; i < b->aicount; i++) {
			if (b->ainum[i] == k)
				return (b->aivalue + i);
		}
	}
	return NULL;
}


/* int_insert --- install subs in the assoc array */

static NODE **
int_insert(NODE *symbol, long k, uint32_t hash1)
{
	BUCKET *b;
	int i;

	b = symbol->buckets[hash1];

	/* Only the first bucket in the chain can be partially full, but is never empty. */

	if (b == NULL || (i = b->aicount) == 2) {
		getbucket(b);
		b->aicount = 0;
		b->ainext = symbol->buckets[hash1];
		symbol->buckets[hash1] = b;
		i = 0;
	}

	b->ainum[i] = k;
	b->aivalue[i] = new_array_element();
	b->aicount++;
	return & b->aivalue[i];
}


/* grow_int_table --- grow the hash table */

static void
grow_int_table(NODE *symbol)
{
	BUCKET **old, **new;
	BUCKET *chain, *next;
	int i, j;
	unsigned long oldsize, newsize, k;

	/*
	 * This is an array of primes. We grow the table by an order of
	 * magnitude each time (not just doubling) so that growing is a
	 * rare operation. We expect, on average, that it won't happen
	 * more than twice.  The final size is also chosen to be small
	 * enough so that MS-DOG mallocs can handle it. When things are
	 * very large (> 8K), we just double more or less, instead of
	 * just jumping from 8K to 64K.
	 */

	static const unsigned long sizes[] = {
		13, 127, 1021, 8191, 16381, 32749, 65497,
		131101, 262147, 524309, 1048583, 2097169,
		4194319, 8388617, 16777259, 33554467,
		67108879, 134217757, 268435459, 536870923,
		1073741827
	};

	/* find next biggest hash size */
	newsize = oldsize = symbol->array_size;

	for (i = 0, j = sizeof(sizes)/sizeof(sizes[0]); i < j; i++) {
		if (oldsize < sizes[i]) {
			newsize = sizes[i];
			break;
		}
	}
	if (newsize == oldsize) {	/* table already at max (!) */
		symbol->flags |= ARRAYMAXED;
		return;
	}

	/* allocate new table */
	ezalloc(new, BUCKET **, newsize * sizeof(BUCKET *));

	old = symbol->buckets;
	symbol->buckets = new;
	symbol->array_size = newsize;

	/* brand new hash table */
	if (old == NULL)
		return;		/* DO NOT initialize symbol->table_size */

	/* old hash table there, move stuff to new, free old */
	/* note that symbol->table_size does not change if an old array. */

	for (k = 0; k < oldsize; k++) {
		long num;
		for (chain = old[k]; chain != NULL; chain = next) {
			for (i = 0; i < chain->aicount; i++) {
				num = chain->ainum[i];
				*int_insert(symbol, num, int_hash(num, newsize)) = chain->aivalue[i];
			}
			next = chain->ainext;
			freebucket(chain);
		}
	}
	efree(old);
}
/*
 * str_array.c - routines for associative arrays of string indices.
 */

/*
 * Copyright (C) 1986, 1988, 1989, 1991-2013, 2016, 2017, 2018, 2019,
 * 2021, 2022, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"

/*
 * Tree walks (``for (iggy in foo)'') and array deletions use expensive
 * linear searching.  So what we do is start out with small arrays and
 * grow them as needed, so that our arrays are hopefully small enough,
 * most of the time, that they're pretty full and we're not looking at
 * wasted space.
 *
 * The decision is made to grow the array if the average chain length is
 * ``too big''. This is defined as the total number of entries in the table
 * divided by the size of the array being greater than some constant.
 *
 * 11/2002: We make the constant a variable, so that it can be tweaked
 * via environment variable.
 * 11/2002: Modern machines are bigger, cut this down from 10.
 */

static size_t STR_CHAIN_MAX = 10;

extern FILE *output_fp;
extern void indent(int indent_level);

static NODE **str_array_init(NODE *symbol, NODE *subs);
static NODE **str_lookup(NODE *symbol, NODE *subs);
static NODE **str_exists(NODE *symbol, NODE *subs);
static NODE **str_clear(NODE *symbol, NODE *subs);
static NODE **str_remove(NODE *symbol, NODE *subs);
static NODE **str_list(NODE *symbol, NODE *subs);
static NODE **str_copy(NODE *symbol, NODE *newsymb);
static NODE **str_dump(NODE *symbol, NODE *ndump);

const array_funcs_t str_array_func = {
	"str",
	str_array_init,
	(afunc_t) 0,
	str_lookup,
	str_exists,
	str_clear,
	str_remove,
	str_list,
	str_copy,
	str_dump,
	(afunc_t) 0,
};

static NODE **env_remove(NODE *symbol, NODE *subs);
static NODE **env_store(NODE *symbol, NODE *subs);
static NODE **env_clear(NODE *symbol, NODE *subs);

/* special case for ENVIRON */
static const array_funcs_t env_array_func = {
	"env",
	str_array_init,
	(afunc_t) 0,
	str_lookup,
	str_exists,
	env_clear,
	env_remove,
	str_list,
	str_copy,
	str_dump,
	env_store,
};

static inline NODE **str_find(NODE *symbol, NODE *s1, size_t code1, unsigned long hash1);
static void grow_table(NODE *symbol);

static unsigned long gst_hash_string(const char *str, size_t len, unsigned long hsize, size_t *code);
static unsigned long scramble(unsigned long x);
static unsigned long fnv1a_hash_string(const char *str, size_t len, unsigned long hsize, size_t *code);
static unsigned long awk_hash(const char *s, size_t len, unsigned long hsize, size_t *code);

unsigned long (*hash)(const char *s, size_t len, unsigned long hsize, size_t *code) = awk_hash;


/* str_array_init --- array initialization routine */

static NODE **
str_array_init(NODE *symbol ATTRIBUTE_UNUSED, NODE *subs ATTRIBUTE_UNUSED)
{
	if (symbol == NULL) {		/* first time */
		long newval;
		const char *val;

		/* check relevant environment variables */
		if ((newval = getenv_long("STR_CHAIN_MAX")) > 0)
			STR_CHAIN_MAX = newval;

		if ((val = getenv("AWK_HASH")) != NULL) {
			if (strcmp(val, "gst") == 0)
				hash = gst_hash_string;
			else if (strcmp(val, "fnv1a") == 0)
				hash = fnv1a_hash_string;
		}
	} else
		null_array(symbol);

	return & success_node;
}


/*
 * str_lookup:
 * Find SYMBOL[SUBS] in the assoc array.  Install it with value "" if it
 * isn't there. Returns a pointer ala get_lhs to where its value is stored.
 *
 * SYMBOL is the address of the node (or other pointer) being dereferenced.
 * SUBS is a number or string used as the subscript.
 */

static NODE **
str_lookup(NODE *symbol, NODE *subs)
{
	unsigned long hash1;
	NODE **lhs;
	BUCKET *b;
	size_t code1;

	subs = force_string(subs);

	if (symbol->buckets == NULL)
		grow_table(symbol);
	hash1 = hash(subs->stptr, subs->stlen,
			(unsigned long) symbol->array_size, & code1);
	if ((lhs = str_find(symbol, subs, code1, hash1)) != NULL)
		return lhs;

	/* It's not there, install it. */
	/* first see if we would need to grow the array, before installing */

	symbol->table_size++;
	if ((symbol->flags & ARRAYMAXED) == 0
			&& (symbol->table_size / symbol->array_size) > STR_CHAIN_MAX) {
		grow_table(symbol);
		/* have to recompute hash value for new size */
		hash1 = code1 % (unsigned long) symbol->array_size;
	}


	/*
	 * Repeat after me: "Array indices are always strings."
	 * "Array indices are always strings."
	 * "Array indices are always strings."
	 * "Array indices are always strings."
	 * ....
	 */
	// Special cases:
	// 1. The string was generated using CONVFMT.
	// 2. The string was from an unassigned variable.
	// 3. The string was from a straight number, perniciously, from MPFR
	// 4. The string was from an unassigned field.
	if (   subs->stfmt != STFMT_UNUSED
	    || subs == Nnull_string
	    || (subs->flags & STRING) == 0
	    || (subs->flags & NULL_FIELD) != 0) {
		NODE *tmp;

		/*
		 * Need to freeze this string value --- it must never
		 * change, no matter what happens to the value
		 * that created it or to CONVFMT, etc.; So, get
		 * a private copy.
		 */

		tmp = make_string(subs->stptr, subs->stlen);

		/*
		* Set the numeric value for the index if it's  available. Useful
		* for numeric sorting by index.  Do this only if the numeric
		* value is available, instead of all the time, since doing it
		* all the time is a big performance hit for something that may
		* never be used.
		*/

		if ((subs->flags & (MPFN|MPZN|NUMCUR)) == NUMCUR) {
			tmp->numbr = subs->numbr;
			tmp->flags |= NUMCUR;
		}
		subs = tmp;
	} else {
		/* string value already "frozen" */

		subs = dupnode(subs);
	}

	getbucket(b);
	b->ahnext = symbol->buckets[hash1];
	symbol->buckets[hash1] = b;
	b->ahname = subs;
	b->ahname_str = subs->stptr;
	b->ahname_len = subs->stlen;
	b->ahvalue = new_array_element();
	b->ahcode = code1;
	return & (b->ahvalue);
}

/* str_exists --- test whether the array element symbol[subs] exists or not,
 * 		return pointer to value if it does.
 */

static NODE **
str_exists(NODE *symbol, NODE *subs)
{
	unsigned long hash1;
	size_t code1;

	if (symbol->table_size == 0)
		return NULL;

	subs = force_string(subs);
	hash1 = hash(subs->stptr, subs->stlen, (unsigned long) symbol->array_size, & code1);
	return str_find(symbol, subs, code1, hash1);
}

/* str_clear --- flush all the values in symbol[] */

static NODE **
str_clear(NODE *symbol, NODE *subs ATTRIBUTE_UNUSED)
{
	unsigned long i;
	BUCKET *b, *next;
	NODE *r;

	for (i = 0; i < symbol->array_size; i++) {
		for (b = symbol->buckets[i]; b != NULL; b = next) {
			next = b->ahnext;
			r = b->ahvalue;
			if (r->type == Node_var_array) {
				assoc_clear(r);	/* recursively clear all sub-arrays */
				efree(r->vname);
				freenode(r);
			} else
				unref(r);
			unref(b->ahname);
			freebucket(b);
		}
		symbol->buckets[i] = NULL;
	}

	if (symbol->buckets != NULL)
		efree(symbol->buckets);
	symbol->ainit(symbol, NULL);	/* re-initialize symbol */
	return NULL;
}


/* str_remove --- If SUBS is already in the table, remove it. */

static NODE **
str_remove(NODE *symbol, NODE *subs)
{
	unsigned long hash1;
	BUCKET *b, *prev;
	NODE *s2;
	size_t s1_len;

	if (symbol->table_size == 0)
		return NULL;

	s2 = force_string(subs);
	hash1 = hash(s2->stptr, s2->stlen, (unsigned long) symbol->array_size, NULL);

	for (b = symbol->buckets[hash1], prev = NULL; b != NULL;
				prev = b, b = b->ahnext) {

		/* Array indexes are strings; compare as such, always! */
		s1_len = b->ahname_len;

		if (s1_len != s2->stlen)
			continue;
		if (s1_len == 0		/* "" is a valid index */
			    || memcmp(b->ahname_str, s2->stptr, s1_len) == 0) {
			/* item found */

			unref(b->ahname);
			if (prev != NULL)
				prev->ahnext = b->ahnext;
			else
				symbol->buckets[hash1] = b->ahnext;

			/* delete bucket */
			freebucket(b);

			/* one less element in array */
			if (--symbol->table_size == 0) {
				if (symbol->buckets != NULL)
					efree(symbol->buckets);
				symbol->ainit(symbol, NULL);	/* re-initialize symbol */
			}

			return & success_node;	/* return success */
		}
	}

	return NULL;
}


/* str_copy --- duplicate input array "symbol" */

static NODE **
str_copy(NODE *symbol, NODE *newsymb)
{
	BUCKET **old, **new, **pnew;
	BUCKET *chain, *newchain;
	unsigned long cursize, i;

	assert(symbol->table_size > 0);

	/* find the current hash size */
	cursize = symbol->array_size;

	/* allocate new table */
	ezalloc(new, BUCKET **, cursize * sizeof(BUCKET *));

	old = symbol->buckets;

	for (i = 0; i < cursize; i++) {
		for (chain = old[i], pnew = & new[i]; chain != NULL;
				chain = chain->ahnext
		) {
			NODE *oldval, *newsubs;

			getbucket(newchain);

			/*
			 * copy the corresponding name and
			 * value from the original input list
			 */

			newsubs = newchain->ahname = dupnode(chain->ahname);
			newchain->ahname_str = newsubs->stptr;
			newchain->ahname_len = newsubs->stlen;

			oldval = chain->ahvalue;
			if (oldval->type == Node_val)
				newchain->ahvalue = dupnode(oldval);
			else {
				NODE *r;

				r = make_array();
				r->vname = estrdup(oldval->vname, strlen(oldval->vname));
				r->parent_array = newsymb;
				newchain->ahvalue = assoc_copy(oldval, r);
			}
			newchain->ahcode = chain->ahcode;

			*pnew = newchain;
			newchain->ahnext = NULL;
			pnew = & newchain->ahnext;
		}
	}

	newsymb->table_size = symbol->table_size;
	newsymb->buckets = new;
	newsymb->array_size = cursize;
	newsymb->flags = symbol->flags;
	return NULL;
}


/* str_list --- return a list of array items */

static NODE**
str_list(NODE *symbol, NODE *t)
{
	NODE **list;
	NODE *subs, *val;
	BUCKET *b;
	unsigned long num_elems, list_size, i, k = 0;
	int elem_size = 1;
	assoc_kind_t assoc_kind;

	if (symbol->table_size == 0)
		return NULL;

	assoc_kind = (assoc_kind_t) t->flags;
	if ((assoc_kind & (AINDEX|AVALUE)) == (AINDEX|AVALUE))
		elem_size = 2;

	/* allocate space for array */
	num_elems = symbol->table_size;
	if ((assoc_kind & (AINDEX|AVALUE|ADELETE)) == (AINDEX|ADELETE))
		num_elems = 1;
	list_size =  elem_size * num_elems;

	emalloc(list, NODE **, list_size * sizeof(NODE *));

	/* populate it */

	for (i = 0; i < symbol->array_size; i++) {
		for (b = symbol->buckets[i]; b != NULL;	b = b->ahnext) {
			/* index */
			subs = b->ahname;
			if ((assoc_kind & AINUM) != 0)
				(void) force_number(subs);
			list[k++] = dupnode(subs);

			/* value */
			if ((assoc_kind & AVALUE) != 0) {
				val = b->ahvalue;
				if (val->type == Node_val) {
					if ((assoc_kind & AVNUM) != 0)
						(void) force_number(val);
					else if ((assoc_kind & AVSTR) != 0)
						val = force_string(val);
				}
				list[k++] = val;
			}
			if (k >= list_size)
				return list;
		}
	}
	return list;
}


/* str_kilobytes --- calculate memory consumption of the assoc array */

AWKNUM
str_kilobytes(NODE *symbol)
{
	unsigned long bucket_cnt;
	AWKNUM kb;

	bucket_cnt = symbol->table_size;

	/* This does not include extra memory for indices with stfmt != STFMT_UNUSED */
	kb = (((AWKNUM) bucket_cnt) * sizeof (BUCKET) +
		((AWKNUM) symbol->array_size) * sizeof (BUCKET *)) / 1024.0;
	return kb;
}


/* str_dump --- dump array info */

static NODE **
str_dump(NODE *symbol, NODE *ndump)
{
#define HCNT	31

	int indent_level;
	unsigned long i, bucket_cnt;
	BUCKET *b;
	static size_t hash_dist[HCNT + 1];

	indent_level = ndump->alevel;

	if ((symbol->flags & XARRAY) == 0)
		fprintf(output_fp, "%s `%s'\n",
				(symbol->parent_array == NULL) ? "array" : "sub-array",
				array_vname(symbol));
	indent_level++;
	indent(indent_level);
	fprintf(output_fp, "array_func: str_array_func\n");
	if (symbol->flags != 0) {
		indent(indent_level);
		fprintf(output_fp, "flags: %s\n", flags2str(symbol->flags));
	}
	indent(indent_level);
	fprintf(output_fp, "STR_CHAIN_MAX: %lu\n", (unsigned long) STR_CHAIN_MAX);
	indent(indent_level);
	fprintf(output_fp, "array_size: %lu\n", (unsigned long) symbol->array_size);
	indent(indent_level);
	fprintf(output_fp, "table_size: %lu\n", (unsigned long) symbol->table_size);
	indent(indent_level);
	fprintf(output_fp, "Avg # of items per chain: %.2g\n",
				((AWKNUM) symbol->table_size) / symbol->array_size);

	indent(indent_level);
	fprintf(output_fp, "memory: %.2g kB\n", str_kilobytes(symbol));

	/* hash value distribution */

	memset(hash_dist, '\0', (HCNT + 1) * sizeof(size_t));
	for (i = 0; i < symbol->array_size; i++) {
		bucket_cnt = 0;
		for (b = symbol->buckets[i]; b != NULL;	b = b->ahnext)
			bucket_cnt++;
		if (bucket_cnt >= HCNT)
			bucket_cnt = HCNT;
		hash_dist[bucket_cnt]++;
	}

	indent(indent_level);
	fprintf(output_fp, "Hash distribution:\n");
	indent_level++;
	for (i = 0; i <= HCNT; i++) {
		if (hash_dist[i] > 0) {
			indent(indent_level);
			if (i == HCNT)
				fprintf(output_fp, "[>=%lu]:%lu\n",
					(unsigned long) HCNT, (unsigned long) hash_dist[i]);
			else
				fprintf(output_fp, "[%lu]:%lu\n",
					(unsigned long) i, (unsigned long) hash_dist[i]);
		}
	}
	indent_level--;

	/* dump elements */

	if (ndump->adepth >= 0) {
		const char *aname;

		fprintf(output_fp, "\n");
		aname = make_aname(symbol);
		for (i = 0; i < symbol->array_size; i++) {
			for (b = symbol->buckets[i]; b != NULL;	b = b->ahnext)
				assoc_info(b->ahname, b->ahvalue, ndump, aname);
		}
	}

	return NULL;

#undef HCNT
}


/* awk_hash --- calculate the hash function of the string in subs */

static unsigned long
awk_hash(const char *s, size_t len, unsigned long hsize, size_t *code)
{
	unsigned long h = 0;
	unsigned long htmp;

	/*
	 * Ozan Yigit's original sdbm hash, copied from Margo Seltzers
	 * db package.
	 *
	 * This is INCREDIBLY ugly, but fast.  We break the string up into
	 * 8 byte units.  On the first time through the loop we get the
	 * "leftover bytes" (strlen % 8).  On every other iteration, we
	 * perform 8 HASHC's so we handle all 8 bytes.  Essentially, this
	 * saves us 7 cmp & branch instructions.  If this routine is
	 * heavily used enough, it's worth the ugly coding.
	 */

	/*
	 * Even more speed:
	 * #define HASHC   h = *s++ + 65599 * h
	 * Because 65599 = pow(2, 6) + pow(2, 16) - 1 we multiply by shifts
	 *
	 * 4/2011: Force the results to 32 bits, to get the same
	 * result on both 32- and 64-bit systems. This may be a
	 * bad idea.
	 */
#define HASHC   htmp = (h << 6);  \
		h = *s++ + htmp + (htmp << 10) - h ; \
		htmp &= 0xFFFFFFFF; \
		h &= 0xFFFFFFFF

	h = 0;

	/* "Duff's Device" */
	if (len > 0) {
		size_t loop = (len + 8 - 1) >> 3;

		switch (len & (8 - 1)) {
		case 0:
			do {	/* All fall throughs */
				HASHC;
		case 7:		HASHC;
		case 6:		HASHC;
		case 5:		HASHC;
		case 4:		HASHC;
		case 3:		HASHC;
		case 2:		HASHC;
		case 1:		HASHC;
			} while (--loop);
		}
	}

	if (code != NULL)
		*code = h;

	if (h >= hsize)
		h %= hsize;
	return h;
}


/* str_find --- locate symbol[subs] */

static inline NODE **
str_find(NODE *symbol, NODE *s1, size_t code1, unsigned long hash1)
{
	BUCKET *b;
	size_t s2_len;

	for (b = symbol->buckets[hash1]; b != NULL; b = b->ahnext) {
		/*
		 * This used to use cmp_nodes() here.  That's wrong.
		 * Array indexes are strings; compare as such, always!
	 	 */
		s2_len = b->ahname_len;

		if (code1 == b->ahcode
			&& s1->stlen == s2_len
			&& (s2_len == 0		/* "" is a valid index */
				|| memcmp(s1->stptr, b->ahname_str, s2_len) == 0)
		)
			return & (b->ahvalue);
	}
	return NULL;
}


/* grow_table --- grow a hash table */

static void
grow_table(NODE *symbol)
{
	BUCKET **old, **new;
	BUCKET *chain, *next;
	int i, j;
	unsigned long oldsize, newsize, k;
	unsigned long hash1;

	/*
	 * This is an array of primes. We grow the table by an order of
	 * magnitude each time (not just doubling) so that growing is a
	 * rare operation. We expect, on average, that it won't happen
	 * more than twice.  The final size is also chosen to be small
	 * enough so that MS-DOG mallocs can handle it. When things are
	 * very large (> 8K), we just double more or less, instead of
	 * just jumping from 8K to 64K.
	 */

	static const unsigned long sizes[] = {
		13, 127, 1021, 8191, 16381, 32749, 65497,
		131101, 262147, 524309, 1048583, 2097169,
		4194319, 8388617, 16777259, 33554467,
		67108879, 134217757, 268435459, 536870923,
		1073741827
	};

	/* find next biggest hash size */
	newsize = oldsize = symbol->array_size;

	for (i = 0, j = sizeof(sizes)/sizeof(sizes[0]); i < j; i++) {
		if (oldsize < sizes[i]) {
			newsize = sizes[i];
			break;
		}
	}
	if (newsize == oldsize) {	/* table already at max (!) */
		symbol->flags |= ARRAYMAXED;
		return;
	}

	/* allocate new table */
	ezalloc(new, BUCKET **, newsize * sizeof(BUCKET *));

	old = symbol->buckets;
	symbol->buckets = new;
	symbol->array_size = newsize;

	/* brand new hash table, set things up and return */
	if (old == NULL) {
		symbol->table_size = 0;
		return;
	}

	/* old hash table there, move stuff to new, free old */

	/*
	 * note that symbol->table_size does not change if an old array,
	 * and is explicitly set to 0 if a new one.
	 */

	for (k = 0; k < oldsize; k++) {
		for (chain = old[k]; chain != NULL; chain = next) {
			next = chain->ahnext;
			hash1 = chain->ahcode % newsize;

			/* remove from old list, add to new */
			chain->ahnext = new[hash1];
			new[hash1] = chain;
		}
	}
	efree(old);
}



/*
From bonzini@gnu.org  Mon Oct 28 16:05:26 2002
Date: Mon, 28 Oct 2002 13:33:03 +0100
From: Paolo Bonzini <bonzini@gnu.org>
To: arnold@skeeve.com
Subject: Hash function
Message-ID: <20021028123303.GA6832@biancaneve>

Here is the hash function I'm using in GNU Smalltalk.  The scrambling is
needed if you use powers of two as the table sizes.  If you use primes it
is not needed.

To use double-hashing with power-of-two size, you should use the
_gst_hash_string(str, len) as the primary hash and
scramble(_gst_hash_string (str, len)) | 1 as the secondary hash.

Paolo

*/
/*
 * ADR: Slightly modified to work w/in the context of gawk.
 */

static unsigned long
gst_hash_string(const char *str, size_t len, unsigned long hsize, size_t *code)
{
	unsigned long hashVal = 1497032417;    /* arbitrary value */
	unsigned long ret;

	while (len--) {
		hashVal += *str++;
		hashVal += (hashVal << 10);
		hashVal ^= (hashVal >> 6);
	}

	ret = scramble(hashVal);

	if (code != NULL)
		*code = ret;

	if (ret >= hsize)
		ret %= hsize;

	return ret;
}

static unsigned long
scramble(unsigned long x)
{
	if (sizeof(long) == 4) {
		int y = ~x;

		x += (y << 10) | (y >> 22);
		x += (x << 6)  | (x >> 26);
		x -= (x << 16) | (x >> 16);
	} else {
		x ^= (~x) >> 31;
		x += (x << 21) | (x >> 11);
		x += (x << 5) | (x >> 27);
		x += (x << 27) | (x >> 5);
		x += (x << 31);
	}

	return x;
}

/* fnv1a_hash_string --- fnv1a hash function */

/*
 * FNV-1a hash function
 * http://www.isthe.com/chongo/tech/comp/fnv/index.html
 */

static unsigned long
fnv1a_hash_string(const char *str, size_t len, unsigned long hsize, size_t *code)
{
	/* FNV-1a */
	register unsigned ret = 2166136261U;

	while (len > 0) {
		ret ^= (unsigned char) (*str++);
		ret *= 16777619U;
		len-- ;
	}

	if (code != NULL)
		*code = ret;

	if (ret >= hsize)
		ret %= hsize;

	return ret;
}

/* env_remove --- for ENVIRON, remove value from real environment */

static NODE **
env_remove(NODE *symbol, NODE *subs)
{
	NODE **val = str_remove(symbol, subs);
	char save;

	if (val != NULL) {
		str_terminate(subs, save);
		(void) unsetenv(subs->stptr);
		str_restore(subs, save);
	}

	return val;
}

/* env_clear --- clear out the environment when ENVIRON is deleted */

static NODE **
env_clear(NODE *symbol, NODE *subs)
{
	extern char **environ;
	NODE **val = str_clear(symbol, subs);

	environ = NULL;	/* ZAP! */

	/* str_clear zaps the vtable, reset it */
	symbol->array_funcs = & env_array_func;

	return val;
}

/* env_store --- post assign function for ENVIRON, put new value into env */

static NODE **
env_store(NODE *symbol, NODE *subs)
{
	NODE **val = str_exists(symbol, subs);
	const char *newval;

	assert(val != NULL);

	newval = (*val)->stptr;
	if (newval == NULL)
		newval = "";

	(void) setenv(subs->stptr, newval, 1);

	return val;
}

/* init_env_array --- set up the pointers for ENVIRON. A bit hacky. */

void
init_env_array(NODE *env_node)
{
	/* If POSIX simply don't reset the vtable and things work as before */
	if (do_posix)
		return;

	env_node->array_funcs = & env_array_func;
}
/* A Bison parser, made by GNU Bison 3.8.2.  */

/* Bison implementation for Yacc-like parsers in C

   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
   Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   especially those whose name start with YY_ or yy_.  They are
   private implementation details that can be changed or removed.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output, and Bison version.  */
#define YYBISON 30802

/* Bison version string.  */
#define YYBISON_VERSION "3.8.2"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 0

/* Push parsers.  */
#define YYPUSH 0

/* Pull parsers.  */
#define YYPULL 1


/* Substitute the variable and function names.  */
#define yyparse         zzparse
#define yylex           zzlex
#define yyerror         zzerror
#define yydebug         zzdebug
#define yynerrs         zznerrs
#define yylval          zzlval
#define yychar          zzchar

/* First part of user prologue.  */
#line 28 "command.y"

#include "awk.h"
#include "cmd.h"

#if 0
#define YYDEBUG 12
int yydebug = 2;
#endif

static int yylex(void);
static void yyerror(const char *mesg, ...);
#define YYERROR_IS_DECLARED	1	/* for bison 3.8. sigh. */

static int find_command(const char *token, size_t toklen);

static bool want_nodeval = false;

static int cmd_idx = -1;		/* index of current command in cmd table */
static int repeat_idx = -1;		/* index of last repeatable command in command table */
static CMDARG *arg_list = NULL;		/* list of arguments */
static long dbg_errcount = 0;
static char *lexptr_begin = NULL;
static bool in_commands = false;
static int num_dim;

static bool in_eval = false;
static const char start_EVAL[] = "function @eval(){";
static const char end_EVAL[] = "}";
static CMDARG *append_statement(CMDARG *stmt_list, char *stmt);
static NODE *concat_args(CMDARG *a, int count);

#ifdef HAVE_LIBREADLINE
static char *next_word(char *p, int len, char **endp);
static void history_expand_line(char **line);
static char *command_generator(const char *text, int state);
static char *srcfile_generator(const char *text, int state);
static char *argument_generator(const char *text, int state);
static char *variable_generator(const char *text, int state);
extern char *option_generator(const char *text, int state);
static int this_cmd = D_illegal;
#else
#define history_expand_line(p)	/* nothing */
static int rl_inhibit_completion;	/* dummy variable */
#endif

struct argtoken {
	const char *name;
	enum argtype cmd;
	enum nametypeval value;
};

/*
 * These two should be static, but there are some compilers that
 * don't like the static keyword with an empty size. Therefore give
 * them names that are less likely to conflict with the rest of gawk.
 */
#define argtab zz_debug_argtab
#define cmdtab zz_debug_cmdtab

extern struct argtoken argtab[];
extern struct cmdtoken cmdtab[];

static CMDARG *mk_cmdarg(enum argtype type);
static void append_cmdarg(CMDARG *arg);
static int find_argument(CMDARG *arg);
#define YYSTYPE CMDARG *

#line 146 "command.c"

# ifndef YY_CAST
#  ifdef __cplusplus
#   define YY_CAST(Type, Val) static_cast<Type> (Val)
#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
#  else
#   define YY_CAST(Type, Val) ((Type) (Val))
#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
#  endif
# endif
# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif


/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int zzdebug;
#endif

/* Token kinds.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
  enum yytokentype
  {
    YYEMPTY = -2,
    YYEOF = 0,                     /* "end of file"  */
    YYerror = 256,                 /* error  */
    YYUNDEF = 257,                 /* "invalid token"  */
    D_BACKTRACE = 258,             /* D_BACKTRACE  */
    D_BREAK = 259,                 /* D_BREAK  */
    D_CLEAR = 260,                 /* D_CLEAR  */
    D_CONTINUE = 261,              /* D_CONTINUE  */
    D_DELETE = 262,                /* D_DELETE  */
    D_DISABLE = 263,               /* D_DISABLE  */
    D_DOWN = 264,                  /* D_DOWN  */
    D_ENABLE = 265,                /* D_ENABLE  */
    D_FINISH = 266,                /* D_FINISH  */
    D_FRAME = 267,                 /* D_FRAME  */
    D_HELP = 268,                  /* D_HELP  */
    D_IGNORE = 269,                /* D_IGNORE  */
    D_INFO = 270,                  /* D_INFO  */
    D_LIST = 271,                  /* D_LIST  */
    D_NEXT = 272,                  /* D_NEXT  */
    D_NEXTI = 273,                 /* D_NEXTI  */
    D_PRINT = 274,                 /* D_PRINT  */
    D_PRINTF = 275,                /* D_PRINTF  */
    D_QUIT = 276,                  /* D_QUIT  */
    D_RETURN = 277,                /* D_RETURN  */
    D_RUN = 278,                   /* D_RUN  */
    D_SET = 279,                   /* D_SET  */
    D_STEP = 280,                  /* D_STEP  */
    D_STEPI = 281,                 /* D_STEPI  */
    D_TBREAK = 282,                /* D_TBREAK  */
    D_UP = 283,                    /* D_UP  */
    D_UNTIL = 284,                 /* D_UNTIL  */
    D_DISPLAY = 285,               /* D_DISPLAY  */
    D_UNDISPLAY = 286,             /* D_UNDISPLAY  */
    D_WATCH = 287,                 /* D_WATCH  */
    D_UNWATCH = 288,               /* D_UNWATCH  */
    D_DUMP = 289,                  /* D_DUMP  */
    D_TRACE = 290,                 /* D_TRACE  */
    D_INT = 291,                   /* D_INT  */
    D_STRING = 292,                /* D_STRING  */
    D_NODE = 293,                  /* D_NODE  */
    D_VARIABLE = 294,              /* D_VARIABLE  */
    D_OPTION = 295,                /* D_OPTION  */
    D_COMMANDS = 296,              /* D_COMMANDS  */
    D_END = 297,                   /* D_END  */
    D_SILENT = 298,                /* D_SILENT  */
    D_SOURCE = 299,                /* D_SOURCE  */
    D_SAVE = 300,                  /* D_SAVE  */
    D_EVAL = 301,                  /* D_EVAL  */
    D_CONDITION = 302,             /* D_CONDITION  */
    D_STATEMENT = 303              /* D_STATEMENT  */
  };
  typedef enum yytokentype yytoken_kind_t;
#endif
/* Token kinds.  */
#define YYEMPTY -2
#define YYEOF 0
#define YYerror 256
#define YYUNDEF 257
#define D_BACKTRACE 258
#define D_BREAK 259
#define D_CLEAR 260
#define D_CONTINUE 261
#define D_DELETE 262
#define D_DISABLE 263
#define D_DOWN 264
#define D_ENABLE 265
#define D_FINISH 266
#define D_FRAME 267
#define D_HELP 268
#define D_IGNORE 269
#define D_INFO 270
#define D_LIST 271
#define D_NEXT 272
#define D_NEXTI 273
#define D_PRINT 274
#define D_PRINTF 275
#define D_QUIT 276
#define D_RETURN 277
#define D_RUN 278
#define D_SET 279
#define D_STEP 280
#define D_STEPI 281
#define D_TBREAK 282
#define D_UP 283
#define D_UNTIL 284
#define D_DISPLAY 285
#define D_UNDISPLAY 286
#define D_WATCH 287
#define D_UNWATCH 288
#define D_DUMP 289
#define D_TRACE 290
#define D_INT 291
#define D_STRING 292
#define D_NODE 293
#define D_VARIABLE 294
#define D_OPTION 295
#define D_COMMANDS 296
#define D_END 297
#define D_SILENT 298
#define D_SOURCE 299
#define D_SAVE 300
#define D_EVAL 301
#define D_CONDITION 302
#define D_STATEMENT 303

/* Value type.  */
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif


extern YYSTYPE zzlval;


int zzparse (void);



/* Symbol kind.  */
enum yysymbol_kind_t
{
  YYSYMBOL_YYEMPTY = -2,
  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
  YYSYMBOL_YYerror = 1,                    /* error  */
  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
  YYSYMBOL_D_BACKTRACE = 3,                /* D_BACKTRACE  */
  YYSYMBOL_D_BREAK = 4,                    /* D_BREAK  */
  YYSYMBOL_D_CLEAR = 5,                    /* D_CLEAR  */
  YYSYMBOL_D_CONTINUE = 6,                 /* D_CONTINUE  */
  YYSYMBOL_D_DELETE = 7,                   /* D_DELETE  */
  YYSYMBOL_D_DISABLE = 8,                  /* D_DISABLE  */
  YYSYMBOL_D_DOWN = 9,                     /* D_DOWN  */
  YYSYMBOL_D_ENABLE = 10,                  /* D_ENABLE  */
  YYSYMBOL_D_FINISH = 11,                  /* D_FINISH  */
  YYSYMBOL_D_FRAME = 12,                   /* D_FRAME  */
  YYSYMBOL_D_HELP = 13,                    /* D_HELP  */
  YYSYMBOL_D_IGNORE = 14,                  /* D_IGNORE  */
  YYSYMBOL_D_INFO = 15,                    /* D_INFO  */
  YYSYMBOL_D_LIST = 16,                    /* D_LIST  */
  YYSYMBOL_D_NEXT = 17,                    /* D_NEXT  */
  YYSYMBOL_D_NEXTI = 18,                   /* D_NEXTI  */
  YYSYMBOL_D_PRINT = 19,                   /* D_PRINT  */
  YYSYMBOL_D_PRINTF = 20,                  /* D_PRINTF  */
  YYSYMBOL_D_QUIT = 21,                    /* D_QUIT  */
  YYSYMBOL_D_RETURN = 22,                  /* D_RETURN  */
  YYSYMBOL_D_RUN = 23,                     /* D_RUN  */
  YYSYMBOL_D_SET = 24,                     /* D_SET  */
  YYSYMBOL_D_STEP = 25,                    /* D_STEP  */
  YYSYMBOL_D_STEPI = 26,                   /* D_STEPI  */
  YYSYMBOL_D_TBREAK = 27,                  /* D_TBREAK  */
  YYSYMBOL_D_UP = 28,                      /* D_UP  */
  YYSYMBOL_D_UNTIL = 29,                   /* D_UNTIL  */
  YYSYMBOL_D_DISPLAY = 30,                 /* D_DISPLAY  */
  YYSYMBOL_D_UNDISPLAY = 31,               /* D_UNDISPLAY  */
  YYSYMBOL_D_WATCH = 32,                   /* D_WATCH  */
  YYSYMBOL_D_UNWATCH = 33,                 /* D_UNWATCH  */
  YYSYMBOL_D_DUMP = 34,                    /* D_DUMP  */
  YYSYMBOL_D_TRACE = 35,                   /* D_TRACE  */
  YYSYMBOL_D_INT = 36,                     /* D_INT  */
  YYSYMBOL_D_STRING = 37,                  /* D_STRING  */
  YYSYMBOL_D_NODE = 38,                    /* D_NODE  */
  YYSYMBOL_D_VARIABLE = 39,                /* D_VARIABLE  */
  YYSYMBOL_D_OPTION = 40,                  /* D_OPTION  */
  YYSYMBOL_D_COMMANDS = 41,                /* D_COMMANDS  */
  YYSYMBOL_D_END = 42,                     /* D_END  */
  YYSYMBOL_D_SILENT = 43,                  /* D_SILENT  */
  YYSYMBOL_D_SOURCE = 44,                  /* D_SOURCE  */
  YYSYMBOL_D_SAVE = 45,                    /* D_SAVE  */
  YYSYMBOL_D_EVAL = 46,                    /* D_EVAL  */
  YYSYMBOL_D_CONDITION = 47,               /* D_CONDITION  */
  YYSYMBOL_D_STATEMENT = 48,               /* D_STATEMENT  */
  YYSYMBOL_49_ = 49,                       /* '='  */
  YYSYMBOL_50_ = 50,                       /* ','  */
  YYSYMBOL_51_ = 51,                       /* ':'  */
  YYSYMBOL_52_ = 52,                       /* '@'  */
  YYSYMBOL_53_ = 53,                       /* '+'  */
  YYSYMBOL_54_ = 54,                       /* '-'  */
  YYSYMBOL_55_ = 55,                       /* '['  */
  YYSYMBOL_56_ = 56,                       /* ']'  */
  YYSYMBOL_57_ = 57,                       /* '$'  */
  YYSYMBOL_58_n_ = 58,                     /* '\n'  */
  YYSYMBOL_YYACCEPT = 59,                  /* $accept  */
  YYSYMBOL_input = 60,                     /* input  */
  YYSYMBOL_line = 61,                      /* line  */
  YYSYMBOL_control_cmd = 62,               /* control_cmd  */
  YYSYMBOL_d_cmd = 63,                     /* d_cmd  */
  YYSYMBOL_frame_cmd = 64,                 /* frame_cmd  */
  YYSYMBOL_break_cmd = 65,                 /* break_cmd  */
  YYSYMBOL_set_want_nodeval = 66,          /* set_want_nodeval  */
  YYSYMBOL_eval_prologue = 67,             /* eval_prologue  */
  YYSYMBOL_statement_list = 68,            /* statement_list  */
  YYSYMBOL_69_1 = 69,                      /* @1  */
  YYSYMBOL_eval_cmd = 70,                  /* eval_cmd  */
  YYSYMBOL_command = 71,                   /* command  */
  YYSYMBOL_72_2 = 72,                      /* $@2  */
  YYSYMBOL_73_3 = 73,                      /* $@3  */
  YYSYMBOL_74_4 = 74,                      /* $@4  */
  YYSYMBOL_75_5 = 75,                      /* $@5  */
  YYSYMBOL_76_6 = 76,                      /* $@6  */
  YYSYMBOL_77_7 = 77,                      /* $@7  */
  YYSYMBOL_78_8 = 78,                      /* $@8  */
  YYSYMBOL_condition_exp = 79,             /* condition_exp  */
  YYSYMBOL_commands_arg = 80,              /* commands_arg  */
  YYSYMBOL_opt_param_list = 81,            /* opt_param_list  */
  YYSYMBOL_param_list = 82,                /* param_list  */
  YYSYMBOL_opt_string_node = 83,           /* opt_string_node  */
  YYSYMBOL_string_node = 84,               /* string_node  */
  YYSYMBOL_option_args = 85,               /* option_args  */
  YYSYMBOL_func_name = 86,                 /* func_name  */
  YYSYMBOL_location = 87,                  /* location  */
  YYSYMBOL_break_args = 88,                /* break_args  */
  YYSYMBOL_89_9 = 89,                      /* $@9  */
  YYSYMBOL_90_10 = 90,                     /* $@10  */
  YYSYMBOL_opt_variable = 91,              /* opt_variable  */
  YYSYMBOL_opt_string = 92,                /* opt_string  */
  YYSYMBOL_opt_node = 93,                  /* opt_node  */
  YYSYMBOL_help_args = 94,                 /* help_args  */
  YYSYMBOL_enable_args = 95,               /* enable_args  */
  YYSYMBOL_print_exp = 96,                 /* print_exp  */
  YYSYMBOL_print_args = 97,                /* print_args  */
  YYSYMBOL_printf_exp = 98,                /* printf_exp  */
  YYSYMBOL_printf_args = 99,               /* printf_args  */
  YYSYMBOL_list_args = 100,                /* list_args  */
  YYSYMBOL_integer_range = 101,            /* integer_range  */
  YYSYMBOL_opt_integer_list = 102,         /* opt_integer_list  */
  YYSYMBOL_integer_list = 103,             /* integer_list  */
  YYSYMBOL_exp_list = 104,                 /* exp_list  */
  YYSYMBOL_subscript = 105,                /* subscript  */
  YYSYMBOL_subscript_list = 106,           /* subscript_list  */
  YYSYMBOL_variable = 107,                 /* variable  */
  YYSYMBOL_node = 108,                     /* node  */
  YYSYMBOL_opt_plus_integer = 109,         /* opt_plus_integer  */
  YYSYMBOL_opt_integer = 110,              /* opt_integer  */
  YYSYMBOL_plus_integer = 111,             /* plus_integer  */
  YYSYMBOL_integer = 112,                  /* integer  */
  YYSYMBOL_nls = 113                       /* nls  */
};
typedef enum yysymbol_kind_t yysymbol_kind_t;




#ifdef short
# undef short
#endif

/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
   <limits.h> and (if available) <stdint.h> are included
   so that the code can choose integer types of a good width.  */

#ifndef __PTRDIFF_MAX__
# include <limits.h> /* INFRINGES ON USER NAME SPACE */
# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
#  define YY_STDINT_H
# endif
#endif

/* Narrow types that promote to a signed type and that can represent a
   signed or unsigned integer of at least N bits.  In tables they can
   save space and decrease cache pressure.  Promoting to a signed type
   helps avoid bugs in integer arithmetic.  */

#ifdef __INT_LEAST8_MAX__
typedef __INT_LEAST8_TYPE__ yytype_int8;
#elif defined YY_STDINT_H
typedef int_least8_t yytype_int8;
#else
typedef signed char yytype_int8;
#endif

#ifdef __INT_LEAST16_MAX__
typedef __INT_LEAST16_TYPE__ yytype_int16;
#elif defined YY_STDINT_H
typedef int_least16_t yytype_int16;
#else
typedef short yytype_int16;
#endif

/* Work around bug in HP-UX 11.23, which defines these macros
   incorrectly for preprocessor constants.  This workaround can likely
   be removed in 2023, as HPE has promised support for HP-UX 11.23
   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
#ifdef __hpux
# undef UINT_LEAST8_MAX
# undef UINT_LEAST16_MAX
# define UINT_LEAST8_MAX 255
# define UINT_LEAST16_MAX 65535
#endif

#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
typedef __UINT_LEAST8_TYPE__ yytype_uint8;
#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST8_MAX <= INT_MAX)
typedef uint_least8_t yytype_uint8;
#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
typedef unsigned char yytype_uint8;
#else
typedef short yytype_uint8;
#endif

#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
typedef __UINT_LEAST16_TYPE__ yytype_uint16;
#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
       && UINT_LEAST16_MAX <= INT_MAX)
typedef uint_least16_t yytype_uint16;
#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
typedef unsigned short yytype_uint16;
#else
typedef int yytype_uint16;
#endif

#ifndef YYPTRDIFF_T
# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
#  define YYPTRDIFF_T __PTRDIFF_TYPE__
#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
# elif defined PTRDIFF_MAX
#  ifndef ptrdiff_t
#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  endif
#  define YYPTRDIFF_T ptrdiff_t
#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
# else
#  define YYPTRDIFF_T long
#  define YYPTRDIFF_MAXIMUM LONG_MAX
# endif
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned
# endif
#endif

#define YYSIZE_MAXIMUM                                  \
  YY_CAST (YYPTRDIFF_T,                                 \
           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
            ? YYPTRDIFF_MAXIMUM                         \
            : YY_CAST (YYSIZE_T, -1)))

#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))


/* Stored state numbers (used for stacks). */
typedef yytype_uint8 yy_state_t;

/* State numbers in computations.  */
typedef int yy_state_fast_t;

#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(Msgid) Msgid
# endif
#endif


#ifndef YY_ATTRIBUTE_PURE
# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define YY_ATTRIBUTE_PURE
# endif
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
# else
#  define YY_ATTRIBUTE_UNUSED
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YY_USE(E) ((void) (E))
#else
# define YY_USE(E) /* empty */
#endif

/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
# else
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# endif
# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif

#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
# define YY_IGNORE_USELESS_CAST_BEGIN                          \
    _Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
# define YY_IGNORE_USELESS_CAST_END            \
    _Pragma ("GCC diagnostic pop")
#endif
#ifndef YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_END
#endif


#define YY_ASSERT(E) ((void) (0 && (E)))

#if !defined yyoverflow

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
#     ifndef EXIT_SUCCESS
#      define EXIT_SUCCESS 0
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's 'empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
       && ! ((defined YYMALLOC || defined malloc) \
             && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef EXIT_SUCCESS
#    define EXIT_SUCCESS 0
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined EXIT_SUCCESS
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined EXIT_SUCCESS
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* !defined yyoverflow */

#if (! defined yyoverflow \
     && (! defined __cplusplus \
         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yy_state_t yyss_alloc;
  YYSTYPE yyvs_alloc;
};

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

# define YYCOPY_NEEDED 1

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
    do                                                                  \
      {                                                                 \
        YYPTRDIFF_T yynewbytes;                                         \
        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        Stack = &yyptr->Stack_alloc;                                    \
        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
      }                                                                 \
    while (0)

#endif

#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
/* Copy COUNT objects from SRC to DST.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(Dst, Src, Count) \
      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
#  else
#   define YYCOPY(Dst, Src, Count)              \
      do                                        \
        {                                       \
          YYPTRDIFF_T yyi;                      \
          for (yyi = 0; yyi < (Count); yyi++)   \
            (Dst)[yyi] = (Src)[yyi];            \
        }                                       \
      while (0)
#  endif
# endif
#endif /* !YYCOPY_NEEDED */

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  2
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   203

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  59
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  55
/* YYNRULES -- Number of rules.  */
#define YYNRULES  156
/* YYNSTATES -- Number of states.  */
#define YYNSTATES  203

/* YYMAXUTOK -- Last valid token kind.  */
#define YYMAXUTOK   303


/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex, with out-of-bounds checking.  */
#define YYTRANSLATE(YYX)                                \
  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
   : YYSYMBOL_YYUNDEF)

/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
   as returned by yylex.  */
static const yytype_int8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
      58,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,    57,     2,     2,     2,
       2,     2,     2,    53,    50,    54,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,    51,     2,
       2,    49,     2,     2,    52,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,    55,     2,    56,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    47,    48
};

#if YYDEBUG
/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
static const yytype_int16 yyrline[] =
{
       0,   110,   110,   111,   129,   130,   180,   187,   188,   189,
     190,   191,   195,   196,   197,   198,   202,   203,   204,   205,
     209,   210,   215,   219,   239,   246,   246,   253,   269,   283,
     284,   285,   286,   287,   288,   294,   306,   307,   308,   308,
     309,   309,   310,   311,   312,   313,   314,   314,   315,   316,
     316,   317,   317,   318,   318,   319,   320,   321,   326,   331,
     357,   367,   372,   384,   384,   392,   406,   419,   420,   426,
     427,   431,   432,   433,   434,   440,   441,   442,   447,   458,
     459,   464,   472,   489,   490,   491,   492,   493,   498,   499,
     499,   500,   501,   501,   502,   507,   508,   513,   514,   519,
     520,   524,   525,   529,   530,   545,   546,   551,   559,   560,
     561,   562,   566,   567,   571,   572,   573,   578,   579,   581,
     588,   589,   590,   591,   592,   593,   597,   610,   611,   612,
     616,   617,   618,   619,   623,   625,   627,   631,   646,   650,
     652,   657,   658,   667,   677,   679,   686,   699,   700,   706,
     707,   712,   718,   727,   729,   731,   739
};
#endif

/** Accessing symbol of state STATE.  */
#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])

#if YYDEBUG || 0
/* The user-facing name of the symbol whose (internal) number is
   YYSYMBOL.  No bounds checking.  */
static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;

/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
static const char *const yytname[] =
{
  "\"end of file\"", "error", "\"invalid token\"", "D_BACKTRACE",
  "D_BREAK", "D_CLEAR", "D_CONTINUE", "D_DELETE", "D_DISABLE", "D_DOWN",
  "D_ENABLE", "D_FINISH", "D_FRAME", "D_HELP", "D_IGNORE", "D_INFO",
  "D_LIST", "D_NEXT", "D_NEXTI", "D_PRINT", "D_PRINTF", "D_QUIT",
  "D_RETURN", "D_RUN", "D_SET", "D_STEP", "D_STEPI", "D_TBREAK", "D_UP",
  "D_UNTIL", "D_DISPLAY", "D_UNDISPLAY", "D_WATCH", "D_UNWATCH", "D_DUMP",
  "D_TRACE", "D_INT", "D_STRING", "D_NODE", "D_VARIABLE", "D_OPTION",
  "D_COMMANDS", "D_END", "D_SILENT", "D_SOURCE", "D_SAVE", "D_EVAL",
  "D_CONDITION", "D_STATEMENT", "'='", "','", "':'", "'@'", "'+'", "'-'",
  "'['", "']'", "'$'", "'\\n'", "$accept", "input", "line", "control_cmd",
  "d_cmd", "frame_cmd", "break_cmd", "set_want_nodeval", "eval_prologue",
  "statement_list", "@1", "eval_cmd", "command", "$@2", "$@3", "$@4",
  "$@5", "$@6", "$@7", "$@8", "condition_exp", "commands_arg",
  "opt_param_list", "param_list", "opt_string_node", "string_node",
  "option_args", "func_name", "location", "break_args", "$@9", "$@10",
  "opt_variable", "opt_string", "opt_node", "help_args", "enable_args",
  "print_exp", "print_args", "printf_exp", "printf_args", "list_args",
  "integer_range", "opt_integer_list", "integer_list", "exp_list",
  "subscript", "subscript_list", "variable", "node", "opt_plus_integer",
  "opt_integer", "plus_integer", "integer", "nls", YY_NULLPTR
};

static const char *
yysymbol_name (yysymbol_kind_t yysymbol)
{
  return yytname[yysymbol];
}
#endif

#define YYPACT_NINF (-151)

#define yypact_value_is_default(Yyn) \
  ((Yyn) == YYPACT_NINF)

#define YYTABLE_NINF (-148)

#define yytable_value_is_error(Yyn) \
  0

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
static const yytype_int16 yypact[] =
{
    -151,   145,  -151,   -34,  -151,  -151,    50,  -151,  -151,  -151,
    -151,    10,  -151,  -151,   -10,    59,    -9,    43,  -151,  -151,
    -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,
      50,  -151,  -151,  -151,  -151,    -8,    -6,    14,    12,  -151,
    -151,    22,    23,  -151,    59,  -151,  -151,    59,    13,    36,
      64,  -151,  -151,   -34,  -151,  -151,  -151,    24,    47,  -151,
    -151,  -151,  -151,    13,  -151,  -151,  -151,    59,    48,  -151,
    -151,    80,  -151,    67,    47,  -151,  -151,  -151,  -151,    48,
       4,    19,    69,   -20,  -151,   -20,   -20,  -151,  -151,  -151,
      70,  -151,  -151,  -151,  -151,  -151,  -151,  -151,    16,  -151,
    -151,  -151,  -151,    84,    85,  -151,  -151,    73,  -151,  -151,
    -151,    40,  -151,    74,  -151,  -151,  -151,    48,    59,  -151,
      74,  -151,    71,    89,    91,  -151,    42,  -151,  -151,  -151,
    -151,    81,  -151,  -151,    92,    94,  -151,  -151,    86,  -151,
    -151,     6,    96,  -151,  -151,  -151,   -34,    75,  -151,     6,
    -151,  -151,    74,     6,  -151,  -151,  -151,  -151,  -151,  -151,
    -151,  -151,    48,    31,  -151,    71,    71,  -151,    52,  -151,
     -17,  -151,  -151,    69,  -151,  -151,  -151,  -151,  -151,  -151,
    -151,    95,  -151,  -151,  -151,  -151,   -34,  -151,    17,  -151,
    -151,    71,  -151,  -151,  -151,  -151,     6,  -151,  -151,    69,
    -151,  -151,  -151
};

/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
   Performed when YYTABLE does not specify something else to do.  Zero
   means the default is an error.  */
static const yytype_uint8 yydefact[] =
{
       2,     0,     1,     0,    18,    20,    83,     7,    15,    14,
      17,     0,    32,    19,   101,     0,     0,   117,     8,     9,
      38,    40,    30,    49,    31,    46,    10,    11,    21,    16,
      83,    51,    12,    53,    13,    97,     0,    79,     0,    60,
      61,     0,     0,    22,     0,   156,     3,   147,     0,   149,
      88,    24,    65,     0,     4,     6,   151,    82,     0,    85,
      44,    84,   129,     0,    37,   131,   103,   128,   130,   102,
      29,     0,    35,    82,   118,   119,   121,    42,   122,   120,
       0,     0,    99,     0,    43,    95,     0,    98,    56,    62,
      80,    48,    68,    59,    67,   148,    57,    58,     0,    63,
      33,    55,   153,     0,     0,    34,   150,    82,    91,    45,
      89,     0,     5,     0,   152,   104,   133,   132,     0,    36,
       0,   111,   141,     0,     0,   108,    39,   105,   116,   112,
     114,    41,   113,   144,     0,     0,    50,   100,     0,    52,
      96,     0,     0,    74,    78,    71,     0,    70,    28,     0,
     154,   155,     0,     0,    27,    25,    82,    87,    86,   126,
     124,   125,   123,     0,   139,   143,   106,   142,     0,   109,
       0,   145,   146,     0,    77,    54,    66,    76,    81,    23,
      72,     0,    64,    94,    92,    90,     0,   136,     0,   134,
     140,   107,   110,   115,    47,    73,     0,    26,   138,     0,
     137,    93,   135
};

/* YYPGOTO[NTERM-NUM].  */
static const yytype_int16 yypgoto[] =
{
    -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,
    -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,  -151,
    -119,  -151,  -151,  -151,  -151,    38,  -151,   -15,   108,  -151,
    -151,  -151,  -151,  -151,  -151,  -151,  -151,   -90,  -151,   -31,
    -151,  -151,   -14,   -25,  -151,  -151,  -150,   -26,   -77,  -147,
      97,  -151,    -5,  -151,    -3
};

/* YYDEFGOTO[NTERM-NUM].  */
static const yytype_uint8 yydefgoto[] =
{
       0,     1,    46,    47,    48,    49,    50,    98,    51,   111,
     186,    52,    53,    80,    81,    83,    82,    85,    86,   149,
     175,    93,   146,   147,   176,   177,    91,    59,    60,   109,
     153,   196,   139,    88,   136,    70,    64,   125,   126,   130,
     131,    77,    65,    66,    67,   188,   164,   165,   127,   137,
      94,   105,    68,   106,    54
};

/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule whose
   number is the opposite.  If YYTABLE_NINF, syntax error.  */
static const yytype_int16 yytable[] =
{
      55,    61,    76,    78,   132,   121,   138,   174,   140,   141,
      71,    62,    79,    92,    62,   190,   189,   143,   198,   122,
     128,   129,   122,   101,    45,    61,   194,    69,    72,    87,
     182,    89,   187,    95,   185,   108,   169,   124,   115,    99,
     124,   190,    95,   122,   144,   110,    56,    63,    56,    56,
     112,    90,   202,   116,   144,   145,   123,   129,   122,    96,
      97,   124,   117,    58,   -75,    58,    58,   199,  -127,   133,
    -147,  -127,   102,   200,   -69,   113,   124,   201,   192,    56,
      73,   122,   154,   114,   134,   135,    56,    57,   155,   103,
     104,   122,   168,   132,   123,    56,    74,    75,   157,   124,
      56,   107,   118,    58,   123,   160,   161,   133,   158,   124,
      56,   156,    58,   159,   180,   162,   119,    58,   120,   142,
     150,   151,   134,   135,   152,   181,   163,    58,   166,   167,
     171,   170,   172,   178,   195,   173,   148,   183,    84,   193,
     191,     0,     0,   179,   100,     2,     3,   184,     4,     5,
       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
      36,     0,     0,   197,     0,    37,    38,    39,    40,    41,
      42,    43,    44,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,    45
};

static const yytype_int16 yycheck[] =
{
       3,     6,    17,    17,    81,     1,    83,     1,    85,    86,
      15,     1,    17,     1,     1,   165,   163,     1,     1,    39,
       1,    38,    39,    48,    58,    30,   173,    37,    37,    37,
     149,    37,     1,    38,   153,    50,   126,    57,    63,    44,
      57,   191,    47,    39,    38,    50,    36,    37,    36,    36,
      53,    37,   199,    67,    38,    39,    52,    38,    39,    37,
      37,    57,    67,    53,    58,    53,    53,    50,    58,    38,
      58,    58,    36,    56,    58,    51,    57,   196,   168,    36,
      37,    39,    42,    36,    53,    54,    36,    37,    48,    53,
      54,    39,    50,   170,    52,    36,    53,    54,   113,    57,
      36,    37,    54,    53,    52,   120,   120,    38,   113,    57,
      36,    37,    53,   118,    39,   120,    36,    53,    51,    49,
      36,    36,    53,    54,    51,    50,    55,    53,    39,    38,
      38,    50,    38,    37,    39,    49,    98,   152,    30,   170,
     166,    -1,    -1,   146,    47,     0,     1,   152,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    -1,    -1,   186,    -1,    40,    41,    42,    43,    44,
      45,    46,    47,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    58
};

/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
   state STATE-NUM.  */
static const yytype_int8 yystos[] =
{
       0,    60,     0,     1,     3,     4,     5,     6,     7,     8,
       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
      29,    30,    31,    32,    33,    34,    35,    40,    41,    42,
      43,    44,    45,    46,    47,    58,    61,    62,    63,    64,
      65,    67,    70,    71,   113,   113,    36,    37,    53,    86,
      87,   111,     1,    37,    95,   101,   102,   103,   111,    37,
      94,   111,    37,    37,    53,    54,    86,   100,   101,   111,
      72,    73,    75,    74,    87,    76,    77,    37,    92,    37,
      37,    85,     1,    80,   109,   111,    37,    37,    66,   111,
     109,   102,    36,    53,    54,   110,   112,    37,    86,    88,
     111,    68,   113,    51,    36,   102,   101,   111,    54,    36,
      51,     1,    39,    52,    57,    96,    97,   107,     1,    38,
      98,    99,   107,    38,    53,    54,    93,   108,   107,    91,
     107,   107,    49,     1,    38,    39,    81,    82,    84,    78,
      36,    36,    51,    89,    42,    48,    37,    86,   111,   111,
      86,   101,   111,    55,   105,   106,    39,    38,    50,    96,
      50,    38,    38,    49,     1,    79,    83,    84,    37,   113,
      39,    50,    79,    86,   111,    79,    69,     1,   104,   108,
     105,   106,    96,    98,   108,    39,    90,   113,     1,    50,
      56,    79,   108
};

/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
static const yytype_int8 yyr1[] =
{
       0,    59,    60,    60,    61,    61,    61,    62,    62,    62,
      62,    62,    63,    63,    63,    63,    64,    64,    64,    64,
      65,    65,    66,    67,    68,    69,    68,    70,    70,    71,
      71,    71,    71,    71,    71,    71,    71,    71,    72,    71,
      73,    71,    71,    71,    71,    71,    74,    71,    71,    75,
      71,    76,    71,    77,    71,    71,    71,    71,    71,    71,
      71,    71,    71,    78,    71,    71,    79,    80,    80,    81,
      81,    82,    82,    82,    82,    83,    83,    83,    84,    85,
      85,    85,    86,    87,    87,    87,    87,    87,    88,    89,
      88,    88,    90,    88,    88,    91,    91,    92,    92,    93,
      93,    94,    94,    95,    95,    96,    96,    96,    97,    97,
      97,    97,    98,    98,    99,    99,    99,   100,   100,   100,
     100,   100,   100,   100,   100,   100,   101,   102,   102,   102,
     103,   103,   103,   103,   104,   104,   104,   105,   105,   106,
     106,   107,   107,   107,   108,   108,   108,   109,   109,   110,
     110,   111,   111,   112,   112,   112,   113
};

/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
static const yytype_int8 yyr2[] =
{
       0,     2,     0,     2,     1,     2,     2,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     0,     4,     0,     0,     4,     3,     3,     2,
       1,     1,     1,     2,     2,     2,     3,     2,     0,     3,
       0,     3,     2,     2,     2,     2,     0,     5,     2,     0,
       3,     0,     3,     0,     4,     2,     2,     2,     2,     2,
       1,     1,     2,     0,     4,     1,     1,     1,     1,     0,
       1,     1,     2,     3,     1,     0,     1,     1,     1,     0,
       1,     3,     1,     0,     1,     1,     3,     3,     0,     0,
       3,     1,     0,     5,     3,     0,     1,     0,     1,     0,
       1,     0,     1,     1,     2,     1,     2,     3,     1,     2,
       3,     1,     1,     1,     1,     3,     1,     0,     1,     1,
       1,     1,     1,     3,     3,     3,     3,     0,     1,     1,
       1,     1,     2,     2,     1,     3,     1,     3,     3,     1,
       2,     1,     2,     2,     1,     2,     2,     0,     1,     0,
       1,     1,     2,     1,     2,     2,     1
};


enum { YYENOMEM = -2 };

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYNOMEM         goto yyexhaustedlab


#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)                                    \
  do                                                              \
    if (yychar == YYEMPTY)                                        \
      {                                                           \
        yychar = (Token);                                         \
        yylval = (Value);                                         \
        YYPOPSTACK (yylen);                                       \
        yystate = *yyssp;                                         \
        goto yybackup;                                            \
      }                                                           \
    else                                                          \
      {                                                           \
        yyerror (YY_("syntax error: cannot back up")); \
        YYERROR;                                                  \
      }                                                           \
  while (0)

/* Backward compatibility with an undocumented macro.
   Use YYerror or YYUNDEF. */
#define YYERRCODE YYUNDEF


/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF fprintf
# endif

# define YYDPRINTF(Args)                        \
do {                                            \
  if (yydebug)                                  \
    YYFPRINTF Args;                             \
} while (0)




# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
do {                                                                      \
  if (yydebug)                                                            \
    {                                                                     \
      YYFPRINTF (stderr, "%s ", Title);                                   \
      yy_symbol_print (stderr,                                            \
                  Kind, Value); \
      YYFPRINTF (stderr, "\n");                                           \
    }                                                                     \
} while (0)


/*-----------------------------------.
| Print this symbol's value on YYO.  |
`-----------------------------------*/

static void
yy_symbol_value_print (FILE *yyo,
                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
  FILE *yyoutput = yyo;
  YY_USE (yyoutput);
  if (!yyvaluep)
    return;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/*---------------------------.
| Print this symbol on YYO.  |
`---------------------------*/

static void
yy_symbol_print (FILE *yyo,
                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
{
  YYFPRINTF (yyo, "%s %s (",
             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));

  yy_symbol_value_print (yyo, yykind, yyvaluep);
  YYFPRINTF (yyo, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

static void
yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
{
  YYFPRINTF (stderr, "Stack now");
  for (; yybottom <= yytop; yybottom++)
    {
      int yybot = *yybottom;
      YYFPRINTF (stderr, " %d", yybot);
    }
  YYFPRINTF (stderr, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)                            \
do {                                                            \
  if (yydebug)                                                  \
    yy_stack_print ((Bottom), (Top));                           \
} while (0)


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

static void
yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
                 int yyrule)
{
  int yylno = yyrline[yyrule];
  int yynrhs = yyr2[yyrule];
  int yyi;
  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
             yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
      yy_symbol_print (stderr,
                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
                       &yyvsp[(yyi + 1) - (yynrhs)]);
      YYFPRINTF (stderr, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)          \
do {                                    \
  if (yydebug)                          \
    yy_reduce_print (yyssp, yyvsp, Rule); \
} while (0)

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args) ((void) 0)
# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif






/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

static void
yydestruct (const char *yymsg,
            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
{
  YY_USE (yyvaluep);
  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  YY_USE (yykind);
  YY_IGNORE_MAYBE_UNINITIALIZED_END
}


/* Lookahead token kind.  */
int yychar;

/* The semantic value of the lookahead symbol.  */
YYSTYPE yylval;
/* Number of syntax errors so far.  */
int yynerrs;




/*----------.
| yyparse.  |
`----------*/

int
yyparse (void)
{
    yy_state_fast_t yystate = 0;
    /* Number of tokens to shift before error messages enabled.  */
    int yyerrstatus = 0;

    /* Refer to the stacks through separate pointers, to allow yyoverflow
       to reallocate them elsewhere.  */

    /* Their size.  */
    YYPTRDIFF_T yystacksize = YYINITDEPTH;

    /* The state stack: array, bottom, top.  */
    yy_state_t yyssa[YYINITDEPTH];
    yy_state_t *yyss = yyssa;
    yy_state_t *yyssp = yyss;

    /* The semantic value stack: array, bottom, top.  */
    YYSTYPE yyvsa[YYINITDEPTH];
    YYSTYPE *yyvs = yyvsa;
    YYSTYPE *yyvsp = yyvs;

  int yyn;
  /* The return value of yyparse.  */
  int yyresult;
  /* Lookahead symbol kind.  */
  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;



#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  YYDPRINTF ((stderr, "Starting parse\n"));

  yychar = YYEMPTY; /* Cause a token to be read.  */

  goto yysetstate;


/*------------------------------------------------------------.
| yynewstate -- push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;


/*--------------------------------------------------------------------.
| yysetstate -- set current state (the top of the stack) to yystate.  |
`--------------------------------------------------------------------*/
yysetstate:
  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
  YY_IGNORE_USELESS_CAST_BEGIN
  *yyssp = YY_CAST (yy_state_t, yystate);
  YY_IGNORE_USELESS_CAST_END
  YY_STACK_PRINT (yyss, yyssp);

  if (yyss + yystacksize - 1 <= yyssp)
#if !defined yyoverflow && !defined YYSTACK_RELOCATE
    YYNOMEM;
#else
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYPTRDIFF_T yysize = yyssp - yyss + 1;

# if defined yyoverflow
      {
        /* Give user a chance to reallocate the stack.  Use copies of
           these so that the &'s don't force the real ones into
           memory.  */
        yy_state_t *yyss1 = yyss;
        YYSTYPE *yyvs1 = yyvs;

        /* Each stack pointer address is followed by the size of the
           data in use in that stack, in bytes.  This used to be a
           conditional around just the two extra args, but that might
           be undefined if yyoverflow is a macro.  */
        yyoverflow (YY_("memory exhausted"),
                    &yyss1, yysize * YYSIZEOF (*yyssp),
                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
                    &yystacksize);
        yyss = yyss1;
        yyvs = yyvs1;
      }
# else /* defined YYSTACK_RELOCATE */
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
        YYNOMEM;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
        yystacksize = YYMAXDEPTH;

      {
        yy_state_t *yyss1 = yyss;
        union yyalloc *yyptr =
          YY_CAST (union yyalloc *,
                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
        if (! yyptr)
          YYNOMEM;
        YYSTACK_RELOCATE (yyss_alloc, yyss);
        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
#  undef YYSTACK_RELOCATE
        if (yyss1 != yyssa)
          YYSTACK_FREE (yyss1);
      }
# endif

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;

      YY_IGNORE_USELESS_CAST_BEGIN
      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
                  YY_CAST (long, yystacksize)));
      YY_IGNORE_USELESS_CAST_END

      if (yyss + yystacksize - 1 <= yyssp)
        YYABORT;
    }
#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */


  if (yystate == YYFINAL)
    YYACCEPT;

  goto yybackup;


/*-----------.
| yybackup.  |
`-----------*/
yybackup:
  /* Do appropriate processing given the current state.  Read a
     lookahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to lookahead token.  */
  yyn = yypact[yystate];
  if (yypact_value_is_default (yyn))
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((stderr, "Reading a token\n"));
      yychar = yylex ();
    }

  if (yychar <= YYEOF)
    {
      yychar = YYEOF;
      yytoken = YYSYMBOL_YYEOF;
      YYDPRINTF ((stderr, "Now at end of input.\n"));
    }
  else if (yychar == YYerror)
    {
      /* The scanner already issued an error message, process directly
         to error recovery.  But do not keep the error token as
         lookahead, it is too special and may lead us to an endless
         loop in error recovery. */
      yychar = YYUNDEF;
      yytoken = YYSYMBOL_YYerror;
      goto yyerrlab1;
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yytable_value_is_error (yyn))
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the lookahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
  yystate = yyn;
  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END

  /* Discard the shifted token.  */
  yychar = YYEMPTY;
  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     '$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
  case 3: /* input: input line  */
#line 112 "command.y"
          {
		cmd_idx = -1;
		want_nodeval = false;
		if (lexptr_begin != NULL) {
			if (input_from_tty && lexptr_begin[0] != '\0')
				add_history(lexptr_begin);
			efree(lexptr_begin);
			lexptr_begin = NULL;
		}
		if (arg_list != NULL) {
			free_cmdarg(arg_list);
			arg_list = NULL;
		}
	  }
#line 1556 "command.c"
    break;

  case 5: /* line: command nls  */
#line 131 "command.y"
          {
		if (dbg_errcount == 0 && cmd_idx >= 0) {
			Func_cmd cmdfunc;
			bool terminate = false;
			CMDARG *args;
			int ctype = 0;

			ctype = cmdtab[cmd_idx].type;

			/* a blank line repeats previous command
			 * (list, next, nexti, step, stepi and continue without arguments).
			 * save the index in the command table; used in yylex
			 */
			if ((ctype == D_list
					|| ctype == D_next
					|| ctype == D_step
					|| ctype == D_nexti
					|| ctype == D_stepi
					|| ctype == D_continue)
				&& arg_list == NULL
				&& ! in_commands
				&& input_from_tty
			)
				repeat_idx = cmd_idx;
			else
				repeat_idx = -1;

			/* call the command handler; reset the globals arg_list, cmd_idx,
			 * since this handler could invoke yyparse again.
			 * call do_commands for the list of commands in `commands';
			 * arg_list isn't freed on return.
			 */

			cmdfunc = cmdtab[cmd_idx].cf_ptr;
			if (in_commands)
				cmdfunc = do_commands;
			cmd_idx = -1;
			want_nodeval = false;

			args = arg_list;
			arg_list = NULL;

			terminate = (*cmdfunc)(args, ctype);
			if (! in_commands || ctype == D_commands)
				free_cmdarg(args);
			if (terminate)
				YYACCEPT;
		}
	  }
#line 1610 "command.c"
    break;

  case 6: /* line: error nls  */
#line 181 "command.y"
          {
		yyerrok;
	  }
#line 1618 "command.c"
    break;

  case 22: /* set_want_nodeval: %empty  */
#line 215 "command.y"
          { want_nodeval = true; }
#line 1624 "command.c"
    break;

  case 23: /* eval_prologue: D_EVAL set_want_nodeval opt_param_list nls  */
#line 220 "command.y"
          {
		if (dbg_errcount == 0) {
			/* don't free arg_list;	passed on to statement_list
			 * non-terminal (empty rule action). See below.
			 */
			if (input_from_tty) {
				dbg_prompt = eval_prompt;
				fprintf(out_fp,
		_("Type (g)awk statement(s). End with the command `end'\n"));
				rl_inhibit_completion = 1;
			}
			cmd_idx = -1;
			in_eval = true;
		}
	  }
#line 1644 "command.c"
    break;

  case 24: /* statement_list: %empty  */
#line 239 "command.y"
          {
		yyval = append_statement(arg_list, (char *) start_EVAL);
		if (read_a_line == read_commands_string)	/* unserializing 'eval' in 'commands' */
			yyval->a_string[0] = '\0';
		free_cmdarg(arg_list);
		arg_list = NULL;
	  }
#line 1656 "command.c"
    break;

  case 25: /* @1: %empty  */
#line 246 "command.y"
                                     { yyval = append_statement(yyvsp[-1], lexptr_begin); }
#line 1662 "command.c"
    break;

  case 26: /* statement_list: statement_list D_STATEMENT @1 nls  */
#line 247 "command.y"
          {
		yyval = yyvsp[-1];
	  }
#line 1670 "command.c"
    break;

  case 27: /* eval_cmd: eval_prologue statement_list D_END  */
#line 254 "command.y"
          {
		arg_list = append_statement(yyvsp[-1], (char *) end_EVAL);
		if (read_a_line == read_commands_string) {	/* unserializing 'eval' in 'commands' */
			char *str = arg_list->a_string;
			size_t len = strlen(str);
			assert(len > 2 && str[len - 2] == '}');
			str[len - 2] = '\0';
		}
		if (input_from_tty) {
			dbg_prompt = in_commands ? commands_prompt : dgawk_prompt;
			rl_inhibit_completion = 0;
		}
		cmd_idx = find_command("eval", 4);
		in_eval = false;
	  }
#line 1690 "command.c"
    break;

  case 28: /* eval_cmd: D_EVAL set_want_nodeval string_node  */
#line 270 "command.y"
          {
		NODE *n;
		CMDARG *arg;
		n = yyvsp[0]->a_node;
		arg = append_statement(NULL, (char *) start_EVAL);
		(void) append_statement(arg, n->stptr);
		(void) append_statement(arg, (char *) end_EVAL);
		free_cmdarg(arg_list);
		arg_list = arg;
	  }
#line 1705 "command.c"
    break;

  case 34: /* command: frame_cmd opt_integer  */
#line 289 "command.y"
          {
		if (cmdtab[cmd_idx].lex_class == D_FRAME
				&& yyvsp[0] != NULL && yyvsp[0]->a_int < 0)
			yyerror(_("invalid frame number: %d"), yyvsp[0]->a_int);
	  }
#line 1715 "command.c"
    break;

  case 35: /* command: D_INFO D_STRING  */
#line 295 "command.y"
          {
		int idx = find_argument(yyvsp[0]);
		if (idx < 0)
			yyerror(_("info: invalid option - `%s'"), yyvsp[0]->a_string);
		else {
			efree(yyvsp[0]->a_string);
			yyvsp[0]->a_string = NULL;
			yyvsp[0]->type = D_argument;
			yyvsp[0]->a_argument = argtab[idx].value;
		}
	  }
#line 1731 "command.c"
    break;

  case 38: /* $@2: %empty  */
#line 308 "command.y"
                  { want_nodeval = true; }
#line 1737 "command.c"
    break;

  case 40: /* $@3: %empty  */
#line 309 "command.y"
                   { want_nodeval = true; }
#line 1743 "command.c"
    break;

  case 46: /* $@4: %empty  */
#line 314 "command.y"
                { want_nodeval = true; }
#line 1749 "command.c"
    break;

  case 49: /* $@5: %empty  */
#line 316 "command.y"
                   { want_nodeval = true; }
#line 1755 "command.c"
    break;

  case 51: /* $@6: %empty  */
#line 317 "command.y"
                    { want_nodeval = true; }
#line 1761 "command.c"
    break;

  case 53: /* $@7: %empty  */
#line 318 "command.y"
                  { want_nodeval = true; }
#line 1767 "command.c"
    break;

  case 57: /* command: D_SOURCE D_STRING  */
#line 322 "command.y"
          {
		if (in_cmd_src(yyvsp[0]->a_string))
			yyerror(_("source: `%s': already sourced"), yyvsp[0]->a_string);
	  }
#line 1776 "command.c"
    break;

  case 58: /* command: D_SAVE D_STRING  */
#line 327 "command.y"
          {
		if (! input_from_tty)
			yyerror(_("save: `%s': command not permitted"), yyvsp[0]->a_string);
	  }
#line 1785 "command.c"
    break;

  case 59: /* command: D_COMMANDS commands_arg  */
#line 332 "command.y"
          {
		int type = 0;
		int num;

		if (yyvsp[0] != NULL)
			num = yyvsp[0]->a_int;

		if (dbg_errcount != 0)
			;
		else if (in_commands)
			yyerror(_("cannot use command `commands' for breakpoint/watchpoint commands"));
		else if (yyvsp[0] == NULL &&  ! (type = has_break_or_watch_point(&num, true)))
			yyerror(_("no breakpoint/watchpoint has been set yet"));
		else if (yyvsp[0] != NULL && ! (type = has_break_or_watch_point(&num, false)))
			yyerror(_("invalid breakpoint/watchpoint number"));
		if (type) {
			in_commands = true;
			if (input_from_tty) {
				dbg_prompt = commands_prompt;
				fprintf(out_fp, _("Type commands for when %s %d is hit, one per line.\n"),
								(type == D_break) ? "breakpoint" : "watchpoint", num);
				fprintf(out_fp, _("End with the command `end'\n"));
			}
		}
	  }
#line 1815 "command.c"
    break;

  case 60: /* command: D_END  */
#line 358 "command.y"
          {
		if (! in_commands)
			yyerror(_("`end' valid only in command `commands' or `eval'"));
		else {
			if (input_from_tty)
				dbg_prompt = dgawk_prompt;
			in_commands = false;
		}
	  }
#line 1829 "command.c"
    break;

  case 61: /* command: D_SILENT  */
#line 368 "command.y"
          {
		if (! in_commands)
			yyerror(_("`silent' valid only in command `commands'"));
	  }
#line 1838 "command.c"
    break;

  case 62: /* command: D_TRACE D_STRING  */
#line 373 "command.y"
          {
		int idx = find_argument(yyvsp[0]);
		if (idx < 0)
			yyerror(_("trace: invalid option - `%s'"), yyvsp[0]->a_string);
		else {
			efree(yyvsp[0]->a_string);
			yyvsp[0]->a_string = NULL;
			yyvsp[0]->type = D_argument;
			yyvsp[0]->a_argument = argtab[idx].value;
		}
	  }
#line 1854 "command.c"
    break;

  case 63: /* $@8: %empty  */
#line 384 "command.y"
                                   { want_nodeval = true; }
#line 1860 "command.c"
    break;

  case 64: /* command: D_CONDITION plus_integer $@8 condition_exp  */
#line 385 "command.y"
          {
		int type;
		int num = yyvsp[-2]->a_int;
		type = has_break_or_watch_point(&num, false);
		if (! type)
			yyerror(_("condition: invalid breakpoint/watchpoint number"));
	  }
#line 1872 "command.c"
    break;

  case 65: /* command: eval_cmd  */
#line 393 "command.y"
          {
		if (in_commands) {
			/* Prepend command 'eval' to argument list */
			CMDARG *arg;
			arg = mk_cmdarg(D_string);
			arg->a_string = estrdup("eval", 4);
			arg->next = arg_list;
			arg_list = arg;
		}
	  }
#line 1887 "command.c"
    break;

  case 66: /* condition_exp: opt_string_node  */
#line 407 "command.y"
          {
		if (yyvsp[0] != NULL) {
			NODE *n = yyvsp[0]->a_node;
			yyvsp[0]->type = D_string;
			yyvsp[0]->a_string = n->stptr;
			freenode(n);
		}
		yyval = yyvsp[0];
	  }
#line 1901 "command.c"
    break;

  case 68: /* commands_arg: error  */
#line 421 "command.y"
          {	yyval = NULL; }
#line 1907 "command.c"
    break;

  case 69: /* opt_param_list: %empty  */
#line 426 "command.y"
          { yyval = NULL; }
#line 1913 "command.c"
    break;

  case 74: /* param_list: error  */
#line 435 "command.y"
          { yyval = NULL; }
#line 1919 "command.c"
    break;

  case 75: /* opt_string_node: %empty  */
#line 440 "command.y"
          { yyval = NULL; }
#line 1925 "command.c"
    break;

  case 77: /* opt_string_node: error  */
#line 443 "command.y"
          { yyval = NULL; }
#line 1931 "command.c"
    break;

  case 78: /* string_node: D_NODE  */
#line 448 "command.y"
          {
		NODE *n;
		n = yyvsp[0]->a_node;
		if ((n->flags & STRING) == 0)
			yyerror(_("argument not a string"));
	  }
#line 1942 "command.c"
    break;

  case 79: /* option_args: %empty  */
#line 458 "command.y"
          { yyval = NULL; }
#line 1948 "command.c"
    break;

  case 80: /* option_args: D_STRING  */
#line 460 "command.y"
          {
		if (find_option(yyvsp[0]->a_string) < 0)
			yyerror(_("option: invalid parameter - `%s'"), yyvsp[0]->a_string);
 	  }
#line 1957 "command.c"
    break;

  case 81: /* option_args: D_STRING '=' D_STRING  */
#line 465 "command.y"
          {
		if (find_option(yyvsp[-2]->a_string) < 0)
			yyerror(_("option: invalid parameter - `%s'"), yyvsp[-2]->a_string);
 	  }
#line 1966 "command.c"
    break;

  case 82: /* func_name: D_STRING  */
#line 473 "command.y"
          {
		NODE *n;
		n = lookup(yyvsp[0]->a_string);
		if (n == NULL || n->type != Node_func)
			yyerror(_("no such function - `%s'"), yyvsp[0]->a_string);
		else {
			yyvsp[0]->type = D_func;
			efree(yyvsp[0]->a_string);
			yyvsp[0]->a_string = NULL;
			yyvsp[0]->a_node = n;
		}
	  }
#line 1983 "command.c"
    break;

  case 83: /* location: %empty  */
#line 489 "command.y"
          { yyval = NULL; }
#line 1989 "command.c"
    break;

  case 88: /* break_args: %empty  */
#line 498 "command.y"
          { yyval = NULL; }
#line 1995 "command.c"
    break;

  case 89: /* $@9: %empty  */
#line 499 "command.y"
                       { want_nodeval = true; }
#line 2001 "command.c"
    break;

  case 92: /* $@10: %empty  */
#line 501 "command.y"
                                    { want_nodeval = true; }
#line 2007 "command.c"
    break;

  case 95: /* opt_variable: %empty  */
#line 507 "command.y"
          { yyval = NULL; }
#line 2013 "command.c"
    break;

  case 97: /* opt_string: %empty  */
#line 513 "command.y"
          { yyval = NULL; }
#line 2019 "command.c"
    break;

  case 99: /* opt_node: %empty  */
#line 519 "command.y"
          { yyval = NULL; }
#line 2025 "command.c"
    break;

  case 104: /* enable_args: D_STRING opt_integer_list  */
#line 531 "command.y"
          {
		int idx = find_argument(yyvsp[-1]);
		if (idx < 0)
			yyerror(_("enable: invalid option - `%s'"), yyvsp[-1]->a_string);
		else {
			efree(yyvsp[-1]->a_string);
			yyvsp[-1]->a_string = NULL;
			yyvsp[-1]->type = D_argument;
			yyvsp[-1]->a_argument = argtab[idx].value;
		}
	  }
#line 2041 "command.c"
    break;

  case 106: /* print_exp: '@' D_VARIABLE  */
#line 547 "command.y"
          {
		yyvsp[0]->type = D_array;	/* dump all items */
		yyvsp[0]->a_count = 0;
	  }
#line 2050 "command.c"
    break;

  case 107: /* print_exp: '@' D_VARIABLE subscript_list  */
#line 552 "command.y"
          {
		yyvsp[-1]->type = D_array;
		yyvsp[-1]->a_count = num_dim;
	  }
#line 2059 "command.c"
    break;

  case 117: /* list_args: %empty  */
#line 578 "command.y"
          { yyval = NULL; }
#line 2065 "command.c"
    break;

  case 118: /* list_args: '+'  */
#line 580 "command.y"
          { yyval = NULL; }
#line 2071 "command.c"
    break;

  case 119: /* list_args: '-'  */
#line 582 "command.y"
          {
		CMDARG *a;
		a = mk_cmdarg(D_int);
		a->a_int = -1;
		append_cmdarg(a);
	  }
#line 2082 "command.c"
    break;

  case 126: /* integer_range: plus_integer '-' plus_integer  */
#line 598 "command.y"
          {
		if (yyvsp[-2]->a_int > yyvsp[0]->a_int)
			yyerror(_("invalid range specification: %d - %d"),
				yyvsp[-2]->a_int, yyvsp[0]->a_int);
		else
			yyvsp[-2]->type = D_range;
		yyval = yyvsp[-2];
	  }
#line 2095 "command.c"
    break;

  case 127: /* opt_integer_list: %empty  */
#line 610 "command.y"
          { yyval = NULL; }
#line 2101 "command.c"
    break;

  case 134: /* exp_list: node  */
#line 624 "command.y"
          { yyval = yyvsp[0]; }
#line 2107 "command.c"
    break;

  case 135: /* exp_list: exp_list ',' node  */
#line 626 "command.y"
          { yyval = yyvsp[-2]; }
#line 2113 "command.c"
    break;

  case 137: /* subscript: '[' exp_list ']'  */
#line 632 "command.y"
          {
		CMDARG *a;
		NODE *subs;
		int count = 0;

		for (a = yyvsp[-1]; a != NULL; a = a->next)
			count++;
		subs = concat_args(yyvsp[-1], count);
		free_cmdarg(yyvsp[-1]->next);
		yyvsp[-1]->next = NULL;
		yyvsp[-1]->type = D_node;
		yyvsp[-1]->a_node = subs;
		yyval = yyvsp[-1];
	  }
#line 2132 "command.c"
    break;

  case 139: /* subscript_list: subscript  */
#line 651 "command.y"
          { yyval = yyvsp[0]; num_dim = 1; }
#line 2138 "command.c"
    break;

  case 140: /* subscript_list: subscript_list subscript  */
#line 653 "command.y"
          {	yyval = yyvsp[-1]; num_dim++; }
#line 2144 "command.c"
    break;

  case 142: /* variable: '$' D_NODE  */
#line 659 "command.y"
          {
		NODE *n = yyvsp[0]->a_node;
		if ((n->flags & NUMBER) == 0)
			yyerror(_("non-numeric value for field number"));
		else
			yyvsp[0]->type = D_field;
		yyval = yyvsp[0];
	  }
#line 2157 "command.c"
    break;

  case 143: /* variable: D_VARIABLE subscript_list  */
#line 668 "command.y"
          {
		/* a_string is array name, a_count is dimension count */
		yyvsp[-1]->type = D_subscript;
		yyvsp[-1]->a_count = num_dim;
		yyval = yyvsp[-1];
	  }
#line 2168 "command.c"
    break;

  case 144: /* node: D_NODE  */
#line 678 "command.y"
          { yyval = yyvsp[0]; }
#line 2174 "command.c"
    break;

  case 145: /* node: '+' D_NODE  */
#line 680 "command.y"
          {
		NODE *n = yyvsp[0]->a_node;
		if ((n->flags & NUMBER) == 0)
			yyerror(_("non-numeric value found, numeric expected"));
		yyval = yyvsp[0];
	  }
#line 2185 "command.c"
    break;

  case 146: /* node: '-' D_NODE  */
#line 687 "command.y"
          {
		NODE *n = yyvsp[0]->a_node;
		if ((n->flags & NUMBER) == 0)
			yyerror(_("non-numeric value found, numeric expected"));
		else
			negate_num(n);
		yyval = yyvsp[0];
	  }
#line 2198 "command.c"
    break;

  case 147: /* opt_plus_integer: %empty  */
#line 699 "command.y"
          { yyval = NULL; }
#line 2204 "command.c"
    break;

  case 148: /* opt_plus_integer: plus_integer  */
#line 701 "command.y"
          { yyval = yyvsp[0]; }
#line 2210 "command.c"
    break;

  case 149: /* opt_integer: %empty  */
#line 706 "command.y"
          { yyval = NULL; }
#line 2216 "command.c"
    break;

  case 150: /* opt_integer: integer  */
#line 708 "command.y"
          { yyval = yyvsp[0]; }
#line 2222 "command.c"
    break;

  case 151: /* plus_integer: D_INT  */
#line 713 "command.y"
          {
		if (yyvsp[0]->a_int == 0)
			yyerror(_("non-zero integer value"));
		yyval = yyvsp[0];
	  }
#line 2232 "command.c"
    break;

  case 152: /* plus_integer: '+' D_INT  */
#line 719 "command.y"
          {
		if (yyvsp[0]->a_int == 0)
			yyerror(_("non-zero integer value"));
		yyval = yyvsp[0];
	  }
#line 2242 "command.c"
    break;

  case 153: /* integer: D_INT  */
#line 728 "command.y"
          { yyval = yyvsp[0]; }
#line 2248 "command.c"
    break;

  case 154: /* integer: '+' D_INT  */
#line 730 "command.y"
          { yyval = yyvsp[0]; }
#line 2254 "command.c"
    break;

  case 155: /* integer: '-' D_INT  */
#line 732 "command.y"
          {
		yyvsp[0]->a_int = - yyvsp[0]->a_int;
		yyval = yyvsp[0];
	  }
#line 2263 "command.c"
    break;

  case 156: /* nls: '\n'  */
#line 740 "command.y"
          {
		if (lexptr_begin != NULL) {
			if (input_from_tty && lexptr_begin[0] != '\0')
				add_history(lexptr_begin);
			efree(lexptr_begin);
			lexptr_begin = NULL;
		}
	  }
#line 2276 "command.c"
    break;


#line 2280 "command.c"

      default: break;
    }
  /* User semantic actions sometimes alter yychar, and that requires
     that yytoken be updated with the new translation.  We take the
     approach of translating immediately before every use of yytoken.
     One alternative is translating here after every semantic action,
     but that translation would be missed if the semantic action invokes
     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
     incorrect destructor might then be invoked immediately.  In the
     case of YYERROR or YYBACKUP, subsequent parser actions might lead
     to an incorrect destructor call or verbose syntax error message
     before the lookahead is translated.  */
  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;

  *++yyvsp = yyval;

  /* Now 'shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */
  {
    const int yylhs = yyr1[yyn] - YYNTOKENS;
    const int yyi = yypgoto[yylhs] + *yyssp;
    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
               ? yytable[yyi]
               : yydefgoto[yylhs]);
  }

  goto yynewstate;


/*--------------------------------------.
| yyerrlab -- here on detecting error.  |
`--------------------------------------*/
yyerrlab:
  /* Make sure we have latest lookahead translation.  See comments at
     user semantic actions for why this is necessary.  */
  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
      yyerror (YY_("syntax error"));
    }

  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse lookahead token after an
         error, discard it.  */

      if (yychar <= YYEOF)
        {
          /* Return failure if at end of input.  */
          if (yychar == YYEOF)
            YYABORT;
        }
      else
        {
          yydestruct ("Error: discarding",
                      yytoken, &yylval);
          yychar = YYEMPTY;
        }
    }

  /* Else will try to reuse lookahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:
  /* Pacify compilers when the user code never invokes YYERROR and the
     label yyerrorlab therefore never appears in user code.  */
  if (0)
    YYERROR;
  ++yynerrs;

  /* Do not reclaim the symbols of the rule whose action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;      /* Each real token shifted decrements this.  */

  /* Pop stack until we find a state that shifts the error token.  */
  for (;;)
    {
      yyn = yypact[yystate];
      if (!yypact_value_is_default (yyn))
        {
          yyn += YYSYMBOL_YYerror;
          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
        YYABORT;


      yydestruct ("Error: popping",
                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  *++yyvsp = yylval;
  YY_IGNORE_MAYBE_UNINITIALIZED_END


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturnlab;


/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturnlab;


/*-----------------------------------------------------------.
| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
`-----------------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_("memory exhausted"));
  yyresult = 2;
  goto yyreturnlab;


/*----------------------------------------------------------.
| yyreturnlab -- parsing is finished, clean up and return.  |
`----------------------------------------------------------*/
yyreturnlab:
  if (yychar != YYEMPTY)
    {
      /* Make sure we have latest lookahead translation.  See comments at
         user semantic actions for why this is necessary.  */
      yytoken = YYTRANSLATE (yychar);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval);
    }
  /* Do not reclaim the symbols of the rule whose action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif

  return yyresult;
}

#line 750 "command.y"



/* append_statement --- append 'stmt' to the list of eval awk statements */

static CMDARG *
append_statement(CMDARG *stmt_list, char *stmt)
{
	CMDARG *a, *arg;
	char *s;
	int len, slen, ssize;

#define EVALSIZE	512

	if (stmt == start_EVAL) {
		len = sizeof(start_EVAL);
		for (a = stmt_list; a != NULL; a = a->next)
			len += strlen(a->a_string) + 1;	/* 1 for ',' */
		len += EVALSIZE;

		emalloc(s, char *, (len + 1) * sizeof(char));
		arg = mk_cmdarg(D_string);
		arg->a_string = s;
		arg->a_count = len;	/* kludge */

		slen = sizeof("function @eval(") - 1;
		memcpy(s, start_EVAL, slen);

		for (a = stmt_list; a != NULL; a = a->next) {
			len = strlen(a->a_string);
			memcpy(s + slen, a->a_string, len);
			slen += len;
			if (a->next != NULL)
				s[slen++] = ',';
		}
		s[slen++] = ')';
		s[slen++] = '{';
		s[slen] = '\0';
		return arg;
	}

	len = strlen(stmt) + 1;	/* 1 for newline */
	s = stmt_list->a_string;
	slen = strlen(s);
	ssize = stmt_list->a_count;
	if (len > ssize - slen) {
		ssize = slen + len + EVALSIZE;
		erealloc(s, char *, (ssize + 1) * sizeof(char));
		stmt_list->a_string = s;
		stmt_list->a_count = ssize;
	}
	memcpy(s + slen, stmt, len);
	slen += len;
	if (slen >= 2 && s[slen - 2] != '\n') {
		s[slen - 1] = '\n';
		s[slen] = '\0';
	}

	if (stmt == end_EVAL)
		erealloc(stmt_list->a_string, char *, slen + 1);
	return stmt_list;

#undef EVALSIZE
}


/* command names sorted in ascending order */

struct cmdtoken cmdtab[] = {
{ "backtrace", "bt", D_backtrace, D_BACKTRACE, do_backtrace,
	gettext_noop("backtrace [N] - print trace of all or N innermost (outermost if N < 0) frames") },
{ "break", "b", D_break, D_BREAK, do_breakpoint,
	gettext_noop("break [[filename:]N|function] - set breakpoint at the specified location") },
{ "clear", "", D_clear, D_CLEAR, do_clear,
	gettext_noop("clear [[filename:]N|function] - delete breakpoints previously set") },
{ "commands", "", D_commands, D_COMMANDS, do_commands,
	gettext_noop("commands [num] - starts a list of commands to be executed at a breakpoint(watchpoint) hit") },
{ "condition", "", D_condition, D_CONDITION, do_condition,
	gettext_noop("condition num [expr] - set or clear breakpoint or watchpoint condition") },
{ "continue", "c", D_continue, D_CONTINUE, do_continue,
	gettext_noop("continue [COUNT] - continue program being debugged") },
{ "delete", "d", D_delete, D_DELETE, do_delete_breakpoint,
	gettext_noop("delete [breakpoints] [range] - delete specified breakpoints") },
{ "disable", "", D_disable, D_DISABLE, do_disable_breakpoint,
	gettext_noop("disable [breakpoints] [range] - disable specified breakpoints") },
{ "display", "", D_display, D_DISPLAY, do_display,
	gettext_noop("display [var] - print value of variable each time the program stops") },
{ "down", "", D_down, D_DOWN, do_down,
	gettext_noop("down [N] - move N frames down the stack") },
{ "dump", "", D_dump, D_DUMP, do_dump_instructions,
	gettext_noop("dump [filename] - dump instructions to file or stdout") },
{ "enable", "e", D_enable, D_ENABLE, do_enable_breakpoint,
	gettext_noop("enable [once|del] [breakpoints] [range] - enable specified breakpoints") },
{ "end", "", D_end, D_END, do_commands,
	gettext_noop("end - end a list of commands or awk statements") },
{ "eval", "", D_eval, D_EVAL, do_eval,
	gettext_noop("eval stmt|[p1, p2, ...] - evaluate awk statement(s)") },
{ "exit", "", D_quit, D_QUIT, do_quit,
	gettext_noop("exit - (same as quit) exit debugger") },
{ "finish", "", D_finish, D_FINISH, do_finish,
	gettext_noop("finish - execute until selected stack frame returns") },
{ "frame", "f", D_frame, D_FRAME, do_frame,
	gettext_noop("frame [N] - select and print stack frame number N") },
{ "help", "h", D_help, D_HELP, do_help,
	gettext_noop("help [command] - print list of commands or explanation of command") },
{ "ignore", "", D_ignore, D_IGNORE, do_ignore_breakpoint,
	gettext_noop("ignore N COUNT - set ignore-count of breakpoint number N to COUNT") },
{ "info", "i", D_info, D_INFO, do_info,
	gettext_noop("info topic - source|sources|variables|functions|break|frame|args|locals|display|watch") },
{ "list", "l", D_list, D_LIST, do_list,
	gettext_noop("list [-|+|[filename:]lineno|function|range] - list specified line(s)") },
{ "next", "n", D_next, D_NEXT, do_next,
	gettext_noop("next [COUNT] - step program, proceeding through subroutine calls") },
{ "nexti", "ni", D_nexti, D_NEXTI, do_nexti,
	gettext_noop("nexti [COUNT] - step one instruction, but proceed through subroutine calls") },
{ "option", "o", D_option, D_OPTION, do_option,
	gettext_noop("option [name[=value]] - set or display debugger option(s)") },
{ "print", "p", D_print, D_PRINT, do_print_var,
	gettext_noop("print var [var] - print value of a variable or array") },
{ "printf", "", D_printf, D_PRINTF, do_print_f,
	gettext_noop("printf format, [arg], ... - formatted output") },
{ "quit", "q", D_quit, D_QUIT, do_quit,
	gettext_noop("quit - exit debugger") },
{ "return", "", D_return, D_RETURN, do_return,
	gettext_noop("return [value] - make selected stack frame return to its caller") },
{ "run", "r", D_run, D_RUN, do_run,
	gettext_noop("run - start or restart executing program") },
#ifdef HAVE_LIBREADLINE
{ "save", "", D_save, D_SAVE, do_save,
	gettext_noop("save filename - save commands from the session to file") },
#endif
{ "set", "", D_set, D_SET, do_set_var,
	gettext_noop("set var = value - assign value to a scalar variable") },
{ "silent", "", D_silent, D_SILENT, do_commands,
	gettext_noop("silent - suspends usual message when stopped at a breakpoint/watchpoint") },
{ "source", "", D_source, D_SOURCE, do_source,
	gettext_noop("source file - execute commands from file") },
{ "step", "s", D_step, D_STEP, do_step,
	gettext_noop("step [COUNT] - step program until it reaches a different source line") },
{ "stepi", "si", D_stepi, D_STEPI, do_stepi,
	gettext_noop("stepi [COUNT] - step one instruction exactly") },
{ "tbreak", "t", D_tbreak, D_TBREAK, do_tmp_breakpoint,
	gettext_noop("tbreak [[filename:]N|function] - set a temporary breakpoint") },
{ "trace", "", D_trace, D_TRACE, do_trace_instruction,
	gettext_noop("trace on|off - print instruction before executing") },
{ "undisplay",	"", D_undisplay, D_UNDISPLAY, do_undisplay,
	gettext_noop("undisplay [N] - remove variable(s) from automatic display list") },
{ "until", "u", D_until, D_UNTIL, do_until,
	gettext_noop("until [[filename:]N|function] - execute until program reaches a different line or line N within current frame") },
{ "unwatch", "", D_unwatch, D_UNWATCH, do_unwatch,
	gettext_noop("unwatch [N] - remove variable(s) from watch list") },
{ "up",	"", D_up, D_UP, do_up,
	gettext_noop("up [N] - move N frames up the stack") },
{ "watch", "w", D_watch, D_WATCH, do_watch,
	gettext_noop("watch var - set a watchpoint for a variable") },
{ "where", "", D_backtrace, D_BACKTRACE, do_backtrace,
	gettext_noop("where [N] - (same as backtrace) print trace of all or N innermost (outermost if N < 0) frames") },
{ NULL, NULL, D_illegal, 0, (Func_cmd) 0,
	 NULL },
};

struct argtoken argtab[] = {
	{ "args", D_info, A_ARGS },
	{ "break", D_info, A_BREAK },
	{ "del", D_enable, A_DEL },
	{ "display", D_info, A_DISPLAY },
	{ "frame", D_info, A_FRAME },
	{ "functions", D_info, A_FUNCTIONS },
	{ "locals", D_info, A_LOCALS },
	{ "off", D_trace, A_TRACE_OFF },
	{ "on", D_trace, A_TRACE_ON },
	{ "once", D_enable, A_ONCE },
	{ "source", D_info, A_SOURCE },
	{ "sources", D_info, A_SOURCES },
	{ "variables", D_info, A_VARIABLES },
	{ "watch", D_info, A_WATCH },
	{ NULL, D_illegal, A_NONE },
};


/* get_command --- return command handler function */

Func_cmd
get_command(int ctype)
{
	int i;
	for (i = 0; cmdtab[i].name != NULL; i++) {
		if (cmdtab[i].type == ctype)
			return cmdtab[i].cf_ptr;
	}
	return (Func_cmd) 0;
}

/* get_command_name --- return command name given it's type */

const char *
get_command_name(int ctype)
{
	int i;
	for (i = 0; cmdtab[i].name != NULL; i++) {
		if (cmdtab[i].type == ctype)
			return cmdtab[i].name;
	}
	return NULL;
}

/* mk_cmdarg --- make an argument for command */

static CMDARG *
mk_cmdarg(enum argtype type)
{
	CMDARG *arg;
	ezalloc(arg, CMDARG *, sizeof(CMDARG));
	arg->type = type;
	return arg;
}

/* append_cmdarg --- append ARG to the list of arguments for the current command */

static void
append_cmdarg(CMDARG *arg)
{
	static CMDARG *savetail;

	if (arg_list == NULL)
		arg_list = arg;
	else
		savetail->next = arg;
	savetail = arg;
}

/* free_cmdarg --- free all arguments in LIST */

void
free_cmdarg(CMDARG *list)
{
	CMDARG *arg, *nexta;

	for (arg = list; arg != NULL; arg = nexta) {
		nexta = arg->next;

		switch (arg->type) {
		case D_variable:
		case D_subscript:
		case D_array:
		case D_string:
			if (arg->a_string != NULL)
				efree(arg->a_string);
			break;
		case D_node:
		case D_field:
			unref(arg->a_node);
			break;
		default:
			break;
		}
		efree(arg);
	}
}

/* yyerror --- print a syntax error message */

static void
yyerror(const char *mesg, ...)
{
	va_list args;
	va_start(args, mesg);
	fprintf(out_fp, _("error: "));
	vfprintf(out_fp, mesg, args);
	fprintf(out_fp, "\n");
	va_end(args);
	dbg_errcount++;
	repeat_idx = -1;
}


/* yylex --- read a command and turn it into tokens */

static int
#ifdef USE_EBCDIC
yylex_ebcdic(void)
#else
yylex(void)
#endif
{
	static char *lexptr = NULL;
	static char *lexend;
	int c;
	char *tokstart;
	size_t toklen;

	yylval = (CMDARG *) NULL;

	if (dbg_errcount > 0 && lexptr_begin == NULL) {
		/* fake a new line */
		dbg_errcount = 0;
		return '\n';
	}

	if (lexptr_begin == NULL) {
again:
		lexptr_begin = read_a_line(dbg_prompt);
		if (lexptr_begin == NULL) {	/* EOF or error */
			if (get_eof_status() == EXIT_FATAL)
				exit(EXIT_FATAL);
			if (get_eof_status() == EXIT_FAILURE) {
				static int seen_eof = 0;

				/* force a quit, and let do_quit (in debug.c) exit */
				if (! seen_eof) {
					if (errno != 0)	{
						fprintf(stderr, _("cannot read command: %s\n"), strerror(errno));
						exit_val = EXIT_FAILURE;
					} /* else
						exit_val = EXIT_SUCCESS; */

					seen_eof = 1;
					return '\n';	/* end current command if any */
				} else if (seen_eof++ == 1) {
					cmd_idx = find_command("quit", 4);
					return D_QUIT;	/* 'quit' token */
				} else
					return '\n';	/* end command 'quit' */
			}
			if (errno != 0)
				d_error(_("cannot read command: %s"), strerror(errno));
			if (pop_cmd_src() == 0)
				goto again;
			exit(EXIT_FATAL);	/* shouldn't happen */
		}

		if (! in_commands && ! in_eval	/* history expansion off in 'commands' and 'eval' */
				&& input_from_tty
		)
			history_expand_line(&lexptr_begin);

		lexptr = lexptr_begin;
		lexend = lexptr + strlen(lexptr);
		if (*lexptr == '\0'		/* blank line */
				&& repeat_idx >= 0
				&& input_from_tty
				&& ! in_eval
		) {
#ifdef HAVE_LIBREADLINE
			HIST_ENTRY *h;
			h = previous_history();
			if (h != NULL)
				add_history(h->line);
#endif
			cmd_idx = repeat_idx;
			return cmdtab[cmd_idx].lex_class;	/* repeat last command */
		}
		repeat_idx = -1;
	}

	c = *lexptr;

	while (c == ' ' || c == '\t')
		c = *++lexptr;

	if (! input_from_tty && c == '#')
		return '\n';

	tokstart = lexptr;
	if (lexptr >= lexend)
		return '\n';

	if (cmd_idx < 0) {	/* need a command */
		if (c == '?' && tokstart[1] == '\0'	&& ! in_eval) {
			lexptr++;
			cmd_idx = find_command("help", 4);
			return D_HELP;
		}

		while (c != '\0' && c != ' ' && c != '\t') {
			if (! is_alpha(c) && ! in_eval) {
				yyerror(_("invalid character in command"));
				return '\n';
			}
			c = *++lexptr;
		}

		toklen = lexptr - tokstart;

		if (in_eval) {
			if (toklen == 3
					&& tokstart[3] == '\0'
					&& tokstart[0] == 'e'
					&& tokstart[1] == 'n'
					&& tokstart[2] == 'd'
			) {
				cmd_idx = find_command(tokstart, toklen);
				return D_END;
			}
			lexptr = lexend;
			return D_STATEMENT;
		}

		cmd_idx = find_command(tokstart, toklen);
		if (cmd_idx >= 0) {
			if (in_commands && cmdtab[cmd_idx].type != D_eval) {
				/* add the actual command string (lexptr_begin) to
				 * arg_list; command string for 'eval' prepended to the arg_list
				 * in the grammer above (see eval_cmd non-terminal).
				 */
				CMDARG *arg;
				arg = mk_cmdarg(D_string);
				arg->a_string = estrdup(lexptr_begin, lexend - lexptr_begin);
				append_cmdarg(arg);
			}
			return cmdtab[cmd_idx].lex_class;
		} else {
			yyerror(_("unknown command - `%.*s', try help"), toklen, tokstart);
			return '\n';
		}
	}

	c = *lexptr;

	if (cmdtab[cmd_idx].type == D_option) {
		if (c == '=')
			return *lexptr++;
	} else if (c == '-' || c == '+' || c == ':' || c == '|')
		return *lexptr++;

	if (c == '"') {
		char *str, *p;
		int flags = ALREADY_MALLOCED;
		bool esc_seen = false;

		toklen = lexend - lexptr;
		emalloc(str, char *, toklen + 1);
		p = str;

		while ((c = *++lexptr) != '"') {
			if (lexptr == lexend) {
err:
				efree(str);
				yyerror(_("unterminated string"));
				return '\n';
			}
			if (c == '\\') {
				c = *++lexptr;
				esc_seen = true;
				if (want_nodeval || c != '"')
					*p++ = '\\';
			}
			if (lexptr == lexend)
				goto err;
			*p++ = c;
		}
		lexptr++;
		*p = '\0';

		if (! want_nodeval) {
			yylval = mk_cmdarg(D_string);
			yylval->a_string = str;
			append_cmdarg(yylval);
			return D_STRING;
		} else {	/* awk string */
			if (esc_seen)
				flags |= SCAN;
			yylval = mk_cmdarg(D_node);
			yylval->a_node = make_str_node(str, p - str, flags);
			append_cmdarg(yylval);
			return D_NODE;
		}
	}

	if (! want_nodeval) {
		while ((c = *++lexptr) != '\0' && c != ':' && c != '-'
					&& c != ' ' && c != '\t' && c != '=')
			;

		/* Is it an integer? */
		if (isdigit((unsigned char) tokstart[0]) && cmdtab[cmd_idx].type != D_option) {
			char *end;
			long l;

			errno = 0;
			l = strtol(tokstart, &end, 0);
			if (errno != 0) {
				yyerror("%s", strerror(errno));
				errno = 0;
				return '\n';
			}

			if (lexptr == end) {
				yylval = mk_cmdarg(D_int);
				yylval->a_int = l;
				append_cmdarg(yylval);
				return D_INT;
			}
		}

		/* Must be string */
		yylval = mk_cmdarg(D_string);
		yylval->a_string = estrdup(tokstart, lexptr - tokstart);
		append_cmdarg(yylval);
		return D_STRING;
	}

	/* look for awk number */

	if (isdigit((unsigned char) tokstart[0])) {
		NODE *r = NULL;

		errno = 0;
#ifdef HAVE_MPFR
		if (do_mpfr) {
			int tval;
			r = mpg_float();
			tval = mpfr_strtofr(r->mpg_numbr, tokstart, & lexptr, 0, ROUND_MODE);
			IEEE_FMT(r->mpg_numbr, tval);
			if (mpfr_integer_p(r->mpg_numbr)) {
				/* integral value, convert to a GMP type. */
				NODE *tmp = r;
				r = mpg_integer();
				mpfr_get_z(r->mpg_i, tmp->mpg_numbr, MPFR_RNDZ);
				unref(tmp);
			}
		} else
#endif
			r = make_number(strtod(tokstart, & lexptr));

		if (errno != 0) {
			yyerror(strerror(errno));
			unref(r);
			errno = 0;
			return '\n';
		}
		yylval = mk_cmdarg(D_node);
		yylval->a_node = r;
		append_cmdarg(yylval);
		return D_NODE;
	}

	c = *lexptr;
	if (c == '$' || c == '@'
			|| c == '[' || c == ']'
			|| c == ',' || c == '=')
		return *lexptr++;

	if (! is_letter(c)) {
		yyerror(_("invalid character"));
		return '\n';
	}

	while (is_identchar(c))
		c = *++lexptr;
	toklen = lexptr - tokstart;

	/* awk variable */
	yylval = mk_cmdarg(D_variable);
	yylval->a_string = estrdup(tokstart, toklen);
	append_cmdarg(yylval);
	return D_VARIABLE;
}

/* Convert single-character tokens coming out of yylex() from EBCDIC to
   ASCII values on-the-fly so that the parse tables need not be regenerated
   for EBCDIC systems.  */
#ifdef USE_EBCDIC
static int
yylex(void)
{
	static char etoa_xlate[256];
	static int do_etoa_init = 1;
	int tok;

	if (do_etoa_init)
	{
		for (tok = 0; tok < 256; tok++)
			etoa_xlate[tok] = (char) tok;
#ifdef HAVE___ETOA_L
		/* IBM helpfully provides this function.  */
		__etoa_l(etoa_xlate, sizeof(etoa_xlate));
#else
# error "An EBCDIC-to-ASCII translation function is needed for this system"
#endif
		do_etoa_init = 0;
	}

	tok = yylex_ebcdic();

	if (tok >= 0 && tok <= 0xFF)
		tok = etoa_xlate[tok];

	return tok;
}
#endif /* USE_EBCDIC */

/* find_argument --- find index in 'argtab' for a command option */

static int
find_argument(CMDARG *arg)
{
	/* non-number argument */
	int idx;
	char *name, *p;
	size_t len;
	assert(cmd_idx >= 0);
	name = arg->a_string;
	len = strlen(name);
	for (idx = 0; (p = (char *) argtab[idx].name) != NULL; idx++) {
		if (cmdtab[cmd_idx].type == argtab[idx].cmd
				&& *p == *name
				&& strlen(p) == len
				&& strncmp(p, name, len) == 0
		)
			return idx;
	}
	return -1;	/* invalid option */
}

/* concat_args --- concatenate argument strings into a single string NODE */

static NODE *
concat_args(CMDARG *arg, int count)
{
	NODE *n;
	NODE **tmp;
	char *str, *subsep, *p;
	long len, subseplen;
	int i;

	if (count == 1) {
		n = force_string(arg->a_node);
		return dupnode(n);
	}

	emalloc(tmp, NODE **, count * sizeof(NODE *));
	subseplen = SUBSEP_node->var_value->stlen;
	subsep = SUBSEP_node->var_value->stptr;
	len = -subseplen;

	for (i = 0; i < count; i++) {
		n = force_string(arg->a_node);
		len += n->stlen + subseplen;
		tmp[i] = n;
		arg = arg->next;
	}

	emalloc(str, char *, len + 1);
	n = tmp[0];
	memcpy(str, n->stptr, n->stlen);
	p = str + n->stlen;
	for (i = 1; i < count; i++) {
		if (subseplen == 1)
			*p++ = *subsep;
		else if (subseplen > 0) {
			memcpy(p, subsep, subseplen);
			p += subseplen;
		}

		n = tmp[i];
		memcpy(p, n->stptr, n->stlen);
		p += n->stlen;
	}
	str[len] = '\0';
	efree(tmp);
	return make_str_node(str, len, ALREADY_MALLOCED);
}

/* find_command --- find the index in 'cmdtab' using exact,
 *                  abbreviation or unique partial match
 */

static int
find_command(const char *token, size_t toklen)
{
	const char *name, *abrv;
	int i, k;
	bool try_exact = true;
	int abrv_match = -1;
	int partial_match = -1;

#ifdef USE_EBCDIC
	/* make sure all lower case characters in token (sorting
	 * isn't the solution in this case)
	 */
	for (i = 0; i < toklen; i++) {
		if (token[i] != tolower(token[i]))
			return -1;
	}
#endif

	k = sizeof(cmdtab)/sizeof(cmdtab[0]) - 1;
	for (i = 0; i < k; i++) {
		name = (char *) cmdtab[i].name;
		if (try_exact && *token == *name
				&& toklen == strlen(name)
				&& strncmp(name, token, toklen) == 0
		)
			return i;

		if (*name > *token || i == (k - 1))
			try_exact = false;

		if (abrv_match < 0) {
			abrv = cmdtab[i].abbrvn;
			if (abrv[0] == token[0]) {
				if (toklen == 1 && ! abrv[1])
					abrv_match = i;
				else if (toklen == 2 && abrv[1] == token[1])
					abrv_match = i;
			}
		}
		if (! try_exact && abrv_match >= 0)
			return abrv_match;
		if (partial_match < 0) {
			if (*token == *name
					&& toklen < strlen(name)
					&& strncmp(name, token, toklen) == 0
			) {
				if ((i == k - 1 || strncmp(cmdtab[i + 1].name, token, toklen) != 0)
					&& (i == 0 || strncmp(cmdtab[i - 1].name, token, toklen) != 0)
				)
					partial_match = i;
			}
		}
	}
	return partial_match;
}

/* do_help -- help command */

int
do_help(CMDARG *arg, int cmd)
{
	int i;
	if (arg == NULL) {
		initialize_pager(out_fp);
		if (setjmp(pager_quit_tag) == 0) {
			for (i = 0; cmdtab[i].name != NULL; i++) {
				gprintf(out_fp, "%s:\n", cmdtab[i].name);
				gprintf(out_fp, "\t%s\n", _(cmdtab[i].help_txt));
			}
		}
	} else if (arg->type == D_string) {
		char *name;
		name = arg->a_string;
		i = find_command(name, strlen(name));
		if (i >= 0) {
			fprintf(out_fp, "%s\n", cmdtab[i].help_txt);
			if (strcmp(cmdtab[i].name, "option") == 0)
				option_help();
		} else
			fprintf(out_fp, _("undefined command: %s\n"), name);
	}

	return false;
}


#ifdef HAVE_LIBREADLINE

/* next_word --- find the next word in a line to complete
 *               (word seperation characters are space and tab).
 */

static char *
next_word(char *p, int len, char **endp)
{
	char *q;
	int i;

	if (p == NULL || len <= 0)
		return NULL;
	for (i = 0; i < len; i++, p++)
		if (*p != ' ' && *p != '\t')
			break;
	if (i == len)
		return NULL;
	if (endp != NULL) {
		for (i++, q = p + 1; i < len; i++, q++)
			if (*q == ' ' || *q == '\t')
				break;
		*endp = q;
	}
	return p;
}

/* command_completion --- attempt to complete based on the word number in line;
 *    try to complete on command names if this is the first word; for the next
 *    word(s), the type of completion depends on the command name (first word).
 */

#ifndef RL_READLINE_VERSION		/* < 4.2a */
#define rl_completion_matches(x, y) completion_matches((char *) (x), (y))
#endif


char **
command_completion(const char *text, int start, int end)
{
	char *cmdtok, *e;
	int idx;
	int len;

	rl_attempted_completion_over = true;	/* no default filename completion please */

	this_cmd = D_illegal;
	len = start;
	if ((cmdtok = next_word(rl_line_buffer, len, &e)) == NULL)	/* no first word yet */
		return  rl_completion_matches(text, command_generator);
	len -= (e - rl_line_buffer);

	idx = find_command(cmdtok, e - cmdtok);
	if (idx < 0)
		return NULL;
	this_cmd = cmdtab[idx].type;

	if (! next_word(e, len, NULL)) {
		switch (this_cmd) {
		case D_break:
		case D_list:
		case D_until:
		case D_tbreak:
		case D_clear:
			return rl_completion_matches(text, srcfile_generator);
		case D_info:
		case D_enable:
		case D_trace:
		case D_help:
			return rl_completion_matches(text, argument_generator);
		case D_option:
			return rl_completion_matches(text, option_generator);
		case D_print:
		case D_printf:
		case D_set:
		case D_display:
		case D_watch:
			return rl_completion_matches(text, variable_generator);
		default:
			return NULL;
		}
	}

	if (this_cmd == D_print || this_cmd == D_printf)
		return rl_completion_matches(text, variable_generator);
	return NULL;
}

/* command_generator --- generator function for command completion */

static char *
command_generator(const char *text, int state)
{
	static size_t textlen;
	static int idx = 0;
	char *name;

	if (! state) {	/* first time */
		textlen = strlen(text);
		idx = 0;
	}
	while ((name = (char *) cmdtab[idx].name) != NULL) {
		idx++;
		if (strncmp(name, text, textlen) == 0)
			return estrdup(name, strlen(name));
	}
	return NULL;
}

/* srcfile_generator --- generator function for source file completion */

static char *
srcfile_generator(const char *text, int state)
{
	static size_t textlen;
	static SRCFILE *s;
	char *name;
	extern SRCFILE *srcfiles;

	if (! state) {	/* first time */
		textlen = strlen(text);
		s = srcfiles->next;
	}
	while (s != srcfiles) {
		if (s->stype != SRC_FILE && s->stype != SRC_INC) {
			s = s->next;
			continue;
		}
		name = s->src;
		s = s->next;
		if (strncmp(name, text, textlen) == 0)
			return estrdup(name, strlen(name));
	}
	return NULL;
}

/* argument_generator --- generator function for non-number argument completion */

static char *
argument_generator(const char *text, int state)
{
	static size_t textlen;
	static int idx;
	const char *name;

	if (! state) {	/* first time */
		textlen = strlen(text);
		idx = 0;
	}

	if (this_cmd == D_help) {
		while ((name = cmdtab[idx++].name) != NULL) {
			if (strncmp(name, text, textlen) == 0)
				return estrdup(name, strlen(name));
		}
	} else {
		while ((name = argtab[idx].name) != NULL) {
			if (this_cmd != argtab[idx++].cmd)
				continue;
			if (strncmp(name, text, textlen) == 0)
				return estrdup(name, strlen(name));
		}
	}
	return NULL;
}

/* variable_generator --- generator function for variable name completion */

static char *
variable_generator(const char *text, int state)
{
	static size_t textlen;
	static int idx = 0;
	static NODE *func = NULL;
	static NODE **vars = NULL;
	const char *name;
	NODE *r;

	if (! state) {	/* first time */
		textlen = strlen(text);
		if (vars != NULL)
			efree(vars);
		vars = variable_list();
		idx = 0;
		func = get_function();  /* function in current context */
	}

	/* function params */
	while (func != NULL) {
		if (idx >= func->param_cnt) {
			func = NULL;	/* don't try to match params again */
			idx = 0;
			break;
		}
		name = func->fparms[idx++].param;
		if (strncmp(name, text, textlen) == 0)
			return estrdup(name, strlen(name));
	}

	/* globals */
	while ((r = vars[idx++]) != NULL) {
		name = r->vname;
		if (strncmp(name, text, textlen) == 0)
			return estrdup(name, strlen(name));
	}

	return NULL;
}

/* history_expand_line ---  history expand the LINE */

static void
history_expand_line(char **line)
{
	int ret;
	char *expansion;

	if (! *line || input_fd != 0 || ! input_from_tty)
		return;
	using_history();
	ret = history_expand(*line, &expansion);
	if (ret < 0 || ret == 2)
		efree(expansion);
	else {
		efree(*line);
		*line = expansion;
	}
}

#endif
/*
 * ext.c - Builtin function that links external gawk functions and related
 *	   utilities.
 *
 * Christos Zoulas, Thu Jun 29 17:40:41 EDT 1995
 * Arnold Robbins, update for 3.1, Mon Nov 23 12:53:39 EST 1998
 */

/*
 * Copyright (C) 1995 - 2001, 2003-2014, 2016-2020, 2022, 2025,
 * the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "awk.h"
extern SRCFILE *srcfiles;

#ifdef DYNAMIC

#include <dlfcn.h>

#define INIT_FUNC	"dl_load"

/* load_ext --- load an external library */

void
load_ext(const char *lib_name)
{
	int (*install_func)(const gawk_api_t *const, awk_ext_id_t);
	void *dl;
	int flags = RTLD_LAZY;
	int *gpl_compat;

	if (do_sandbox)
		fatal(_("extensions are not allowed in sandbox mode"));

	if (do_traditional || do_posix)
		fatal(_("-l / @load are gawk extensions"));

	if (lib_name == NULL)
		fatal(_("load_ext: received NULL lib_name"));

	if ((dl = dlopen(lib_name, flags)) == NULL)
		fatal(_("load_ext: cannot open library `%s': %s"), lib_name,
		      dlerror());

	/* Per the GNU Coding standards */
	gpl_compat = (int *) dlsym(dl, "plugin_is_GPL_compatible");
	if (gpl_compat == NULL)
		fatal(_("load_ext: library `%s': does not define `plugin_is_GPL_compatible': %s"),
				lib_name, dlerror());

	install_func = (int (*)(const gawk_api_t *const, awk_ext_id_t))
				dlsym(dl, INIT_FUNC);
	if (install_func == NULL)
		fatal(_("load_ext: library `%s': cannot call function `%s': %s"),
				lib_name, INIT_FUNC, dlerror());

	if (install_func(& api_impl, NULL /* ext_id */) == 0)
		warning(_("load_ext: library `%s' initialization routine `%s' failed"),
				lib_name, INIT_FUNC);
}

/* make_builtin --- register name to be called as func with a builtin body */

awk_bool_t
make_builtin(const char *name_space, const awk_ext_func_t *funcinfo)
{
	NODE *symbol, *f;
	INSTRUCTION *b;
	const char *name = funcinfo->name;
	int count = funcinfo->max_expected_args;
	const char *install_name;

	if (name == NULL || *name == '\0')
		fatal(_("make_builtin: missing function name"));

	if (! is_valid_identifier(name))
		return awk_false;

	assert(name_space != NULL);
	if (name_space[0] == '\0' || strcmp(name_space, awk_namespace) == 0) {
		if (check_special(name) >= 0)
			fatal(_("make_builtin: cannot use gawk built-in `%s' as function name"), name);

		f = lookup(name);
		install_name = estrdup(name, strlen(name));
	} else {
		if (! is_valid_identifier(name_space))
			return awk_false;

		if (check_special(name_space) >= 0)
			fatal(_("make_builtin: cannot use gawk built-in `%s' as namespace name"), name_space);
		if (check_special(name) >= 0)
			fatal(_("make_builtin: cannot use gawk built-in `%s' as function name"), name);

		size_t len = strlen(name_space) + 2 + strlen(name) + 1;
		char *buf;
		emalloc(buf, char *, len);
		sprintf(buf, "%s::%s", name_space, name);
		install_name = buf;

		f = lookup(install_name);
	}

	if (f != NULL) {
		// found it, but it shouldn't be there if we want to install this function
		if (f->type == Node_func) {
			/* user-defined function */
			fatal(_("make_builtin: cannot redefine function `%s'"), name);
		} else if (f->type == Node_ext_func) {
			/* multiple extension() calls etc. */
			if (do_lint)
				lintwarn(_("make_builtin: function `%s' already defined"), name);
			free((void *) install_name);
			return awk_false;
		} else
			/* variable name etc. */
			fatal(_("make_builtin: function name `%s' previously defined"), name);
	}

	if (count < 0)
		fatal(_("make_builtin: negative argument count for function `%s'"),
				name);

	b = bcalloc(Op_symbol, 1, 0);
	b->extfunc = funcinfo->function;
	b->c_function = (awk_ext_func_t *) funcinfo;

	/* NB: extension sub must return something */

	symbol = install_symbol(install_name, Node_ext_func);
	symbol->code_ptr = b;
	track_ext_func(name);
	return awk_true;
}

/* get_argument --- get the i'th argument of a dynamically linked function */

NODE *
get_argument(int i)
{
	NODE *t;
	int arg_count;
	INSTRUCTION *pc;

	pc = TOP()->code_ptr;		/* Op_ext_builtin instruction */
	arg_count = pc->expr_count;	/* # of arguments supplied */

	if (i < 0 || i >= arg_count)
		return NULL;

	t = PEEK(arg_count - i);
	if (t->type == Node_param_list)
		t = GET_PARAM(t->param_cnt);

	if (t->type == Node_array_ref) {
		if (t->orig_array->type == Node_var) {
			/* already a scalar, can no longer use it as array */
			t->type = Node_var;
			t->var_value = Nnull_string;
			return t;
		}
		return t->orig_array; 	/* Node_var_new or Node_var_array */
	}
	if (t->type == Node_var)	/* See Case Node_var in setup_frame(), eval.c */
		return Nnull_string;
	/* Node_var_new, Node_var_array or Node_val */
	return t;
}


/*
 * get_actual_argument --- get the i'th scalar or array argument of a
 *	dynamically linked function.
 */

NODE *
get_actual_argument(NODE *t, int i, bool want_array)
{
	char *fname;
	INSTRUCTION *pc;

	pc = TOP()->code_ptr;	/* Op_ext_builtin instruction */
	fname = (pc + 1)->func_name;

	if (t->type == Node_var_new || t->type == Node_elem_new) {
		if (want_array)
			return force_array(t, false);
		else {
			if (t->type == Node_elem_new) {
				elem_new_reset(t);
				if (t->valref > 1)	// ADR: 2/2025: Can this happen?
					unref(t);
			}
			t->type = Node_var;
			t->var_value = dupnode(Nnull_string);
			return t->var_value;
		}
	}

	if (want_array) {
		if (t->type != Node_var_array)
			fatal(_("function `%s': argument #%d: attempt to use scalar as an array"),
				fname, i + 1);
	} else {
		if (t->type != Node_val)
			fatal(_("function `%s': argument #%d: attempt to use array as a scalar"),
				fname, i + 1);
	}
	assert(t->type == Node_var_array || t->type == Node_val);
	return t;
}

#else

/* load_ext --- dummy version if extensions not available */

void
load_ext(const char *lib_name)
{
	fatal(_("dynamic loading of libraries is not supported"));
}
#endif

/* close_extensions --- execute extension cleanup routines */

void
close_extensions()
{
	SRCFILE *s;

	if (srcfiles == NULL)
		return;

	for (s = srcfiles->next; s != srcfiles; s = s->next)
		if (s->stype == SRC_EXTLIB && s->fini_func)
               	        (*s->fini_func)();
}

/* is_valid_identifier --- return true if name is a valid simple identifier */

bool
is_valid_identifier(const char *name)
{
	const char *sp = name;
	int c;

	if (! is_letter(*sp))
		return false;

	for (sp++; (c = *sp++) != '\0';) {
		if (! is_identchar(c))
			return false;
	}

	return true;
}
#include "config.h"

const char *version_string = PACKAGE_STRING;
#include "awk.h"
#include "pc/gawkmisc.pc"
/*
 * Copyright (C) 2010, 2013, 2014, 2016, the Free Software Foundation, Inc.
 *
 * This file is part of GAWK, the GNU implementation of the
 * AWK Programming Language.
 *
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include <process.h>
#include <errno.h>
#include "popen.h"
#undef popen
#undef pclose
#undef system

#ifndef _NFILE
#define _NFILE 40
#endif

static struct {
  char *command;
  char *name;
  char pmode[4];
} pipes[_NFILE];


/*
 * For systems where system() and popen() do not follow SHELL:
 *  1. Write command to temp file.  Temp filename must have slashes
 *     compatible with SHELL (if set) or COMSPEC.
 *  2. Convert slashes in SHELL (if present) to be compatible with COMSPEC.
 * Currently, only MSC (running under DOS) and MINGW versions are managed.
 */

#if defined(__MINGW32__)

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#if 0
static int
unixshell(char *p)
{
  static char *shell[] = {"sh", "bash", "csh", "tcsh", "sh32", "sh16", "ksh", NULL};
  char **shellp = shell, *s, *q;

  if (p == NULL) return (0);
  s = p = strdup(p);
  if ((q = strrchr(p, '\\')) != NULL)
    p = q + 1;
  if ((q = strrchr(p, '/')) != NULL)
    p = q + 1;
  if ((q = strchr(p, '.')) != NULL)
    *q = '\0';
  strlwr(p);
  do {
    if (strcmp(*shellp, p) == 0) break;
  } while (*++shellp);
  free(s);
  return(*shellp ? 1 : 0);
}

static char *
slashify(char *p, char *s)
{
  if (unixshell(s))
    while (s = strchr(p, '\\')) *s = '/';
  else
    while (s = strchr(p, '/')) *s = '\\';
  return(p);
}

static char *
scriptify(const char *command)
{
  FILE *fp;
  char *cmd, *name, *s, *p;
  int i;

  if((name = tempnam(".", "pip")) == NULL) return(NULL);
  p = getenv("COMSPEC"); s = getenv("SHELL");
  cmd = malloc(strlen(name) + (s ? strlen(s) : 0) + 9); *cmd = '\0';
  if (s) {
    slashify(strcpy(cmd, s), p);
    p = s;
  }
  slashify(name, p);
  if (! (i = unixshell(p))) {
    char *p = (char *) realloc(name, strlen(name) + 5);
    if (p == NULL) {
	free(cmd);
	return NULL;
    }
    name = p;
    strcat(name, ".bat");
  }
  if (s) sprintf(cmd + strlen(cmd), " %cc ", unixshell(s) ? '-' : '/');
  strcpy(p = cmd + strlen(cmd), name); free(name);

  if ((fp = fopen(p, i ? "wb" : "w")) != NULL) {
    if (! i) fputs("@echo off\n", fp);
    i = strlen(command);
    if ((fwrite(command, 1, i, fp) < i) || (fputc('\n', fp) == EOF)) {
      free(cmd);
      cmd = NULL;
    }
  } else {
    free(cmd);
    cmd = NULL;
  }
  if (fp) fclose(fp);
  return(cmd);
}

static void
unlink_and_free(char *cmd)
{
  char *s;

  if (s = strrchr(cmd, ' '))
    s++;
  else
    s = cmd;
  unlink(s); free(cmd);
}
#endif

int
os_system(const char *cmd)
{
  char *cmdexe = getenv("ComSpec");
  char *cmd1 = quote_cmd(cmd);
  int i = spawnl(P_WAIT, cmdexe, "cmd.exe", "/c", cmd1, NULL);

  free(cmd1);
  return(i);
}

#ifndef PIPES_SIMULATED
int
kill (int pid, int sig)
{
  HANDLE ph;
  int retval = 0;

  /* We only support SIGKILL.  */
  if (sig != SIGKILL)
    {
      errno = ENOSYS;
      return -1;
    }

  ph = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
  if (ph)
    {
      BOOL status = TerminateProcess(ph, -1);

      if (!status)
	{
	  errno = EPERM;
	  retval = -1;
	}
    }
  else
    {
      /* If we cannot open the process, it means we eaither aren't
	 allowed to (e.g., a process of another user), or such a
	 process doesn't exist.  */
      switch (GetLastError ())
	{
	  case ERROR_ACCESS_DENIED:
	    errno = EPERM;
	    break;
	  default:
	    errno = ESRCH;
	    break;
	}
      retval = -1;
    }
  CloseHandle (ph);
  return retval;
}

char *
quote_cmd(const char *cmd)
{
  char *quoted;

  /* The command will be invoked via cmd.exe, whose behavior wrt
     quoted commands is to remove the first and the last quote
     characters, and leave the rest (including any quote characters
     inside the outer pair) intact.  */
  quoted = malloc(strlen (cmd) + 2 + 1);
  sprintf(quoted, "\"%s\"", cmd);

  return quoted;
}
#endif

#else  /* !__MINGW32__ */
#define os_system(cmd) system(cmd)
#endif


FILE *
os_popen(const char *command, const char *mode )
{
    FILE *current;
    char *name;
    int cur;
    char curmode[4];

    if (*mode != 'r' && *mode != 'w')
      return NULL;
    strncpy(curmode, mode, 3); curmode[3] = '\0';

#if defined(__MINGW32__)
    current = popen(command, mode);
    cur = fileno(current);
    strcpy(pipes[cur].pmode, curmode);
    return(current);
#endif

    /*
    ** get a name to use.
    */
    if((name = tempnam(".","pip"))==NULL)
        return NULL;
    /*
    ** If we're reading, just call system to get a file filled with
    ** output.
    */
    if (*curmode == 'r') {
        FILE *fp;
        if ((cur = dup(fileno(stdout))) == -1)
	    return NULL;
	*curmode = 'w';
        if ((current = freopen(name, curmode, stdout)) == NULL)
	    return NULL;
        os_system(command);
        if (dup2(cur, fileno(stdout)) == -1)
	    return NULL;
	close(cur);
	*curmode = 'r';
        if ((current = fopen(name, curmode)) == NULL)
            return NULL;
    } else {
        if ((current = fopen(name, curmode)) == NULL)
            return NULL;
    }
    cur = fileno(current);
    pipes[cur].name = name;
    strcpy(pipes[cur].pmode, curmode);
    pipes[cur].command = strdup(command);
    return current;
}

int
os_pclose( FILE * current)
{
    int cur = fileno(current);
    int fd, rval;

#if defined(__MINGW32__)
    rval = pclose(current);
    *pipes[cur].pmode = '\0';
    return rval;
#endif

    /*
    ** check for an open file.
    */
    switch (*pipes[cur].pmode) {
    case 'r':
        /*
        ** input pipes are just files we're done with.
        */
        rval = fclose(current);
        unlink(pipes[cur].name);
	break;
    case 'w':
        /*
        ** output pipes are temporary files we have
        ** to cram down the throats of programs.
        */
        fclose(current);
	rval = -1;
	if ((fd = dup(fileno(stdin))) != -1) {
	  char *mode = pipes[cur].pmode; *mode = 'r';
	  if (current = freopen(pipes[cur].name, mode, stdin)) {
	    rval = os_system(pipes[cur].command);
	    fclose(current);
	    if (dup2(fd, fileno(stdin)) == -1) rval = -1;
	    close(fd);
	  }
	}
        unlink(pipes[cur].name);
	break;
    default:
      return -1;
    }
    /*
    ** clean up current pipe.
    */
    *pipes[cur].pmode = '\0';
    free(pipes[cur].name);
    free(pipes[cur].command);
    return rval;
}
#include <stdio.h>
long timegm(void* t) { return 0; }
size_t rpl_strftime(char* s, size_t m, const char* f, void* t) { return 0; }
/* dfa.c - deterministic extended regexp routines for GNU
   Copyright (C) 1988, 1998, 2000, 2002, 2004-2005, 2007-2025 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* Written June, 1988 by Mike Haertel
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */

#include <config.h>

#include "dfa.h"

#include "flexmember.h"
#include "idx.h"
#include "verify.h"

#include <assert.h>
#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <wchar.h>

#include "gettext.h"
#define _(str) gettext (str)

#include "xalloc.h"
#include "localeinfo.h"

#if GAWK
/* Use ISO C 99 API.  */
# include <wctype.h>
# define char32_t wchar_t
# define mbrtoc32 mbrtowc
# define c32rtomb wcrtomb
# define c32tob wctob
# define c32isprint iswprint
# define c32isspace iswspace
# define mbszero(p) memset ((p), 0, sizeof (mbstate_t))
#else
/* Use ISO C 11 + gnulib API.  */
# include <uchar.h>
#endif

/* Pacify gcc -Wanalyzer-null-dereference in areas where GCC
   understandably cannot deduce that the input comes from a
   well-formed regular expression.  There's little point to the
   runtime overhead of 'assert' instead of 'assume_nonnull' when the
   MMU will check anyway.  */
#define assume_nonnull(x) assume ((x) != NULL)

static bool
str_eq (char const *a, char const *b)
{
  return strcmp (a, b) == 0;
}

static bool
c_isdigit (char c)
{
  return '0' <= c && c <= '9';
}

#ifndef FALLTHROUGH
# if 201710L < __STDC_VERSION__
#  define FALLTHROUGH [[__fallthrough__]]
# elif ((__GNUC__ >= 7 && !defined __clang__) \
        || (defined __apple_build_version__ \
            ? __apple_build_version__ >= 12000000 \
            : __clang_major__ >= 10))
#  define FALLTHROUGH __attribute__ ((__fallthrough__))
# else
#  define FALLTHROUGH ((void) 0)
# endif
#endif

#ifndef MIN
# define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

/* HPUX defines these as macros in sys/param.h.  */
#ifdef setbit
# undef setbit
#endif
#ifdef clrbit
# undef clrbit
#endif

/* For code that does not use Gnulibs isblank module.  */
#if !defined isblank && !defined HAVE_ISBLANK && !defined GNULIB_ISBLANK
# define isblank dfa_isblank
static int
isblank (int c)
{
  return c == ' ' || c == '\t';
}
#endif

/* First integer value that is greater than any character code.  */
enum { NOTCHAR = 1 << CHAR_BIT };

#ifdef UINT_LEAST64_MAX

/* Number of bits used in a charclass word.  */
enum { CHARCLASS_WORD_BITS = 64 };

/* This represents part of a character class.  It must be unsigned and
   at least CHARCLASS_WORD_BITS wide.  Any excess bits are zero.  */
typedef uint_least64_t charclass_word;

/* Part of a charclass initializer that represents 64 bits' worth of a
   charclass, where LO and HI are the low and high-order 32 bits of
   the 64-bit quantity.  */
# define CHARCLASS_PAIR(lo, hi) (((charclass_word) (hi) << 32) + (lo))

#else
/* Fallbacks for pre-C99 hosts that lack 64-bit integers.  */
enum { CHARCLASS_WORD_BITS = 32 };
typedef unsigned long charclass_word;
# define CHARCLASS_PAIR(lo, hi) lo, hi
#endif

/* An initializer for a charclass whose 32-bit words are A through H.  */
#define CHARCLASS_INIT(a, b, c, d, e, f, g, h)		\
   {{							\
      CHARCLASS_PAIR (a, b), CHARCLASS_PAIR (c, d),	\
      CHARCLASS_PAIR (e, f), CHARCLASS_PAIR (g, h)	\
   }}

/* The maximum useful value of a charclass_word; all used bits are 1.  */
static charclass_word const CHARCLASS_WORD_MASK
  = ((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1;

/* Number of words required to hold a bit for every character.  */
enum
{
  CHARCLASS_WORDS = (NOTCHAR + CHARCLASS_WORD_BITS - 1) / CHARCLASS_WORD_BITS
};

/* Sets of unsigned characters are stored as bit vectors in arrays of ints.  */
typedef struct { charclass_word w[CHARCLASS_WORDS]; } charclass;

/* Convert a possibly-signed character to an unsigned character.  This is
   a bit safer than casting to unsigned char, since it catches some type
   errors that the cast doesn't.  */
static unsigned char
to_uchar (char ch)
{
  return ch;
}

/* Contexts tell us whether a character is a newline or a word constituent.
   Word-constituent characters are those that satisfy iswalnum, plus '_'.
   Each character has a single CTX_* value; bitmasks of CTX_* values denote
   a particular character class.

   A state also stores a context value, which is a bitmask of CTX_* values.
   A state's context represents a set of characters that the state's
   predecessors must match.  For example, a state whose context does not
   include CTX_LETTER will never have transitions where the previous
   character is a word constituent.  A state whose context is CTX_ANY
   might have transitions from any character.  */

enum
  {
    CTX_NONE = 1,
    CTX_LETTER = 2,
    CTX_NEWLINE = 4,
    CTX_ANY = 7
  };

/* Sometimes characters can only be matched depending on the surrounding
   context.  Such context decisions depend on what the previous character
   was, and the value of the current (lookahead) character.  Context
   dependent constraints are encoded as 9-bit integers.  Each bit that
   is set indicates that the constraint succeeds in the corresponding
   context.

   bit 6-8  - valid contexts when next character is CTX_NEWLINE
   bit 3-5  - valid contexts when next character is CTX_LETTER
   bit 0-2  - valid contexts when next character is CTX_NONE

   succeeds_in_context determines whether a given constraint
   succeeds in a particular context.  Prev is a bitmask of possible
   context values for the previous character, curr is the (single-bit)
   context value for the lookahead character.  */
static int
newline_constraint (int constraint)
{
  return (constraint >> 6) & 7;
}
static int
letter_constraint (int constraint)
{
  return (constraint >> 3) & 7;
}
static int
other_constraint (int constraint)
{
  return constraint & 7;
}

static bool
succeeds_in_context (int constraint, int prev, int curr)
{
  return !! (((curr & CTX_NONE      ? other_constraint (constraint) : 0) \
              | (curr & CTX_LETTER  ? letter_constraint (constraint) : 0) \
              | (curr & CTX_NEWLINE ? newline_constraint (constraint) : 0)) \
             & prev);
}

/* The following describe what a constraint depends on.  */
static bool
prev_newline_dependent (int constraint)
{
  return ((constraint ^ constraint >> 2) & 0111) != 0;
}
static bool
prev_letter_dependent (int constraint)
{
  return ((constraint ^ constraint >> 1) & 0111) != 0;
}

/* Tokens that match the empty string subject to some constraint actually
   work by applying that constraint to determine what may follow them,
   taking into account what has gone before.  The following values are
   the constraints corresponding to the special tokens previously defined.  */
enum
  {
    NO_CONSTRAINT = 0777,
    BEGLINE_CONSTRAINT = 0444,
    ENDLINE_CONSTRAINT = 0700,
    BEGWORD_CONSTRAINT = 0050,
    ENDWORD_CONSTRAINT = 0202,
    LIMWORD_CONSTRAINT = 0252,
    NOTLIMWORD_CONSTRAINT = 0525
  };

/* The regexp is parsed into an array of tokens in postfix form.  Some tokens
   are operators and others are terminal symbols.  Most (but not all) of these
   codes are returned by the lexical analyzer.  */

typedef ptrdiff_t token;
static token const TOKEN_MAX = PTRDIFF_MAX;

/* States are indexed by state_num values.  These are normally
   nonnegative but -1 is used as a special value.  */
typedef ptrdiff_t state_num;

/* Predefined token values.  */
enum
{
  END = -1,                     /* END is a terminal symbol that matches the
                                   end of input; any value of END or less in
                                   the parse tree is such a symbol.  Accepting
                                   states of the DFA are those that would have
                                   a transition on END.  This is -1, not some
                                   more-negative value, to tweak the speed of
                                   comparisons to END.  */

  /* Ordinary character values are terminal symbols that match themselves.  */

  /* CSET must come last in the following list of special tokens.  Otherwise,
     the list order matters only for performance.  Related special tokens
     should have nearby values so that code like (t == ANYCHAR || t == MBCSET
     || CSET <= t) can be done with a single machine-level comparison.  */

  EMPTY = NOTCHAR,              /* EMPTY is a terminal symbol that matches
                                   the empty string.  */

  QMARK,                        /* QMARK is an operator of one argument that
                                   matches zero or one occurrences of its
                                   argument.  */

  STAR,                         /* STAR is an operator of one argument that
                                   matches the Kleene closure (zero or more
                                   occurrences) of its argument.  */

  PLUS,                         /* PLUS is an operator of one argument that
                                   matches the positive closure (one or more
                                   occurrences) of its argument.  */

  REPMN,                        /* REPMN is a lexical token corresponding
                                   to the {m,n} construct.  REPMN never
                                   appears in the compiled token vector.  */

  CAT,                          /* CAT is an operator of two arguments that
                                   matches the concatenation of its
                                   arguments.  CAT is never returned by the
                                   lexical analyzer.  */

  OR,                           /* OR is an operator of two arguments that
                                   matches either of its arguments.  */

  LPAREN,                       /* LPAREN never appears in the parse tree,
                                   it is only a lexeme.  */

  RPAREN,                       /* RPAREN never appears in the parse tree.  */

  WCHAR,                        /* Only returned by lex.  wctok contains the
                                   32-bit wide character representation.  */

  ANYCHAR,                      /* ANYCHAR is a terminal symbol that matches
                                   a valid multibyte (or single byte) character.
                                   It is used only if MB_CUR_MAX > 1.  */

  BEG,                          /* BEG is an initial symbol that matches the
                                   beginning of input.  */

  BEGLINE,                      /* BEGLINE is a terminal symbol that matches
                                   the empty string at the beginning of a
                                   line.  */

  ENDLINE,                      /* ENDLINE is a terminal symbol that matches
                                   the empty string at the end of a line.  */

  BEGWORD,                      /* BEGWORD is a terminal symbol that matches
                                   the empty string at the beginning of a
                                   word.  */

  ENDWORD,                      /* ENDWORD is a terminal symbol that matches
                                   the empty string at the end of a word.  */

  LIMWORD,                      /* LIMWORD is a terminal symbol that matches
                                   the empty string at the beginning or the
                                   end of a word.  */

  NOTLIMWORD,                   /* NOTLIMWORD is a terminal symbol that
                                   matches the empty string not at
                                   the beginning or end of a word.  */

  BACKREF,                      /* BACKREF is generated by \<digit>
                                   or by any other construct that
                                   is not completely handled.  If the scanner
                                   detects a transition on backref, it returns
                                   a kind of "semi-success" indicating that
                                   the match will have to be verified with
                                   a backtracking matcher.  */

  MBCSET,                       /* MBCSET is similar to CSET, but for
                                   multibyte characters.  */

  CSET                          /* CSET and (and any value greater) is a
                                   terminal symbol that matches any of a
                                   class of characters.  */
};


/* States of the recognizer correspond to sets of positions in the parse
   tree, together with the constraints under which they may be matched.
   So a position is encoded as an index into the parse tree together with
   a constraint.  */
typedef struct
{
  idx_t index;			/* Index into the parse array.  */
  unsigned int constraint;      /* Constraint for matching this position.  */
} position;

/* Sets of positions are stored as arrays.  */
typedef struct
{
  position *elems;              /* Elements of this position set.  */
  idx_t nelem;			/* Number of elements in this set.  */
  idx_t alloc;			/* Number of elements allocated in ELEMS.  */
} position_set;

/* A state of the dfa consists of a set of positions, some flags,
   and the token value of the lowest-numbered position of the state that
   contains an END token.  */
typedef struct
{
  size_t hash;                  /* Hash of the positions of this state.  */
  position_set elems;           /* Positions this state could match.  */
  unsigned char context;        /* Context from previous state.  */
  unsigned short constraint;    /* Constraint for this state to accept.  */
  position_set mbps;            /* Positions which can match multibyte
                                   characters or the follows, e.g., period.
                                   Used only if MB_CUR_MAX > 1.  */
  state_num mb_trindex;         /* Index of this state in MB_TRANS, or
                                   negative if the state does not have
                                   ANYCHAR.  */
} dfa_state;

/* Maximum for any transition table count.  This should be at least 3,
   for the initial state setup.  */
enum { MAX_TRCOUNT = 1024 };

/* A bracket operator.
   e.g., [a-c], [[:alpha:]], etc.  */
struct mb_char_classes
{
  ptrdiff_t cset;
  bool invert;
  char32_t *chars;              /* Normal characters.  */
  idx_t nchars;
  idx_t nchars_alloc;
};

struct regex_syntax
{
  /* Syntax bits controlling the behavior of the lexical analyzer.  */
  reg_syntax_t syntax_bits;
  int dfaopts;
  bool syntax_bits_set;

  /* Flag for case-folding letters into sets.  */
  bool case_fold;

  /* End-of-line byte in data.  */
  unsigned char eolbyte;

  /* Cache of char-context values.  */
  char sbit[NOTCHAR];

  /* If never_trail[B], the byte B cannot be a non-initial byte in a
     multibyte character.  */
  bool never_trail[NOTCHAR];

  /* Set of characters considered letters.  */
  charclass letters;

  /* Set of characters that are newline.  */
  charclass newline;
};

/* Lexical analyzer.  All the dross that deals with the obnoxious
   GNU Regex syntax bits is located here.  The poor, suffering
   reader is referred to the GNU Regex documentation for the
   meaning of the @#%!@#%^!@ syntax bits.  */
struct lexer_state
{
  char const *ptr;	/* Pointer to next input character.  */
  idx_t left;		/* Number of characters remaining.  */
  token lasttok;	/* Previous token returned; initially END.  */
  idx_t parens;		/* Count of outstanding left parens.  */
  int minrep, maxrep;	/* Repeat counts for {m,n}.  */

  /* 32-bit wide character representation of the current multibyte character,
     or WEOF if there was an encoding error.  Used only if
     MB_CUR_MAX > 1.  */
  wint_t wctok;

  /* The most recently analyzed multibyte bracket expression.  */
  struct mb_char_classes brack;

  /* We're separated from beginning or (, | only by zero-width characters.  */
  bool laststart;
};

/* Recursive descent parser for regular expressions.  */

struct parser_state
{
  token tok;               /* Lookahead token.  */
  idx_t depth;		   /* Current depth of a hypothetical stack
                              holding deferred productions.  This is
                              used to determine the depth that will be
                              required of the real stack later on in
                              dfaanalyze.  */
};

/* A compiled regular expression.  */
struct dfa
{
  /* Fields filled by the scanner.  */
  charclass *charclasses;       /* Array of character sets for CSET tokens.  */
  idx_t cindex;			/* Index for adding new charclasses.  */
  idx_t calloc;			/* Number of charclasses allocated.  */
  ptrdiff_t canychar;           /* Index of anychar class, or -1.  */

  /* Scanner state */
  struct lexer_state lex;

  /* Parser state */
  struct parser_state parse;

  /* Fields filled by the parser.  */
  token *tokens;                /* Postfix parse array.  */
  idx_t tindex;			/* Index for adding new tokens.  */
  idx_t talloc;			/* Number of tokens currently allocated.  */
  idx_t depth;			/* Depth required of an evaluation stack
                                   used for depth-first traversal of the
                                   parse tree.  */
  idx_t nleaves;		/* Number of non-EMPTY leaves
                                   in the parse tree.  */
  idx_t nregexps;		/* Count of parallel regexps being built
                                   with dfaparse.  */
  bool fast;			/* The DFA is fast.  */
  bool epsilon;			/* Does a token match only the empty string?  */
  token utf8_anychar_classes[9]; /* To lower ANYCHAR in UTF-8 locales.  */
  mbstate_t mbs;		/* Multibyte conversion state.  */

  /* The following are valid only if MB_CUR_MAX > 1.  */

  /* The value of multibyte_prop[i] is defined by following rule.
     if tokens[i] < NOTCHAR
     bit 0 : tokens[i] is the first byte of a character, including
     single-byte characters.
     bit 1 : tokens[i] is the last byte of a character, including
     single-byte characters.

     e.g.
     tokens
     = 'single_byte_a', 'multi_byte_A', single_byte_b'
     = 'sb_a', 'mb_A(1st byte)', 'mb_A(2nd byte)', 'mb_A(3rd byte)', 'sb_b'
     multibyte_prop
     = 3     , 1               ,  0              ,  2              , 3
   */
  char *multibyte_prop;

  /* Fields filled by the superset.  */
  struct dfa *superset;             /* Hint of the dfa.  */

  /* Fields filled by the state builder.  */
  dfa_state *states;            /* States of the dfa.  */
  state_num sindex;             /* Index for adding new states.  */
  idx_t salloc;			/* Number of states currently allocated.  */

  /* Fields filled by the parse tree->NFA conversion.  */
  position_set *follows;        /* Array of follow sets, indexed by position
                                   index.  The follow of a position is the set
                                   of positions containing characters that
                                   could conceivably follow a character
                                   matching the given position in a string
                                   matching the regexp.  Allocated to the
                                   maximum possible position index.  */
  bool searchflag;		/* We are supposed to build a searching
                                   as opposed to an exact matcher.  A searching
                                   matcher finds the first and shortest string
                                   matching a regexp anywhere in the buffer,
                                   whereas an exact matcher finds the longest
                                   string matching, but anchored to the
                                   beginning of the buffer.  */

  /* Fields filled by dfaanalyze.  */
  int *constraints;             /* Array of union of accepting constraints
                                   in the follow of a position.  */
  int *separates;               /* Array of contexts on follow of a
                                   position.  */

  /* Fields filled by dfaexec.  */
  state_num tralloc;            /* Number of transition tables that have
                                   slots so far, not counting trans[-1] and
                                   trans[-2].  */
  int trcount;                  /* Number of transition tables that have
                                   been built, other than for initial
                                   states.  */
  int min_trcount;              /* Number of initial states.  Equivalently,
                                   the minimum state number for which trcount
                                   counts transitions.  */
  state_num **trans;            /* Transition tables for states that can
                                   never accept.  If the transitions for a
                                   state have not yet been computed, or the
                                   state could possibly accept, its entry in
                                   this table is NULL.  This points to two
                                   past the start of the allocated array,
                                   and trans[-1] and trans[-2] are always
                                   NULL.  */
  state_num **fails;            /* Transition tables after failing to accept
                                   on a state that potentially could do so.
                                   If trans[i] is non-null, fails[i] must
                                   be null.  */
  char *success;                /* Table of acceptance conditions used in
                                   dfaexec and computed in build_state.  */
  state_num *newlines;          /* Transitions on newlines.  The entry for a
                                   newline in any transition table is always
                                   -1 so we can count lines without wasting
                                   too many cycles.  The transition for a
                                   newline is stored separately and handled
                                   as a special case.  Newline is also used
                                   as a sentinel at the end of the buffer.  */
  state_num initstate_notbol;   /* Initial state for CTX_LETTER and CTX_NONE
                                   context in multibyte locales, in which we
                                   do not distinguish between their contexts,
                                   as not supported word.  */
  position_set mb_follows;      /* Follow set added by ANYCHAR on demand.  */
  state_num **mb_trans;         /* Transition tables for states with
                                   ANYCHAR.  */
  state_num mb_trcount;         /* Number of transition tables for states with
                                   ANYCHAR that have actually been built.  */

  /* Syntax configuration.  This is near the end so that dfacopysyntax
     can memset up to here.  */
  struct regex_syntax syntax;

  /* Information derived from the locale.  This is at the end so that
     a quick memset need not clear it specially.  */

  /* dfaexec implementation.  */
  char *(*dfaexec) (struct dfa *, char const *, char *,
                    bool, idx_t *, bool *);

  /* Other cached information derived from the locale.  */
  struct localeinfo localeinfo;
};

/* User access to dfa internals.  */

/* S could possibly be an accepting state of R.  */
static bool
accepting (state_num s, struct dfa const *r)
{
  return r->states[s].constraint != 0;
}

/* STATE accepts in the specified context.  */
static bool
accepts_in_context (int prev, int curr, state_num state, struct dfa const *dfa)
{
  return succeeds_in_context (dfa->states[state].constraint, prev, curr);
}

static void regexp (struct dfa *dfa);

/* Store into *PWC the result of converting the leading bytes of the
   multibyte buffer S of length N bytes, using D->localeinfo.sbctowc
   and updating the conversion state in *D.  On conversion error,
   convert just a single byte, to WEOF.  Return the number of bytes
   converted.

   This differs from mbrtoc32 (PWC, S, N, &D->mbs) as follows:

   * PWC points to wint_t, not to char32_t.
   * The last arg is a dfa *D instead of merely a multibyte conversion
     state D->mbs.
   * N is idx_t not size_t, and must be at least 1.
   * S[N - 1] must be a sentinel byte.
   * Shift encodings are not supported.
   * The return value is always in the range 1..N.
   * D->mbs is always valid afterwards.
   * *PWC is always set to something.  */
static int
mbs_to_wchar (wint_t *pwc, char const *s, idx_t n, struct dfa *d)
{
  unsigned char uc = s[0];
  wint_t wc = d->localeinfo.sbctowc[uc];

  if (wc == WEOF)
    {
      char32_t wch;
      size_t nbytes = mbrtoc32 (&wch, s, n, &d->mbs);
      if (0 < nbytes && nbytes < (size_t) -2)
        {
          *pwc = wch;
          /* nbytes cannot be == (size) -3 here, since we rely on the
             'mbrtoc32-regular' module.  */
          return nbytes;
        }
      mbszero (&d->mbs);
    }

  *pwc = wc;
  return 1;
}

#ifdef DEBUG

static void
prtok (token t)
{
  if (t <= END)
    fprintf (stderr, "END");
  else if (0 <= t && t < NOTCHAR)
    {
      unsigned int ch = t;
      fprintf (stderr, "0x%02x", ch);
    }
  else
    {
      char const *s;
      switch (t)
        {
        case BEG:
          s = "BEG";
          break;
        case EMPTY:
          s = "EMPTY";
          break;
        case BACKREF:
          s = "BACKREF";
          break;
        case BEGLINE:
          s = "BEGLINE";
          break;
        case ENDLINE:
          s = "ENDLINE";
          break;
        case BEGWORD:
          s = "BEGWORD";
          break;
        case ENDWORD:
          s = "ENDWORD";
          break;
        case LIMWORD:
          s = "LIMWORD";
          break;
        case NOTLIMWORD:
          s = "NOTLIMWORD";
          break;
        case QMARK:
          s = "QMARK";
          break;
        case STAR:
          s = "STAR";
          break;
        case PLUS:
          s = "PLUS";
          break;
        case CAT:
          s = "CAT";
          break;
        case OR:
          s = "OR";
          break;
        case LPAREN:
          s = "LPAREN";
          break;
        case RPAREN:
          s = "RPAREN";
          break;
        case ANYCHAR:
          s = "ANYCHAR";
          break;
        case MBCSET:
          s = "MBCSET";
          break;
        default:
          s = "CSET";
          break;
        }
      fprintf (stderr, "%s", s);
    }
}
#endif /* DEBUG */

/* Stuff pertaining to charclasses.  */

static bool
tstbit (unsigned int b, charclass const *c)
{
  return c->w[b / CHARCLASS_WORD_BITS] >> b % CHARCLASS_WORD_BITS & 1;
}

static void
setbit (unsigned int b, charclass *c)
{
  charclass_word one = 1;
  c->w[b / CHARCLASS_WORD_BITS] |= one << b % CHARCLASS_WORD_BITS;
}

static void
clrbit (unsigned int b, charclass *c)
{
  charclass_word one = 1;
  c->w[b / CHARCLASS_WORD_BITS] &= ~(one << b % CHARCLASS_WORD_BITS);
}

static void
zeroset (charclass *s)
{
  memset (s, 0, sizeof *s);
}

static void
fillset (charclass *s)
{
  for (int i = 0; i < CHARCLASS_WORDS; i++)
    s->w[i] = CHARCLASS_WORD_MASK;
}

static void
notset (charclass *s)
{
  for (int i = 0; i < CHARCLASS_WORDS; ++i)
    s->w[i] = CHARCLASS_WORD_MASK & ~s->w[i];
}

static bool
equal (charclass const *s1, charclass const *s2)
{
  charclass_word w = 0;
  for (int i = 0; i < CHARCLASS_WORDS; i++)
    w |= s1->w[i] ^ s2->w[i];
  return w == 0;
}

static bool
emptyset (charclass const *s)
{
  charclass_word w = 0;
  for (int i = 0; i < CHARCLASS_WORDS; i++)
    w |= s->w[i];
  return w == 0;
}

/* Ensure that the array addressed by PA holds at least I + 1 items.
   Either return PA, or reallocate the array and return its new address.
   Although PA may be null, the returned value is never null.

   The array holds *NITEMS items, where 0 <= I <= *NITEMS; *NITEMS
   is updated on reallocation.  If PA is null, *NITEMS must be zero.
   Do not allocate more than NITEMS_MAX items total; -1 means no limit.
   ITEM_SIZE is the size of one item; it must be positive.
   Avoid O(N**2) behavior on arrays growing linearly.  */
static void *
maybe_realloc (void *pa, idx_t i, idx_t *nitems,
               ptrdiff_t nitems_max, idx_t item_size)
{
  if (i < *nitems)
    return pa;
  return xpalloc (pa, nitems, 1, nitems_max, item_size);
}

/* In DFA D, find the index of charclass S, or allocate a new one.  */
static idx_t
charclass_index (struct dfa *d, charclass const *s)
{
  idx_t i;

  for (i = 0; i < d->cindex; ++i)
    if (equal (s, &d->charclasses[i]))
      return i;
  d->charclasses = maybe_realloc (d->charclasses, d->cindex, &d->calloc,
                                  TOKEN_MAX - CSET, sizeof *d->charclasses);
  ++d->cindex;
  d->charclasses[i] = *s;
  return i;
}

static bool
unibyte_word_constituent (struct dfa const *dfa, unsigned char c)
{
  return dfa->localeinfo.sbctowc[c] != WEOF && (isalnum (c) || (c) == '_');
}

static int
char_context (struct dfa const *dfa, unsigned char c)
{
  if (c == dfa->syntax.eolbyte && !(dfa->syntax.dfaopts & DFA_ANCHOR))
    return CTX_NEWLINE;
  if (unibyte_word_constituent (dfa, c))
    return CTX_LETTER;
  return CTX_NONE;
}

/* Set a bit in the charclass for the given char32_t.  Do nothing if WC
   is represented by a multi-byte sequence.  Even for MB_CUR_MAX == 1,
   this may happen when folding case in weird Turkish locales where
   dotless i/dotted I are not included in the chosen character set.
   Return whether a bit was set in the charclass.  */
static bool
setbit_wc (char32_t wc, charclass *c)
{
  int b = c32tob (wc);
  if (b < 0)
    return false;

  setbit (b, c);
  return true;
}

/* Set a bit for B and its case variants in the charclass C.
   MB_CUR_MAX must be 1.  */
static void
setbit_case_fold_c (int b, charclass *c)
{
  int ub = toupper (b);
  for (int i = 0; i < NOTCHAR; i++)
    if (toupper (i) == ub)
      setbit (i, c);
}

/* Fetch the next lexical input character from the pattern.  There
   must at least one byte of pattern input.  Set DFA->lex.wctok to the
   value of the character or to WEOF depending on whether the input is
   a valid multibyte character (possibly of length 1).  Then return
   the next input byte value, except return EOF if the input is a
   multibyte character of length greater than 1.  */
static int
fetch_wc (struct dfa *dfa)
{
  int nbytes = mbs_to_wchar (&dfa->lex.wctok, dfa->lex.ptr, dfa->lex.left,
                             dfa);
  int c = nbytes == 1 ? to_uchar (dfa->lex.ptr[0]) : EOF;
  dfa->lex.ptr += nbytes;
  dfa->lex.left -= nbytes;
  return c;
}

/* If there is no more input, report an error about unbalanced brackets.
   Otherwise, behave as with fetch_wc (DFA).  */
static int
bracket_fetch_wc (struct dfa *dfa)
{
  if (! dfa->lex.left)
    dfaerror (_("unbalanced ["));
  return fetch_wc (dfa);
}

typedef int predicate (int);

/* The following list maps the names of the Posix named character classes
   to predicate functions that determine whether a given character is in
   the class.  The leading [ has already been eaten by the lexical
   analyzer.  */
struct dfa_ctype
{
  const char *name;
  predicate *func;
  bool single_byte_only;
};

static const struct dfa_ctype prednames[] = {
  {"alpha", isalpha, false},
  {"upper", isupper, false},
  {"lower", islower, false},
  {"digit", isdigit, true},
  {"xdigit", isxdigit, false},
  {"space", isspace, false},
  {"punct", ispunct, false},
  {"alnum", isalnum, false},
  {"print", isprint, false},
  {"graph", isgraph, false},
  {"cntrl", iscntrl, false},
  {"blank", isblank, false},
  {NULL, NULL, false}
};

static const struct dfa_ctype *_GL_ATTRIBUTE_PURE
find_pred (const char *str)
{
  for (int i = 0; prednames[i].name; i++)
    if (str_eq (str, prednames[i].name))
      return &prednames[i];
  return NULL;
}

/* Parse a bracket expression, which possibly includes multibyte
   characters.  */
static token
parse_bracket_exp (struct dfa *dfa)
{
  /* This is a bracket expression that dfaexec is known to
     process correctly.  */
  bool known_bracket_exp = true;

  /* Used to warn about [:space:].
     Bit 0 = first character is a colon.
     Bit 1 = last character is a colon.
     Bit 2 = includes any other character but a colon.
     Bit 3 = includes ranges, char/equiv classes or collation elements.  */
  int colon_warning_state;

  dfa->lex.brack.nchars = 0;
  charclass ccl;
  zeroset (&ccl);
  int c = bracket_fetch_wc (dfa);
  bool invert = c == '^';
  if (invert)
    {
      c = bracket_fetch_wc (dfa);
      known_bracket_exp = dfa->localeinfo.simple;
    }
  wint_t wc = dfa->lex.wctok;
  int c1;
  wint_t wc1;
  colon_warning_state = (c == ':');
  do
    {
      c1 = NOTCHAR;	/* Mark c1 as not initialized.  */
      colon_warning_state &= ~2;

      /* Note that if we're looking at some other [:...:] construct,
         we just treat it as a bunch of ordinary characters.  We can do
         this because we assume regex has checked for syntax errors before
         dfa is ever called.  */
      if (c == '[')
        {
          c1 = bracket_fetch_wc (dfa);
          wc1 = dfa->lex.wctok;

          if ((c1 == ':' && (dfa->syntax.syntax_bits & RE_CHAR_CLASSES))
              || c1 == '.' || c1 == '=')
            {
              enum { MAX_BRACKET_STRING_LEN = 32 };
              char str[MAX_BRACKET_STRING_LEN + 1];
              int len = 0;
              for (;;)
                {
                  c = bracket_fetch_wc (dfa);
                  if (dfa->lex.left == 0
                      || (c == c1 && dfa->lex.ptr[0] == ']'))
                    break;
                  if (len < MAX_BRACKET_STRING_LEN)
                    str[len++] = c;
                  else
                    /* This is in any case an invalid class name.  */
                    str[0] = '\0';
                }
              str[len] = '\0';

              /* Fetch bracket.  */
              c = bracket_fetch_wc (dfa);
              wc = dfa->lex.wctok;
              if (c1 == ':')
                /* Build character class.  POSIX allows character
                   classes to match multicharacter collating elements,
                   but the regex code does not support that, so do not
                   worry about that possibility.  */
                {
                  char const *class
                    = (dfa->syntax.case_fold && (str_eq (str, "upper")
                                                 || str_eq (str, "lower"))
                       ? "alpha" : str);
                  const struct dfa_ctype *pred = find_pred (class);
                  if (!pred)
                    dfaerror (_("invalid character class"));

                  if (dfa->localeinfo.multibyte && !pred->single_byte_only)
                    known_bracket_exp = false;
                  else
                    for (int c2 = 0; c2 < NOTCHAR; ++c2)
                      if (pred->func (c2))
                        setbit (c2, &ccl);
                }
              else
                known_bracket_exp = false;

              colon_warning_state |= 8;

              /* Fetch new lookahead character.  */
              c1 = bracket_fetch_wc (dfa);
              wc1 = dfa->lex.wctok;
              continue;
            }

          /* We treat '[' as a normal character here.  c/c1/wc/wc1
             are already set up.  */
        }

      if (c == '\\'
          && (dfa->syntax.syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
        {
          c = bracket_fetch_wc (dfa);
          wc = dfa->lex.wctok;
        }

      if (c1 == NOTCHAR)
        {
          c1 = bracket_fetch_wc (dfa);
          wc1 = dfa->lex.wctok;
        }

      if (c1 == '-')
        /* build range characters.  */
        {
          int c2 = bracket_fetch_wc (dfa);
          wint_t wc2 = dfa->lex.wctok;

          /* A bracket expression like [a-[.aa.]] matches an unknown set.
             Treat it like [-a[.aa.]] while parsing it, and
             remember that the set is unknown.  */
          if (c2 == '[' && dfa->lex.ptr[0] == '.')
            {
              known_bracket_exp = false;
              c2 = ']';
            }

          if (c2 == ']')
            {
              /* In the case [x-], the - is an ordinary hyphen,
                 which is left in c1, the lookahead character.  */
              dfa->lex.ptr--;
              dfa->lex.left++;
            }
          else
            {
              if (c2 == '\\' && (dfa->syntax.syntax_bits
                                 & RE_BACKSLASH_ESCAPE_IN_LISTS))
                {
                  c2 = bracket_fetch_wc (dfa);
                  wc2 = dfa->lex.wctok;
                }

              colon_warning_state |= 8;
              c1 = bracket_fetch_wc (dfa);
              wc1 = dfa->lex.wctok;

              /* Treat [x-y] as a range if x != y.  */
              if (wc != wc2 || wc == WEOF)
                {
                  if (dfa->localeinfo.simple
                      || (c_isdigit (c) & c_isdigit (c2)))
                    {
                      for (int ci = c; ci <= c2; ci++)
                        if (dfa->syntax.case_fold && isalpha (ci))
                          setbit_case_fold_c (ci, &ccl);
                        else
                          setbit (ci, &ccl);
                    }
                  else
                    known_bracket_exp = false;

                  continue;
                }
            }
        }

      colon_warning_state |= (c == ':') ? 2 : 4;

      if (!dfa->localeinfo.multibyte)
        {
          if (dfa->syntax.case_fold && isalpha (c))
            setbit_case_fold_c (c, &ccl);
          else
            setbit (c, &ccl);
          continue;
        }

      if (wc == WEOF)
        known_bracket_exp = false;
      else
        {
          char32_t folded[CASE_FOLDED_BUFSIZE + 1];
          int n = (dfa->syntax.case_fold
                   ? case_folded_counterparts (wc, folded + 1) + 1
                   : 1);
          folded[0] = wc;
          for (int i = 0; i < n; i++)
            if (!setbit_wc (folded[i], &ccl))
              {
                dfa->lex.brack.chars
                  = maybe_realloc (dfa->lex.brack.chars, dfa->lex.brack.nchars,
                                   &dfa->lex.brack.nchars_alloc, -1,
                                   sizeof *dfa->lex.brack.chars);
                dfa->lex.brack.chars[dfa->lex.brack.nchars++] = folded[i];
              }
        }
    }
  while ((wc = wc1, (c = c1) != ']'));

  if (colon_warning_state == 7)
    {
      char const *msg
        = _("character class syntax is [[:space:]], not [:space:]");
      if (dfa->syntax.dfaopts & DFA_CONFUSING_BRACKETS_ERROR)
        dfaerror (msg);
      else
        dfawarn (msg);
    }

  if (! known_bracket_exp)
    return BACKREF;

  if (dfa->localeinfo.multibyte && (invert || dfa->lex.brack.nchars != 0))
    {
      dfa->lex.brack.invert = invert;
      dfa->lex.brack.cset = emptyset (&ccl) ? -1 : charclass_index (dfa, &ccl);
      return MBCSET;
    }

  if (invert)
    {
      notset (&ccl);
      if (dfa->syntax.syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
        clrbit ('\n', &ccl);
    }

  return CSET + charclass_index (dfa, &ccl);
}

struct lexptr
{
  char const *ptr;
  idx_t left;
};

static void
push_lex_state (struct dfa *dfa, struct lexptr *ls, char const *s)
{
  ls->ptr = dfa->lex.ptr;
  ls->left = dfa->lex.left;
  dfa->lex.ptr = s;
  dfa->lex.left = strlen (s);
}

static void
pop_lex_state (struct dfa *dfa, struct lexptr const *ls)
{
  dfa->lex.ptr = ls->ptr;
  dfa->lex.left = ls->left;
}

static token
lex (struct dfa *dfa)
{
  bool backslash = false;

  /* Basic plan: We fetch a character.  If it's a backslash,
     we set the backslash flag and go through the loop again.
     On the plus side, this avoids having a duplicate of the
     main switch inside the backslash case.  On the minus side,
     it means that just about every case tests the backslash flag.  */
  for (int i = 0; ; i++)
    {
      /* This loop should consume at most a backslash and some other
         character.  */
      if (2 <= i)
        abort ();

      if (! dfa->lex.left)
        return dfa->lex.lasttok = END;
      int c = fetch_wc (dfa);

      switch (c)
        {
        case '\\':
          if (backslash)
            goto normal_char;
          if (dfa->lex.left == 0)
            dfaerror (_("unfinished \\ escape"));
          backslash = true;
          break;

        case '^':
          if (backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS
              || dfa->lex.lasttok == END || dfa->lex.lasttok == LPAREN
              || dfa->lex.lasttok == OR)
            return dfa->lex.lasttok = BEGLINE;
          goto normal_char;

        case '$':
          if (backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_ANCHORS
              || dfa->lex.left == 0
              || ((dfa->lex.left
                   > !(dfa->syntax.syntax_bits & RE_NO_BK_PARENS))
                  && (dfa->lex.ptr[!(dfa->syntax.syntax_bits & RE_NO_BK_PARENS)
                                   & (dfa->lex.ptr[0] == '\\')]
                      == ')'))
              || ((dfa->lex.left
                   > !(dfa->syntax.syntax_bits & RE_NO_BK_VBAR))
                  && (dfa->lex.ptr[!(dfa->syntax.syntax_bits & RE_NO_BK_VBAR)
                                   & (dfa->lex.ptr[0] == '\\')]
                      == '|'))
              || ((dfa->syntax.syntax_bits & RE_NEWLINE_ALT)
                  && dfa->lex.left > 0 && dfa->lex.ptr[0] == '\n'))
            return dfa->lex.lasttok = ENDLINE;
          goto normal_char;

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_BK_REFS)
            goto stray_backslash;

          dfa->lex.laststart = false;
          return dfa->lex.lasttok = BACKREF;

        case '`':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          /* FIXME: should be beginning of string */
          return dfa->lex.lasttok = BEGLINE;

        case '\'':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          /* FIXME: should be end of string */
          return dfa->lex.lasttok = ENDLINE;

        case '<':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          return dfa->lex.lasttok = BEGWORD;

        case '>':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          return dfa->lex.lasttok = ENDWORD;

        case 'b':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          return dfa->lex.lasttok = LIMWORD;

        case 'B':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          return dfa->lex.lasttok = NOTLIMWORD;

        case '?':
          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)
            goto default_case;
          if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))
            goto normal_char;
          if (dfa->lex.laststart)
            {
              if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))
                goto default_case;
              if (dfa->syntax.dfaopts & DFA_PLUS_WARN)
                dfawarn (_("? at start of expression"));
            }
          return dfa->lex.lasttok = QMARK;

        case '*':
          if (backslash)
            goto normal_char;
          if (dfa->lex.laststart)
            {
              if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))
                goto default_case;
              if (dfa->syntax.dfaopts & DFA_STAR_WARN)
                dfawarn (_("* at start of expression"));
            }
          return dfa->lex.lasttok = STAR;

        case '+':
          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)
            goto default_case;
          if (backslash != ((dfa->syntax.syntax_bits & RE_BK_PLUS_QM) != 0))
            goto normal_char;
          if (dfa->lex.laststart)
            {
              if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))
                goto default_case;
              if (dfa->syntax.dfaopts & DFA_PLUS_WARN)
                dfawarn (_("+ at start of expression"));
            }
          return dfa->lex.lasttok = PLUS;

        case '{':
          if (!(dfa->syntax.syntax_bits & RE_INTERVALS))
            goto default_case;
          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_BRACES) == 0))
            goto normal_char;

          /* Cases:
             {M} - exact count
             {M,} - minimum count, maximum is infinity
             {,N} - 0 through N
             {,} - 0 to infinity (same as '*')
             {M,N} - M through N */
          {
            char const *p = dfa->lex.ptr;
            char const *lim = p + dfa->lex.left;
            dfa->lex.minrep = dfa->lex.maxrep = -1;
            for (; p != lim && c_isdigit (*p); p++)
              dfa->lex.minrep = (dfa->lex.minrep < 0
                                 ? *p - '0'
                                 : MIN (RE_DUP_MAX + 1,
                                        dfa->lex.minrep * 10 + *p - '0'));
            if (p != lim)
              {
                if (*p != ',')
                  dfa->lex.maxrep = dfa->lex.minrep;
                else
                  {
                    if (dfa->lex.minrep < 0)
                      dfa->lex.minrep = 0;
                    while (++p != lim && c_isdigit (*p))
                      dfa->lex.maxrep
                        = (dfa->lex.maxrep < 0
                           ? *p - '0'
                           : MIN (RE_DUP_MAX + 1,
                                  dfa->lex.maxrep * 10 + *p - '0'));
                  }
              }
            bool invalid_content
              = ! ((! backslash || (p != lim && *p++ == '\\'))
                   && p != lim && *p++ == '}'
                   && 0 <= dfa->lex.minrep
                   && (dfa->lex.maxrep < 0
                       || dfa->lex.minrep <= dfa->lex.maxrep));
            if (invalid_content
                && (dfa->syntax.syntax_bits & RE_INVALID_INTERVAL_ORD))
              goto normal_char;
            if (dfa->lex.laststart)
              {
                if (!(dfa->syntax.syntax_bits & RE_CONTEXT_INDEP_OPS))
                  goto default_case;
                if (dfa->syntax.dfaopts & DFA_PLUS_WARN)
                  dfawarn (_("{...} at start of expression"));
              }
            if (invalid_content)
              dfaerror (_("invalid content of \\{\\}"));
            if (RE_DUP_MAX < dfa->lex.maxrep)
              dfaerror (_("regular expression too big"));
            dfa->lex.ptr = p;
            dfa->lex.left = lim - p;
          }
          dfa->lex.laststart = false;
          return dfa->lex.lasttok = REPMN;

        case '|':
          if (dfa->syntax.syntax_bits & RE_LIMITED_OPS)
            goto default_case;
          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_VBAR) == 0))
            goto normal_char;
          dfa->lex.laststart = true;
          return dfa->lex.lasttok = OR;

        case '\n':
          if (!(dfa->syntax.syntax_bits & RE_NEWLINE_ALT))
            goto default_case;
          if (backslash)
            goto normal_char;
          dfa->lex.laststart = true;
          return dfa->lex.lasttok = OR;

        case '(':
          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))
            goto normal_char;
          dfa->lex.parens++;
          dfa->lex.laststart = true;
          return dfa->lex.lasttok = LPAREN;

        case ')':
          if (backslash != ((dfa->syntax.syntax_bits & RE_NO_BK_PARENS) == 0))
            goto normal_char;
          if (dfa->lex.parens == 0
              && dfa->syntax.syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
            goto normal_char;
          dfa->lex.parens--;
          dfa->lex.laststart = false;
          return dfa->lex.lasttok = RPAREN;

        case '.':
          if (backslash)
            goto normal_char;
          if (dfa->canychar < 0)
            {
              charclass ccl;
              fillset (&ccl);
              if (!(dfa->syntax.syntax_bits & RE_DOT_NEWLINE))
                clrbit ('\n', &ccl);
              if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)
                clrbit ('\0', &ccl);
              if (dfa->localeinfo.multibyte)
                for (int c2 = 0; c2 < NOTCHAR; c2++)
                  if (dfa->localeinfo.sbctowc[c2] == WEOF)
                    clrbit (c2, &ccl);
              dfa->canychar = charclass_index (dfa, &ccl);
            }
          dfa->lex.laststart = false;
          return dfa->lex.lasttok = (dfa->localeinfo.multibyte
                                     ? ANYCHAR
                                     : CSET + dfa->canychar);

        case 's':
        case 'S':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          if (!dfa->localeinfo.multibyte)
            {
              charclass ccl;
              zeroset (&ccl);
              for (int c2 = 0; c2 < NOTCHAR; ++c2)
                if (isspace (c2))
                  setbit (c2, &ccl);
              if (c == 'S')
                notset (&ccl);
              dfa->lex.laststart = false;
              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);
            }

          /* FIXME: see if optimizing this, as is done with ANYCHAR and
             add_utf8_anychar, makes sense.  */

          /* \s and \S are documented to be equivalent to [[:space:]] and
             [^[:space:]] respectively, so tell the lexer to process those
             strings, each minus its "already processed" '['.  */
          {
            struct lexptr ls;
            push_lex_state (dfa, &ls, &"^[:space:]]"[c == 's']);
            dfa->lex.lasttok = parse_bracket_exp (dfa);
            pop_lex_state (dfa, &ls);
          }

          dfa->lex.laststart = false;
          return dfa->lex.lasttok;

        case 'w':
        case 'W':
          if (!backslash)
            goto normal_char;
          if (dfa->syntax.syntax_bits & RE_NO_GNU_OPS)
            goto stray_backslash;

          if (!dfa->localeinfo.multibyte)
            {
              charclass ccl;
              zeroset (&ccl);
              for (int c2 = 0; c2 < NOTCHAR; ++c2)
                if (dfa->syntax.sbit[c2] == CTX_LETTER)
                  setbit (c2, &ccl);
              if (c == 'W')
                notset (&ccl);
              dfa->lex.laststart = false;
              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);
            }

          /* FIXME: see if optimizing this, as is done with ANYCHAR and
             add_utf8_anychar, makes sense.  */

          /* \w and \W are documented to be equivalent to [_[:alnum:]] and
             [^_[:alnum:]] respectively, so tell the lexer to process those
             strings, each minus its "already processed" '['.  */
          {
            struct lexptr ls;
            push_lex_state (dfa, &ls, &"^_[:alnum:]]"[c == 'w']);
            dfa->lex.lasttok = parse_bracket_exp (dfa);
            pop_lex_state (dfa, &ls);
          }

          dfa->lex.laststart = false;
          return dfa->lex.lasttok;

        case '[':
          if (backslash)
            goto normal_char;
          dfa->lex.laststart = false;
          return dfa->lex.lasttok = parse_bracket_exp (dfa);

        default:
        default_case:
          if (!backslash)
            goto normal_char;
        stray_backslash:
          if (dfa->syntax.dfaopts & DFA_STRAY_BACKSLASH_WARN)
            {
              char const *msg;
              char msgbuf[100];
              if (!c32isprint (dfa->lex.wctok))
                msg = _("stray \\ before unprintable character");
              else if (c32isspace (dfa->lex.wctok))
                msg = _("stray \\ before white space");
              else
                {
                  char buf[MB_LEN_MAX + 1];
                  mbstate_t s;
                  mbszero (&s);
                  size_t stored_bytes = c32rtomb (buf, dfa->lex.wctok, &s);
                  if (stored_bytes < (size_t) -1)
                    {
                      buf[stored_bytes] = '\0';
                      int n = snprintf (msgbuf, sizeof msgbuf,
                                        _("stray \\ before %s"), buf);
                      msg = 0 <= n && n < sizeof msgbuf ? msgbuf : _("stray \\");
                    }
                  else
                    msg = _("stray \\");
                }
              dfawarn (msg);
            }
          FALLTHROUGH;
        case ']': case '}':
        normal_char:
          dfa->lex.laststart = false;
          /* For multibyte character sets, folding is done in atom.  Always
             return WCHAR.  */
          if (dfa->localeinfo.multibyte)
            return dfa->lex.lasttok = WCHAR;

          if (dfa->syntax.case_fold && isalpha (c))
            {
              charclass ccl;
              zeroset (&ccl);
              setbit_case_fold_c (c, &ccl);
              return dfa->lex.lasttok = CSET + charclass_index (dfa, &ccl);
            }

          return dfa->lex.lasttok = c;
        }
    }
}

static void
addtok_mb (struct dfa *dfa, token t, char mbprop)
{
  if (dfa->talloc == dfa->tindex)
    {
      dfa->tokens = xpalloc (dfa->tokens, &dfa->talloc, 1, -1,
                             sizeof *dfa->tokens);
      if (dfa->localeinfo.multibyte)
        dfa->multibyte_prop = xreallocarray (dfa->multibyte_prop, dfa->talloc,
                                             sizeof *dfa->multibyte_prop);
    }
  if (dfa->localeinfo.multibyte)
    dfa->multibyte_prop[dfa->tindex] = mbprop;
  dfa->tokens[dfa->tindex++] = t;

  switch (t)
    {
    case QMARK:
    case STAR:
    case PLUS:
      break;

    case CAT:
    case OR:
      dfa->parse.depth--;
      break;

    case EMPTY:
      dfa->epsilon = true;
      goto increment_depth;

    case BACKREF:
      dfa->fast = false;
      goto increment_nleaves;

    case BEGLINE:
    case ENDLINE:
    case BEGWORD:
    case ENDWORD:
    case LIMWORD:
    case NOTLIMWORD:
      dfa->epsilon = true;
      FALLTHROUGH;
    default:
    increment_nleaves:
      dfa->nleaves++;
    increment_depth:
      dfa->parse.depth++;
      if (dfa->depth < dfa->parse.depth)
        dfa->depth = dfa->parse.depth;
      break;
    }
}

static void addtok_wc (struct dfa *dfa, wint_t wc);

/* Add the given token to the parse tree, maintaining the depth count and
   updating the maximum depth if necessary.  */
static void
addtok (struct dfa *dfa, token t)
{
  if (dfa->localeinfo.multibyte && t == MBCSET)
    {
      bool need_or = false;

      /* Extract wide characters into alternations for better performance.
         This does not require UTF-8.  */
      for (idx_t i = 0; i < dfa->lex.brack.nchars; i++)
        {
          addtok_wc (dfa, dfa->lex.brack.chars[i]);
          if (need_or)
            addtok (dfa, OR);
          need_or = true;
        }
      dfa->lex.brack.nchars = 0;

      /* Wide characters have been handled above, so it is possible
         that the set is empty now.  Do nothing in that case.  */
      if (dfa->lex.brack.cset != -1)
        {
          addtok (dfa, CSET + dfa->lex.brack.cset);
          if (need_or)
            addtok (dfa, OR);
        }
    }
  else
    {
      addtok_mb (dfa, t, 3);
    }
}

/* We treat a multibyte character as a single atom, so that DFA
   can treat a multibyte character as a single expression.

   e.g., we construct the following tree from "<mb1><mb2>".
   <mb1(1st-byte)><mb1(2nd-byte)><CAT><mb1(3rd-byte)><CAT>
   <mb2(1st-byte)><mb2(2nd-byte)><CAT><mb2(3rd-byte)><CAT><CAT> */
static void
addtok_wc (struct dfa *dfa, wint_t wc)
{
  unsigned char buf[MB_LEN_MAX];
  mbstate_t s;
  mbszero (&s);
  size_t stored_bytes = c32rtomb ((char *) buf, wc, &s);
  int buflen;

  if (stored_bytes != (size_t) -1)
    buflen = stored_bytes;
  else
    {
      /* This is merely stop-gap.  buf[0] is undefined, yet skipping
         the addtok_mb call altogether can corrupt the heap.  */
      buflen = 1;
      buf[0] = 0;
    }

  addtok_mb (dfa, buf[0], buflen == 1 ? 3 : 1);
  for (int i = 1; i < buflen; i++)
    {
      addtok_mb (dfa, buf[i], i == buflen - 1 ? 2 : 0);
      addtok (dfa, CAT);
    }
}

static void
add_utf8_anychar (struct dfa *dfa)
{
  /* Since the Unicode Standard Version 4.0.0 (2003), a well-formed
     UTF-8 byte sequence has been defined as follows:

     ([\x00-\x7f]
     |[\xc2-\xdf][\x80-\xbf]
     |[\xe0][\xa0-\xbf][\x80-\xbf]
     |[\xe1-\xec\xee-\xef][\x80-\xbf][\x80-\xbf]
     |[\xed][\x80-\x9f][\x80-\xbf]
     |[\xf0][\x90-\xbf][\x80-\xbf][\x80-\xbf])
     |[\xf1-\xf3][\x80-\xbf][\x80-\xbf][\x80-\xbf]
     |[\xf4][\x80-\x8f][\x80-\xbf][\x80-\xbf])

     which I'll write more concisely "A|BC|DEC|FCC|GHC|IJCC|KCCC|LMCC",
     where A = [\x00-\x7f], B = [\xc2-\xdf], C = [\x80-\xbf],
     D = [\xe0], E = [\xa0-\xbf], F = [\xe1-\xec\xee-\xef], G = [\xed],
     H = [\x80-\x9f], I = [\xf0],
     J = [\x90-\xbf], K = [\xf1-\xf3], L = [\xf4], M = [\x80-\x8f].

     This can be refactored to "A|(B|DE|GH|(F|IJ|LM|KC)C)C".  */

  /* Mnemonics for classes containing two or more bytes.  */
  enum { A, B, C, E, F, H, J, K, M };

  /* Mnemonics for single-byte tokens.  */
  enum { D_token = 0xe0, G_token = 0xed, I_token = 0xf0, L_token = 0xf4 };

  static charclass const utf8_classes[] = {
    /* A. 00-7f: 1-byte sequence.  */
    CHARCLASS_INIT (0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0, 0, 0, 0),

    /* B. c2-df: 1st byte of a 2-byte sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0xfffffffc, 0),

    /* C. 80-bf: non-leading bytes.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0xffffffff, 0xffffffff, 0, 0),

    /* D. e0 (just a token).  */

    /* E. a0-bf: 2nd byte of a "DEC" sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0, 0xffffffff, 0, 0),

    /* F. e1-ec + ee-ef: 1st byte of an "FCC" sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0, 0xdffe),

    /* G. ed (just a token).  */

    /* H. 80-9f: 2nd byte of a "GHC" sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0xffffffff, 0, 0, 0),

    /* I. f0 (just a token).  */

    /* J. 90-bf: 2nd byte of an "IJCC" sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0xffff0000, 0xffffffff, 0, 0),

    /* K. f1-f3: 1st byte of a "KCCC" sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0, 0, 0, 0xe0000),

    /* L. f4 (just a token).  */

    /* M. 80-8f: 2nd byte of a "LMCC" sequence.  */
    CHARCLASS_INIT (0, 0, 0, 0, 0xffff, 0, 0, 0),
  };

  /* Define the character classes that are needed below.  */
  if (dfa->utf8_anychar_classes[0] == 0)
    {
      charclass c = utf8_classes[0];
      if (! (dfa->syntax.syntax_bits & RE_DOT_NEWLINE))
        clrbit ('\n', &c);
      if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)
        clrbit ('\0', &c);
      dfa->utf8_anychar_classes[0] = CSET + charclass_index (dfa, &c);

      for (int i = 1; i < sizeof utf8_classes / sizeof *utf8_classes; i++)
        dfa->utf8_anychar_classes[i]
          = CSET + charclass_index (dfa, &utf8_classes[i]);
    }

  /* Implement the "A|(B|DE|GH|(F|IJ|LM|KC)C)C" pattern mentioned above.
     The token buffer is in reverse Polish order, so we get
     "A B D E CAT OR G H CAT OR F I J CAT OR L M CAT OR K
      C CAT OR C CAT OR C CAT OR".  */
  addtok (dfa, dfa->utf8_anychar_classes[A]);
  addtok (dfa, dfa->utf8_anychar_classes[B]);
  addtok (dfa, D_token);
  addtok (dfa, dfa->utf8_anychar_classes[E]);
  addtok (dfa, CAT);
  addtok (dfa, OR);
  addtok (dfa, G_token);
  addtok (dfa, dfa->utf8_anychar_classes[H]);
  addtok (dfa, CAT);
  addtok (dfa, OR);
  addtok (dfa, dfa->utf8_anychar_classes[F]);
  addtok (dfa, I_token);
  addtok (dfa, dfa->utf8_anychar_classes[J]);
  addtok (dfa, CAT);
  addtok (dfa, OR);
  addtok (dfa, L_token);
  addtok (dfa, dfa->utf8_anychar_classes[M]);
  addtok (dfa, CAT);
  addtok (dfa, OR);
  addtok (dfa, dfa->utf8_anychar_classes[K]);
  for (int i = 0; i < 3; i++)
    {
      addtok (dfa, dfa->utf8_anychar_classes[C]);
      addtok (dfa, CAT);
      addtok (dfa, OR);
    }
}

/* The grammar understood by the parser is as follows.

   regexp:
     regexp OR branch
     branch

   branch:
     branch closure
     closure

   closure:
     closure QMARK
     closure STAR
     closure PLUS
     closure REPMN
     atom

   atom:
     <normal character>
     <multibyte character>
     ANYCHAR
     MBCSET
     CSET
     BACKREF
     BEGLINE
     ENDLINE
     BEGWORD
     ENDWORD
     LIMWORD
     NOTLIMWORD
     LPAREN regexp RPAREN
     <empty>

   The parser builds a parse tree in postfix form in an array of tokens.  */

static void
atom (struct dfa *dfa)
{
  if ((0 <= dfa->parse.tok && dfa->parse.tok < NOTCHAR)
      || dfa->parse.tok >= CSET
      || dfa->parse.tok == BEG || dfa->parse.tok == BACKREF
      || dfa->parse.tok == BEGLINE || dfa->parse.tok == ENDLINE
      || dfa->parse.tok == BEGWORD || dfa->parse.tok == ENDWORD
      || dfa->parse.tok == LIMWORD || dfa->parse.tok == NOTLIMWORD
      || dfa->parse.tok == ANYCHAR || dfa->parse.tok == MBCSET)
    {
      if (dfa->parse.tok == ANYCHAR && dfa->localeinfo.using_utf8)
        {
          /* For UTF-8 expand the period to a series of CSETs that define a
             valid UTF-8 character.  This avoids using the slow multibyte
             path.  I'm pretty sure it would be both profitable and correct to
             do it for any encoding; however, the optimization must be done
             manually as it is done above in add_utf8_anychar.  So, let's
             start with UTF-8: it is the most used, and the structure of the
             encoding makes the correctness more obvious.  */
          add_utf8_anychar (dfa);
        }
      else
        addtok (dfa, dfa->parse.tok);
      dfa->parse.tok = lex (dfa);
    }
  else if (dfa->parse.tok == WCHAR)
    {
      if (dfa->lex.wctok == WEOF)
        addtok (dfa, BACKREF);
      else
        {
          addtok_wc (dfa, dfa->lex.wctok);

          if (dfa->syntax.case_fold)
            {
              char32_t folded[CASE_FOLDED_BUFSIZE];
              int n = case_folded_counterparts (dfa->lex.wctok, folded);
              for (int i = 0; i < n; i++)
                {
                  addtok_wc (dfa, folded[i]);
                  addtok (dfa, OR);
                }
            }
        }

      dfa->parse.tok = lex (dfa);
    }
  else if (dfa->parse.tok == LPAREN)
    {
      dfa->parse.tok = lex (dfa);
      regexp (dfa);
      if (dfa->parse.tok != RPAREN)
        dfaerror (_("unbalanced ("));
      dfa->parse.tok = lex (dfa);
    }
  else
    addtok (dfa, EMPTY);
}

/* Return the number of tokens in the given subexpression.  */
static idx_t _GL_ATTRIBUTE_PURE
nsubtoks (struct dfa const *dfa, idx_t tindex)
{
  switch (dfa->tokens[tindex - 1])
    {
    default:
      return 1;
    case QMARK:
    case STAR:
    case PLUS:
      return 1 + nsubtoks (dfa, tindex - 1);
    case CAT:
    case OR:
      {
        idx_t ntoks1 = nsubtoks (dfa, tindex - 1);
        return 1 + ntoks1 + nsubtoks (dfa, tindex - 1 - ntoks1);
      }
    }
}

/* Copy the given subexpression to the top of the tree.  */
static void
copytoks (struct dfa *dfa, idx_t tindex, idx_t ntokens)
{
  if (dfa->localeinfo.multibyte)
    for (idx_t i = 0; i < ntokens; i++)
      addtok_mb (dfa, dfa->tokens[tindex + i],
                 dfa->multibyte_prop[tindex + i]);
  else
    for (idx_t i = 0; i < ntokens; i++)
      addtok_mb (dfa, dfa->tokens[tindex + i], 3);
}

static void
closure (struct dfa *dfa)
{
  atom (dfa);
  while (dfa->parse.tok == QMARK || dfa->parse.tok == STAR
         || dfa->parse.tok == PLUS || dfa->parse.tok == REPMN)
    if (dfa->parse.tok == REPMN && (dfa->lex.minrep || dfa->lex.maxrep))
      {
        idx_t ntokens = nsubtoks (dfa, dfa->tindex);
        idx_t tindex = dfa->tindex - ntokens;
        if (dfa->lex.maxrep < 0)
          addtok (dfa, PLUS);
        if (dfa->lex.minrep == 0)
          addtok (dfa, QMARK);
        int i;
        for (i = 1; i < dfa->lex.minrep; i++)
          {
            copytoks (dfa, tindex, ntokens);
            addtok (dfa, CAT);
          }
        for (; i < dfa->lex.maxrep; i++)
          {
            copytoks (dfa, tindex, ntokens);
            addtok (dfa, QMARK);
            addtok (dfa, CAT);
          }
        dfa->parse.tok = lex (dfa);
      }
    else if (dfa->parse.tok == REPMN)
      {
        dfa->tindex -= nsubtoks (dfa, dfa->tindex);
        dfa->parse.tok = lex (dfa);
        closure (dfa);
      }
    else
      {
        addtok (dfa, dfa->parse.tok);
        dfa->parse.tok = lex (dfa);
      }
}

static void
branch (struct dfa* dfa)
{
  closure (dfa);
  while (dfa->parse.tok != RPAREN && dfa->parse.tok != OR
         && dfa->parse.tok >= 0)
    {
      closure (dfa);
      addtok (dfa, CAT);
    }
}

static void
regexp (struct dfa *dfa)
{
  branch (dfa);
  while (dfa->parse.tok == OR)
    {
      dfa->parse.tok = lex (dfa);
      branch (dfa);
      addtok (dfa, OR);
    }
}

/* Parse a string S of length LEN into D.  S can include NUL characters.
   This is the main entry point for the parser.  */
void
dfaparse (char const *s, idx_t len, struct dfa *d)
{
  d->lex.ptr = s;
  d->lex.left = len;
  d->lex.lasttok = END;
  d->lex.laststart = true;

  if (!d->syntax.syntax_bits_set)
    dfaerror (_("no syntax specified"));

  if (!d->nregexps)
    addtok (d, BEG);

  d->parse.tok = lex (d);
  d->parse.depth = d->depth;

  regexp (d);

  if (d->parse.tok != END)
    dfaerror (_("unbalanced )"));

  addtok (d, END - d->nregexps);
  addtok (d, CAT);

  if (d->nregexps)
    addtok (d, OR);

  ++d->nregexps;
}

/* Some primitives for operating on sets of positions.  */

/* Copy one set to another.  */
static void
copy (position_set const *src, position_set *dst)
{
  if (dst->alloc < src->nelem)
    {
      free (dst->elems);
      dst->elems = xpalloc (NULL, &dst->alloc, src->nelem - dst->alloc, -1,
                            sizeof *dst->elems);
    }
  dst->nelem = src->nelem;
  if (src->nelem != 0)
    memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);
}

static void
alloc_position_set (position_set *s, idx_t size)
{
  s->elems = xnmalloc (size, sizeof *s->elems);
  s->alloc = size;
  s->nelem = 0;
}

/* Insert position P in set S.  S is maintained in sorted order on
   decreasing index.  If there is already an entry in S with P.index
   then merge (logically-OR) P's constraints into the one in S.
   S->elems must point to an array large enough to hold the resulting set.  */
static void
insert (position p, position_set *s)
{
  idx_t count = s->nelem;
  idx_t lo = 0, hi = count;
  while (lo < hi)
    {
      idx_t mid = (lo + hi) >> 1;
      if (s->elems[mid].index < p.index)
        lo = mid + 1;
      else if (s->elems[mid].index == p.index)
        {
          s->elems[mid].constraint |= p.constraint;
          return;
        }
      else
        hi = mid;
    }

  s->elems = maybe_realloc (s->elems, count, &s->alloc, -1, sizeof *s->elems);
  for (idx_t i = count; i > lo; i--)
    s->elems[i] = s->elems[i - 1];
  s->elems[lo] = p;
  ++s->nelem;
}

static void
append (position p, position_set *s)
{
  idx_t count = s->nelem;
  s->elems = maybe_realloc (s->elems, count, &s->alloc, -1, sizeof *s->elems);
  s->elems[s->nelem++] = p;
}

/* Merge S1 and S2 (with the additional constraint C2) into M.  The
   result is as if the positions of S1, and of S2 with the additional
   constraint C2, were inserted into an initially empty set.  */
static void
merge_constrained (position_set const *s1, position_set const *s2,
                   unsigned int c2, position_set *m)
{
  idx_t i = 0, j = 0;

  if (m->alloc - s1->nelem < s2->nelem)
    {
      free (m->elems);
      m->alloc = s1->nelem;
      m->elems = xpalloc (NULL, &m->alloc, s2->nelem, -1, sizeof *m->elems);
    }
  m->nelem = 0;
  while (i < s1->nelem || j < s2->nelem)
    if (! (j < s2->nelem)
        || (i < s1->nelem && s1->elems[i].index <= s2->elems[j].index))
      {
        unsigned int c = ((i < s1->nelem && j < s2->nelem
                           && s1->elems[i].index == s2->elems[j].index)
                          ? s2->elems[j++].constraint & c2
                          : 0);
        m->elems[m->nelem].index = s1->elems[i].index;
        m->elems[m->nelem++].constraint = s1->elems[i++].constraint | c;
      }
    else
      {
        if (s2->elems[j].constraint & c2)
          {
            m->elems[m->nelem].index = s2->elems[j].index;
            m->elems[m->nelem++].constraint = s2->elems[j].constraint & c2;
          }
        j++;
      }
}

/* Merge two sets of positions into a third.  The result is exactly as if
   the positions of both sets were inserted into an initially empty set.  */
static void
merge (position_set const *s1, position_set const *s2, position_set *m)
{
  merge_constrained (s1, s2, -1, m);
}

/* Merge into DST all the elements of SRC, possibly destroying
   the contents of the temporary M.  */
static void
merge2 (position_set *dst, position_set const *src, position_set *m)
{
  if (src->nelem < 4)
    {
      for (idx_t i = 0; i < src->nelem; i++)
        insert (src->elems[i], dst);
    }
   else
    {
      merge (src, dst, m);
      copy (m, dst);
    }
}

/* Delete a position from a set.  Return the nonzero constraint of the
   deleted position, or zero if there was no such position.  */
static unsigned int
delete (idx_t del, position_set *s)
{
  idx_t count = s->nelem;
  idx_t lo = 0, hi = count;
  while (lo < hi)
    {
      idx_t mid = (lo + hi) >> 1;
      if (s->elems[mid].index < del)
        lo = mid + 1;
      else if (s->elems[mid].index == del)
        {
          unsigned int c = s->elems[mid].constraint;
          idx_t i;
          for (i = mid; i + 1 < count; i++)
            s->elems[i] = s->elems[i + 1];
          s->nelem = i;
          return c;
        }
      else
        hi = mid;
    }
  return 0;
}

/* Replace a position with the followed set.  */
static void
replace (position_set *dst, idx_t del, position_set *add,
         unsigned int constraint, position_set *tmp)
{
  unsigned int c = delete (del, dst) & constraint;

  if (c)
    {
      copy (dst, tmp);
      merge_constrained (tmp, add, c, dst);
    }
}

/* Find the index of the state corresponding to the given position set with
   the given preceding context, or create a new state if there is no such
   state.  Context tells whether we got here on a newline or letter.  */
static state_num
state_index (struct dfa *d, position_set const *s, int context)
{
  size_t hash = 0;
  int constraint = 0;
  state_num i;

  for (i = 0; i < s->nelem; ++i)
    {
      idx_t ind = s->elems[i].index;
      hash ^= ind + s->elems[i].constraint;
    }

  /* Try to find a state that exactly matches the proposed one.  */
  for (i = 0; i < d->sindex; ++i)
    {
      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
          || context != d->states[i].context)
        continue;
      state_num j;
      for (j = 0; j < s->nelem; ++j)
        if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint
            || s->elems[j].index != d->states[i].elems.elems[j].index)
          break;
      if (j == s->nelem)
        return i;
    }

#ifdef DEBUG
  fprintf (stderr, "new state %td\n nextpos:", i);
  for (state_num j = 0; j < s->nelem; j++)
    {
      fprintf (stderr, " %td:", s->elems[j].index);
      prtok (d->tokens[s->elems[j].index]);
    }
  fprintf (stderr, "\n context:");
  if (context ^ CTX_ANY)
    {
      if (context & CTX_NONE)
        fprintf (stderr, " CTX_NONE");
      if (context & CTX_LETTER)
        fprintf (stderr, " CTX_LETTER");
      if (context & CTX_NEWLINE)
        fprintf (stderr, " CTX_NEWLINE");
    }
  else
    fprintf (stderr, " CTX_ANY");
  fprintf (stderr, "\n");
#endif

  for (state_num j = 0; j < s->nelem; j++)
    {
      int c = d->constraints[s->elems[j].index];

      if (c != 0)
        {
          if (succeeds_in_context (c, context, CTX_ANY))
            constraint |= c;
        }
      else if (d->tokens[s->elems[j].index] == BACKREF)
        constraint = NO_CONSTRAINT;
    }


  /* Create a new state.  */
  d->states = maybe_realloc (d->states, d->sindex, &d->salloc, -1,
                             sizeof *d->states);
  d->states[i].hash = hash;
  alloc_position_set (&d->states[i].elems, s->nelem);
  copy (s, &d->states[i].elems);
  d->states[i].context = context;
  d->states[i].constraint = constraint;
  d->states[i].mbps.nelem = 0;
  d->states[i].mbps.elems = NULL;
  d->states[i].mb_trindex = -1;

  ++d->sindex;

  return i;
}

/* Find the epsilon closure of D's set of positions.  If any position of the set
   contains a symbol that matches the empty string in some context, replace
   that position with the elements of its follow labeled with an appropriate
   constraint.  Repeat exhaustively until no funny positions are left.
   S->elems must be large enough to hold the result.  BACKWARD is D's
   backward set; use and update it too.  */
static void
epsclosure (struct dfa const *d, position_set *backward)
{
  position_set tmp;
  alloc_position_set (&tmp, d->nleaves);
  for (idx_t i = 0; i < d->tindex; i++)
    if (0 < d->follows[i].nelem)
      {
        unsigned int constraint;
        switch (d->tokens[i])
          {
          default:
            continue;

          case BEGLINE:
            constraint = BEGLINE_CONSTRAINT;
            break;
          case ENDLINE:
            constraint = ENDLINE_CONSTRAINT;
            break;
          case BEGWORD:
            constraint = BEGWORD_CONSTRAINT;
            break;
          case ENDWORD:
            constraint = ENDWORD_CONSTRAINT;
            break;
          case LIMWORD:
            constraint = LIMWORD_CONSTRAINT;
            break;
          case NOTLIMWORD:
            constraint = NOTLIMWORD_CONSTRAINT;
            break;
          case EMPTY:
            constraint = NO_CONSTRAINT;
            break;
          }

        delete (i, &d->follows[i]);

        for (idx_t j = 0; j < backward[i].nelem; j++)
          replace (&d->follows[backward[i].elems[j].index], i, &d->follows[i],
                   constraint, &tmp);
        for (idx_t j = 0; j < d->follows[i].nelem; j++)
          replace (&backward[d->follows[i].elems[j].index], i, &backward[i],
                   NO_CONSTRAINT, &tmp);
      }
  free (tmp.elems);
}

/* Returns the set of contexts for which there is at least one
   character included in C.  */

static int
charclass_context (struct dfa const *dfa, charclass const *c)
{
  int context = 0;

  for (int j = 0; j < CHARCLASS_WORDS; j++)
    {
      if (c->w[j] & dfa->syntax.newline.w[j])
        context |= CTX_NEWLINE;
      if (c->w[j] & dfa->syntax.letters.w[j])
        context |= CTX_LETTER;
      if (c->w[j] & ~(dfa->syntax.letters.w[j] | dfa->syntax.newline.w[j]))
        context |= CTX_NONE;
    }

  return context;
}

/* Returns the contexts on which the position set S depends.  Each context
   in the set of returned contexts (let's call it SC) may have a different
   follow set than other contexts in SC, and also different from the
   follow set of the complement set (sc ^ CTX_ANY).  However, all contexts
   in the complement set will have the same follow set.  */

static int _GL_ATTRIBUTE_PURE
state_separate_contexts (struct dfa *d, position_set const *s)
{
  int separate_contexts = 0;

  for (idx_t j = 0; j < s->nelem; j++)
    separate_contexts |= d->separates[s->elems[j].index];

  return separate_contexts;
}

enum
{
  /* Single token is repeated.  It is distinguished from non-repeated.  */
  OPT_REPEAT = (1 << 0),

  /* Multiple tokens are repeated.  This flag is on at head of tokens.  The
     node is not merged.  */
  OPT_LPAREN = (1 << 1),

  /* Multiple branches are joined.  The node is not merged.  */
  OPT_RPAREN = (1 << 2),

  /* The node is walked.  If the node is found in walking again, OPT_RPAREN
     flag is turned on. */
  OPT_WALKED = (1 << 3),

  /* The node is queued.  The node is not queued again.  */
  OPT_QUEUED = (1 << 4)
};

static void
merge_nfa_state (struct dfa *d, idx_t tindex, char *flags,
                 position_set *merged)
{
  position_set *follows = d->follows;
  idx_t nelem = 0;

  for (idx_t i = 0; i < follows[tindex].nelem; i++)
    {
      idx_t sindex = follows[tindex].elems[i].index;

      /* Skip the node as pruned in future.  */
      unsigned int iconstraint = follows[tindex].elems[i].constraint;
      if (iconstraint == 0)
        continue;

      if (d->tokens[follows[tindex].elems[i].index] <= END)
        {
          d->constraints[tindex] |= follows[tindex].elems[i].constraint;
          continue;
        }

      if (sindex != tindex && !(flags[sindex] & (OPT_LPAREN | OPT_RPAREN)))
        {
          idx_t j;

          for (j = 0; j < nelem; j++)
            {
              idx_t dindex = follows[tindex].elems[j].index;

              if (dindex == tindex)
                continue;

              if (follows[tindex].elems[j].constraint != iconstraint)
                continue;

              if (flags[dindex] & (OPT_LPAREN | OPT_RPAREN))
                continue;

              if (d->tokens[sindex] != d->tokens[dindex])
                continue;

              if ((flags[sindex] ^ flags[dindex]) & OPT_REPEAT)
                continue;

              if (flags[sindex] & OPT_REPEAT)
                delete (sindex, &follows[sindex]);

              merge2 (&follows[dindex], &follows[sindex], merged);

              break;
            }

          if (j < nelem)
            continue;
        }

      follows[tindex].elems[nelem++] = follows[tindex].elems[i];
      flags[sindex] |= OPT_QUEUED;
    }

  follows[tindex].nelem = nelem;
}

static int
compare (const void *a, const void *b)
{
  position const *p = a, *q = b;
  return (p->index > q->index) - (p->index < q->index);
}

static void
reorder_tokens (struct dfa *d)
{
  idx_t nleaves = 0;
  ptrdiff_t *map = xnmalloc (d->tindex, sizeof *map);
  map[0] = nleaves++;
  for (idx_t i = 1; i < d->tindex; i++)
    map[i] = -1;

  token *tokens = xnmalloc (d->nleaves, sizeof *tokens);
  position_set *follows = xnmalloc (d->nleaves, sizeof *follows);
  int *constraints = xnmalloc (d->nleaves, sizeof *constraints);
  char *multibyte_prop = (d->localeinfo.multibyte
                          ? xnmalloc (d->nleaves, sizeof *multibyte_prop)
                          : NULL);

  for (idx_t i = 0; i < d->tindex; i++)
    {
      if (map[i] < 0)
        {
          free (d->follows[i].elems);
          d->follows[i].elems = NULL;
          d->follows[i].nelem = 0;
          continue;
        }

      tokens[map[i]] = d->tokens[i];
      follows[map[i]] = d->follows[i];
      constraints[map[i]] = d->constraints[i];

      if (multibyte_prop != NULL)
        multibyte_prop[map[i]] = d->multibyte_prop[i];

      for (idx_t j = 0; j < d->follows[i].nelem; j++)
        {
          if (map[d->follows[i].elems[j].index] == -1)
            map[d->follows[i].elems[j].index] = nleaves++;

          d->follows[i].elems[j].index = map[d->follows[i].elems[j].index];
        }

      qsort (d->follows[i].elems, d->follows[i].nelem,
             sizeof *d->follows[i].elems, compare);
    }

  for (idx_t i = 0; i < nleaves; i++)
    {
      d->tokens[i] = tokens[i];
      d->follows[i] = follows[i];
      d->constraints[i] = constraints[i];

      if (multibyte_prop != NULL)
        d->multibyte_prop[i] = multibyte_prop[i];
    }

  d->tindex = d->nleaves = nleaves;

  free (tokens);
  free (follows);
  free (constraints);
  free (multibyte_prop);
  free (map);
}

static void
dfaoptimize (struct dfa *d)
{
  char *flags = xizalloc (d->tindex);

  for (idx_t i = 0; i < d->tindex; i++)
    {
      for (idx_t j = 0; j < d->follows[i].nelem; j++)
        {
          if (d->follows[i].elems[j].index == i)
            flags[d->follows[i].elems[j].index] |= OPT_REPEAT;
          else if (d->follows[i].elems[j].index < i)
            flags[d->follows[i].elems[j].index] |= OPT_LPAREN;
          else if (flags[d->follows[i].elems[j].index] &= OPT_WALKED)
            flags[d->follows[i].elems[j].index] |= OPT_RPAREN;
          else
            flags[d->follows[i].elems[j].index] |= OPT_WALKED;
        }
    }

  flags[0] |= OPT_QUEUED;

  position_set merged0;
  position_set *merged = &merged0;
  alloc_position_set (merged, d->nleaves);

  d->constraints = xicalloc (d->tindex, sizeof *d->constraints);

  for (idx_t i = 0; i < d->tindex; i++)
    if (flags[i] & OPT_QUEUED)
      merge_nfa_state (d, i, flags, merged);

  reorder_tokens (d);

  free (merged->elems);
  free (flags);
}

/* Perform bottom-up analysis on the parse tree, computing various functions.
   Note that at this point, we're pretending constructs like \< are real
   characters rather than constraints on what can follow them.

   Nullable:  A node is nullable if it is at the root of a regexp that can
   match the empty string.
   *  EMPTY leaves are nullable.
   * No other leaf is nullable.
   * A QMARK or STAR node is nullable.
   * A PLUS node is nullable if its argument is nullable.
   * A CAT node is nullable if both its arguments are nullable.
   * An OR node is nullable if either argument is nullable.

   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
   that could correspond to the first character of a string matching the
   regexp rooted at the given node.
   * EMPTY leaves have empty firstpos.
   * The firstpos of a nonempty leaf is that leaf itself.
   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
     argument.
   * The firstpos of a CAT node is the firstpos of the left argument, union
     the firstpos of the right if the left argument is nullable.
   * The firstpos of an OR node is the union of firstpos of each argument.

   Lastpos:  The lastpos of a node is the set of positions that could
   correspond to the last character of a string matching the regexp at
   the given node.
   * EMPTY leaves have empty lastpos.
   * The lastpos of a nonempty leaf is that leaf itself.
   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
     argument.
   * The lastpos of a CAT node is the lastpos of its right argument, union
     the lastpos of the left if the right argument is nullable.
   * The lastpos of an OR node is the union of the lastpos of each argument.

   Follow:  The follow of a position is the set of positions that could
   correspond to the character following a character matching the node in
   a string matching the regexp.  At this point we consider special symbols
   that match the empty string in some context to be just normal characters.
   Later, if we find that a special symbol is in a follow set, we will
   replace it with the elements of its follow, labeled with an appropriate
   constraint.
   * Every node in the firstpos of the argument of a STAR or PLUS node is in
     the follow of every node in the lastpos.
   * Every node in the firstpos of the second argument of a CAT node is in
     the follow of every node in the lastpos of the first argument.

   Because of the postfix representation of the parse tree, the depth-first
   analysis is conveniently done by a linear scan with the aid of a stack.
   Sets are stored as arrays of the elements, obeying a stack-like allocation
   scheme; the number of elements in each set deeper in the stack can be
   used to determine the address of a particular set's array.  */
static void
dfaanalyze (struct dfa *d, bool searchflag)
{
  /* Array allocated to hold position sets.  */
  position *posalloc = xnmalloc (d->nleaves, 2 * sizeof *posalloc);
  /* Firstpos and lastpos elements.  */
  position *firstpos = posalloc;
  position *lastpos = firstpos + d->nleaves;
  position pos;
  position_set tmp;

  /* Stack for element counts and nullable flags.  */
  struct
  {
    /* Whether the entry is nullable.  */
    bool nullable;

    /* Counts of firstpos and lastpos sets.  */
    idx_t nfirstpos;
    idx_t nlastpos;
  } *stkalloc = xnmalloc (d->depth, sizeof *stkalloc), *stk = stkalloc;

  position_set merged;          /* Result of merging sets.  */

  addtok (d, CAT);
  idx_t tindex = d->tindex;

#ifdef DEBUG
  fprintf (stderr, "dfaanalyze:\n");
  for (idx_t i = 0; i < tindex; i++)
    {
      fprintf (stderr, " %td:", i);
      prtok (d->tokens[i]);
    }
  putc ('\n', stderr);
#endif

  d->searchflag = searchflag;
  alloc_position_set (&merged, d->nleaves);
  d->follows = xicalloc (tindex, sizeof *d->follows);
  position_set *backward
    = d->epsilon ? xicalloc (tindex, sizeof *backward) : NULL;

  for (idx_t i = 0; i < tindex; i++)
    {
      switch (d->tokens[i])
        {
        case EMPTY:
          /* The empty set is nullable.  */
          stk->nullable = true;

          /* The firstpos and lastpos of the empty leaf are both empty.  */
          stk->nfirstpos = stk->nlastpos = 0;
          stk++;
          break;

        case STAR:
        case PLUS:
          /* Every element in the lastpos of the argument is in the backward
             set of every element in the firstpos.  */
          if (d->epsilon)
            {
              tmp.elems = lastpos - stk[-1].nlastpos;
              tmp.nelem = stk[-1].nlastpos;
              for (position *p = firstpos - stk[-1].nfirstpos;
                   p < firstpos; p++)
                merge2 (&backward[p->index], &tmp, &merged);
            }

          /* Every element in the firstpos of the argument is in the follow
             of every element in the lastpos.  */
          {
            tmp.elems = firstpos - stk[-1].nfirstpos;
            tmp.nelem = stk[-1].nfirstpos;
            for (position *p = lastpos - stk[-1].nlastpos; p < lastpos; p++)
              merge2 (&d->follows[p->index], &tmp, &merged);
          }
          FALLTHROUGH;
        case QMARK:
          /* A QMARK or STAR node is automatically nullable.  */
          if (d->tokens[i] != PLUS)
            stk[-1].nullable = true;
          break;

        case CAT:
          /* Every element in the lastpos of the first argument is in
             the backward set of every element in the firstpos of the
             second argument.  */
          if (backward)
            {
              tmp.nelem = stk[-2].nlastpos;
              tmp.elems = lastpos - stk[-1].nlastpos - stk[-2].nlastpos;
              for (position *p = firstpos - stk[-1].nfirstpos;
                   p < firstpos; p++)
                merge2 (&backward[p->index], &tmp, &merged);
            }

          /* Every element in the firstpos of the second argument is in the
             follow of every element in the lastpos of the first argument.  */
          {
            tmp.nelem = stk[-1].nfirstpos;
            tmp.elems = firstpos - stk[-1].nfirstpos;
            for (position *plim = lastpos - stk[-1].nlastpos,
                   *p = plim - stk[-2].nlastpos;
                 p < plim; p++)
              merge2 (&d->follows[p->index], &tmp, &merged);
          }

          /* The firstpos of a CAT node is the firstpos of the first argument,
             union that of the second argument if the first is nullable.  */
          if (stk[-2].nullable)
            stk[-2].nfirstpos += stk[-1].nfirstpos;
          else
            firstpos -= stk[-1].nfirstpos;

          /* The lastpos of a CAT node is the lastpos of the second argument,
             union that of the first argument if the second is nullable.  */
          if (stk[-1].nullable)
            stk[-2].nlastpos += stk[-1].nlastpos;
          else
            {
              position *p = lastpos - stk[-1].nlastpos - stk[-2].nlastpos;
              for (idx_t j = 0; j < stk[-1].nlastpos; j++)
                p[j] = p[j + stk[-2].nlastpos];
              lastpos -= stk[-2].nlastpos;
              stk[-2].nlastpos = stk[-1].nlastpos;
            }

          /* A CAT node is nullable if both arguments are nullable.  */
          stk[-2].nullable &= stk[-1].nullable;
          stk--;
          break;

        case OR:
          /* The firstpos is the union of the firstpos of each argument.  */
          stk[-2].nfirstpos += stk[-1].nfirstpos;

          /* The lastpos is the union of the lastpos of each argument.  */
          stk[-2].nlastpos += stk[-1].nlastpos;

          /* An OR node is nullable if either argument is nullable.  */
          stk[-2].nullable |= stk[-1].nullable;
          stk--;
          break;

        default:
          /* Anything else is a nonempty position.  (Note that special
             constructs like \< are treated as nonempty strings here;
             an "epsilon closure" effectively makes them nullable later.
             Backreferences have to get a real position so we can detect
             transitions on them later.  But they are nullable.  */
          stk->nullable = d->tokens[i] == BACKREF;

          /* This position is in its own firstpos and lastpos.  */
          stk->nfirstpos = stk->nlastpos = 1;
          stk++;

          firstpos->index = lastpos->index = i;
          firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
          firstpos++, lastpos++;

          break;
        }
#ifdef DEBUG
      /* ... balance the above nonsyntactic #ifdef goo...  */
      fprintf (stderr, "node %td:", i);
      prtok (d->tokens[i]);
      putc ('\n', stderr);
      fprintf (stderr,
               stk[-1].nullable ? " nullable: yes\n" : " nullable: no\n");
      fprintf (stderr, " firstpos:");
      for (idx_t j = 0; j < stk[-1].nfirstpos; j++)
        {
          fprintf (stderr, " %td:", firstpos[j - stk[-1].nfirstpos].index);
          prtok (d->tokens[firstpos[j - stk[-1].nfirstpos].index]);
        }
      fprintf (stderr, "\n lastpos:");
      for (idx_t j = 0; j < stk[-1].nlastpos; j++)
        {
          fprintf (stderr, " %td:", lastpos[j - stk[-1].nlastpos].index);
          prtok (d->tokens[lastpos[j - stk[-1].nlastpos].index]);
        }
      putc ('\n', stderr);
#endif
    }

  if (backward)
    {
      /* For each follow set that is the follow set of a real position,
         replace it with its epsilon closure.  */
      epsclosure (d, backward);

      for (idx_t i = 0; i < tindex; i++)
        free (backward[i].elems);
      free (backward);
    }

  dfaoptimize (d);

#ifdef DEBUG
  for (idx_t i = 0; i < tindex; i++)
    if (d->tokens[i] == BEG || d->tokens[i] < NOTCHAR
        || d->tokens[i] == BACKREF || d->tokens[i] == ANYCHAR
        || d->tokens[i] == MBCSET || d->tokens[i] >= CSET)
      {
        fprintf (stderr, "follows(%td:", i);
        prtok (d->tokens[i]);
        fprintf (stderr, "):");
        for (idx_t j = 0; j < d->follows[i].nelem; j++)
          {
            fprintf (stderr, " %td:", d->follows[i].elems[j].index);
            prtok (d->tokens[d->follows[i].elems[j].index]);
          }
        putc ('\n', stderr);
      }
#endif

  pos.index = 0;
  pos.constraint = NO_CONSTRAINT;

  alloc_position_set (&tmp, 1);

  append (pos, &tmp);

  d->separates = xicalloc (tindex, sizeof *d->separates);

  for (idx_t i = 0; i < tindex; i++)
    {
      if (prev_newline_dependent (d->constraints[i]))
        d->separates[i] |= CTX_NEWLINE;
      if (prev_letter_dependent (d->constraints[i]))
        d->separates[i] |= CTX_LETTER;

      for (idx_t j = 0; j < d->follows[i].nelem; j++)
        {
          if (prev_newline_dependent (d->follows[i].elems[j].constraint))
            d->separates[i] |= CTX_NEWLINE;
          if (prev_letter_dependent (d->follows[i].elems[j].constraint))
            d->separates[i] |= CTX_LETTER;
        }
    }

  /* Context wanted by some position.  */
  int separate_contexts = state_separate_contexts (d, &tmp);

  /* Build the initial state.  */
  if (separate_contexts & CTX_NEWLINE)
    state_index (d, &tmp, CTX_NEWLINE);
  d->initstate_notbol = d->min_trcount
    = state_index (d, &tmp, separate_contexts ^ CTX_ANY);
  if (separate_contexts & CTX_LETTER)
    d->min_trcount = state_index (d, &tmp, CTX_LETTER);
  d->min_trcount++;
  d->trcount = 0;

  free (posalloc);
  free (stkalloc);
  free (merged.elems);
  free (tmp.elems);
}

/* Make sure D's state arrays are large enough to hold NEW_STATE.  */
static void
realloc_trans_if_necessary (struct dfa *d)
{
  state_num oldalloc = d->tralloc;
  if (oldalloc < d->sindex)
    {
      state_num **realtrans = d->trans ? d->trans - 2 : NULL;
      idx_t newalloc1 = realtrans ? d->tralloc + 2 : 0;
      realtrans = xpalloc (realtrans, &newalloc1, d->sindex - oldalloc,
                           -1, sizeof *realtrans);
      realtrans[0] = realtrans[1] = NULL;
      d->trans = realtrans + 2;
      idx_t newalloc = d->tralloc = newalloc1 - 2;
      d->fails = xreallocarray (d->fails, newalloc, sizeof *d->fails);
      d->success = xreallocarray (d->success, newalloc, sizeof *d->success);
      d->newlines = xreallocarray (d->newlines, newalloc, sizeof *d->newlines);
      if (d->localeinfo.multibyte)
        {
          realtrans = d->mb_trans ? d->mb_trans - 2 : NULL;
          realtrans = xreallocarray (realtrans, newalloc1, sizeof *realtrans);
          if (oldalloc == 0)
            realtrans[0] = realtrans[1] = NULL;
          d->mb_trans = realtrans + 2;
        }
      for (; oldalloc < newalloc; oldalloc++)
        {
          d->trans[oldalloc] = NULL;
          d->fails[oldalloc] = NULL;
          if (d->localeinfo.multibyte)
            d->mb_trans[oldalloc] = NULL;
        }
    }
}

/*
   Calculate the transition table for a new state derived from state s
   for a compiled dfa d after input character uc, and return the new
   state number.

   Do not worry about all possible input characters; calculate just the group
   of positions that match uc.  Label it with the set of characters that
   every position in the group matches (taking into account, if necessary,
   preceding context information of s).  Then find the union
   of these positions' follows, i.e., the set of positions of the
   new state.  For each character in the group's label, set the transition
   on this character to be to a state corresponding to the set's positions,
   and its associated backward context information, if necessary.

   When building a searching matcher, include the positions of state
   0 in every state.

   The group is constructed by building an equivalence-class
   partition of the positions of s.

   For each position, find the set of characters C that it matches.  Eliminate
   any characters from C that fail on grounds of backward context.

   Check whether the group's label L has nonempty
   intersection with C.  If L - C is nonempty, create a new group labeled
   L - C and having the same positions as the current group, and set L to
   the intersection of L and C.  Insert the position in the group, set
   C = C - L, and resume scanning.

   If after comparing with every group there are characters remaining in C,
   create a new group labeled with the characters of C and insert this
   position in that group.  */

static state_num
build_state (state_num s, struct dfa *d, unsigned char uc)
{
  position_set follows;         /* Union of the follows for each
                                   position of the current state.  */
  position_set group;           /* Positions that match the input char.  */
  position_set tmp;             /* Temporary space for merging sets.  */
  state_num state;              /* New state.  */
  state_num state_newline;      /* New state on a newline transition.  */
  state_num state_letter;       /* New state on a letter transition.  */

#ifdef DEBUG
  fprintf (stderr, "build state %td\n", s);
#endif

  /* A pointer to the new transition table, and the table itself.  */
  state_num **ptrans = (accepting (s, d) ? d->fails : d->trans) + s;
  state_num *trans = *ptrans;

  if (!trans)
    {
      /* MAX_TRCOUNT is an arbitrary upper limit on the number of
         transition tables that can exist at once, other than for
         initial states.  Often-used transition tables are quickly
         rebuilt, whereas rarely-used ones are cleared away.  */
      if (MAX_TRCOUNT <= d->trcount)
        {
          for (state_num i = d->min_trcount; i < d->tralloc; i++)
            {
              free (d->trans[i]);
              free (d->fails[i]);
              d->trans[i] = d->fails[i] = NULL;
            }
          d->trcount = 0;
        }

      d->trcount++;
      *ptrans = trans = xmalloc (NOTCHAR * sizeof *trans);

      /* Fill transition table with a default value which means that the
         transited state has not been calculated yet.  */
      for (int i = 0; i < NOTCHAR; i++)
        trans[i] = -2;
    }

  /* Set up the success bits for this state.  */
  d->success[s] = 0;
  if (accepts_in_context (d->states[s].context, CTX_NEWLINE, s, d))
    d->success[s] |= CTX_NEWLINE;
  if (accepts_in_context (d->states[s].context, CTX_LETTER, s, d))
    d->success[s] |= CTX_LETTER;
  if (accepts_in_context (d->states[s].context, CTX_NONE, s, d))
    d->success[s] |= CTX_NONE;

  alloc_position_set (&follows, d->nleaves);

  /* Find the union of the follows of the positions of the group.
     This is a hideously inefficient loop.  Fix it someday.  */
  for (idx_t j = 0; j < d->states[s].elems.nelem; j++)
    for (idx_t k = 0;
         k < d->follows[d->states[s].elems.elems[j].index].nelem; ++k)
      insert (d->follows[d->states[s].elems.elems[j].index].elems[k],
              &follows);

  /* Positions that match the input char.  */
  alloc_position_set (&group, d->nleaves);

  /* The group's label.  */
  charclass label;
  fillset (&label);

  for (idx_t i = 0; i < follows.nelem; i++)
    {
      charclass matches;            /* Set of matching characters.  */
      position pos = follows.elems[i];
      bool matched = false;
      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
        {
          zeroset (&matches);
          setbit (d->tokens[pos.index], &matches);
          if (d->tokens[pos.index] == uc)
            matched = true;
        }
      else if (d->tokens[pos.index] >= CSET)
        {
          matches = d->charclasses[d->tokens[pos.index] - CSET];
          if (tstbit (uc, &matches))
            matched = true;
        }
      else if (d->tokens[pos.index] == ANYCHAR)
        {
          matches = d->charclasses[d->canychar];
          if (tstbit (uc, &matches))
            matched = true;

          /* ANYCHAR must match with a single character, so we must put
             it to D->states[s].mbps which contains the positions which
             can match with a single character not a byte.  If all
             positions which has ANYCHAR does not depend on context of
             next character, we put the follows instead of it to
             D->states[s].mbps to optimize.  */
          if (succeeds_in_context (pos.constraint, d->states[s].context,
                                   CTX_NONE))
            {
              if (d->states[s].mbps.nelem == 0)
                alloc_position_set (&d->states[s].mbps, 1);
              insert (pos, &d->states[s].mbps);
            }
        }
      else
        continue;

      /* Some characters may need to be eliminated from matches because
         they fail in the current context.  */
      if (pos.constraint != NO_CONSTRAINT)
        {
          if (!succeeds_in_context (pos.constraint,
                                    d->states[s].context, CTX_NEWLINE))
            for (int j = 0; j < CHARCLASS_WORDS; j++)
              matches.w[j] &= ~d->syntax.newline.w[j];
          if (!succeeds_in_context (pos.constraint,
                                    d->states[s].context, CTX_LETTER))
            for (int j = 0; j < CHARCLASS_WORDS; ++j)
              matches.w[j] &= ~d->syntax.letters.w[j];
          if (!succeeds_in_context (pos.constraint,
                                    d->states[s].context, CTX_NONE))
            for (int j = 0; j < CHARCLASS_WORDS; ++j)
              matches.w[j] &= d->syntax.letters.w[j] | d->syntax.newline.w[j];

          /* If there are no characters left, there's no point in going on.  */
          if (emptyset (&matches))
            continue;

          /* If we have reset the bit that made us declare "matched", reset
             that indicator, too.  This is required to avoid an infinite loop
             with this command: echo cx | LC_ALL=C grep -E 'c\b[x ]'  */
          if (!tstbit (uc, &matches))
            matched = false;
        }

#ifdef DEBUG
      fprintf (stderr, " nextpos %td:", pos.index);
      prtok (d->tokens[pos.index]);
      fprintf (stderr, " of");
      for (unsigned j = 0; j < NOTCHAR; j++)
        if (tstbit (j, &matches))
          fprintf (stderr, " 0x%02x", j);
      fprintf (stderr, "\n");
#endif

      if (matched)
        {
          for (int k = 0; k < CHARCLASS_WORDS; ++k)
            label.w[k] &= matches.w[k];
          append (pos, &group);
        }
      else
        {
          for (int k = 0; k < CHARCLASS_WORDS; ++k)
            label.w[k] &= ~matches.w[k];
        }
    }

  alloc_position_set (&tmp, d->nleaves);

  if (group.nelem > 0)
    {
      /* If we are building a searching matcher, throw in the positions
         of state 0 as well, if possible.  */
      if (d->searchflag)
        {
          /* If a token in follows.elems is not 1st byte of a multibyte
             character, or the states of follows must accept the bytes
             which are not 1st byte of the multibyte character.
             Then, if a state of follows encounters a byte, it must not be
             a 1st byte of a multibyte character nor a single byte character.
             In this case, do not add state[0].follows to next state, because
             state[0] must accept 1st-byte.

             For example, suppose <sb a> is a certain single byte character,
             <mb A> is a certain multibyte character, and the codepoint of
             <sb a> equals the 2nd byte of the codepoint of <mb A>.  When
             state[0] accepts <sb a>, state[i] transits to state[i+1] by
             accepting the 1st byte of <mb A>, and state[i+1] accepts the
             2nd byte of <mb A>, if state[i+1] encounters the codepoint of
             <sb a>, it must not be <sb a> but the 2nd byte of <mb A>, so do
             not add state[0].  */

          bool mergeit = !d->localeinfo.multibyte;
          if (!mergeit)
            {
              mergeit = true;
              for (idx_t j = 0; mergeit && j < group.nelem; j++)
                mergeit &= d->multibyte_prop[group.elems[j].index];
            }
          if (mergeit)
            merge2 (&group, &d->states[0].elems, &tmp);
        }

      /* Find out if the new state will want any context information,
         by calculating possible contexts that the group can match,
         and separate contexts that the new state wants to know.  */
      int possible_contexts = charclass_context (d, &label);
      int separate_contexts = state_separate_contexts (d, &group);

      /* Find the state(s) corresponding to the union of the follows.  */
      if (possible_contexts & ~separate_contexts)
        state = state_index (d, &group, separate_contexts ^ CTX_ANY);
      else
        state = -1;
      if (separate_contexts & possible_contexts & CTX_NEWLINE)
        state_newline = state_index (d, &group, CTX_NEWLINE);
      else
        state_newline = state;
      if (separate_contexts & possible_contexts & CTX_LETTER)
        state_letter = state_index (d, &group, CTX_LETTER);
      else
        state_letter = state;

      /* Reallocate now, to reallocate any newline transition properly.  */
      realloc_trans_if_necessary (d);
    }

  /* If we are a searching matcher, the default transition is to a state
     containing the positions of state 0, otherwise the default transition
     is to fail miserably.  */
  else if (d->searchflag)
    {
      state_newline = 0;
      state_letter = d->min_trcount - 1;
      state = d->initstate_notbol;
    }
  else
    {
      state_newline = -1;
      state_letter = -1;
      state = -1;
    }

  /* Set the transitions for each character in the label.  */
  for (int i = 0; i < NOTCHAR; i++)
    if (tstbit (i, &label))
      switch (d->syntax.sbit[i])
        {
        case CTX_NEWLINE:
          trans[i] = state_newline;
          break;
        case CTX_LETTER:
          trans[i] = state_letter;
          break;
        default:
          trans[i] = state;
          break;
        }

#ifdef DEBUG
  fprintf (stderr, "trans table %td", s);
  for (int i = 0; i < NOTCHAR; ++i)
    {
      if (!(i & 0xf))
        fprintf (stderr, "\n");
      fprintf (stderr, " %2td", trans[i]);
    }
  fprintf (stderr, "\n");
#endif

  free (group.elems);
  free (follows.elems);
  free (tmp.elems);

  /* Keep the newline transition in a special place so we can use it as
     a sentinel.  */
  if (tstbit (d->syntax.eolbyte, &label))
    {
      d->newlines[s] = trans[d->syntax.eolbyte];
      trans[d->syntax.eolbyte] = -1;
    }

  return trans[uc];
}

/* Multibyte character handling sub-routines for dfaexec.  */

/* Consume a single byte and transit state from 's' to '*next_state'.
   This is almost the same as the state transition routine in dfaexec.
   But the state transition is done just once; otherwise, matching succeeds or
   we reach the end of the buffer.  */
static state_num
transit_state_singlebyte (struct dfa *d, state_num s, unsigned char const **pp)
{
  state_num *t;

  if (d->trans[s])
    t = d->trans[s];
  else if (d->fails[s])
    t = d->fails[s];
  else
    {
      build_state (s, d, **pp);
      if (d->trans[s])
        t = d->trans[s];
      else
        {
          t = d->fails[s];
          assert (t);
        }
    }

  if (t[**pp] == -2)
    build_state (s, d, **pp);

  return t[*(*pp)++];
}

/* Transit state from s, then return new state and update the pointer of
   the buffer.  This function is for a period operator which can match a
   multi-byte character.  */
static state_num
transit_state (struct dfa *d, state_num s, unsigned char const **pp,
               unsigned char const *end)
{
  wint_t wc;

  int mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);

  /* This state has some operators which can match a multibyte character.  */
  d->mb_follows.nelem = 0;

  /* Calculate the state which can be reached from the state 's' by
     consuming 'mbclen' single bytes from the buffer.  */
  state_num s1 = s;
  int mbci;
  for (mbci = 0; mbci < mbclen && (mbci == 0 || d->min_trcount <= s); mbci++)
    s = transit_state_singlebyte (d, s, pp);
  *pp += mbclen - mbci;

  if (wc == WEOF)
    {
      /* It is an invalid character, so ANYCHAR is not accepted.  */
      return s;
    }

  /* If all positions which have ANYCHAR do not depend on the context
     of the next character, calculate the next state with
     pre-calculated follows and cache the result.  */
  if (d->states[s1].mb_trindex < 0)
    {
      if (MAX_TRCOUNT <= d->mb_trcount)
        {
          state_num s3;
          for (s3 = -1; s3 < d->tralloc; s3++)
            {
              free (d->mb_trans[s3]);
              d->mb_trans[s3] = NULL;
            }

          for (state_num i = 0; i < d->sindex; i++)
            d->states[i].mb_trindex = -1;
          d->mb_trcount = 0;
        }
      d->states[s1].mb_trindex = d->mb_trcount++;
    }

  if (! d->mb_trans[s])
    {
      enum { TRANSPTR_SIZE = sizeof *d->mb_trans[s] };
      enum { TRANSALLOC_SIZE = MAX_TRCOUNT * TRANSPTR_SIZE };
      d->mb_trans[s] = xmalloc (TRANSALLOC_SIZE);
      for (int i = 0; i < MAX_TRCOUNT; i++)
        d->mb_trans[s][i] = -1;
    }
  else if (d->mb_trans[s][d->states[s1].mb_trindex] >= 0)
    return d->mb_trans[s][d->states[s1].mb_trindex];

  if (s == -1)
    copy (&d->states[s1].mbps, &d->mb_follows);
  else
    merge (&d->states[s1].mbps, &d->states[s].elems, &d->mb_follows);

  int separate_contexts = state_separate_contexts (d, &d->mb_follows);
  state_num s2 = state_index (d, &d->mb_follows, separate_contexts ^ CTX_ANY);
  realloc_trans_if_necessary (d);

  d->mb_trans[s][d->states[s1].mb_trindex] = s2;

  return s2;
}

/* The initial state may encounter a byte which is not a single byte character
   nor the first byte of a multibyte character.  But it is incorrect for the
   initial state to accept such a byte.  For example, in Shift JIS the regular
   expression "\\" accepts the codepoint 0x5c, but should not accept the second
   byte of the codepoint 0x815c.  Then the initial state must skip the bytes
   that are not a single byte character nor the first byte of a multibyte
   character.

   Given DFA state d, use mbs_to_wchar to advance MBP until it reaches
   or exceeds P, and return the advanced MBP.  If WCP is non-NULL and
   the result is greater than P, set *WCP to the final wide character
   processed, or to WEOF if no wide character is processed.  Otherwise,
   if WCP is non-NULL, *WCP may or may not be updated.

   Both P and MBP must be no larger than END.  */
static unsigned char const *
skip_remains_mb (struct dfa *d, unsigned char const *p,
                 unsigned char const *mbp, char const *end)
{
  if (d->syntax.never_trail[*p])
    return p;
  while (mbp < p)
    {
      wint_t wc;
      mbp += mbs_to_wchar (&wc, (char const *) mbp,
                           end - (char const *) mbp, d);
    }
  return mbp;
}

/* Search through a buffer looking for a match to the struct dfa *D.
   Find the first occurrence of a string matching the regexp in the
   buffer, and the shortest possible version thereof.  Return a pointer to
   the first character after the match, or NULL if none is found.  BEGIN
   points to the beginning of the buffer, and END points to the first byte
   after its end.  Note however that we store a sentinel byte (usually
   newline) in *END, so the actual buffer must be one byte longer.
   When ALLOW_NL, newlines may appear in the matching string.
   If COUNT is non-NULL, increment *COUNT once for each newline processed.
   If MULTIBYTE, the input consists of multibyte characters and/or
   encoding-error bytes.  Otherwise, it consists of single-byte characters.
   Here is the list of features that make this DFA matcher punt:
    - [M-N] range in non-simple locale: regex is up to 25% faster on [a-z]
    - [^...] in non-simple locale
    - [[=foo=]] or [[.foo.]]
    - [[:alpha:]] etc. in multibyte locale (except [[:digit:]] works OK)
    - back-reference: (.)\1
    - word-delimiter in multibyte locale: \<, \>, \b, \B
   See struct localeinfo.simple for the definition of "simple locale".  */

static inline char *
dfaexec_main (struct dfa *d, char const *begin, char *end, bool allow_nl,
              idx_t *count, bool multibyte)
{
  if (MAX_TRCOUNT <= d->sindex)
    {
      for (state_num s = d->min_trcount; s < d->sindex; s++)
        {
          free (d->states[s].elems.elems);
          free (d->states[s].mbps.elems);
        }
      d->sindex = d->min_trcount;

      if (d->trans)
        {
          for (state_num s = 0; s < d->tralloc; s++)
            {
              free (d->trans[s]);
              free (d->fails[s]);
              d->trans[s] = d->fails[s] = NULL;
            }
          d->trcount = 0;
        }

      if (d->localeinfo.multibyte && d->mb_trans)
        {
          for (state_num s = -1; s < d->tralloc; s++)
            {
              free (d->mb_trans[s]);
              d->mb_trans[s] = NULL;
            }
          for (state_num s = 0; s < d->min_trcount; s++)
            d->states[s].mb_trindex = -1;
          d->mb_trcount = 0;
        }
    }

  if (!d->tralloc)
    realloc_trans_if_necessary (d);

  /* Current state.  */
  state_num s = 0, s1 = 0;

  /* Current input character.  */
  unsigned char const *p = (unsigned char const *) begin;
  unsigned char const *mbp = p;

  /* Copy of d->trans so it can be optimized into a register.  */
  state_num **trans = d->trans;
  unsigned char eol = d->syntax.eolbyte;  /* Likewise for eolbyte.  */
  unsigned char saved_end = *(unsigned char *) end;
  *end = eol;

  if (multibyte)
    {
      mbszero (&d->mbs);
      if (d->mb_follows.alloc == 0)
        alloc_position_set (&d->mb_follows, d->nleaves);
    }

  idx_t nlcount = 0;
  for (;;)
    {
      state_num *t;
      while ((t = trans[s]) != NULL)
        {
          if (s < d->min_trcount)
            {
              if (!multibyte || d->states[s].mbps.nelem == 0)
                {
                  while (t[*p] == s)
                    p++;
                }
              if (multibyte)
                p = mbp = skip_remains_mb (d, p, mbp, end);
            }

          if (multibyte)
            {
              s1 = s;

              if (d->states[s].mbps.nelem == 0
                  || d->localeinfo.sbctowc[*p] != WEOF || (char *) p >= end)
                {
                  /* If an input character does not match ANYCHAR, do it
                     like a single-byte character.  */
                  s = t[*p++];
                }
              else
                {
                  s = transit_state (d, s, &p, (unsigned char *) end);
                  mbp = p;
                  trans = d->trans;
                }
            }
          else
            {
              s1 = t[*p++];
              t = trans[s1];
              if (! t)
                {
                  state_num tmp = s;
                  s = s1;
                  s1 = tmp;     /* swap */
                  break;
                }
              if (s < d->min_trcount)
                {
                  while (t[*p] == s1)
                    p++;
                }
              s = t[*p++];
            }
        }

      if (s < 0)
        {
          if (s == -2)
            {
              s = build_state (s1, d, p[-1]);
              trans = d->trans;
            }
          else if ((char *) p <= end && p[-1] == eol && 0 <= d->newlines[s1])
            {
              /* The previous character was a newline.  Count it, and skip
                 checking of multibyte character boundary until here.  */
              nlcount++;
              mbp = p;

              s = (allow_nl ? d->newlines[s1]
                   : d->syntax.sbit[eol] == CTX_NEWLINE ? 0
                   : d->syntax.sbit[eol] == CTX_LETTER ? d->min_trcount - 1
                   : d->initstate_notbol);
            }
          else
            {
              p = NULL;
              goto done;
            }
        }
      else if (d->fails[s])
        {
          if ((d->success[s] & d->syntax.sbit[*p])
              || ((char *) p == end
                  && accepts_in_context (d->states[s].context, CTX_NEWLINE, s,
                                         d)))
            goto done;

          if (multibyte && s < d->min_trcount)
            p = mbp = skip_remains_mb (d, p, mbp, end);

          s1 = s;
          if (!multibyte || d->states[s].mbps.nelem == 0
              || d->localeinfo.sbctowc[*p] != WEOF || (char *) p >= end)
            {
              /* If a input character does not match ANYCHAR, do it
                 like a single-byte character.  */
              s = d->fails[s][*p++];
            }
          else
            {
              s = transit_state (d, s, &p, (unsigned char *) end);
              mbp = p;
              trans = d->trans;
            }
        }
      else
        {
          build_state (s, d, p[0]);
          trans = d->trans;
        }
    }

 done:
  if (count)
    *count += nlcount;
  *end = saved_end;
  return (char *) p;
}

/* Specialized versions of dfaexec for multibyte and single-byte cases.
   This is for performance, as dfaexec_main is an inline function.  */

static char *
dfaexec_mb (struct dfa *d, char const *begin, char *end,
            bool allow_nl, idx_t *count, bool *backref)
{
  return dfaexec_main (d, begin, end, allow_nl, count, true);
}

static char *
dfaexec_sb (struct dfa *d, char const *begin, char *end,
            bool allow_nl, idx_t *count, bool *backref)
{
  return dfaexec_main (d, begin, end, allow_nl, count, false);
}

/* Always set *BACKREF and return BEGIN.  Use this wrapper for
   any regexp that uses a construct not supported by this code.  */
static char *
dfaexec_noop (struct dfa *d, char const *begin, char *end,
              bool allow_nl, idx_t *count, bool *backref)
{
  *backref = true;
  return (char *) begin;
}

/* Like dfaexec_main (D, BEGIN, END, ALLOW_NL, COUNT, D->localeinfo.multibyte),
   but faster and set *BACKREF if the DFA code does not support this
   regexp usage.  */

char *
dfaexec (struct dfa *d, char const *begin, char *end,
         bool allow_nl, idx_t *count, bool *backref)
{
  return d->dfaexec (d, begin, end, allow_nl, count, backref);
}

struct dfa *
dfasuperset (struct dfa const *d)
{
  return d->superset;
}

bool
dfaisfast (struct dfa const *d)
{
  return d->fast;
}

static void
free_mbdata (struct dfa *d)
{
  free (d->multibyte_prop);
  free (d->lex.brack.chars);
  free (d->mb_follows.elems);

  if (d->mb_trans)
    {
      state_num s;
      for (s = -1; s < d->tralloc; s++)
        free (d->mb_trans[s]);
      free (d->mb_trans - 2);
    }
}

/* Return true if every construct in D is supported by this DFA matcher.  */
bool
dfasupported (struct dfa const *d)
{
  for (idx_t i = 0; i < d->tindex; i++)
    {
      switch (d->tokens[i])
        {
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
          if (!d->localeinfo.multibyte)
            continue;
          FALLTHROUGH;
        case BACKREF:
        case MBCSET:
          return false;
        }
    }
  return true;
}

/* Disable use of the superset DFA if it is not likely to help
   performance.  */
static void
maybe_disable_superset_dfa (struct dfa *d)
{
  if (!d->localeinfo.using_utf8)
    return;

  bool have_backref = false;
  for (idx_t i = 0; i < d->tindex; i++)
    {
      switch (d->tokens[i])
        {
        case ANYCHAR:
          /* Lowered.  */
          abort ();
        case BACKREF:
          have_backref = true;
          break;
        case MBCSET:
          /* Requires multi-byte algorithm.  */
          return;
        default:
          break;
        }
    }

  if (!have_backref && d->superset)
    {
      /* The superset DFA is not likely to be much faster, so remove it.  */
      dfafree (d->superset);
      free (d->superset);
      d->superset = NULL;
    }

  free_mbdata (d);
  d->localeinfo.multibyte = false;
  d->dfaexec = dfaexec_sb;
  d->fast = true;
}

static void
dfassbuild (struct dfa *d)
{
  struct dfa *sup = dfaalloc ();

  *sup = *d;
  sup->localeinfo.multibyte = false;
  sup->dfaexec = dfaexec_sb;
  sup->multibyte_prop = NULL;
  sup->superset = NULL;
  sup->states = NULL;
  sup->sindex = 0;
  sup->constraints = NULL;
  sup->separates = NULL;
  sup->follows = NULL;
  sup->tralloc = 0;
  sup->trans = NULL;
  sup->fails = NULL;
  sup->success = NULL;
  sup->newlines = NULL;

  sup->charclasses = xnmalloc (sup->calloc, sizeof *sup->charclasses);
  if (d->cindex)
    {
      memcpy (sup->charclasses, d->charclasses,
              d->cindex * sizeof *sup->charclasses);
    }

  sup->tokens = xnmalloc (d->tindex, 2 * sizeof *sup->tokens);
  sup->talloc = d->tindex * 2;

  bool have_achar = false;
  bool have_nchar = false;
  idx_t j;
  for (idx_t i = j = 0; i < d->tindex; i++)
    {
      switch (d->tokens[i])
        {
        case ANYCHAR:
        case MBCSET:
        case BACKREF:
          {
            charclass ccl;
            fillset (&ccl);
            sup->tokens[j++] = CSET + charclass_index (sup, &ccl);
            sup->tokens[j++] = STAR;
            if (d->tokens[i + 1] == QMARK || d->tokens[i + 1] == STAR
                || d->tokens[i + 1] == PLUS)
              i++;
            have_achar = true;
          }
          break;
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
          if (d->localeinfo.multibyte)
            {
              /* These constraints aren't supported in a multibyte locale.
                 Ignore them in the superset DFA.  */
              sup->tokens[j++] = EMPTY;
              break;
            }
          FALLTHROUGH;
        default:
          sup->tokens[j++] = d->tokens[i];
          if ((0 <= d->tokens[i] && d->tokens[i] < NOTCHAR)
              || d->tokens[i] >= CSET)
            have_nchar = true;
          break;
        }
    }
  sup->tindex = j;

  if (have_nchar && (have_achar || d->localeinfo.multibyte))
    d->superset = sup;
  else
    {
      dfafree (sup);
      free (sup);
    }
}

/* Parse a string S of length LEN into D (but skip this step if S is null).
   Then analyze D and build a matcher for it.
   SEARCHFLAG says whether to build a searching or an exact matcher.  */
void
dfacomp (char const *s, idx_t len, struct dfa *d, bool searchflag)
{
  if (s != NULL)
    dfaparse (s, len, d);

  dfassbuild (d);

  if (dfasupported (d))
    {
      maybe_disable_superset_dfa (d);
      dfaanalyze (d, searchflag);
    }
  else
    {
      d->dfaexec = dfaexec_noop;
    }

  if (d->superset)
    {
      d->fast = true;
      dfaanalyze (d->superset, searchflag);
    }
}

/* Free the storage held by the components of a dfa.  */
void
dfafree (struct dfa *d)
{
  free (d->charclasses);
  free (d->tokens);

  if (d->localeinfo.multibyte)
    free_mbdata (d);

  free (d->constraints);
  free (d->separates);

  for (idx_t i = 0; i < d->sindex; i++)
    {
      free (d->states[i].elems.elems);
      free (d->states[i].mbps.elems);
    }
  free (d->states);

  if (d->follows)
    {
      for (idx_t i = 0; i < d->tindex; i++)
        free (d->follows[i].elems);
      free (d->follows);
    }

  if (d->trans)
    {
      for (idx_t i = 0; i < d->tralloc; i++)
        {
          free (d->trans[i]);
          free (d->fails[i]);
        }

      free (d->trans - 2);
      free (d->fails);
      free (d->newlines);
      free (d->success);
    }

  if (d->superset)
    {
      dfafree (d->superset);
      free (d->superset);
    }
}

/* Having found the postfix representation of the regular expression,
   try to find a long sequence of characters that must appear in any line
   containing the r.e.
   Finding a "longest" sequence is beyond the scope here;
   we take an easy way out and hope for the best.
   (Take "(ab|a)b"--please.)

   We do a bottom-up calculation of sequences of characters that must appear
   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
   representation:
        sequences that must appear at the left of the match ("left")
        sequences that must appear at the right of the match ("right")
        lists of sequences that must appear somewhere in the match ("in")
        sequences that must constitute the match ("is")

   When we get to the root of the tree, we use one of the longest of its
   calculated "in" sequences as our answer.

   The sequences calculated for the various types of node (in pseudo ANSI c)
   are shown below.  "p" is the operand of unary operators (and the left-hand
   operand of binary operators); "q" is the right-hand operand of binary
   operators.

   "ZERO" means "a zero-length sequence" below.

        Type	left		right		is		in
        ----	----		-----		--		--
        char c	# c		# c		# c		# c

        ANYCHAR	ZERO		ZERO		ZERO		ZERO

        MBCSET	ZERO		ZERO		ZERO		ZERO

        CSET	ZERO		ZERO		ZERO		ZERO

        STAR	ZERO		ZERO		ZERO		ZERO

        QMARK	ZERO		ZERO		ZERO		ZERO

        PLUS	p->left		p->right	ZERO		p->in

        CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
                p->left :	q->right :	q->is!=ZERO) ?	q->in plus
                p->is##q->left	p->right##q->is	p->is##q->is : p->right##q->left
                                                ZERO

        OR	longest common	longest common	(do p->is and substrings common
                leading		trailing	to q->is have same p->in and
                (sub)sequence	(sub)sequence	q->in length and content) ?
                of p->left	of p->right
                and q->left	and q->right	p->is : NULL

   If there's anything else we recognize in the tree, all four sequences get set
   to zero-length sequences.  If there's something we don't recognize in the
   tree, we just return a zero-length sequence.

   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
   'aaa')?

   And ... is it here or someplace that we might ponder "optimizations" such as
        egrep 'psi|epsilon'	->	egrep 'psi'
        egrep 'pepsi|epsilon'	->	egrep 'epsi'
                                        (Yes, we now find "epsi" as a "string
                                        that must occur", but we might also
                                        simplify the *entire* r.e. being sought)
        grep '[c]'		->	grep 'c'
        grep '(ab|a)b'		->	grep 'ab'
        grep 'ab*'		->	grep 'a'
        grep 'a*b'		->	grep 'b'

   There are several issues:

   Is optimization easy (enough)?

   Does optimization actually accomplish anything,
   or is the automaton you get from "psi|epsilon" (for example)
   the same as the one you get from "psi" (for example)?

   Are optimizable r.e.'s likely to be used in real-life situations
   (something like 'ab*' is probably unlikely; something like is
   'psi|epsilon' is likelier)?  */

static char *
icatalloc (char *old, char const *new)
{
  idx_t newsize = strlen (new);
  if (newsize == 0)
    return old;
  idx_t oldsize = strlen (old);
  char *result = xirealloc (old, oldsize + newsize + 1);
  memcpy (result + oldsize, new, newsize + 1);
  return result;
}

static void
freelist (char **cpp)
{
  while (*cpp)
    free (*cpp++);
}

static char **
enlistnew (char **cpp, char *new)
{
  /* Is there already something in the list that's new (or longer)?  */
  idx_t i;
  for (i = 0; cpp[i] != NULL; i++)
    if (strstr (cpp[i], new) != NULL)
      {
        free (new);
        return cpp;
      }
  /* Eliminate any obsoleted strings.  */
  for (idx_t j = 0; cpp[j] != NULL; )
    if (strstr (new, cpp[j]) == NULL)
      ++j;
    else
      {
        free (cpp[j]);
        if (--i == j)
          break;
        cpp[j] = cpp[i];
        cpp[i] = NULL;
      }
  /* Add the new string.  */
  cpp = xreallocarray (cpp, i + 2, sizeof *cpp);
  cpp[i] = new;
  cpp[i + 1] = NULL;
  return cpp;
}

static char **
enlist (char **cpp, char const *str, idx_t len)
{
  return enlistnew (cpp, ximemdup0 (str, len));
}

/* Given pointers to two strings, return a pointer to an allocated
   list of their distinct common substrings.  */
static char **
comsubs (char *left, char const *right)
{
  char **cpp = xzalloc (sizeof *cpp);

  for (char *lcp = left; *lcp != '\0'; lcp++)
    {
      idx_t len = 0;
      char *rcp = strchr (right, *lcp);
      while (rcp != NULL)
        {
          idx_t i;
          for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
            continue;
          if (i > len)
            len = i;
          rcp = strchr (rcp + 1, *lcp);
        }
      if (len != 0)
        cpp = enlist (cpp, lcp, len);
    }
  return cpp;
}

static char **
addlists (char **old, char **new)
{
  for (; *new; new++)
    old = enlistnew (old, xstrdup (*new));
  return old;
}

/* Given two lists of substrings, return a new list giving substrings
   common to both.  */
static char **
inboth (char **left, char **right)
{
  char **both = xzalloc (sizeof *both);

  for (idx_t lnum = 0; left[lnum] != NULL; lnum++)
    {
      for (idx_t rnum = 0; right[rnum] != NULL; rnum++)
        {
          char **temp = comsubs (left[lnum], right[rnum]);
          both = addlists (both, temp);
          freelist (temp);
          free (temp);
        }
    }
  return both;
}

typedef struct must must;

struct must
{
  char **in;
  char *left;
  char *right;
  char *is;
  bool begline;
  bool endline;
  must *prev;
};

static must *
allocmust (must *mp, idx_t size)
{
  must *new_mp = xmalloc (sizeof *new_mp);
  new_mp->in = xzalloc (sizeof *new_mp->in);
  new_mp->left = xizalloc (size);
  new_mp->right = xizalloc (size);
  new_mp->is = xizalloc (size);
  new_mp->begline = false;
  new_mp->endline = false;
  new_mp->prev = mp;
  return new_mp;
}

static void
resetmust (must *mp)
{
  freelist (mp->in);
  mp->in[0] = NULL;
  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
  mp->begline = false;
  mp->endline = false;
}

static void
freemust (must *mp)
{
  freelist (mp->in);
  free (mp->in);
  free (mp->left);
  free (mp->right);
  free (mp->is);
  free (mp);
}

struct dfamust *
dfamust (struct dfa const *d)
{
  must *mp = NULL;
  char const *result = "";
  bool exact = false;
  bool begline = false;
  bool endline = false;
  bool need_begline = false;
  bool need_endline = false;
  bool case_fold_unibyte = d->syntax.case_fold & !d->localeinfo.multibyte;

  for (idx_t ri = 1; ri + 1 < d->tindex; ri++)
    {
      token t = d->tokens[ri];
      switch (t)
        {
        case BEGLINE:
          mp = allocmust (mp, 2);
          mp->begline = true;
          need_begline = true;
          break;
        case ENDLINE:
          mp = allocmust (mp, 2);
          mp->endline = true;
          need_endline = true;
          break;
        case LPAREN:
        case RPAREN:
          assert (!"neither LPAREN nor RPAREN may appear here");

        case EMPTY:
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
        case BACKREF:
        case ANYCHAR:
        case MBCSET:
          mp = allocmust (mp, 2);
          break;

        case STAR:
        case QMARK:
          assume_nonnull (mp);
          resetmust (mp);
          break;

        case OR:
          {
            char **new;
            must *rmp = mp;
            assume_nonnull (rmp);
            must *lmp = mp = mp->prev;
            assume_nonnull (lmp);
            idx_t j, ln, rn, n;

            /* Guaranteed to be.  Unlikely, but ...  */
            if (str_eq (lmp->is, rmp->is))
              {
                lmp->begline &= rmp->begline;
                lmp->endline &= rmp->endline;
              }
            else
              {
                lmp->is[0] = '\0';
                lmp->begline = false;
                lmp->endline = false;
              }
            /* Left side--easy */
            idx_t i = 0;
            while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
              ++i;
            lmp->left[i] = '\0';
            /* Right side */
            ln = strlen (lmp->right);
            rn = strlen (rmp->right);
            n = ln;
            if (n > rn)
              n = rn;
            for (i = 0; i < n; ++i)
              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
                break;
            for (j = 0; j < i; ++j)
              lmp->right[j] = lmp->right[(ln - i) + j];
            lmp->right[j] = '\0';
            new = inboth (lmp->in, rmp->in);
            freelist (lmp->in);
            free (lmp->in);
            lmp->in = new;
            freemust (rmp);
          }
          break;

        case PLUS:
          assume_nonnull (mp);
          mp->is[0] = '\0';
          break;

        case END:
          assume_nonnull (mp);
          assert (!mp->prev);
          for (idx_t i = 0; mp->in[i] != NULL; i++)
            if (strlen (mp->in[i]) > strlen (result))
              result = mp->in[i];
          if (str_eq (result, mp->is))
            {
              if ((!need_begline || mp->begline) && (!need_endline
                                                     || mp->endline))
                exact = true;
              begline = mp->begline;
              endline = mp->endline;
            }
          goto done;

        case CAT:
          {
            must *rmp = mp;
            assume_nonnull (rmp);
            must *lmp = mp = mp->prev;
            assume_nonnull (lmp);

            /* In.  Everything in left, plus everything in
               right, plus concatenation of
               left's right and right's left.  */
            lmp->in = addlists (lmp->in, rmp->in);
            if (lmp->right[0] != '\0' && rmp->left[0] != '\0')
              {
                idx_t lrlen = strlen (lmp->right);
                idx_t rllen = strlen (rmp->left);
                char *tp = ximalloc (lrlen + rllen + 1);
                memcpy (tp + lrlen, rmp->left, rllen + 1);
                memcpy (tp, lmp->right, lrlen);
                lmp->in = enlistnew (lmp->in, tp);
              }
            /* Left-hand */
            if (lmp->is[0] != '\0')
              lmp->left = icatalloc (lmp->left, rmp->left);
            /* Right-hand */
            if (rmp->is[0] == '\0')
              lmp->right[0] = '\0';
            lmp->right = icatalloc (lmp->right, rmp->right);
            /* Guaranteed to be */
            if ((lmp->is[0] != '\0' || lmp->begline)
                && (rmp->is[0] != '\0' || rmp->endline))
              {
                lmp->is = icatalloc (lmp->is, rmp->is);
                lmp->endline = rmp->endline;
              }
            else
              {
                lmp->is[0] = '\0';
                lmp->begline = false;
                lmp->endline = false;
              }
            freemust (rmp);
          }
          break;

        case '\0':
          /* Not on *my* shift.  */
          goto done;

        default:
          if (CSET <= t)
            {
              /* If T is a singleton, or if case-folding in a unibyte
                 locale and T's members all case-fold to the same char,
                 convert T to one of its members.  Otherwise, do
                 nothing further with T.  */
              charclass *ccl = &d->charclasses[t - CSET];
              int j;
              for (j = 0; j < NOTCHAR; j++)
                if (tstbit (j, ccl))
                  break;
              if (! (j < NOTCHAR))
                {
                  mp = allocmust (mp, 2);
                  break;
                }
              t = j;
              while (++j < NOTCHAR)
                if (tstbit (j, ccl)
                    && ! (case_fold_unibyte
                          && toupper (j) == toupper (t)))
                  break;
              if (j < NOTCHAR)
                {
                  mp = allocmust (mp, 2);
                  break;
                }
            }

          idx_t rj = ri + 2;
          if (d->tokens[ri + 1] == CAT)
            {
              for (; rj < d->tindex - 1; rj += 2)
                {
                  if ((rj != ri && (d->tokens[rj] <= 0
                                    || NOTCHAR <= d->tokens[rj]))
                      || d->tokens[rj + 1] != CAT)
                    break;
                }
            }
          mp = allocmust (mp, ((rj - ri) >> 1) + 1);
          mp->is[0] = mp->left[0] = mp->right[0]
            = case_fold_unibyte ? toupper (t) : t;

          idx_t i;
          for (i = 1; ri + 2 < rj; i++)
            {
              ri += 2;
              t = d->tokens[ri];
              mp->is[i] = mp->left[i] = mp->right[i]
                = case_fold_unibyte ? toupper (t) : t;
            }
          mp->is[i] = mp->left[i] = mp->right[i] = '\0';
          mp->in = enlist (mp->in, mp->is, i);
          break;
        }
    }
 done:;

  struct dfamust *dm = NULL;
  if (*result)
    {
      dm = xmalloc (FLEXSIZEOF (struct dfamust, must, strlen (result) + 1));
      dm->exact = exact;
      dm->begline = begline;
      dm->endline = endline;
      strcpy (dm->must, result);
    }

  while (mp)
    {
      must *prev = mp->prev;
      freemust (mp);
      mp = prev;
    }

  return dm;
}

void
dfamustfree (struct dfamust *dm)
{
  free (dm);
}

struct dfa *
dfaalloc (void)
{
  return xmalloc (sizeof (struct dfa));
}

/* Initialize DFA.  */
void
dfasyntax (struct dfa *dfa, struct localeinfo const *linfo,
           reg_syntax_t bits, int dfaopts)
{
  memset (dfa, 0, offsetof (struct dfa, dfaexec));
  dfa->dfaexec = linfo->multibyte ? dfaexec_mb : dfaexec_sb;
  dfa->localeinfo = *linfo;

  dfa->fast = !dfa->localeinfo.multibyte;

  dfa->canychar = -1;
  dfa->syntax.syntax_bits_set = true;
  dfa->syntax.case_fold = (bits & RE_ICASE) != 0;
  dfa->syntax.eolbyte = dfaopts & DFA_EOL_NUL ? '\0' : '\n';
  dfa->syntax.syntax_bits = bits;
  dfa->syntax.dfaopts = dfaopts;

  for (int i = CHAR_MIN; i <= CHAR_MAX; ++i)
    {
      unsigned char uc = i;

      dfa->syntax.sbit[uc] = char_context (dfa, uc);
      switch (dfa->syntax.sbit[uc])
        {
        case CTX_LETTER:
          setbit (uc, &dfa->syntax.letters);
          break;
        case CTX_NEWLINE:
          setbit (uc, &dfa->syntax.newline);
          break;
        }

      /* POSIX requires that the five bytes in "\n\r./" (including the
         terminating NUL) cannot occur inside a multibyte character.  */
      dfa->syntax.never_trail[uc] = (dfa->localeinfo.using_utf8
                                     ? (uc & 0xc0) != 0x80
                                     : strchr ("\n\r./", uc) != NULL);
    }
}

/* Initialize TO by copying FROM's syntax settings.  */
void
dfacopysyntax (struct dfa *to, struct dfa const *from)
{
  memset (to, 0, offsetof (struct dfa, syntax));
  to->canychar = -1;
  to->fast = from->fast;
  to->syntax = from->syntax;
  to->dfaexec = from->dfaexec;
  to->localeinfo = from->localeinfo;
}

/* vim:set shiftwidth=2: */
/* Getopt for GNU.
   NOTE: getopt is part of the C library, so if you don't know what
   "Keep this file name-space clean" means, talk to drepper@gnu.org
   before changing it!
   Copyright (C) 1987-2017 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
   Ditto for AIX 3.2 and <stdlib.h>.  */
#ifndef _NO_PROTO
# define _NO_PROTO
#endif

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>	/* For malloc and free */

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#define GETOPT_INTERFACE_VERSION 2
#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
# include <gnu-versions.h>
# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
#  define ELIDE_CODE
# endif
#endif

/* !@#$%^&*() !!!!!!!! */
#ifdef GAWK
#undef ELIDE_CODE
#endif

#ifndef ELIDE_CODE


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#if defined (__GNU_LIBRARY__) || defined (__CYGWIN__) || defined(__DJGPP__) || defined(__APPLE__) || defined(__MINGW32__) || defined(__sun) /* Illumos */
/* Don't include stdlib.h for
 * non-GNU C libraries
 * non-Cygwin
 * non-DJGPP
 * non-MinGW
 * because some of them contain conflicting prototypes for getopt.  */
# include <stdlib.h>
# include <unistd.h>
#endif	/* GNU C library.  */

#include <string.h>

#ifdef VMS
# include <unixlib.h>
#endif

#ifdef _LIBC
# include <libintl.h>
#else
# include "gettext.h"
# define _(msgid) gettext (msgid)
#endif

#if defined _LIBC
# include <wchar.h>
#endif

#ifndef attribute_hidden
# define attribute_hidden
#endif

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.

   Setting the environment variable POSIXLY_CORRECT disables permutation.
   Then the behavior is completely standard.

   GNU application programs can use a third alternative mode in which
   they can distinguish the relative order of options and other arguments.  */

#include "getopt.h"
#include "getopt_int.h"

/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

/* 1003.2 says this must be 1 before any call.  */
int optind = 1;

/* Callers store zero here to inhibit the error message
   for unrecognized options.  */

int opterr = 1;

/* Set to an option character which was unrecognized.
   This must be initialized on some systems to avoid linking in the
   system's own getopt implementation.  */

int optopt = '?';

/* Keep a global copy of all internal members of getopt_data.  */

static struct _getopt_data getopt_data;


#ifndef __GNU_LIBRARY__

/* Avoid depending on library functions or files
   whose names are inconsistent.  */

#ifndef getenv
extern char *getenv (const char*);
#endif

#endif /* not __GNU_LIBRARY__ */

#ifdef _LIBC
/* Stored original parameters.
   XXX This is no good solution.  We should rather copy the args so
   that we can compare them later.  But we must not use malloc(3).  */
extern int __libc_argc;
extern char **__libc_argv;

/* Bash 2.0 gives us an environment variable containing flags
   indicating ARGV elements that should not be considered arguments.  */

# ifdef USE_NONOPTION_FLAGS
/* Defined in getopt_init.c  */
extern char *__getopt_nonoption_flags;
# endif

# ifdef USE_NONOPTION_FLAGS
#  define SWAP_FLAGS(ch1, ch2) \
  if (d->__nonoption_flags_len > 0)					      \
    {									      \
      char __tmp = __getopt_nonoption_flags[ch1];			      \
      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
      __getopt_nonoption_flags[ch2] = __tmp;				      \
    }
# else
#  define SWAP_FLAGS(ch1, ch2)
# endif
#else	/* !_LIBC */
# define SWAP_FLAGS(ch1, ch2)
#endif	/* _LIBC */

/* Exchange two adjacent subsequences of ARGV.
   One subsequence is elements [first_nonopt,last_nonopt)
   which contains all the non-options that have been skipped so far.
   The other is elements [last_nonopt,optind), which contains all
   the options processed since those non-options were skipped.

   `first_nonopt' and `last_nonopt' are relocated so that they describe
   the new indices of the non-options in ARGV after they are moved.  */

static void
exchange (char **argv, struct _getopt_data *d)
{
  int bottom = d->__first_nonopt;
  int middle = d->__last_nonopt;
  int top = d->optind;
  char *tem;

  /* Exchange the shorter segment with the far end of the longer segment.
     That puts the shorter segment into the right place.
     It leaves the longer segment in the right place overall,
     but it consists of two parts that need to be swapped next.  */

#if defined _LIBC && defined USE_NONOPTION_FLAGS
  /* First make sure the handling of the `__getopt_nonoption_flags'
     string can work normally.  Our top argument must be in the range
     of the string.  */
  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)
    {
      /* We must extend the array.  The user plays games with us and
	 presents new arguments.  */
      char *new_str = malloc (top + 1);
      if (new_str == NULL)
	d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;
      else
	{
	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
			     d->__nonoption_flags_max_len),
		  '\0', top + 1 - d->__nonoption_flags_max_len);
	  d->__nonoption_flags_max_len = top + 1;
	  __getopt_nonoption_flags = new_str;
	}
    }
#endif

  while (top > middle && middle > bottom)
    {
      if (top - middle > middle - bottom)
	{
	  /* Bottom segment is the short one.  */
	  int len = middle - bottom;
	  int i;

	  /* Swap it with the top part of the top segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[top - (middle - bottom) + i];
	      argv[top - (middle - bottom) + i] = tem;
	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
	    }
	  /* Exclude the moved bottom segment from further swapping.  */
	  top -= len;
	}
      else
	{
	  /* Top segment is the short one.  */
	  int len = top - middle;
	  int i;

	  /* Swap it with the bottom part of the bottom segment.  */
	  for (i = 0; i < len; i++)
	    {
	      tem = argv[bottom + i];
	      argv[bottom + i] = argv[middle + i];
	      argv[middle + i] = tem;
	      SWAP_FLAGS (bottom + i, middle + i);
	    }
	  /* Exclude the moved top segment from further swapping.  */
	  bottom += len;
	}
    }

  /* Update records for the slots the non-options now occupy.  */

  d->__first_nonopt += (d->optind - d->__last_nonopt);
  d->__last_nonopt = d->optind;
}

/* Initialize the internal data when the first call is made.  */

static const char *
_getopt_initialize (int argc, char *const *argv, const char *optstring,
		    struct _getopt_data *d, int posixly_correct)
{
  /* Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  d->__first_nonopt = d->__last_nonopt = d->optind;

  d->__nextchar = NULL;

  d->__posixly_correct = posixly_correct | !!getenv ("POSIXLY_CORRECT");

  /* Determine how to handle the ordering of options and nonoptions.  */

  if (optstring[0] == '-')
    {
      d->__ordering = RETURN_IN_ORDER;
      ++optstring;
    }
  else if (optstring[0] == '+')
    {
      d->__ordering = REQUIRE_ORDER;
      ++optstring;
    }
  else if (d->__posixly_correct)
    d->__ordering = REQUIRE_ORDER;
  else
    d->__ordering = PERMUTE;

#if defined _LIBC && defined USE_NONOPTION_FLAGS
  if (!d->__posixly_correct
      && argc == __libc_argc && argv == __libc_argv)
    {
      if (d->__nonoption_flags_max_len == 0)
	{
	  if (__getopt_nonoption_flags == NULL
	      || __getopt_nonoption_flags[0] == '\0')
	    d->__nonoption_flags_max_len = -1;
	  else
	    {
	      const char *orig_str = __getopt_nonoption_flags;
	      int len = d->__nonoption_flags_max_len = strlen (orig_str);
	      if (d->__nonoption_flags_max_len < argc)
		d->__nonoption_flags_max_len = argc;
	      __getopt_nonoption_flags =
		(char *) malloc (d->__nonoption_flags_max_len);
	      if (__getopt_nonoption_flags == NULL)
		d->__nonoption_flags_max_len = -1;
	      else
		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
			'\0', d->__nonoption_flags_max_len - len);
	    }
	}
      d->__nonoption_flags_len = d->__nonoption_flags_max_len;
    }
  else
    d->__nonoption_flags_len = 0;
#endif

  return optstring;
}

/* Scan elements of ARGV (whose length is ARGC) for option characters
   given in OPTSTRING.

   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   then it is an option element.  The characters of this element
   (aside from the initial '-') are option characters.  If `getopt'
   is called repeatedly, it returns successively each of the option characters
   from each of the option elements.

   If `getopt' finds another option character, it returns that character,
   updating `optind' and `nextchar' so that the next call to `getopt' can
   resume the scan with the following option character or ARGV-element.

   If there are no more option characters, `getopt' returns -1.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so that those that are not options now come last.)

   OPTSTRING is a string containing the legitimate option characters.
   If an option character is seen that is not listed in OPTSTRING,
   return '?' after printing an error message.  If you set `opterr' to
   zero, the error message is suppressed but we still return '?'.

   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   it is returned in `optarg', otherwise `optarg' is set to zero.

   If OPTSTRING starts with `-' or `+', it requests different methods of
   handling the non-option ARGV-elements.
   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.

   Long-named options begin with `--' instead of `-'.
   Their names may be abbreviated as long as the abbreviation is unique
   or is an exact match for some defined option.  If they have an
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   When `getopt' finds a long-named option, it returns 0 if that option's
   `flag' field is nonzero, the value of the option's `val' field
   if the `flag' field is zero.

   The elements of ARGV aren't really const, because we permute them.
   But we pretend they're const in the prototype to be compatible
   with other systems.

   LONGOPTS is a vector of `struct option' terminated by an
   element containing a name which is zero.

   LONGIND returns the index in LONGOPT of the long-named option found.
   It is only valid when a long-named option has been found by the most
   recent call.

   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
   long-named options.  */

int
_getopt_internal_r (int argc, char *const *argv, const char *optstring,
		    const struct option *longopts, int *longind,
		    int long_only, struct _getopt_data *d, int posixly_correct)
{
  int print_errors = d->opterr;

  if (argc < 1)
    return -1;

  d->optarg = NULL;

  if (d->optind == 0 || !d->__initialized)
    {
      if (d->optind == 0)
	d->optind = 1;	/* Don't scan ARGV[0], the program name.  */
      optstring = _getopt_initialize (argc, argv, optstring, d,
				      posixly_correct);
      d->__initialized = 1;
    }
  else if (optstring[0] == '-' || optstring[0] == '+')
    optstring++;
  if (optstring[0] == ':')
    print_errors = 0;

  /* Test whether ARGV[optind] points to a non-option argument.
     Either it does not have option syntax, or there is an environment flag
     from the shell indicating it is not an option.  The later information
     is only used when the used in the GNU libc.  */
#if defined _LIBC && defined USE_NONOPTION_FLAGS
# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\0' \
		      || (d->optind < d->__nonoption_flags_len		      \
			  && __getopt_nonoption_flags[d->optind] == '1'))
#else
# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\0')
#endif

  if (d->__nextchar == NULL || *d->__nextchar == '\0')
    {
      /* Advance to the next ARGV-element.  */

      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
	 moved back by the user (who may also have changed the arguments).  */
      if (d->__last_nonopt > d->optind)
	d->__last_nonopt = d->optind;
      if (d->__first_nonopt > d->optind)
	d->__first_nonopt = d->optind;

      if (d->__ordering == PERMUTE)
	{
	  /* If we have just processed some options following some non-options,
	     exchange them so that the options come first.  */

	  if (d->__first_nonopt != d->__last_nonopt
	      && d->__last_nonopt != d->optind)
	    exchange ((char **) argv, d);
	  else if (d->__last_nonopt != d->optind)
	    d->__first_nonopt = d->optind;

	  /* Skip any additional non-options
	     and extend the range of non-options previously skipped.  */

	  while (d->optind < argc && NONOPTION_P)
	    d->optind++;
	  d->__last_nonopt = d->optind;
	}

      /* The special ARGV-element `--' means premature end of options.
	 Skip it like a null option,
	 then exchange with previous non-options as if it were an option,
	 then skip everything else like a non-option.  */

      if (d->optind != argc && !strcmp (argv[d->optind], "--"))
	{
	  d->optind++;

	  if (d->__first_nonopt != d->__last_nonopt
	      && d->__last_nonopt != d->optind)
	    exchange ((char **) argv, d);
	  else if (d->__first_nonopt == d->__last_nonopt)
	    d->__first_nonopt = d->optind;
	  d->__last_nonopt = argc;

	  d->optind = argc;
	}

      /* If we have done all the ARGV-elements, stop the scan
	 and back over any non-options that we skipped and permuted.  */

      if (d->optind == argc)
	{
	  /* Set the next-arg-index to point at the non-options
	     that we previously skipped, so the caller will digest them.  */
	  if (d->__first_nonopt != d->__last_nonopt)
	    d->optind = d->__first_nonopt;
	  return -1;
	}

      /* If we have come to a non-option and did not permute it,
	 either stop the scan or describe it to the caller and pass it by.  */

      if (NONOPTION_P)
	{
	  if (d->__ordering == REQUIRE_ORDER)
	    return -1;
	  d->optarg = argv[d->optind++];
	  return 1;
	}

      /* We have found another option-ARGV-element.
	 Skip the initial punctuation.  */

      d->__nextchar = (argv[d->optind] + 1
		  + (longopts != NULL && argv[d->optind][1] == '-'));
    }

  /* Decode the current option-ARGV-element.  */

  /* Check whether the ARGV-element is a long option.

     If long_only and the ARGV-element has the form "-f", where f is
     a valid short option, don't consider it an abbreviated form of
     a long option that starts with f.  Otherwise there would be no
     way to give the -f short option.

     On the other hand, if there's a long option "fubar" and
     the ARGV-element is "-fu", do consider that an abbreviation of
     the long option, just like "--fu", and not "-f" with arg "u".

     This distinction seems to be the most useful approach.  */

  if (longopts != NULL
      && (argv[d->optind][1] == '-'
	  || (long_only && (argv[d->optind][2]
			    || !strchr (optstring, argv[d->optind][1])))))
    {
      char *nameend;
      unsigned int namelen;
      const struct option *p;
      const struct option *pfound = NULL;
      struct option_list
      {
	const struct option *p;
	struct option_list *next;
	int needs_free;
      } *ambig_list = NULL;
      int exact = 0;
      int indfound = -1;
      int option_index;

      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)
	/* Do nothing.  */ ;
      namelen = nameend - d->__nextchar;

      /* Test all long options for either exact match
	 or abbreviated matches.  */
      for (p = longopts, option_index = 0; p->name; p++, option_index++)
	if (!strncmp (p->name, d->__nextchar, namelen))
	  {
	    if (namelen == (unsigned int) strlen (p->name))
	      {
		/* Exact match found.  */
		pfound = p;
		indfound = option_index;
		exact = 1;
		break;
	      }
	    else if (pfound == NULL)
	      {
		/* First nonexact match found.  */
		pfound = p;
		indfound = option_index;
	      }
	    else if (long_only
		     || pfound->has_arg != p->has_arg
		     || pfound->flag != p->flag
		     || pfound->val != p->val)
	      {
		/* Second or later nonexact match found.  */
		struct option_list *newp = malloc (sizeof (*newp));
		newp->p = p;
		newp->needs_free = 1;
		newp->next = ambig_list;
		ambig_list = newp;
	      }
	  }

      if (ambig_list != NULL && !exact)
	{
	  if (print_errors)
	    {
	      struct option_list first;
	      first.p = pfound;
	      first.next = ambig_list;
	      first.needs_free = 0;
	      ambig_list = &first;

#if defined _LIBC
	      char *buf = NULL;
	      size_t buflen = 0;

	      FILE *fp = __open_memstream (&buf, &buflen);
	      if (fp != NULL)
		{
		  fprintf (fp,
			   _("%s: option '%s' is ambiguous; possibilities:"),
			   argv[0], argv[d->optind]);

		  do
		    {
		      fprintf (fp, " '--%s'", ambig_list->p->name);
		      ambig_list = ambig_list->next;
		    }
		  while (ambig_list != NULL);

		  fputc_unlocked ('\n', fp);

		  if (__glibc_likely (fclose (fp) != EOF))
		    {
		      _IO_flockfile (stderr);

		      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
		      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;

		      __fxprintf (NULL, "%s", buf);

		      ((_IO_FILE *) stderr)->_flags2 = old_flags2;
		      _IO_funlockfile (stderr);

		      free (buf);
		    }
		}
#else
	      fprintf (stderr,
		       _("%s: option '%s' is ambiguous; possibilities:"),
		       argv[0], argv[d->optind]);
	      do
		{
		  struct option_list *tmp_next;

		  fprintf (stderr, " '--%s'", ambig_list->p->name);
		  tmp_next = ambig_list->next;
		  if (ambig_list->needs_free)
		    free(ambig_list);
		  ambig_list = tmp_next;
		}
	      while (ambig_list != NULL);

	      fputc ('\n', stderr);
#endif
	    }
	  d->__nextchar += strlen (d->__nextchar);
	  d->optind++;
	  d->optopt = 0;
	  return '?';
	}

      if (pfound != NULL)
	{
	  option_index = indfound;
	  d->optind++;
	  if (*nameend)
	    {
	      /* Don't test has_arg with >, because some C compilers don't
		 allow it to be used on enums.  */
	      if (pfound->has_arg)
		d->optarg = nameend + 1;
	      else
		{
		  if (print_errors)
		    {
#if defined _LIBC
		      char *buf;
		      int n;
#endif

		      if (argv[d->optind - 1][1] == '-')
			{
			  /* --option */
#if defined _LIBC
			  n = __asprintf (&buf, _("\
%s: option '--%s' doesn't allow an argument\n"),
					  argv[0], pfound->name);
#else
			  fprintf (stderr, _("\
%s: option '--%s' doesn't allow an argument\n"),
				   argv[0], pfound->name);
#endif
			}
		      else
			{
			  /* +option or -option */
#if defined _LIBC
			  n = __asprintf (&buf, _("\
%s: option '%c%s' doesn't allow an argument\n"),
					  argv[0], argv[d->optind - 1][0],
					  pfound->name);
#else
			  fprintf (stderr, _("\
%s: option '%c%s' doesn't allow an argument\n"),
				   argv[0], argv[d->optind - 1][0],
				   pfound->name);
#endif
			}

#if defined _LIBC
		      if (n >= 0)
			{
			  _IO_flockfile (stderr);

			  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
			  ((_IO_FILE *) stderr)->_flags2
			    |= _IO_FLAGS2_NOTCANCEL;

			  __fxprintf (NULL, "%s", buf);

			  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
			  _IO_funlockfile (stderr);

			  free (buf);
			}
#endif
		    }

		  d->__nextchar += strlen (d->__nextchar);

		  d->optopt = pfound->val;
		  return '?';
		}
	    }
	  else if (pfound->has_arg == 1)
	    {
	      if (d->optind < argc)
		d->optarg = argv[d->optind++];
	      else
		{
		  if (print_errors)
		    {
#if defined _LIBC
		      char *buf;

		      if (__asprintf (&buf, _("\
%s: option '--%s' requires an argument\n"),
				      argv[0], pfound->name) >= 0)
			{
			  _IO_flockfile (stderr);

			  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
			  ((_IO_FILE *) stderr)->_flags2
			    |= _IO_FLAGS2_NOTCANCEL;

			  __fxprintf (NULL, "%s", buf);

			  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
			  _IO_funlockfile (stderr);

			  free (buf);
			}
#else
		      fprintf (stderr,
			       _("%s: option '--%s' requires an argument\n"),
			       argv[0], pfound->name);
#endif
		    }
		  d->__nextchar += strlen (d->__nextchar);
		  d->optopt = pfound->val;
		  return optstring[0] == ':' ? ':' : '?';
		}
	    }
	  d->__nextchar += strlen (d->__nextchar);
	  if (longind != NULL)
	    *longind = option_index;
	  if (pfound->flag)
	    {
	      *(pfound->flag) = pfound->val;
	      return 0;
	    }
	  return pfound->val;
	}

      /* Can't find it as a long option.  If this is not getopt_long_only,
	 or the option starts with '--' or is not a valid short
	 option, then it's an error.
	 Otherwise interpret it as a short option.  */
      if (!long_only || argv[d->optind][1] == '-'
	  || strchr (optstring, *d->__nextchar) == NULL)
	{
	  if (print_errors)
	    {
#if defined _LIBC
	      char *buf;
	      int n;
#endif

	      if (argv[d->optind][1] == '-')
		{
		  /* --option */
#if defined _LIBC
		  n = __asprintf (&buf, _("%s: unrecognized option '--%s'\n"),
				  argv[0], d->__nextchar);
#else
		  fprintf (stderr, _("%s: unrecognized option '--%s'\n"),
			   argv[0], d->__nextchar);
#endif
		}
	      else
		{
		  /* +option or -option */
#if defined _LIBC
		  n = __asprintf (&buf, _("%s: unrecognized option '%c%s'\n"),
				  argv[0], argv[d->optind][0], d->__nextchar);
#else
		  fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),
			   argv[0], argv[d->optind][0], d->__nextchar);
#endif
		}

#if defined _LIBC
	      if (n >= 0)
		{
		  _IO_flockfile (stderr);

		  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
		  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;

		  __fxprintf (NULL, "%s", buf);

		  ((_IO_FILE *) stderr)->_flags2 = old_flags2;
		  _IO_funlockfile (stderr);

		  free (buf);
		}
#endif
	    }
	  d->__nextchar = (char *) "";
	  d->optind++;
	  d->optopt = 0;
	  return '?';
	}
    }

  /* Look at and handle the next short option-character.  */

  {
    char c = *d->__nextchar++;
    char *temp = strchr (optstring, c);

    /* Increment `optind' when we start to process its last character.  */
    if (*d->__nextchar == '\0')
      ++d->optind;

    if (temp == NULL || c == ':' || c == ';')
      {
	if (print_errors)
	  {
#if defined _LIBC
	    char *buf;
	    int n;
#endif

#if defined _LIBC
	    n = __asprintf (&buf, _("%s: invalid option -- '%c'\n"),
			    argv[0], c);
#else
	    fprintf (stderr, _("%s: invalid option -- '%c'\n"), argv[0], c);
#endif

#if defined _LIBC
	    if (n >= 0)
	      {
		_IO_flockfile (stderr);

		int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
		((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;

		__fxprintf (NULL, "%s", buf);

		((_IO_FILE *) stderr)->_flags2 = old_flags2;
		_IO_funlockfile (stderr);

		free (buf);
	      }
#endif
	  }
	d->optopt = c;
	return '?';
      }
    /* Convenience. Treat POSIX -W foo same as long option --foo */
    if (temp[0] == 'W' && temp[1] == ';')
      {
	char *nameend;
	const struct option *p;
	const struct option *pfound = NULL;
	int exact = 0;
	int ambig = 0;
	int indfound = 0;
	int option_index;

	if (longopts == NULL)
	  goto no_longs;

	/* This is an option that requires an argument.  */
	if (*d->__nextchar != '\0')
	  {
	    d->optarg = d->__nextchar;
	    /* If we end this ARGV-element by taking the rest as an arg,
	       we must advance to the next element now.  */
	    d->optind++;
	  }
	else if (d->optind == argc)
	  {
	    if (print_errors)
	      {
#if defined _LIBC
		char *buf;

		if (__asprintf (&buf,
				_("%s: option requires an argument -- '%c'\n"),
				argv[0], c) >= 0)
		  {
		    _IO_flockfile (stderr);

		    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
		    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;

		    __fxprintf (NULL, "%s", buf);

		    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
		    _IO_funlockfile (stderr);

		    free (buf);
		  }
#else
		fprintf (stderr,
			 _("%s: option requires an argument -- '%c'\n"),
			 argv[0], c);
#endif
	      }
	    d->optopt = c;
	    if (optstring[0] == ':')
	      c = ':';
	    else
	      c = '?';
	    return c;
	  }
	else
	  /* We already incremented `d->optind' once;
	     increment it again when taking next ARGV-elt as argument.  */
	  d->optarg = argv[d->optind++];

	/* optarg is now the argument, see if it's in the
	   table of longopts.  */

	for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';
	     nameend++)
	  /* Do nothing.  */ ;

	/* Test all long options for either exact match
	   or abbreviated matches.  */
	for (p = longopts, option_index = 0; p->name; p++, option_index++)
	  if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))
	    {
	      if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))
		{
		  /* Exact match found.  */
		  pfound = p;
		  indfound = option_index;
		  exact = 1;
		  break;
		}
	      else if (pfound == NULL)
		{
		  /* First nonexact match found.  */
		  pfound = p;
		  indfound = option_index;
		}
	      else if (long_only
		       || pfound->has_arg != p->has_arg
		       || pfound->flag != p->flag
		       || pfound->val != p->val)
		/* Second or later nonexact match found.  */
		ambig = 1;
	    }
	if (ambig && !exact)
	  {
	    if (print_errors)
	      {
#if defined _LIBC
		char *buf;

		if (__asprintf (&buf, _("%s: option '-W %s' is ambiguous\n"),
				argv[0], d->optarg) >= 0)
		  {
		    _IO_flockfile (stderr);

		    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
		    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;

		    __fxprintf (NULL, "%s", buf);

		    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
		    _IO_funlockfile (stderr);

		    free (buf);
		  }
#else
		fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),
			 argv[0], d->optarg);
#endif
	      }
	    d->__nextchar += strlen (d->__nextchar);
	    d->optind++;
	    return '?';
	  }
	if (pfound != NULL)
	  {
	    option_index = indfound;
	    if (*nameend)
	      {
		/* Don't test has_arg with >, because some C compilers don't
		   allow it to be used on enums.  */
		if (pfound->has_arg)
		  d->optarg = nameend + 1;
		else
		  {
		    if (print_errors)
		      {
#if defined _LIBC
			char *buf;

			if (__asprintf (&buf, _("\
%s: option '-W %s' doesn't allow an argument\n"),
					argv[0], pfound->name) >= 0)
			  {
			    _IO_flockfile (stderr);

			    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
			    ((_IO_FILE *) stderr)->_flags2
			      |= _IO_FLAGS2_NOTCANCEL;

			    __fxprintf (NULL, "%s", buf);

			    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
			    _IO_funlockfile (stderr);

			    free (buf);
			  }
#else
			fprintf (stderr, _("\
%s: option '-W %s' doesn't allow an argument\n"),
				 argv[0], pfound->name);
#endif
		      }

		    d->__nextchar += strlen (d->__nextchar);
		    return '?';
		  }
	      }
	    else if (pfound->has_arg == 1)
	      {
		if (d->optind < argc)
		  d->optarg = argv[d->optind++];
		else
		  {
		    if (print_errors)
		      {
#if defined _LIBC
			char *buf;

			if (__asprintf (&buf, _("\
%s: option '-W %s' requires an argument\n"),
					argv[0], pfound->name) >= 0)
			  {
			    _IO_flockfile (stderr);

			    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
			    ((_IO_FILE *) stderr)->_flags2
			      |= _IO_FLAGS2_NOTCANCEL;

			    __fxprintf (NULL, "%s", buf);

			    ((_IO_FILE *) stderr)->_flags2 = old_flags2;
			    _IO_funlockfile (stderr);

			    free (buf);
			  }
#else
			fprintf (stderr, _("\
%s: option '-W %s' requires an argument\n"),
				 argv[0], pfound->name);
#endif
		      }
		    d->__nextchar += strlen (d->__nextchar);
		    return optstring[0] == ':' ? ':' : '?';
		  }
	      }
	    else
	      d->optarg = NULL;
	    d->__nextchar += strlen (d->__nextchar);
	    if (longind != NULL)
	      *longind = option_index;
	    if (pfound->flag)
	      {
		*(pfound->flag) = pfound->val;
		return 0;
	      }
	    return pfound->val;
	  }

      no_longs:
	d->__nextchar = NULL;
	return 'W';	/* Let the application handle it.   */
      }
    if (temp[1] == ':')
      {
	if (temp[2] == ':')
	  {
	    /* This is an option that accepts an argument optionally.  */
	    if (*d->__nextchar != '\0')
	      {
		d->optarg = d->__nextchar;
		d->optind++;
	      }
	    else
	      d->optarg = NULL;
	    d->__nextchar = NULL;
	  }
	else
	  {
	    /* This is an option that requires an argument.  */
	    if (*d->__nextchar != '\0')
	      {
		d->optarg = d->__nextchar;
		/* If we end this ARGV-element by taking the rest as an arg,
		   we must advance to the next element now.  */
		d->optind++;
	      }
	    else if (d->optind == argc)
	      {
		if (print_errors)
		  {
#if defined _LIBC
		    char *buf;

		    if (__asprintf (&buf, _("\
%s: option requires an argument -- '%c'\n"),
				    argv[0], c) >= 0)
		      {
			_IO_flockfile (stderr);

			int old_flags2 = ((_IO_FILE *) stderr)->_flags2;
			((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;

			__fxprintf (NULL, "%s", buf);

			((_IO_FILE *) stderr)->_flags2 = old_flags2;
			_IO_funlockfile (stderr);

			free (buf);
		      }
#else
		    fprintf (stderr,
			     _("%s: option requires an argument -- '%c'\n"),
			     argv[0], c);
#endif
		  }
		d->optopt = c;
		if (optstring[0] == ':')
		  c = ':';
		else
		  c = '?';
	      }
	    else
	      /* We already incremented `optind' once;
		 increment it again when taking next ARGV-elt as argument.  */
	      d->optarg = argv[d->optind++];
	    d->__nextchar = NULL;
	  }
      }
    return c;
  }
}

int
_getopt_internal (int argc, char *const *argv, const char *optstring,
		  const struct option *longopts, int *longind, int long_only,
		  int posixly_correct)
{
  int result;

  getopt_data.optind = optind;
  getopt_data.opterr = opterr;

  result = _getopt_internal_r (argc, argv, optstring, longopts,
			       longind, long_only, &getopt_data,
			       posixly_correct);

  optind = getopt_data.optind;
  optarg = getopt_data.optarg;
  optopt = getopt_data.optopt;

  return result;
}

int
getopt (int argc, char *const *argv, const char *optstring)
{
  return _getopt_internal (argc, argv, optstring,
			   (const struct option *) 0,
			   (int *) 0,
			   0, 0);
}

#ifdef _LIBC
int
__posix_getopt (int argc, char *const *argv, const char *optstring)
{
  return _getopt_internal (argc, argv, optstring,
			   (const struct option *) 0,
			   (int *) 0,
			   0, 1);
}
#endif

#endif	/* Not ELIDE_CODE.  */

#ifdef TEST

/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */

int
main (int argc, char **argv)
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;

      c = getopt (argc, argv, "abc:d:0123456789");
      if (c == -1)
	break;

      switch (c)
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value '%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
/* getopt_long and getopt_long_only entry points for GNU getopt.
   Copyright (C) 1987-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef _LIBC
# include <getopt.h>
#else
# include "getopt.h"
#endif
#include "getopt_int.h"

#include <stdio.h>

/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
   it is simpler to just do this in the source for each such file.  */

#define GETOPT_INTERFACE_VERSION 2
#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
#include <gnu-versions.h>
#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
#define ELIDE_CODE
#endif
#endif

/* !@#$%^&*() !!!!!!!! */
#ifdef GAWK
#undef ELIDE_CODE
#endif

#ifndef ELIDE_CODE


/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
#ifdef __GNU_LIBRARY__
#include <stdlib.h>
#endif

#ifndef	NULL
#define NULL 0
#endif

int
getopt_long (int argc, char *const *argv, const char *options,
	     const struct option *long_options, int *opt_index)
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 0, 0);
}

int
_getopt_long_r (int argc, char *const *argv, const char *options,
		const struct option *long_options, int *opt_index,
		struct _getopt_data *d)
{
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
			     0, d, 0);
}

/* Like getopt_long, but '-' as well as '--' can indicate a long option.
   If an option that starts with '-' (not '--') doesn't match a long option,
   but does match a short option, it is parsed as a short option
   instead.  */

int
getopt_long_only (int argc, char *const *argv, const char *options,
		  const struct option *long_options, int *opt_index)
{
  return _getopt_internal (argc, argv, options, long_options, opt_index, 1, 0);
}

int
_getopt_long_only_r (int argc, char *const *argv, const char *options,
		     const struct option *long_options, int *opt_index,
		     struct _getopt_data *d)
{
  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
			     1, d, 0);
}

#endif	/* Not ELIDE_CODE.  */

#ifdef TEST

#include <stdio.h>

int
main (int argc, char **argv)
{
  int c;
  int digit_optind = 0;

  while (1)
    {
      int this_option_optind = optind ? optind : 1;
      int option_index = 0;
      static struct option long_options[] =
      {
	{"add", 1, 0, 0},
	{"append", 0, 0, 0},
	{"delete", 1, 0, 0},
	{"verbose", 0, 0, 0},
	{"create", 0, 0, 0},
	{"file", 1, 0, 0},
	{0, 0, 0, 0}
      };

      c = getopt_long (argc, argv, "abc:d:0123456789",
		       long_options, &option_index);
      if (c == -1)
	break;

      switch (c)
	{
	case 0:
	  printf ("option %s", long_options[option_index].name);
	  if (optarg)
	    printf (" with arg %s", optarg);
	  printf ("\n");
	  break;

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	    printf ("digits occur in two different argv-elements.\n");
	  digit_optind = this_option_optind;
	  printf ("option %c\n", c);
	  break;

	case 'a':
	  printf ("option a\n");
	  break;

	case 'b':
	  printf ("option b\n");
	  break;

	case 'c':
	  printf ("option c with value `%s'\n", optarg);
	  break;

	case 'd':
	  printf ("option d with value `%s'\n", optarg);
	  break;

	case '?':
	  break;

	default:
	  printf ("?? getopt returned character code 0%o ??\n", c);
	}
    }

  if (optind < argc)
    {
      printf ("non-option ARGV-elements: ");
      while (optind < argc)
	printf ("%s ", argv[optind++]);
      printf ("\n");
    }

  exit (0);
}

#endif /* TEST */
/* Extended regular expression matching and search library.
   Copyright (C) 2002-2025 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#define __STDC_WANT_IEC_60559_BFP_EXT__

#ifndef _LIBC
# include <libc-config.h>

# if __GNUC_PREREQ (4, 6)
#  pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#  pragma GCC diagnostic ignored "-Wvla"
# endif
#endif

/* Make sure no one compiles this code with a C++ compiler.  */
#if defined __cplusplus && defined _LIBC
# error "This is C code, use a C compiler"
#endif

#ifdef _LIBC
/* We have to keep the namespace clean.  */
# define regfree(preg) __regfree (preg)
# define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
# define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
# define regerror(errcode, preg, errbuf, errbuf_size) \
	__regerror(errcode, preg, errbuf, errbuf_size)
# define re_set_registers(bu, re, nu, st, en) \
	__re_set_registers (bu, re, nu, st, en)
# define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
# define re_match(bufp, string, size, pos, regs) \
	__re_match (bufp, string, size, pos, regs)
# define re_search(bufp, string, size, startpos, range, regs) \
	__re_search (bufp, string, size, startpos, range, regs)
# define re_compile_pattern(pattern, length, bufp) \
	__re_compile_pattern (pattern, length, bufp)
# define re_set_syntax(syntax) __re_set_syntax (syntax)
# define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
# define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)

# include "../locale/localeinfo.h"
#endif

/* On some systems, limits.h sets RE_DUP_MAX to a lower value than
   GNU regex allows.  Include it before <regex.h>, which correctly
   #undefs RE_DUP_MAX and sets it to the right value.  */
#include <limits.h>

#include <regex.h>
#include "regex_internal.h"

#include "regex_internal.c"
#include "regcomp.c"
#include "regexec.c"

/* Binary backward compatibility.  */
#if _LIBC
# include <shlib-compat.h>
# if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
link_warning (re_max_failures, "the 're_max_failures' variable is obsolete and will go away.")
int re_max_failures = 2000;
# endif
#endif
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Per the statement at http://opensource.org/licenses/bsd-license.php,
 *
 *	The advertising clause in the license appearing on BSD Unix files was
 *	officially rescinded by the Director of the Office of Technology
 *	Licensing of the University of California on July 22 1999. He states
 *	that clause 3 is "hereby deleted in its entirety."
 *
 * I removed the advertising clause in the above copyright.
 * The above web site points to
 * ftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change.
 *
 * Arnold Robbins
 * 15 September 2007
 */

#if defined(LIBC_SCCS) && !defined(lint)
static const char sccsid[] = "@(#)random.c	8.2 (Berkeley) 5/19/95";
#endif /* LIBC_SCCS and not lint */

#ifdef HAVE_CONFIG_H		/* gawk addition */
#include <config.h>
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <assert.h>

#include "random.h"		/* gawk addition */

#ifdef HAVE_SYS_TIME_H		/* gawk addition */
#include <sys/time.h>
#endif

#if 0
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: /repoman/r/ncvs/src/lib/libc/stdlib/random.c,v 1.24 2004/01/20 03:02:18 das Exp $");

#include "namespace.h"
#include <sys/time.h>          /* for srandomdev() */
#include <fcntl.h>             /* for srandomdev() */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>            /* for srandomdev() */
#include "un-namespace.h"
#endif

/*
 * random.c:
 *
 * An improved random number generation package.  In addition to the standard
 * rand()/srand() like interface, this package also has a special state info
 * interface.  The initstate() routine is called with a seed, an array of
 * bytes, and a count of how many bytes are being passed in; this array is
 * then initialized to contain information for random number generation with
 * that much state information.  Good sizes for the amount of state
 * information are 32, 64, 128, and 256 bytes.  The state can be switched by
 * calling the setstate() routine with the same array as was initiallized
 * with initstate().  By default, the package runs with 128 bytes of state
 * information and generates far better random numbers than a linear
 * congruential generator.  If the amount of state information is less than
 * 32 bytes, a simple linear congruential R.N.G. is used.
 *
 * Internally, the state information is treated as an array of uint32_t's; the
 * zeroeth element of the array is the type of R.N.G. being used (small
 * integer); the remainder of the array is the state information for the
 * R.N.G.  Thus, 32 bytes of state information will give 7 ints worth of
 * state information, which will allow a degree seven polynomial.  (Note:
 * the zeroeth word of state information also has some other information
 * stored in it -- see setstate() for details).
 *
 * The random number generation technique is a linear feedback shift register
 * approach, employing trinomials (since there are fewer terms to sum up that
 * way).  In this approach, the least significant bit of all the numbers in
 * the state table will act as a linear feedback shift register, and will
 * have period 2^deg - 1 (where deg is the degree of the polynomial being
 * used, assuming that the polynomial is irreducible and primitive).  The
 * higher order bits will have longer periods, since their values are also
 * influenced by pseudo-random carries out of the lower bits.  The total
 * period of the generator is approximately deg*(2**deg - 1); thus doubling
 * the amount of state information has a vast influence on the period of the
 * generator.  Note: the deg*(2**deg - 1) is an approximation only good for
 * large deg, when the period of the shift is the dominant factor.
 * With deg equal to seven, the period is actually much longer than the
 * 7*(2**7 - 1) predicted by this formula.
 *
 * Modified 28 December 1994 by Jacob S. Rosenberg.
 * The following changes have been made:
 * All references to the type u_int have been changed to unsigned long.
 * All references to type int have been changed to type long.  Other
 * cleanups have been made as well.  A warning for both initstate and
 * setstate has been inserted to the effect that on Sparc platforms
 * the 'arg_state' variable must be forced to begin on word boundaries.
 * This can be easily done by casting a long integer array to char *.
 * The overall logic has been left STRICTLY alone.  This software was
 * tested on both a VAX and Sun SpacsStation with exactly the same
 * results.  The new version and the original give IDENTICAL results.
 * The new version is somewhat faster than the original.  As the
 * documentation says:  "By default, the package runs with 128 bytes of
 * state information and generates far better random numbers than a linear
 * congruential generator.  If the amount of state information is less than
 * 32 bytes, a simple linear congruential R.N.G. is used."  For a buffer of
 * 128 bytes, this new version runs about 19 percent faster and for a 16
 * byte buffer it is about 5 percent faster.
 *
 * Modified 06 February 2016 by Nelson H. F. Beebe to interface to a
 * shuffle buffer, producing a huge period, and removing long-range
 * correlations of the basic low-level generator.  See comments and
 * literature references in random() at the end of this file.
 */

#define SHUFFLE_BITS	9			/* see comments in random() below for this choice */
#define SHUFFLE_MAX	(1 << SHUFFLE_BITS)	/* MUST be power of two */
#define SHUFFLE_MASK	(SHUFFLE_MAX - 1)	/* (k & SHUFFLE_MASK) is in [0, SHUFFLE_MAX - 1] */

static int  shuffle_init = 1;
static long shuffle_buffer[SHUFFLE_MAX];

/*
 * For each of the currently supported random number generators, we have a
 * break value on the amount of state information (you need at least this
 * many bytes of state info to support this random number generator), a degree
 * for the polynomial (actually a trinomial) that the R.N.G. is based on, and
 * the separation between the two lower order coefficients of the trinomial.
 */
#define	TYPE_0		0		/* linear congruential */
#define	BREAK_0		8
#define	DEG_0		0
#define	SEP_0		0

#define	TYPE_1		1		/* x**7 + x**3 + 1 */
#define	BREAK_1		32
#define	DEG_1		7
#define	SEP_1		3

#define	TYPE_2		2		/* x**15 + x + 1 */
#define	BREAK_2		64
#define	DEG_2		15
#define	SEP_2		1

#define	TYPE_3		3		/* x**31 + x**3 + 1 */
#define	BREAK_3		128
#define	DEG_3		31
#define	SEP_3		3

#define	TYPE_4		4		/* x**63 + x + 1 */
#define	BREAK_4		256
#define	DEG_4		63
#define	SEP_4		1

/*
 * Array versions of the above information to make code run faster --
 * relies on fact that TYPE_i == i.
 */
#define	MAX_TYPES	5		/* max number of types above */

#ifdef  USE_WEAK_SEEDING
#define NSHUFF 0
#else   /* !USE_WEAK_SEEDING */
#define NSHUFF 50       /* to drop some "seed -> 1st value" linearity */
#endif  /* !USE_WEAK_SEEDING */

static const int degrees[MAX_TYPES] =	{ DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
static const int seps [MAX_TYPES] =	{ SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };

/*
 * Initially, everything is set up as if from:
 *
 *	initstate(1, randtbl, 128);
 *
 * Note that this initialization takes advantage of the fact that srandom()
 * advances the front and rear pointers 10*rand_deg times, and hence the
 * rear pointer which starts at 0 will also end up at zero; thus the zeroeth
 * element of the state information, which contains info about the current
 * position of the rear pointer is just
 *
 *	MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
 */

static uint32_t randtbl[DEG_3 + 1] = {
	TYPE_3,
#ifdef  USE_WEAK_SEEDING
/* Historic implementation compatibility */
/* The random sequences do not vary much with the seed */
	0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342, 0xde3b81e0, 0xdf0a6fb5,
	0xf103bc02, 0x48f340fb, 0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd,
	0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86, 0xda672e2a, 0x1588ca88,
	0xe369735d, 0x904f35f7, 0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
	0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b, 0xf5ad9d0e, 0x8999220b,
	0x27fb47b9,
#else   /* !USE_WEAK_SEEDING */
	0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05,
	0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454,
	0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471,
	0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1,
	0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41,
	0xf3bec5da
#endif  /* !USE_WEAK_SEEDING */
};

/*
 * fptr and rptr are two pointers into the state info, a front and a rear
 * pointer.  These two pointers are always rand_sep places aparts, as they
 * cycle cyclically through the state information.  (Yes, this does mean we
 * could get away with just one pointer, but the code for random() is more
 * efficient this way).  The pointers are left positioned as they would be
 * from the call
 *
 *	initstate(1, randtbl, 128);
 *
 * (The position of the rear pointer, rptr, is really 0 (as explained above
 * in the initialization of randtbl) because the state table pointer is set
 * to point to randtbl[1] (as explained below).
 */
static uint32_t *fptr = &randtbl[SEP_3 + 1];
static uint32_t *rptr = &randtbl[1];

/*
 * The following things are the pointer to the state information table, the
 * type of the current generator, the degree of the current polynomial being
 * used, and the separation between the two pointers.  Note that for efficiency
 * of random(), we remember the first location of the state information, not
 * the zeroeth.  Hence it is valid to access state[-1], which is used to
 * store the type of the R.N.G.  Also, we remember the last location, since
 * this is more efficient than indexing every time to find the address of
 * the last element to see if the front and rear pointers have wrapped.
 */
static uint32_t *state = &randtbl[1];
static int rand_type = TYPE_3;
static int rand_deg = DEG_3;
static int rand_sep = SEP_3;
static uint32_t *end_ptr = &randtbl[DEG_3 + 1];

static inline uint32_t good_rand(int32_t);

static inline uint32_t good_rand (int32_t x)
{
#ifdef  USE_WEAK_SEEDING
/*
 * Historic implementation compatibility.
 * The random sequences do not vary much with the seed,
 * even with overflowing.
 */
	return (1103515245 * x + 12345);
#else   /* !USE_WEAK_SEEDING */
/*
 * Compute x = (7^5 * x) mod (2^31 - 1)
 * wihout overflowing 31 bits:
 *      (2^31 - 1) = 127773 * (7^5) + 2836
 * From "Random number generators: good ones are hard to find",
 * Park and Miller, Communications of the ACM, vol. 31, no. 10,
 * October 1988, p. 1195.
 */
	int32_t hi, lo;

	/* Can't be initialized with 0, so use another value. */
	if (x == 0)
		x = 123459876;
	hi = x / 127773;
	lo = x % 127773;
	x = 16807 * lo - 2836 * hi;
	if (x < 0)
		x += 0x7fffffff;
	return (x);
#endif  /* !USE_WEAK_SEEDING */
}

/*
 * srandom:
 *
 * Initialize the random number generator based on the given seed.  If the
 * type is the trivial no-state-information type, just remember the seed.
 * Otherwise, initializes state[] based on the given "seed" via a linear
 * congruential generator.  Then, the pointers are set to known locations
 * that are exactly rand_sep places apart.  Lastly, it cycles the state
 * information a given number of times to get rid of any initial dependencies
 * introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
 * for default usage relies on values produced by this routine.
 */
void
srandom(unsigned long x)
{
	int i, lim;

	shuffle_init = 1;

	state[0] = (uint32_t)x;
	if (rand_type == TYPE_0)
		lim = NSHUFF;
	else {
		for (i = 1; i < rand_deg; i++)
			state[i] = good_rand(state[i - 1]);
		fptr = &state[rand_sep];
		rptr = &state[0];
		lim = 10 * rand_deg;
	}
	for (i = 0; i < lim; i++)
		(void)random();
}

#if 0 /* gawk doesn't use this */
/*
 * srandomdev:
 *
 * Many programs choose the seed value in a totally predictable manner.
 * This often causes problems.  We seed the generator using the much more
 * secure random(4) interface.  Note that this particular seeding
 * procedure can generate states which are impossible to reproduce by
 * calling srandom() with any value, since the succeeding terms in the
 * state buffer are no longer derived from the LC algorithm applied to
 * a fixed seed.
 */
void
srandomdev()
{
	int fd, done;
	size_t len;

	if (rand_type == TYPE_0)
		len = sizeof state[0];
	else
		len = rand_deg * sizeof state[0];

	done = 0;
	fd = open("/dev/random", O_RDONLY, 0);
	if (fd >= 0) {
		if (read(fd, (void *) state, len) == (ssize_t) len)
			done = 1;
		close(fd);
	}

	if (!done) {
		struct timeval tv;
		unsigned long junk;

		gettimeofday(&tv, NULL);
		srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);
		return;
	}

	if (rand_type != TYPE_0) {
		fptr = &state[rand_sep];
		rptr = &state[0];
	}
}
#endif

/*
 * initstate:
 *
 * Initialize the state information in the given array of n bytes for future
 * random number generation.  Based on the number of bytes we are given, and
 * the break values for the different R.N.G.'s, we choose the best (largest)
 * one we can and set things up for it.  srandom() is then called to
 * initialize the state information.
 *
 * Note that on return from srandom(), we set state[-1] to be the type
 * multiplexed with the current value of the rear pointer; this is so
 * successive calls to initstate() won't lose this information and will be
 * able to restart with setstate().
 *
 * Note: the first thing we do is save the current state, if any, just like
 * setstate() so that it doesn't matter when initstate is called.
 *
 * Returns a pointer to the old state.
 *
 * Note: The Sparc platform requires that arg_state begin on an int
 * word boundary; otherwise a bus error will occur. Even so, lint will
 * complain about mis-alignment, but you should disregard these messages.
 */
char *
initstate(
	unsigned long seed,		/* seed for R.N.G. */
	char *arg_state,		/* pointer to state array */
	long n)				/* # bytes of state info */
{
	char *ostate = (char *)(&state[-1]);
	uint32_t *int_arg_state = (uint32_t *)arg_state;

	if (rand_type == TYPE_0)
		state[-1] = rand_type;
	else
		state[-1] = MAX_TYPES * (rptr - state) + rand_type;
	if (n < BREAK_0) {
		(void)fprintf(stderr,
		    "random: not enough state (%ld bytes); ignored.\n", n);
		return(0);
	}
	if (n < BREAK_1) {
		rand_type = TYPE_0;
		rand_deg = DEG_0;
		rand_sep = SEP_0;
	} else if (n < BREAK_2) {
		rand_type = TYPE_1;
		rand_deg = DEG_1;
		rand_sep = SEP_1;
	} else if (n < BREAK_3) {
		rand_type = TYPE_2;
		rand_deg = DEG_2;
		rand_sep = SEP_2;
	} else if (n < BREAK_4) {
		rand_type = TYPE_3;
		rand_deg = DEG_3;
		rand_sep = SEP_3;
	} else {
		rand_type = TYPE_4;
		rand_deg = DEG_4;
		rand_sep = SEP_4;
	}
	state = int_arg_state + 1; /* first location */
	end_ptr = &state[rand_deg];	/* must set end_ptr before srandom */
	srandom(seed);
	if (rand_type == TYPE_0)
		int_arg_state[0] = rand_type;
	else
		int_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;
	return(ostate);
}

/*
 * setstate:
 *
 * Restore the state from the given state array.
 *
 * Note: it is important that we also remember the locations of the pointers
 * in the current state information, and restore the locations of the pointers
 * from the old state information.  This is done by multiplexing the pointer
 * location into the zeroeth word of the state information.
 *
 * Note that due to the order in which things are done, it is OK to call
 * setstate() with the same state as the current state.
 *
 * Returns a pointer to the old state information.
 *
 * Note: The Sparc platform requires that arg_state begin on an int
 * word boundary; otherwise a bus error will occur. Even so, lint will
 * complain about mis-alignment, but you should disregard these messages.
 */
char *
setstate(char *arg_state)		/* pointer to state array */
{
	uint32_t *new_state = (uint32_t *)arg_state;
	uint32_t type = new_state[0] % MAX_TYPES;
	uint32_t rear = new_state[0] / MAX_TYPES;
	char *ostate = (char *)(&state[-1]);

	if (rand_type == TYPE_0)
		state[-1] = rand_type;
	else
		state[-1] = MAX_TYPES * (rptr - state) + rand_type;
	switch(type) {
	case TYPE_0:
	case TYPE_1:
	case TYPE_2:
	case TYPE_3:
	case TYPE_4:
		rand_type = type;
		rand_deg = degrees[type];
		rand_sep = seps[type];
		break;
	default:
		(void)fprintf(stderr,
		    "random: state info corrupted; not changed.\n");
	}
	state = new_state + 1;
	if (rand_type != TYPE_0) {
		rptr = &state[rear];
		fptr = &state[(rear + rand_sep) % rand_deg];
	}
	end_ptr = &state[rand_deg];		/* set end_ptr too */
	return(ostate);
}

/*
 * random:
 *
 * If we are using the trivial TYPE_0 R.N.G., just do the old linear
 * congruential bit.  Otherwise, we do our fancy trinomial stuff, which is
 * the same in all the other cases due to all the global variables that have
 * been set up.  The basic operation is to add the number at the rear pointer
 * into the one at the front pointer.  Then both pointers are advanced to
 * the next location cyclically in the table.  The value returned is the sum
 * generated, reduced to 31 bits by throwing away the "least random" low bit.
 *
 * Note: the code takes advantage of the fact that both the front and
 * rear pointers can't wrap on the same call by not testing the rear
 * pointer if the front one has wrapped.
 *
 * Returns a 31-bit random number.
 */
static long
random_old()
{
	uint32_t i;
	uint32_t *f, *r;

	if (rand_type == TYPE_0) {
		i = state[0];
		state[0] = i = (good_rand(i)) & 0x7fffffff;
	} else {
		/*
		 * Use local variables rather than static variables for speed.
		 */
		f = fptr; r = rptr;
		*f += *r;
		i = (*f >> 1) & 0x7fffffff;	/* chucking least random bit */
		if (++f >= end_ptr) {
			f = state;
			++r;
		}
		else if (++r >= end_ptr) {
			r = state;
		}

		fptr = f; rptr = r;
	}
	return((long)i);
}

long
random()
{
	/*
	 * This function is a wrapper to the original random(), now renamed
	 * random_old(), to interpose a shuffle buffer to dramatically extend
	 * the generator period at nearly zero additional execution cost,
	 * and an additional storage cost set by the size of the
	 * shuffle buffer (default: 512 longs, or 2K or 4K bytes).
	 * The algorithm was first described in
	 *
	 *     Carter Bays and S. D. Durham
	 *     Improving a Poor Random Number Generator
	 *     ACM Transactions on Mathematical Software (TOMS) 2(1) 59--64 (March 1976)
	 *     http://dx.doi.org/10.1145/355666.355670
	 * 
	 * and later revisited in
	 * 
	 *     Carter Bays
	 *     C364. Improving a random number generator: a comparison between two shuffling methods
	 *     Journal of Statistical Computation and Simulation 36(1) 57--59 (May 1990)
	 *     http://dx.doi.org/10.1080/00949659008811264
	 *
	 * The second paper is critically important because it
	 * emphasizes how an apparently trivial change to the final
	 * element selection can destroy the period-lengthening
	 * feature of the original shuffle algorithm.
	 * 
	 * Here is a table of the increase in period size for a
	 * shuffle generator using 32-bit and 64-bit unsigned integer
	 * linear congruential generators, which are known to have
	 * significant correlations, and are thus inadvisable for
	 * serious work with random numbers:
	 *
	 * hocd128> for (n = 32; n < 4096; n *= 2) \
	 *              printf("%7d\t%12.3.4e\t%12.3.4e\n",
	 *              n, \
	 *              sqrt(PI * gamma(n + 1)/(2**32 - 1)) / (2**32 - 1), \\
	 *              sqrt(PI * gamma(n + 1)/(2**64 - 1)) / (2**64 - 1))
	 * 
	 *      32    3.230e+03       1.148e-11
	 *      64    2.243e+30       7.969e+15
	 *     128    3.910e+93       1.389e+79
	 *     256   1.844e+239      6.552e+224
	 *     512   1.174e+569      4.172e+554
	 *    1024  4.635e+1305     1.647e+1291
	 *    2048  8.144e+2932     2.893e+2918
	 *
	 * A generator giving one result per nanosecond would produce
	 * about 3.16e16 random numbers per year, so even for
	 * massively parallel operations with, say, one million CPU
	 * cores, it could not produce more than 10**23 values per
	 * year.  The main benefit of an enormous period is that it
	 * makes long-range correlations vanishingly unlikely, even
	 * when starting seeds are similar (e.g., seeds of 0, 1, 2,
	 * ...), and therefore makes possible families of generators
	 * (needed in parallel computations) where the probability of
	 * sequence overlap between family members is essentially
	 * zero.
	 */

	int k;
	long r;
	static long s = 0xcafefeedL;

	if (shuffle_init) {	/* first time, or seed changed by srand() */
		for (k = 0; k < SHUFFLE_MAX; k++)
			shuffle_buffer[k] = random_old();

		s = random_old();
		shuffle_init = 0;
	}

	r = random_old();
	k = s & SHUFFLE_MASK;		/* random index into shuffle_buffer[] */

	assert(0L <= k && k < SHUFFLE_MAX);

	s = shuffle_buffer[k];
	shuffle_buffer[k] = r;

	return (s);
}
/* locale information

   Copyright 2016-2025 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* Written by Paul Eggert.  */

#include <config.h>

#include <localeinfo.h>

#include <verify.h>

#include <limits.h>
#include <locale.h>
#include <stdlib.h>
#include <string.h>
#if GAWK
/* Use ISO C 99 API.  */
# include <wctype.h>
# define char32_t wchar_t
# define mbrtoc32 mbrtowc
# define c32tolower towlower
# define c32toupper towupper
#else
/* Use ISO C 11 + gnulib API.  */
# include <uchar.h>
#endif

/* The sbclen implementation relies on this.  */
verify (MB_LEN_MAX <= SCHAR_MAX);

/* Return true if the locale uses UTF-8.  */

static bool
is_using_utf8 (void)
{
  char32_t wc;
  mbstate_t mbs = {0};
  return mbrtoc32 (&wc, "\xc4\x80", 2, &mbs) == 2 && wc == 0x100;
}

/* Return true if the locale is compatible enough with the C locale so
   that the locale is single-byte, bytes are in collating-sequence
   order, and there are no multi-character collating elements.  */

static bool
using_simple_locale (bool multibyte)
{
  /* The native character set is known to be compatible with
     the C locale.  The following test isn't perfect, but it's good
     enough in practice, as only ASCII and EBCDIC are in common use
     and this test correctly accepts ASCII and rejects EBCDIC.  */
  enum { native_c_charset =
    ('\b' == 8 && '\t' == 9 && '\n' == 10 && '\v' == 11 && '\f' == 12
     && '\r' == 13 && ' ' == 32 && '!' == 33 && '"' == 34 && '#' == 35
     && '%' == 37 && '&' == 38 && '\'' == 39 && '(' == 40 && ')' == 41
     && '*' == 42 && '+' == 43 && ',' == 44 && '-' == 45 && '.' == 46
     && '/' == 47 && '0' == 48 && '9' == 57 && ':' == 58 && ';' == 59
     && '<' == 60 && '=' == 61 && '>' == 62 && '?' == 63 && 'A' == 65
     && 'Z' == 90 && '[' == 91 && '\\' == 92 && ']' == 93 && '^' == 94
     && '_' == 95 && 'a' == 97 && 'z' == 122 && '{' == 123 && '|' == 124
     && '}' == 125 && '~' == 126)
  };

  if (!native_c_charset || multibyte)
    return false;

  /* As a heuristic, use strcoll to compare native character order.
     If this agrees with byte order the locale should be simple.
     This heuristic should work for all known practical locales,
     although it would be invalid for artificially-constructed locales
     where the native order is the collating-sequence order but there
     are multi-character collating elements.  */
  for (int i = 0; i < UCHAR_MAX; i++)
    if (0 <= strcoll (((char []) {i, 0}), ((char []) {i + 1, 0})))
      return false;

  return true;
}

/* Initialize *LOCALEINFO from the current locale.  */

void
init_localeinfo (struct localeinfo *localeinfo)
{
  localeinfo->multibyte = MB_CUR_MAX > 1;
  localeinfo->simple = using_simple_locale (localeinfo->multibyte);
  localeinfo->using_utf8 = is_using_utf8 ();

  for (int i = CHAR_MIN; i <= CHAR_MAX; i++)
    {
      char c = i;
      unsigned char uc = i;
      mbstate_t s = {0};
      char32_t wc;
      size_t len = mbrtoc32 (&wc, &c, 1, &s);
      localeinfo->sbclen[uc] = len <= 1 ? 1 : - (int) - len;
      localeinfo->sbctowc[uc] = len <= 1 ? wc : WEOF;
    }
}

/* The set of char32_t values C such that there's a useful locale
   somewhere where C != towupper (C) && C != towlower (towupper (C)).
   For example, 0x00B5 (U+00B5 MICRO SIGN) is in this table, because
   towupper (0x00B5) == 0x039C (U+039C GREEK CAPITAL LETTER MU), and
   towlower (0x039C) == 0x03BC (U+03BC GREEK SMALL LETTER MU).  */
static unsigned short int const lonesome_lower[] =
  {
    0x00B5, 0x0131, 0x017F, 0x01C5, 0x01C8, 0x01CB, 0x01F2, 0x0345,
    0x03C2, 0x03D0, 0x03D1, 0x03D5, 0x03D6, 0x03F0, 0x03F1,

    /* U+03F2 GREEK LUNATE SIGMA SYMBOL lacks a specific uppercase
       counterpart in locales predating Unicode 4.0.0 (April 2003).  */
    0x03F2,

    0x03F5, 0x1E9B, 0x1FBE,
  };

/* Verify that the worst case fits.  This is 1 for towupper, 1 for
   towlower, and 1 for each entry in LONESOME_LOWER.  */
verify (1 + 1 + sizeof lonesome_lower / sizeof *lonesome_lower
               <= CASE_FOLDED_BUFSIZE);

/* Find the characters equal to C after case-folding, other than C
   itself, and store them into FOLDED.  Return the number of characters
   stored; this is zero if C is WEOF.  */

int
case_folded_counterparts (wint_t c, char32_t folded[CASE_FOLDED_BUFSIZE])
{
  int i;
  int n = 0;
  wint_t uc = c32toupper (c);
  wint_t lc = c32tolower (uc);
  if (uc != c)
    folded[n++] = uc;
  if (lc != uc && lc != c && c32toupper (lc) == uc)
    folded[n++] = lc;
  for (i = 0; i < sizeof lonesome_lower / sizeof *lonesome_lower; i++)
    {
      wint_t li = lonesome_lower[i];
      if (li != lc && li != uc && li != c && c32toupper (li) == uc)
        folded[n++] = li;
    }
  return n;
}
/* Increase the size of a dynamic array.
   Copyright (C) 2017-2025 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#ifndef _LIBC
# include <libc-config.h>
#endif

#include <dynarray.h>
#include <errno.h>
#include <intprops.h>
#include <stdlib.h>
#include <string.h>

bool
__libc_dynarray_resize (struct dynarray_header *list, size_t size,
                        void *scratch, size_t element_size)
{
  /* The existing allocation provides sufficient room.  */
  if (size <= list->allocated)
    {
      list->used = size;
      return true;
    }

  /* Otherwise, use size as the new allocation size.  The caller is
     expected to provide the final size of the array, so there is no
     over-allocation here.  */

  size_t new_size_bytes;
  if (INT_MULTIPLY_WRAPV (size, element_size, &new_size_bytes))
    {
      /* Overflow.  */
      __set_errno (ENOMEM);
      return false;
    }
  void *new_array;
  if (list->array == scratch)
    {
      /* The previous array was not heap-allocated.  */
      new_array = malloc (new_size_bytes);
      if (new_array != NULL && list->array != NULL)
        memcpy (new_array, list->array, list->used * element_size);
    }
  else
    new_array = realloc (list->array, new_size_bytes);
  if (new_array == NULL)
    return false;
  list->array = new_array;
  list->allocated = size;
  list->used = size;
  return true;
}
libc_hidden_def (__libc_dynarray_resize)
